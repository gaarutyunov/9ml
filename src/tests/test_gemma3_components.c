/*
 * test_gemma3_components.c - Test Gemma 3 specific components
 *
 * Tests:
 *   - GeGLU activation (GELU * gate)
 *   - Gemma-style RMSNorm (with +1 weight offset)
 *   - QK normalization
 *   - Attention pattern detection (local vs global)
 *   - Embedding scaling
 *   - Dual RoPE theta selection
 */

#include <u.h>
#include <libc.h>

/* Include test data generated by Python */
#include "gemma3_test_data.h"

/* ----------------------------------------------------------------------------
 * GELU activation
 * ---------------------------------------------------------------------------- */

static float
gelu_tanh(float x)
{
    float c = 0.7978845608f;  /* sqrt(2/pi) */
    float x3 = x * x * x;
    float inner = c * (x + 0.044715f * x3);
    return 0.5f * x * (1.0f + tanh(inner));
}

/* ----------------------------------------------------------------------------
 * Gemma-style RMSNorm (with +1 weight offset)
 * ---------------------------------------------------------------------------- */

static void
rmsnorm_gemma(float *o, float *x, float *weight, int size, float eps)
{
    int j;
    float ss = 0.0f;

    for (j = 0; j < size; j++) {
        ss += x[j] * x[j];
    }
    ss /= size;
    ss += eps;
    ss = 1.0f / sqrt(ss);

    for (j = 0; j < size; j++) {
        o[j] = (1.0f + weight[j]) * (ss * x[j]);
    }
}

/* ----------------------------------------------------------------------------
 * QK normalization
 * ---------------------------------------------------------------------------- */

static void
qk_norm(float *o, float *x, int size, float eps)
{
    int j;
    float ss = 0.0f;

    for (j = 0; j < size; j++) {
        ss += x[j] * x[j];
    }
    ss /= size;
    ss += eps;
    ss = 1.0f / sqrt(ss);

    for (j = 0; j < size; j++) {
        o[j] = x[j] * ss;
    }
}

/* ----------------------------------------------------------------------------
 * Attention pattern helpers
 * ---------------------------------------------------------------------------- */

#define GEMMA3_LOCAL_LAYERS_PER_CYCLE 5
#define GEMMA3_CYCLE_LENGTH 6

static int
gemma3_is_local_layer(int layer_idx)
{
    return (layer_idx % GEMMA3_CYCLE_LENGTH) < GEMMA3_LOCAL_LAYERS_PER_CYCLE;
}

static float
gemma3_get_rope_theta(int layer_idx)
{
    return gemma3_is_local_layer(layer_idx) ? 10000.0f : 1000000.0f;
}

/* ----------------------------------------------------------------------------
 * Test functions
 * ---------------------------------------------------------------------------- */

static int
test_geglu(void)
{
    int i;
    int passed = 0;
    int failed = 0;
    float eps = 1e-5f;
    float gelu_out[GEGLU_DIM];
    float geglu_out[GEGLU_DIM];

    print("\n=== GeGLU Test ===\n");

    /* Compute GELU of x1 */
    for (i = 0; i < GEGLU_DIM; i++) {
        gelu_out[i] = gelu_tanh(geglu_x1[i]);
    }

    /* Compute GeGLU: gelu(x1) * x3 */
    for (i = 0; i < GEGLU_DIM; i++) {
        geglu_out[i] = gelu_out[i] * geglu_x3[i];
    }

    /* Compare with expected */
    for (i = 0; i < GEGLU_DIM; i++) {
        float diff = geglu_out[i] - geglu_expected[i];
        if (diff < 0) diff = -diff;

        if (diff < eps) {
            passed++;
        } else {
            print("  geglu[%d] = %.6f (expected %.6f, diff=%.6f) - FAIL\n",
                  i, geglu_out[i], geglu_expected[i], diff);
            failed++;
        }
    }

    if (failed == 0) {
        print("  PASS: All %d GeGLU values match\n", passed);
    }

    return failed;
}

static int
test_rmsnorm_gemma(void)
{
    int i;
    int passed = 0;
    int failed = 0;
    float eps_cmp = 1e-4f;
    float eps_norm = 1e-6f;
    float output[RMSNORM_GEMMA_DIM];

    print("\n=== Gemma RMSNorm Test ===\n");

    /* Compute Gemma-style RMSNorm */
    rmsnorm_gemma(output, rmsnorm_gemma_x, rmsnorm_gemma_weight, RMSNORM_GEMMA_DIM, eps_norm);

    /* Compare with expected */
    for (i = 0; i < RMSNORM_GEMMA_DIM; i++) {
        float diff = output[i] - rmsnorm_gemma_expected[i];
        if (diff < 0) diff = -diff;

        if (diff < eps_cmp) {
            passed++;
        } else {
            print("  rmsnorm[%d] = %.6f (expected %.6f, diff=%.6f) - FAIL\n",
                  i, output[i], rmsnorm_gemma_expected[i], diff);
            failed++;
        }
    }

    if (failed == 0) {
        print("  PASS: All %d Gemma RMSNorm values match\n", passed);
    }

    return failed;
}

static int
test_qk_norm(void)
{
    int i;
    int passed = 0;
    int failed = 0;
    float eps_cmp = 1e-4f;
    float eps_norm = 1e-6f;
    float output[32];

    print("\n=== QK Normalization Test ===\n");

    /* Copy input to output buffer */
    for (i = 0; i < 32; i++) {
        output[i] = qk_q_input[i];
    }

    /* Apply QK normalization */
    qk_norm(output, output, 32, eps_norm);

    /* Compare with expected */
    for (i = 0; i < 32; i++) {
        float diff = output[i] - qk_q_expected[i];
        if (diff < 0) diff = -diff;

        if (diff < eps_cmp) {
            passed++;
        } else {
            print("  qk_norm[%d] = %.6f (expected %.6f, diff=%.6f) - FAIL\n",
                  i, output[i], qk_q_expected[i], diff);
            failed++;
        }
    }

    if (failed == 0) {
        print("  PASS: All %d QK norm values match\n", passed);
    }

    return failed;
}

static int
test_attention_pattern(void)
{
    int i;
    int passed = 0;
    int failed = 0;

    print("\n=== Attention Pattern Test ===\n");

    for (i = 0; i < GEMMA3_NUM_LAYERS; i++) {
        int is_local = gemma3_is_local_layer(i);
        int expected_local = gemma3_layer_is_local[i];
        float theta = gemma3_get_rope_theta(i);
        float expected_theta = gemma3_layer_theta[i];

        if (is_local == expected_local && theta == expected_theta) {
            passed++;
        } else {
            print("  layer %d: local=%d (expected %d), theta=%.0f (expected %.0f) - FAIL\n",
                  i, is_local, expected_local, theta, expected_theta);
            failed++;
        }
    }

    if (failed == 0) {
        print("  PASS: All %d layers have correct attention pattern\n", GEMMA3_NUM_LAYERS);
        print("  Pattern: 5 local (theta=10000) + 1 global (theta=1000000), repeating\n");
    }

    return failed;
}

static int
test_embedding_scale(void)
{
    int i;
    int passed = 0;
    int failed = 0;
    float eps = 1e-4f;
    float scale;
    float output[16];

    print("\n=== Embedding Scale Test ===\n");

    /* Gemma scales embeddings by sqrt(dim) */
    scale = sqrt((float)EMBED_DIM);

    print("  dim=%d, scale=%.4f (expected %.4f)\n", EMBED_DIM, scale, EMBED_SCALE);

    /* Check scale matches expected */
    if (scale - EMBED_SCALE < eps && EMBED_SCALE - scale < eps) {
        print("  Scale computation: PASS\n");
        passed++;
    } else {
        print("  Scale computation: FAIL (diff=%.6f)\n", scale - EMBED_SCALE);
        failed++;
    }

    /* Apply scaling to first 16 elements */
    for (i = 0; i < 16; i++) {
        output[i] = embed_input[i] * scale;
    }

    /* Compare with expected */
    for (i = 0; i < 16; i++) {
        float diff = output[i] - embed_expected[i];
        if (diff < 0) diff = -diff;

        if (diff < eps) {
            passed++;
        } else {
            print("  scaled[%d] = %.6f (expected %.6f, diff=%.6f) - FAIL\n",
                  i, output[i], embed_expected[i], diff);
            failed++;
        }
    }

    if (failed == 0) {
        print("  PASS: Embedding scaling correct\n");
    }

    return failed;
}

/* ----------------------------------------------------------------------------
 * Main
 * ---------------------------------------------------------------------------- */

void
main(int argc, char *argv[])
{
    int total_failed = 0;

    USED(argc);
    USED(argv);

    print("=== Gemma 3 Components Tests ===\n");

    total_failed += test_geglu();
    total_failed += test_rmsnorm_gemma();
    total_failed += test_qk_norm();
    total_failed += test_attention_pattern();
    total_failed += test_embedding_scale();

    print("\n=== Summary ===\n");
    if (total_failed == 0) {
        print("PASS: All Gemma 3 component tests passed\n");
    } else {
        print("FAIL: %d tests failed\n", total_failed);
    }

    exits(total_failed ? "fail" : 0);
}
