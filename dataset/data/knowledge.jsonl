{"text": "#!/bin/rc\n\nIMAGE_DIR=$home/lib/squeak_image\nSQUEAK=squeak\nSQUEAK_FTP=ftp.squeak.org\nMOUNT_PT=/n/squeak_ftp\n\n\nfn fetch_image {\n\t# Open FTP connection\n\tftpfs -q -m $MOUNT_PT -a anonymous $SQUEAK_FTP\n\n\t# Freshen files in directory\n\tls $MOUNT_PT/current_stable > /dev/null\n\n\techo Fetching files...\n\n\t# Copy image file\n\timg_file=`{ls $MOUNT_PT/current_stable | grep 'Squeak[0-9]+\\.[0-9]+'}\n\n\tcp $img_file $IMAGE_DIR\n\n\t# Copy sources file\n\tsrc_file=`{ls $MOUNT_PT/current_stable | grep 'SqueakV[0-9]+\\.sources\\.zip'}\n\n\tcp $src_file $IMAGE_DIR\n\n\t# Unzip files\n\techo Unpacking files...\n\tcd $IMAGE_DIR\n\tfor(f in *.zip) {\n\t\tunzip -f $f\n\t\trm $f\n\t}\n\tcd ..\n\n\t# Close FTP connection\n\tunmount $MOUNT_PT\n}\n\nmkdir -p $IMAGE_DIR\n\n# Check whether the image file already exists or not\n_img=`{ls $IMAGE_DIR | grep 'Squeak[0-9]+\\.[0-9]+.*\\.image'}\n\nif(~ $#_img 0) {\n\tfetch_image\n\t_img=`{ls $IMAGE_DIR | grep 'Squeak[0-9]+\\.[0-9]+.*\\.image'}\n\n\tif(~ $#_img 0) {\n\t\techo Error fetching image\n\t\texit 'failure'\n\t}\n}\n\n# Run Squeak.  Note that the current interpreter prepends the current working\n# directory to whatever pathame we give it.  This \"helpful\" behavior means that\n# we must give it a relative pathname and must run it from our home directory.\n_relative=`{echo $_img | sed 's@'^$home^'/@@'}\n@{ cd $home ; $SQUEAK $_relative }\n", "source": "Squeak/rc/run_squeak", "file_type": "rc"}
{"text": ";\n; Copyright \u00a9 2013 Raspberry Pi Foundation\n; Copyright \u00a9 2013 RISC OS Open Ltd\n;\n; Permission to use, copy, modify, distribute, and sell this software and its\n; documentation for any purpose is hereby granted without fee, provided that\n; the above copyright notice appear in all copies and that both that\n; copyright notice and this permission notice appear in supporting\n; documentation, and that the name of the copyright holders not be used in\n; advertising or publicity pertaining to distribution of the software without\n; specific, written prior permission.  The copyright holders make no\n; representations about the suitability of this software for any purpose.  It\n; is provided \"as is\" without express or implied warranty.\n;\n; THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS\n; SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND\n; FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY\n; SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n; WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN\n; AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n; OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS\n; SOFTWARE.\n;\n\n; Debug options\n                GBLL    DebugData\n;DebugData       SETL    {TRUE}\n                GBLL    DebugPld\n;DebugPld        SETL    {TRUE}\n                GBLL    VerboseBuild\n;VerboseBuild    SETL    {TRUE}\n\n        GET     BitBltArmSimdAsm.hdr\n\n        AREA    |BitBltArmSimdAlphaBlend$$Code|, CODE, READONLY\n        ARM\n\n; ********************************************************************\n\n        MACRO\n        AlphaBlend32_32_init\n        MOV     ht_info, #1\n        MOV     ht, #0\n        ORR     ht_info, ht_info, ht_info, LSL #16 ; &10001\n        MEND\n\n        MACRO\n        AlphaBlend32_32_1pixel $src, $dst, $tmp0, $tmp1, $tmp2, $known_not_transp\n      [ \"$known_not_transp\" = \"\"\n        MOVS    $tmp2, $src, LSR #24      ; s_a\n        BEQ     %FT09 ; fully transparent - use dst\n      ]\n        TEQ     $tmp2, #&FF\n        BEQ     %FT10 ; fully opaque - use src\n        UXTB    $tmp0, $src, ROR #8       ; s_ag\n        ORR     $tmp0, $tmp0, #&FF0000\n        UXTB16  $tmp1, $src               ; s_rb\n        MUL     $tmp0, $tmp0, $tmp2\n        MUL     $tmp1, $tmp1, $tmp2\n        RSB     $tmp2, $tmp2, #&FF\n        UXTB16  $src, $dst, ROR #8        ; d_ag\n        UXTB16  $dst, $dst                ; d_rb\n        MLA     $src, $src, $tmp2, $tmp0  ; ag\n        MLA     $dst, $dst, $tmp2, $tmp1  ; rb\n        USUB16  $tmp0, $src, ht_info\n        UXTAB16 $src, $src, $src, ROR #8\n        SEL     $tmp1, ht_info, ht\n        UXTAB16 $src, $tmp1, $src, ROR #8\n        USUB16  $tmp0, $dst, ht_info\n        UXTAB16 $dst, $dst, $dst, ROR #8\n        SEL     $tmp1, ht_info, ht\n        UXTAB16 $dst, $tmp1, $dst, ROR #8\n        ORR     $src, $dst, $src, LSL #8  ; recombine\n        B       %FT10\n09      MOV     $src, $dst\n10\n        MEND\n\n        MACRO\n        AlphaBlend32_32_32bits $src, $dst, $fixed_skew\n        Read1Word src, 0, carry, $fixed_skew, skew, scratch\n        ADD     dst, dst, #1*4\n        MOVS    $wk7, $wk0, LSR #24\n        BEQ     %FT01 ; all pixels fully transparent - don't touch destination\n        LDR     $wk4, [dst, #-1*4]\n        AlphaBlend32_32_1pixel $wk0, $wk4, $wk5, $wk6, $wk7, known_not_transp\n        Write1Word dst, 0\n01\n        MEND\n\n        MACRO\n        AlphaBlend32_32_64bits $src, $fixed_skew\n        Read2Words src, 0, carry, $fixed_skew, skew, scratch\n        ADD     dst, dst, #2*4\n        MOVS    $wk7, $wk0, LSR #24\n        MOVEQS  $wk7, $wk1, LSR #24\n        BEQ     %FT01 ; all pixels fully transparent - don't touch destination\n        LDR     $wk4, [dst, #-2*4]\n        AlphaBlend32_32_1pixel $wk0, $wk4, $wk5, $wk6, $wk7\n        LDR     $wk4, [dst, #-1*4]\n        AlphaBlend32_32_1pixel $wk1, $wk4, $wk5, $wk6, $wk7\n        Write2Words dst, 0\n01\n        MEND\n\n        MACRO\n        AlphaBlend32_32_128bits_head $src, $fixed_skew, $intra_preloads\n        Read4Words src, 0, carry, $fixed_skew, skew, scratch\n        MEND\n\n        MACRO\n        AlphaBlend32_32_128bits_tail $src\n        ADD     dst, dst, #4*4\n        MOVS    $wk7, $wk0, LSR #24\n        MOVEQS  $wk7, $wk1, LSR #24\n        MOVEQS  $wk7, $wk2, LSR #24\n        MOVEQS  $wk7, $wk3, LSR #24\n        BEQ     %FT01 ; all pixels fully transparent - don't touch destination\n        LDR     $wk4, [dst, #-4*4]\n        AlphaBlend32_32_1pixel $wk0, $wk4, $wk5, $wk6, $wk7\n        LDR     $wk4, [dst, #-3*4]\n        AlphaBlend32_32_1pixel $wk1, $wk4, $wk5, $wk6, $wk7\n        LDR     $wk4, [dst, #-2*4]\n        AlphaBlend32_32_1pixel $wk2, $wk4, $wk5, $wk6, $wk7\n        LDR     $wk4, [dst, #-1*4]\n        AlphaBlend32_32_1pixel $wk3, $wk4, $wk5, $wk6, $wk7\n        Write4Words dst, 0\n01\n        MEND\n\n;$op     GenerateFunctions $src_bpp, $dst_w_bpp, $qualifier, $flags, $prefetch_distance,\n;        $work_regs, $line_saved_regs, $leading_pixels_reg, $preload_offset_reg, $init, $newline, $cleanup\n\nAlphaBlend GenerateFunctions 32, 32,, \\\n  FLAG_DST_READWRITE :OR: FLAG_SPILL_LINE_VARS :OR: FLAG_PROCESS_PARALLEL :OR: FLAG_NO_PRELOAD_DST, 1, \\\n  \"stride_d,stride_s,map,bitptrs,skew,orig_w,scratch,carry\", \\\n  \"x,stride_d,stride_s\", bitptrs,, init ; leading_pixels_reg = wk3\n\n; ********************************************************************\n\n        END\n", "source": "Squeak/Cross/plugins/BitBltPlugin/BitBltArmSimdAlphaBlend.s", "file_type": "asm"}
{"text": ";\n; Copyright \u00a9 2013 Raspberry Pi Foundation\n; Copyright \u00a9 2013 RISC OS Open Ltd\n;\n; Permission to use, copy, modify, distribute, and sell this software and its\n; documentation for any purpose is hereby granted without fee, provided that\n; the above copyright notice appear in all copies and that both that\n; copyright notice and this permission notice appear in supporting\n; documentation, and that the name of the copyright holders not be used in\n; advertising or publicity pertaining to distribution of the software without\n; specific, written prior permission.  The copyright holders make no\n; representations about the suitability of this software for any purpose.  It\n; is provided \"as is\" without express or implied warranty.\n;\n; THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS\n; SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND\n; FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY\n; SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n; WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN\n; AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n; OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS\n; SOFTWARE.\n;\n\n; Debug options\n                GBLL    DebugData\n;DebugData       SETL    {TRUE}\n                GBLL    DebugPld\n;DebugPld        SETL    {TRUE}\n                GBLL    VerboseBuild\n;VerboseBuild    SETL    {TRUE}\n\n        GET     BitBltArmSimdAsm.hdr\n\n        AREA    |BitBltArmSimdBitLogical$$Code|, CODE, READONLY\n        ARM\n\n; ********************************************************************\n\n        MACRO\n        BitAnd32bits $src, $dst, $fixed_skew\n      [ \"$dst\" = \"memory\"\n        ; Operate on memory, referenced by src/dst registers\n        Read1Word src, 0, carry, $fixed_skew, skew, $wk1\n        ADD     dst, dst, #1*4\n        ; src = 0  => don't read dest; write 0 to dest\n        ; src = -1 => don't read or write dest\n        TEQ     $wk0, $wk0, ASR #32\n        LDRNE   $wk1, [dst, #-1*4]\n        CMP     $wk0, #-1\n        BEQ     %FT01\n        AND     $wk0, $wk0, $wk1\n        Write1Word dst, 0\n01\n      |\n        ; Operate in registers, input from $src/$dst, return in $src\n        AND     $src, $src, $dst\n      ]\n        MEND\n\n        MACRO\n        BitAnd64bits $src, $fixed_skew\n        Read2Words src, 0, carry, $fixed_skew, skew, $wk2\n        ADD     dst, dst, #2*4\n        TEQ     $wk0, $wk0, ASR #32\n        TEQEQ   $wk0, $wk1\n        LDMNEDB dst, {$wk2, $wk3}\n        CMP     $wk0, #-1\n        CMPEQ   $wk1, #-1\n        BEQ     %FT01\n        AND     $wk0, $wk0, $wk2\n        AND     $wk1, $wk1, $wk3\n        Write2Words dst, 0\n01\n        MEND\n\n        MACRO\n        BitAnd128bits_head $src, $fixed_skew, $intra_preloads\n        Read4Words src, 0, carry, $fixed_skew, skew, $wk6\n        MEND\n\n        MACRO\n        BitAnd128bits_tail $src\n        ADD     dst, dst, #4*4\n        TEQ     $wk0, $wk0, ASR #32\n        TEQEQ   $wk0, $wk1\n        TEQEQ   $wk0, $wk2\n        TEQEQ   $wk0, $wk3\n        LDMNEDB dst, {$wk4, $wk5, $wk6, $wk7}\n        CMP     $wk0, #-1\n        CMPEQ   $wk1, #-1\n        CMPEQ   $wk2, #-1\n        CMPEQ   $wk3, #-1\n        BEQ     %FT01\n        AND     $wk0, $wk0, $wk4\n        AND     $wk1, $wk1, $wk5\n        AND     $wk2, $wk2, $wk6\n        AND     $wk3, $wk3, $wk7\n        Write4Words dst, 0\n01\n        MEND\n\n; ********************************************************************\n\n        MACRO\n        BitAnd1_1_32bits $src, $dst, $fixed_skew\n        BitAnd32bits $src, $dst, $fixed_skew\n        MEND\n\n        MACRO\n        BitAnd1_1_64bits $src, $fixed_skew\n        BitAnd64bits $src, $fixed_skew\n        MEND\n\n        MACRO\n        BitAnd1_1_128bits_head $src, $fixed_skew, $intra_preloads\n        BitAnd128bits_head $src, $fixed_skew, $intra_preloads\n        MEND\n\n        MACRO\n        BitAnd1_1_128bits_tail $src\n        BitAnd128bits_tail $src\n        MEND\n\n;$op     GenerateFunctions $src_bpp, $dst_w_bpp, $qualifier, $flags, $prefetch_distance,\n;        $work_regs, $line_saved_regs, $leading_pixels_reg, $preload_offset_reg, $init, $newline, $cleanup\n\nBitAnd GenerateFunctions 1, 1,, \\\n  FLAG_DST_READWRITE :OR: FLAG_SPILL_LINE_VARS :OR: FLAG_NO_EXPAND_SKEW :OR: FLAG_PROCESS_PARALLEL :OR: FLAG_NO_PRELOAD_DST, 3, \\\n  \"stride_d,stride_s,ht,ht_info,map,bitptrs,orig_w,scratch\", \\\n  \"x,stride_d,stride_s,bitptrs\", map ; leading_pixels_reg = wk4\n\n; ********************************************************************\n\n        MACRO\n        BitAnd2_2_32bits $src, $dst, $fixed_skew\n        BitAnd32bits $src, $dst, $fixed_skew\n        MEND\n\n        MACRO\n        BitAnd2_2_64bits $src, $fixed_skew\n        BitAnd64bits $src, $fixed_skew\n        MEND\n\n        MACRO\n        BitAnd2_2_128bits_head $src, $fixed_skew, $intra_preloads\n        BitAnd128bits_head $src, $fixed_skew, $intra_preloads\n        MEND\n\n        MACRO\n        BitAnd2_2_128bits_tail $src\n        BitAnd128bits_tail $src\n        MEND\n\n;$op     GenerateFunctions $src_bpp, $dst_w_bpp, $qualifier, $flags, $prefetch_distance,\n;        $work_regs, $line_saved_regs, $leading_pixels_reg, $preload_offset_reg, $init, $newline, $cleanup\n\nBitAnd GenerateFunctions 2, 2,, \\\n  FLAG_DST_READWRITE :OR: FLAG_SPILL_LINE_VARS :OR: FLAG_NO_EXPAND_SKEW :OR: FLAG_PROCESS_PARALLEL :OR: FLAG_NO_PRELOAD_DST, 1, \\\n  \"stride_d,stride_s,ht,ht_info,map,bitptrs,orig_w,scratch\", \\\n  \"x,stride_d,stride_s,bitptrs\", map ; leading_pixels_reg = wk4\n\n; ********************************************************************\n\n        MACRO\n        BitAnd4_4_32bits $src, $dst, $fixed_skew\n        BitAnd32bits $src, $dst, $fixed_skew\n        MEND\n\n        MACRO\n        BitAnd4_4_64bits $src, $fixed_skew\n        BitAnd64bits $src, $fixed_skew\n        MEND\n\n        MACRO\n        BitAnd4_4_128bits_head $src, $fixed_skew, $intra_preloads\n        BitAnd128bits_head $src, $fixed_skew, $intra_preloads\n        MEND\n\n        MACRO\n        BitAnd4_4_128bits_tail $src\n        BitAnd128bits_tail $src\n        MEND\n\n;$op     GenerateFunctions $src_bpp, $dst_w_bpp, $qualifier, $flags, $prefetch_distance,\n;        $work_regs, $line_saved_regs, $leading_pixels_reg, $preload_offset_reg, $init, $newline, $cleanup\n\nBitAnd GenerateFunctions 4, 4,, \\\n  FLAG_DST_READWRITE :OR: FLAG_SPILL_LINE_VARS :OR: FLAG_NO_EXPAND_SKEW :OR: FLAG_PROCESS_PARALLEL :OR: FLAG_NO_PRELOAD_DST, 2, \\\n  \"stride_d,stride_s,ht,ht_info,map,bitptrs,orig_w,scratch\", \\\n  \"x,stride_d,stride_s,bitptrs\", map ; leading_pixels_reg = wk4\n\n; ********************************************************************\n\n        MACRO\n        BitAnd8_8_32bits $src, $dst, $fixed_skew\n        BitAnd32bits $src, $dst, $fixed_skew\n        MEND\n\n        MACRO\n        BitAnd8_8_64bits $src, $fixed_skew\n        BitAnd64bits $src, $fixed_skew\n        MEND\n\n        MACRO\n        BitAnd8_8_128bits_head $src, $fixed_skew, $intra_preloads\n        BitAnd128bits_head $src, $fixed_skew, $intra_preloads\n        MEND\n\n        MACRO\n        BitAnd8_8_128bits_tail $src\n        BitAnd128bits_tail $src\n        MEND\n\n;$op     GenerateFunctions $src_bpp, $dst_w_bpp, $qualifier, $flags, $prefetch_distance,\n;        $work_regs, $line_saved_regs, $leading_pixels_reg, $preload_offset_reg, $init, $newline, $cleanup\n\nBitAnd GenerateFunctions 8, 8,, \\\n  FLAG_DST_READWRITE :OR: FLAG_SPILL_LINE_VARS :OR: FLAG_PROCESS_PARALLEL :OR: FLAG_NO_PRELOAD_DST, 2, \\\n  \"stride_d,ht,ht_info,map,bitptrs,skew,orig_w,scratch\", \\\n  \"x,stride_d\", bitptrs ; leading_pixels_reg = wk4\n\n; ********************************************************************\n\n        MACRO\n        BitAnd16_16_32bits $src, $dst, $fixed_skew\n        BitAnd32bits $src, $dst, $fixed_skew\n        MEND\n\n        MACRO\n        BitAnd16_16_64bits $src, $fixed_skew\n        BitAnd64bits $src, $fixed_skew\n        MEND\n\n        MACRO\n        BitAnd16_16_128bits_head $src, $fixed_skew, $intra_preloads\n        BitAnd128bits_head $src, $fixed_skew, $intra_preloads\n        MEND\n\n        MACRO\n        BitAnd16_16_128bits_tail $src\n        BitAnd128bits_tail $src\n        MEND\n\n;$op     GenerateFunctions $src_bpp, $dst_w_bpp, $qualifier, $flags, $prefetch_distance,\n;        $work_regs, $line_saved_regs, $leading_pixels_reg, $preload_offset_reg, $init, $newline, $cleanup\n\nBitAnd GenerateFunctions 16, 16,, \\\n  FLAG_DST_READWRITE :OR: FLAG_SPILL_LINE_VARS :OR: FLAG_PROCESS_PARALLEL :OR: FLAG_NO_PRELOAD_DST, 2, \\\n  \"stride_s,ht,ht_info,map,bitptrs,skew,orig_w,scratch\", \\\n  \"x,stride_s\", bitptrs ; leading_pixels_reg = wk4\n\n; ********************************************************************\n\n        MACRO\n        BitAnd32_32_32bits $src, $dst, $fixed_skew\n        BitAnd32bits $src, $dst, $fixed_skew\n        MEND\n\n        MACRO\n        BitAnd32_32_64bits $src, $fixed_skew\n        BitAnd64bits $src, $fixed_skew\n        MEND\n\n        MACRO\n        BitAnd32_32_128bits_head $src, $fixed_skew, $intra_preloads\n        BitAnd128bits_head $src, $fixed_skew, $intra_preloads\n        MEND\n\n        MACRO\n        BitAnd32_32_128bits_tail $src\n        BitAnd128bits_tail $src\n        MEND\n\n;$op     GenerateFunctions $src_bpp, $dst_w_bpp, $qualifier, $flags, $prefetch_distance,\n;        $work_regs, $line_saved_regs, $leading_pixels_reg, $preload_offset_reg, $init, $newline, $cleanup\n\nBitAnd GenerateFunctions 32, 32,, \\\n  FLAG_DST_READWRITE :OR: FLAG_SPILL_LINE_VARS :OR: FLAG_PROCESS_PARALLEL :OR: FLAG_NO_PRELOAD_DST, 1, \\\n  \"ht,ht_info,map,bitptrs,skew,orig_w,scratch,carry\", \\\n  \"x\", skew ; leading_pixels_reg = wk4\n\n; ********************************************************************\n\n        END\n", "source": "Squeak/Cross/plugins/BitBltPlugin/BitBltArmSimdBitLogical.s", "file_type": "asm"}
{"text": ";\n; Copyright \u00a9 2013 Raspberry Pi Foundation\n; Copyright \u00a9 2013 RISC OS Open Ltd\n;\n; Permission to use, copy, modify, distribute, and sell this software and its\n; documentation for any purpose is hereby granted without fee, provided that\n; the above copyright notice appear in all copies and that both that\n; copyright notice and this permission notice appear in supporting\n; documentation, and that the name of the copyright holders not be used in\n; advertising or publicity pertaining to distribution of the software without\n; specific, written prior permission.  The copyright holders make no\n; representations about the suitability of this software for any purpose.  It\n; is provided \"as is\" without express or implied warranty.\n;\n; THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS\n; SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND\n; FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY\n; SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n; WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN\n; AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n; OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS\n; SOFTWARE.\n;\n\n; Debug options\n                GBLL    DebugData\n;DebugData       SETL    {TRUE}\n                GBLL    DebugPld\n;DebugPld        SETL    {TRUE}\n                GBLL    VerboseBuild\n;VerboseBuild    SETL    {TRUE}\n\n        GET     BitBltArmSimdAsm.hdr\n\n        AREA    |BitBltArmSimdPixPaint$$Code|, CODE, READONLY\n        ARM\n\n; ********************************************************************\n\n        MACRO\n        PixPaint1_1_32bits $src, $dst, $fixed_skew\n      [ \"$dst\" = \"memory\"\n        ; Operate on memory, referenced by src/dst registers\n        Read1Word src, 0, carry, $fixed_skew, skew, $wk1\n        ADD     dst, dst, #1*4\n        TEQ     $wk0, #0\n        BEQ     %FT01 ; don't read or write dest unless we really have to\n        LDR     $wk1, [dst, #-4]\n        ORR     $wk0, $wk0, $wk1\n        Write1Word dst, 0\n01\n      |\n        ; Operate in registers, input from $src/$dst, return in $src\n        ORR     $src, $src, $dst\n      ]\n        MEND\n\n        MACRO\n        PixPaint1_1_64bits $src, $fixed_skew\n        Read2Words src, 0, carry, $fixed_skew, skew, $wk2\n        ADD     dst, dst, #2*4\n        TEQ     $wk0, #0\n        TEQEQ   $wk1, #0\n        BEQ     %FT01 ; don't read or write dest unless we really have to\n        LDMDB   dst, {$wk2, $wk3}\n        ORR     $wk0, $wk0, $wk2\n        ORR     $wk1, $wk1, $wk3\n        Write2Words dst, 0\n01\n        MEND\n\n        MACRO\n        PixPaint1_1_128bits_head $src, $fixed_skew, $intra_preloads\n        Read4Words src, 0, carry, $fixed_skew, skew, $wk6\n        MEND\n\n        MACRO\n        PixPaint1_1_128bits_tail $src\n        ADD     dst, dst, #4*4\n        TEQ     $wk0, #0\n        TEQEQ   $wk1, #0\n        TEQEQ   $wk2, #0\n        TEQEQ   $wk3, #0\n        BEQ     %FT01 ; don't read or write dest unless we really have to\n        LDMDB   dst, {$wk4, $wk5, $wk6, $wk7}\n        ORR     $wk0, $wk0, $wk4\n        ORR     $wk1, $wk1, $wk5\n        ORR     $wk2, $wk2, $wk6\n        ORR     $wk3, $wk3, $wk7\n        Write4Words dst, 0\n01\n        MEND\n\n;$op     GenerateFunctions $src_bpp, $dst_w_bpp, $qualifier, $flags, $prefetch_distance,\n;        $work_regs, $line_saved_regs, $leading_pixels_reg, $preload_offset_reg, $init, $newline, $cleanup\n\nPixPaint GenerateFunctions 1, 1,, \\\n  FLAG_DST_READWRITE :OR: FLAG_SPILL_LINE_VARS :OR: FLAG_NO_EXPAND_SKEW :OR: FLAG_PROCESS_PARALLEL :OR: FLAG_NO_PRELOAD_DST, 2, \\\n  \"y,stride_d,stride_s,ht_info,map,bitptrs,orig_w,scratch\", \\\n  \"x,y,stride_d,stride_s,bitptrs\", map\n\n; ********************************************************************\n\n        MACRO\n        PixPaint2_2_init\n        LDR     ht, =&55555555\n        B       %FT00\n        LTORG\n00\n        MEND\n\n        MACRO\n        PixPaint2_2_16pixels $src, $dst, $pattern, $tmp, $src_known_nonzero\n        ORRS    $tmp, $src, $src, LSR #1\n      [ \"$src_known_nonzero\" = \"\"\n        BEQ     %FT03\n      ]\n        AND     $tmp, $tmp, $pattern\n        ORR     $tmp, $tmp, $tmp, LSL #1\n        BIC     $tmp, $dst, $tmp\n        ORR     $src, $src, $tmp\n      [ \"$src_known_nonzero\" = \"\"\n        B       %FT04\n03      MOV     $src, $dst\n04\n      ]\n        MEND\n\n        MACRO\n        PixPaint2_2_32pixels $src0, $src1, $dst0, $dst1, $pattern, $tmp0, $tmp1\n        ORR     $tmp0, $src0, $src0, LSR #1\n        ORR     $tmp1, $src1, $src1, LSR #1\n        AND     $tmp0, $tmp0, $pattern\n        AND     $tmp1, $tmp1, $pattern\n        ORR     $tmp0, $tmp0, $tmp0, LSL #1\n        ORR     $tmp1, $tmp1, $tmp1, LSL #1\n        BIC     $tmp0, $dst0, $tmp0\n        BIC     $tmp1, $dst1, $tmp1\n        ORR     $src0, $src0, $tmp0\n        ORR     $src1, $src1, $tmp1\n        MEND\n\n        MACRO\n        PixPaint2_2_32bits $src, $dst, $fixed_skew\n      [ \"$dst\" = \"memory\"\n        ; Operate on memory, referenced by src/dst registers\n        Read1Word src, 0, carry, $fixed_skew, skew, $wk1\n        ADD     dst, dst, #1*4\n        TEQ     $wk0, #0\n        BEQ     %FT01 ; don't read or write dest unless we really have to\n        LDR     $wk1, [dst, #-4]\n        PixPaint2_2_16pixels $wk0, $wk1, ht, $wk6, src_known_nonzero\n        Write1Word dst, 0\n01\n      |\n        ; Operate in registers, input from $src/$dst, return in $src\n        PixPaint2_2_16pixels $src, $dst, ht, $wk6\n      ]\n        MEND\n\n        MACRO\n        PixPaint2_2_64bits $src, $fixed_skew\n        Read2Words src, 0, carry, $fixed_skew, skew, $wk2\n        ADD     dst, dst, #2*4\n        TEQ     $wk0, #0\n        TEQEQ   $wk1, #0\n        BEQ     %FT01 ; don't read or write dest unless we really have to\n        LDMDB   dst, {$wk2, $wk3}\n        PixPaint2_2_32pixels $wk0, $wk1, $wk2, $wk3, ht, $wk6, $wk7\n        Write2Words dst, 0\n01\n        MEND\n\n        MACRO\n        PixPaint2_2_128bits_head $src, $fixed_skew, $intra_preloads\n        Read4Words src, 0, carry, $fixed_skew, skew, $wk6\n        MEND\n\n        MACRO\n        PixPaint2_2_128bits_tail $src\n        ADD     dst, dst, #4*4\n        TEQ     $wk0, #0\n        TEQEQ   $wk1, #0\n        TEQEQ   $wk2, #0\n        TEQEQ   $wk3, #0\n        BEQ     %FT01 ; don't read or write dest unless we really have to\n        LDRD    $wk4, $wk5, [dst, #-4*4]\n        PixPaint2_2_32pixels $wk0, $wk1, $wk4, $wk5, ht, $wk6, $wk7\n        LDRD    $wk4, $wk5, [dst, #-2*4]\n        PixPaint2_2_32pixels $wk2, $wk3, $wk4, $wk5, ht, $wk6, $wk7\n        Write4Words dst, 0\n01\n        MEND\n\n;$op     GenerateFunctions $src_bpp, $dst_w_bpp, $qualifier, $flags, $prefetch_distance,\n;        $work_regs, $line_saved_regs, $leading_pixels_reg, $preload_offset_reg, $init, $newline, $cleanup\n\nPixPaint GenerateFunctions 2, 2,, \\\n  FLAG_DST_READWRITE :OR: FLAG_SPILL_LINE_VARS :OR: FLAG_NO_EXPAND_SKEW :OR: FLAG_PROCESS_PARALLEL :OR: FLAG_NO_PRELOAD_DST, 2, \\\n  \"y,stride_d,stride_s,ht_info,map,bitptrs,orig_w,scratch\", \\\n  \"x,y,stride_d,stride_s,bitptrs\", map,, init\n\n; ********************************************************************\n\n        MACRO\n        PixPaint4_4_init\n        LDR     ht, =&11111111\n        B       %FT00\n        LTORG\n00\n        MEND\n\n        MACRO\n        PixPaint4_4_8pixels $src, $dst, $pattern, $tmp, $src_known_nonzero\n        ORRS    $tmp, $src, $src, LSR #1\n      [ \"$src_known_nonzero\" = \"\"\n        BEQ     %FT03\n      ]\n        ORR     $tmp, $tmp, $tmp, LSR #2\n        AND     $tmp, $tmp, $pattern\n        ORR     $tmp, $tmp, $tmp, LSL #2\n        ORR     $tmp, $tmp, $tmp, LSL #1\n        BIC     $tmp, $dst, $tmp\n        ORR     $src, $src, $tmp\n      [ \"$src_known_nonzero\" = \"\"\n        B       %FT04\n03      MOV     $src, $dst\n04\n      ]\n        MEND\n\n        MACRO\n        PixPaint4_4_16pixels $src0, $src1, $dst0, $dst1, $pattern, $tmp0, $tmp1\n        ORR     $tmp0, $src0, $src0, LSR #1\n        ORR     $tmp1, $src1, $src1, LSR #1\n        ORR     $tmp0, $tmp0, $tmp0, LSR #2\n        ORR     $tmp1, $tmp1, $tmp1, LSR #2\n        AND     $tmp0, $tmp0, $pattern\n        AND     $tmp1, $tmp1, $pattern\n        ORR     $tmp0, $tmp0, $tmp0, LSL #2\n        ORR     $tmp1, $tmp1, $tmp1, LSL #2\n        ORR     $tmp0, $tmp0, $tmp0, LSL #1\n        ORR     $tmp1, $tmp1, $tmp1, LSL #1\n        BIC     $tmp0, $dst0, $tmp0\n        BIC     $tmp1, $dst1, $tmp1\n        ORR     $src0, $src0, $tmp0\n        ORR     $src1, $src1, $tmp1\n        MEND\n\n        MACRO\n        PixPaint4_4_32bits $src, $dst, $fixed_skew\n      [ \"$dst\" = \"memory\"\n        ; Operate on memory, referenced by src/dst registers\n        Read1Word src, 0, carry, $fixed_skew, skew, $wk1\n        ADD     dst, dst, #1*4\n        TEQ     $wk0, #0\n        BEQ     %FT01 ; don't read or write dest unless we really have to\n        LDR     $wk1, [dst, #-4]\n        PixPaint4_4_8pixels $wk0, $wk1, ht, $wk6, src_known_nonzero\n        Write1Word dst, 0\n01\n      |\n        ; Operate in registers, input from $src/$dst, return in $src\n        PixPaint4_4_8pixels $src, $dst, ht, $wk6\n      ]\n        MEND\n\n        MACRO\n        PixPaint4_4_64bits $src, $fixed_skew\n        Read2Words src, 0, carry, $fixed_skew, skew, $wk2\n        ADD     dst, dst, #2*4\n        TEQ     $wk0, #0\n        TEQEQ   $wk1, #0\n        BEQ     %FT01 ; don't read or write dest unless we really have to\n        LDMDB   dst, {$wk2, $wk3}\n        PixPaint4_4_16pixels $wk0, $wk1, $wk2, $wk3, ht, $wk6, $wk7\n        Write2Words dst, 0\n01\n        MEND\n\n        MACRO\n        PixPaint4_4_128bits_head $src, $fixed_skew, $intra_preloads\n        Read4Words src, 0, carry, $fixed_skew, skew, $wk6\n        MEND\n\n        MACRO\n        PixPaint4_4_128bits_tail $src\n        ADD     dst, dst, #4*4\n        TEQ     $wk0, #0\n        TEQEQ   $wk1, #0\n        TEQEQ   $wk2, #0\n        TEQEQ   $wk3, #0\n        BEQ     %FT01 ; don't read or write dest unless we really have to\n        LDRD    $wk4, $wk5, [dst, #-4*4]\n        PixPaint4_4_16pixels $wk0, $wk1, $wk4, $wk5, ht, $wk6, $wk7\n        LDRD    $wk4, $wk5, [dst, #-2*4]\n        PixPaint4_4_16pixels $wk2, $wk3, $wk4, $wk5, ht, $wk6, $wk7\n        Write4Words dst, 0\n01\n        MEND\n\n;$op     GenerateFunctions $src_bpp, $dst_w_bpp, $qualifier, $flags, $prefetch_distance,\n;        $work_regs, $line_saved_regs, $leading_pixels_reg, $preload_offset_reg, $init, $newline, $cleanup\n\nPixPaint GenerateFunctions 4, 4,, \\\n  FLAG_DST_READWRITE :OR: FLAG_SPILL_LINE_VARS :OR: FLAG_NO_EXPAND_SKEW :OR: FLAG_PROCESS_PARALLEL :OR: FLAG_NO_PRELOAD_DST, 3, \\\n  \"y,stride_d,stride_s,ht_info,map,bitptrs,orig_w,scratch\", \\\n  \"x,y,stride_d,stride_s,bitptrs\", map,, init\n\n; ********************************************************************\n\n        MACRO\n        PixPaint8_8_init\n        MOV     ht, #0\n        MEND\n\n        MACRO\n        PixPaint8_8_4pixels $src, $dst, $zero, $tmp\n        USUB8   $tmp, $zero, $src ; set GE bit for each zero byte\n        SEL     $src, $dst, $src\n        MEND\n\n        MACRO\n        PixPaint8_8_32bits $src, $dst, $fixed_skew\n      [ \"$dst\" = \"memory\"\n        ; Operate on memory, referenced by src/dst registers\n        Read1Word src, 0, carry, $fixed_skew, skew, $wk1\n        ADD     dst, dst, #1*4\n        TEQ     $wk0, #0\n        BEQ     %FT01 ; don't read or write dest unless we really have to\n        LDR     $wk1, [dst, #-4]\n        PixPaint8_8_4pixels $wk0, $wk1, ht, $wk6\n        Write1Word dst, 0\n01\n      |\n        ; Operate in registers, input from $src/$dst, return in $src\n        PixPaint8_8_4pixels $src, $dst, ht, $wk6\n      ]\n        MEND\n\n        MACRO\n        PixPaint8_8_64bits $src, $fixed_skew\n        Read2Words src, 0, carry, $fixed_skew, skew, $wk2\n        ADD     dst, dst, #2*4\n        TEQ     $wk0, #0\n        TEQEQ   $wk1, #0\n        BEQ     %FT01 ; don't read or write dest unless we really have to\n        LDMDB   dst, {$wk2, $wk3}\n        PixPaint8_8_4pixels $wk0, $wk2, ht, $wk6\n        PixPaint8_8_4pixels $wk1, $wk3, ht, $wk6\n        Write2Words dst, 0\n01\n        MEND\n\n        MACRO\n        PixPaint8_8_128bits_head $src, $fixed_skew, $intra_preloads\n        Read4Words src, 0, carry, $fixed_skew, skew, $wk6\n        MEND\n\n        MACRO\n        PixPaint8_8_128bits_tail $src\n        ADD     dst, dst, #4*4\n        TEQ     $wk0, #0\n        TEQEQ   $wk1, #0\n        TEQEQ   $wk2, #0\n        TEQEQ   $wk3, #0\n        BEQ     %FT01 ; don't read or write dest unless we really have to\n        LDRD    $wk5, $wk6, [dst, #-4*4]\n        PixPaint8_8_4pixels $wk0, $wk5, ht, $wk4\n        PixPaint8_8_4pixels $wk1, $wk6, ht, $wk4\n        LDRD    $wk5, $wk6, [dst, #-2*4]\n        PixPaint8_8_4pixels $wk2, $wk5, ht, $wk4\n        PixPaint8_8_4pixels $wk3, $wk6, ht, $wk4\n        Write4Words dst, 0\n01\n        MEND\n\n;$op     GenerateFunctions $src_bpp, $dst_w_bpp, $qualifier, $flags, $prefetch_distance,\n;        $work_regs, $line_saved_regs, $leading_pixels_reg, $preload_offset_reg, $init, $newline, $cleanup\n\nPixPaint GenerateFunctions 8, 8,, \\\n  FLAG_DST_READWRITE :OR: FLAG_SPILL_LINE_VARS :OR: FLAG_PROCESS_PARALLEL :OR: FLAG_NO_PRELOAD_DST, 2, \\\n  \"stride_d,stride_s,ht_info,map,bitptrs,skew,orig_w\", \\\n  \"x,stride_d,stride_s\", bitptrs, scratch, init\n\n; ********************************************************************\n\n        MACRO\n        PixPaint16_16_init\n        MOV     ht, #0\n        MEND\n\n        MACRO\n        PixPaint16_16_2pixels $src, $dst, $zero, $tmp\n        USUB16  $tmp, $zero, $src ; set GE bit pair for each zero halfword\n        SEL     $src, $dst, $src\n        MEND\n\n        MACRO\n        PixPaint16_16_32bits $src, $dst, $fixed_skew\n      [ \"$dst\" = \"memory\"\n        ; Operate on memory, referenced by src/dst registers\n        Read1Word src, 0, carry, $fixed_skew, skew, $wk1\n        ADD     dst, dst, #1*4\n        TEQ     $wk0, #0\n        BEQ     %FT01 ; don't read or write dest unless we really have to\n        LDR     $wk1, [dst, #-4]\n        PixPaint16_16_2pixels $wk0, $wk1, ht, $wk6\n        Write1Word dst, 0\n01\n      |\n        ; Operate in registers, input from $src/$dst, return in $src\n        PixPaint16_16_2pixels $src, $dst, ht, $wk6\n      ]\n        MEND\n\n        MACRO\n        PixPaint16_16_64bits $src, $fixed_skew\n        Read2Words src, 0, carry, $fixed_skew, skew, $wk2\n        ADD     dst, dst, #2*4\n        TEQ     $wk0, #0\n        TEQEQ   $wk1, #0\n        BEQ     %FT01 ; don't read or write dest unless we really have to\n        LDMDB   dst, {$wk2, $wk3}\n        PixPaint16_16_2pixels $wk0, $wk2, ht, $wk6\n        PixPaint16_16_2pixels $wk1, $wk3, ht, $wk6\n        Write2Words dst, 0\n01\n        MEND\n\n        MACRO\n        PixPaint16_16_128bits_head $src, $fixed_skew, $intra_preloads\n        Read4Words src, 0, carry, $fixed_skew, skew, $wk6\n        MEND\n\n        MACRO\n        PixPaint16_16_128bits_tail $src\n        ADD     dst, dst, #4*4\n        TEQ     $wk0, #0\n        TEQEQ   $wk1, #0\n        TEQEQ   $wk2, #0\n        TEQEQ   $wk3, #0\n        BEQ     %FT01 ; don't read or write dest unless we really have to\n        LDRD    $wk5, $wk6, [dst, #-4*4]\n        PixPaint16_16_2pixels $wk0, $wk5, ht, $wk4\n        PixPaint16_16_2pixels $wk1, $wk6, ht, $wk4\n        LDRD    $wk5, $wk6, [dst, #-2*4]\n        PixPaint16_16_2pixels $wk2, $wk5, ht, $wk4\n        PixPaint16_16_2pixels $wk3, $wk6, ht, $wk4\n        Write4Words dst, 0\n01\n        MEND\n\n;$op     GenerateFunctions $src_bpp, $dst_w_bpp, $qualifier, $flags, $prefetch_distance,\n;        $work_regs, $line_saved_regs, $leading_pixels_reg, $preload_offset_reg, $init, $newline, $cleanup\n\nPixPaint GenerateFunctions 16, 16,, \\\n  FLAG_DST_READWRITE :OR: FLAG_SPILL_LINE_VARS :OR: FLAG_PROCESS_PARALLEL :OR: FLAG_NO_PRELOAD_DST, 2, \\\n  \"stride_d,stride_s,ht_info,map,bitptrs,skew,orig_w\", \\\n  \"x,stride_d,stride_s\", bitptrs, scratch, init\n\n; ********************************************************************\n\n        MACRO\n        PixPaint32_32_32bits $src, $dst, $fixed_skew\n        Read1Word src, 0, carry, $fixed_skew, skew, $wk1\n        ADD     dst, dst, #1*4\n        TEQ     $wk0, #0\n        STRNE   $wk0, [dst, #-4]\n        MEND\n\n        MACRO\n        PixPaint32_32_64bits $src, $fixed_skew\n        Read2Words src, 0, carry, $fixed_skew, skew, $wk2\n        ADD     dst, dst, #2*4\n        TEQ     $wk0, #0\n        TEQEQ   $wk1, #0\n        BEQ     %FT01 ; don't read or write dest unless we really have to\n        TEQ     $wk0, #0\n        LDREQ   $wk0, [dst, #-2*4]\n        TEQ     $wk1, #0\n        LDREQ   $wk1, [dst, #-1*4]\n        Write2Words dst, 0\n01\n        MEND\n\n        MACRO\n        PixPaint32_32_128bits_head $src, $fixed_skew, $intra_preloads\n        Read4Words src, 0, carry, $fixed_skew, skew, scratch\n        MEND\n\n        MACRO\n        PixPaint32_32_128bits_tail $src\n        ADD     dst, dst, #4*4\n        TEQ     $wk0, #0\n        TEQEQ   $wk1, #0\n        TEQEQ   $wk2, #0\n        TEQEQ   $wk3, #0\n        BEQ     %FT01 ; don't read or write dest unless we really have to\n        TEQ     $wk0, #0\n        LDREQ   $wk0, [dst, #-4*4]\n        TEQ     $wk1, #0\n        LDREQ   $wk1, [dst, #-3*4]\n        TEQ     $wk2, #0\n        LDREQ   $wk2, [dst, #-2*4]\n        TEQ     $wk3, #0\n        LDREQ   $wk3, [dst, #-1*4]\n        Write4Words dst, 0\n01\n        MEND\n\n;$op     GenerateFunctions $src_bpp, $dst_w_bpp, $qualifier, $flags, $prefetch_distance,\n;        $work_regs, $line_saved_regs, $leading_pixels_reg, $preload_offset_reg, $init, $newline, $cleanup\n\nPixPaint GenerateFunctions 32, 32,, \\\n  FLAG_DST_READWRITE :OR: FLAG_PROCESS_PARALLEL :OR: FLAG_NO_PRELOAD_DST, 2, \\\n  \"ht,ht_info,map,bitptrs\", \\\n  \"\", bitptrs, scratch\n\n; ********************************************************************\n\n        END\n", "source": "Squeak/Cross/plugins/BitBltPlugin/BitBltArmSimdPixPaint.s", "file_type": "asm"}
{"text": "</$objtype/mkfile\n\nINTERP_DIR=src\nCROSS_DIR=../Cross\nOUT=squeak\n\nVM_DIR=$INTERP_DIR/vm\nPLUGIN_DIR=$INTERP_DIR/plugins\nCROSS_PLUGIN_DIR=$CROSS_DIR/plugins\nCROSS_VM_DIR=$CROSS_DIR/vm\n\nINCLUDES=-I$CROSS_PLUGIN_DIR/FilePlugin -I$CROSS_PLUGIN_DIR/SocketPlugin -I$CROSS_VM_DIR -Ivm -I$VM_DIR -I.\nCFLAGS=-+ -p $INCLUDES -DSQUEAK_BUILTIN_PLUGIN\n\nINTERP_NAMES=interp\nPLUGIN_NAMES=BitBltPlugin/BitBltPlugin B2DPlugin/B2DPlugin FilePlugin/FilePlugin SocketPlugin/SocketPlugin\nPLATFORM_NAMES=sqPlan9ExternalPrims sqPlan9clip osExports sqPlan9io sqPlan9prof \\\n\t\t\t   sqPlan9main p9display\nPLATFORM_PLUGIN_NAMES=FilePlugin/sqPlan9file SocketPlugin/sqPlan9socket\nCROSS_NAMES=sqNamedPrims sqVirtualMachine\nCROSS_PLUGIN_NAMES=FilePlugin/sqFilePluginBasicPrims\n\nNAMES=${INTERP_NAMES:%=$VM_DIR/%} \\\n\t  ${PLUGIN_NAMES:%=$PLUGIN_DIR/%} \\\n\t  ${PLATFORM_NAMES:%=vm/%} \\\n\t  ${PLATFORM_PLUGIN_NAMES:%=plugins/%} \\\n\t  ${CROSS_NAMES:%=$CROSS_VM_DIR/%} \\\n\t  ${CROSS_PLUGIN_NAMES:%=$CROSS_PLUGIN_DIR/%}\n\nOBJS=${NAMES:%=%.$O}\n\nall:V: $OUT\n\nclean:\n\trm -f $OBJS $OUT\n\n$OUT: $OBJS\n\t$LD $LDFLAGS -o $target $prereq\n\n%.$O: %.c\n\t$CC -c $CFLAGS -o $target $stem.c\n", "source": "Squeak/Plan9/mkfile", "file_type": "mkfile"}
{"text": "#ifndef _LIBC_WRAPPER_H\n#define _LIBC_WRAPPER_H\n\n/* avoid conflicts with squeak print function */\n#define print p9_print\n\n#include <u.h>\n#include <libc.h>\n\n#undef print\n\n#endif\n", "source": "Squeak/Plan9/vm/libc_wrapper.h", "file_type": "h"}
{"text": "#include <u.h>\n#include <libc.h>\n\nvoid\nusage(void)\n{\n\tfprint(2, \"%s [-abiC] [-m mtpt] [-s srv] [-c] path ...\\n\", argv0);\n\texits(\"usage\");\n}\n\nvoid*\nemalloc(ulong sz)\n{\n\tvoid *v;\n\n\tif((v = malloc(sz)) == nil)\n\t\tsysfatal(\"emalloc: %r\");\n\tmemset(v, 0, sz);\n\tsetmalloctag(v, getcallerpc(&sz));\n\treturn v;\n}\n\nchar*\nestrdup(char *s)\n{\n\tchar *p;\n\n\tif((p = strdup(s)) == nil)\n\t\tsysfatal(\"estrdup: %r\");\n\tsetmalloctag(p, getcallerpc(&s));\n\treturn p;\n}\n", "source": "unionfs/util.c", "file_type": "c"}
{"text": "</$objtype/mkfile\n\nBIN=/$objtype/bin\nMAN=/sys/man/4\nTARG=unionfs\n\nHFILES=\\\n\tunionfs.h\nOFILES=\\\n\tutil.$O\\\n\tqmap.$O\\\n\tdirlist.$O\\\n\tunionfs.$O\n\n</sys/src/cmd/mkone\n\ninstall:V: man\n\nuninstall:V:\n\trm -f $BIN/$TARG\n\trm -f $MAN/$TARG\n", "source": "unionfs/mkfile", "file_type": "mkfile"}
{"text": "#include <u.h>\n#include <libc.h>\n#include <String.h>\n#include <fcall.h>\n#include <thread.h>\n#include <9p.h>\n\ntypedef struct Branch Branch;\ntypedef struct FILE FILE;\ntypedef struct Mtpt Mtpt;\ntypedef struct Dirlist Dirlist;\n\nstruct Branch {\n\tchar *root;\n\tint create;\n};\n\nstruct FILE {\n\tDir;\n\tString *realpath;\n\tString *path;\n\n\tint fd;\n\tMtpt *mtpt;\n\tDirlist *dl;\n\t\n\tint pid;\n\tint flushed;\n};\n\nstruct Mtpt {\n\tchar *path;\n\tMtpt *next;\n};\n\nstruct Dirlist {\n\tDir *all;\n\tlong nall;\n\tDir **dirs;\n\tlong ndirs;\n\t\n\t/* implementation-specific */\n\tchar **seen;\n\tusize nseen, mseen;\n};\n\nvoid usage(void);\nQid qencode(Dir*);\nDirlist *dirlist(int);\nvoid dirlistfree(Dirlist*);\nvoid *emalloc(ulong);\nchar *estrdup(char*);\n", "source": "unionfs/unionfs.h", "file_type": "h"}
{"text": "</$objtype/mkfile\n\nTARG=orca\nCFLAGS=$CFLAGS -p -D__plan9__\nBIN=/$objtype/bin/games\nMAN=/sys/man/1\n\nHFILES=\\\n\tfield.h\\\n\tgbuffer.h\\\n\tplan9.h\\\n\tsim.h\\\n\tvmio.h\\\n\nOFILES=\\\n\tfield.$O\\\n\tgbuffer.$O\\\n\tplan9.$O\\\n\tsim.$O\\\n\ttheme.$O\\\n\tvmio.$O\\\n\ndefault:V:\tall\n\n</sys/src/cmd/mkone\n\ninstall:V: $MAN/$TARG\n", "source": "orca/mkfile", "file_type": "mkfile"}
{"text": "#ifndef __PLAN9_H__\n#define __PLAN9_H__\n#include <u.h>\n#include <libc.h>\n\n#define sprintf sprint\n\ntypedef enum { false, true } bool;\n#define ORCA_NOINLINE\n#define ORCA_FORCEINLINE\n#define ORCA_PURE\n#define ORCA_OK_IF_UNUSED\n#define ORCA_LIKELY\n#define UINT8_MAX 0xff\n#define UINT32_C(x) ((u32int)(x))\n\n#define UINT16_MAX 0xffff\n#define UINT32_MAX 0xffffffffL\n#define SIZE_MAX UINT32_MAX\n#define NULL nil\n\n#define ORCA_Y_MAX UINT16_MAX\n#define ORCA_X_MAX UINT16_MAX\n\ntypedef u8int U8;\ntypedef s8int I8;\ntypedef u16int U16;\ntypedef s16int I16;\ntypedef u32int U32;\ntypedef s32int I32;\ntypedef u64int U64;\ntypedef s64int I64;\ntypedef usize Usz;\ntypedef long Isz;\n\ntypedef char Glyph;\ntypedef U8 Mark;\n\nUsz orca_round_up_power2(Usz x);\nbool orca_is_valid_glyph(Glyph c);\n\n#endif\n", "source": "orca/plan9.h", "file_type": "h"}
{"text": "#include <u.h>\n#include <libc.h>\n#include <plumb.h>\n#include <draw.h>\n#include <bio.h>\n#include <thread.h>\n#include \"theme.h\"\n\nThemeColor colors[Numcolors] = {\n\t[Dback]  = {\"background\", 0x000000},\n\t[Dfhigh] = {\"f_high\",     0xffffff},\n\t[Dfmed]  = {\"f_med\",      0x777777},\n\t[Dflow]  = {\"f_low\",      0x444444},\n\t[Dfinv]  = {\"f_inv\",      0x000000},\n\t[Dbhigh] = {\"b_high\",     0xdddddd},\n\t[Dbmed]  = {\"b_med\",      0x72dec2},\n\t[Dblow]  = {\"b_low\",      0x222222},\n\t[Dbinv]  = {\"b_inv\",      0xffb545},\n};\n\nvoid themechanged(void);\n\nstatic char *themeplumb;\n\nstatic void\nrunpicker(void *x)\n{\n\tint *p, f;\n\tchar tmp[32];\n\n\tsnprint(tmp, sizeof(tmp), \"-pid %d -dx %d -dy %d\", getpid(), 384, 320);\n\tnewwindow(tmp);\n\n\tp = x;\n\tdup(*p, 0); dup(*p, 1); close(*p);\n\tclose(p[1]);\n\tclose(p[2]);\n\tdup(f = open(\"/dev/null\", OWRITE), 2); close(f);\n\texecl(\"/bin/picker\", \"picker\", nil);\n\n\tthreadexits(\"exec: %r\");\n}\n\nvoid\nthemeproc(void *fd)\n{\n\tBiobuf *b;\n\tchar *s, *v[3];\n\tint p[3], n, i;\n\tstatic int pid;\n\n\tthreadsetname(\"themeproc\");\n\tpipe(p);\n\tp[2] = fd != nil ? *(int*)fd : -1;\n\tpostnote(PNGROUP, pid, \"interrupt\");\n\tpid = threadpid(procrfork(runpicker, p, 4096, RFFDG|RFNAMEG|RFNOTEG));\n\tclose(p[0]);\n\tb = Bfdopen(p[1], OREAD);\n\n\tfor(i = 0; i < nelem(colors); i++)\n\t\tfprint(p[1], \"%s\\t%06ux\\n\", colors[i].id, colors[i].rgb);\n\n\tfor(;;){\n\t\tif((s = Brdstr(b, '\\n', 1)) == nil)\n\t\t\tbreak;\n\t\tif((n = tokenize(s, v, nelem(v))) >= 2){\n\t\t\tfor(i = 0; i < nelem(colors); i++){\n\t\t\t\tif(strcmp(colors[i].id, v[0]) == 0){\n\t\t\t\t\tif(display->locking)\n\t\t\t\t\t\tlockdisplay(display);\n\t\t\t\t\tfreeimage(colors[i].im);\n\t\t\t\t\tcolors[i].rgb = strtoul(v[1], nil, 16);\n\t\t\t\t\tcolors[i].im = allocimage(display, Rect(0,0,1,1), RGB24, 1, colors[i].rgb<<8 | 0xff);\n\t\t\t\t\tif(display->locking)\n\t\t\t\t\t\tunlockdisplay(display);\n\t\t\t\t\tthemechanged();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfree(s);\n\t\tif(n != 2)\n\t\t\tbreak;\n\t}\n\tBterm(b);\n\tpostnote(PNGROUP, pid, \"interrupt\");\n\n\tthreadexits(nil);\n}\n\nstatic int\nloadtheme(char *filename, int init)\n{\n\tBiobuf *in;\n\tchar *s, *v[3];\n\tint i, n;\n\n\tif ((in = Bopen(filename, OREAD)) != nil) {\n\t\tif(display->locking && !init)\n\t\t\tlockdisplay(display);\n\t\tfor(;;){\n\t\t\tif((s = Brdstr(in, '\\n', 1)) == nil)\n\t\t\t\tbreak;\n\t\t\tif((n = tokenize(s, v, nelem(v))) == 2){\n\t\t\t\tfor(i = 0; i < nelem(colors); i++){\n\t\t\t\t\tif(strcmp(colors[i].id, v[0]) == 0){\n\t\t\t\t\t\tfreeimage(colors[i].im);\n\t\t\t\t\t\tcolors[i].rgb = strtoul(v[1], nil, 16);\n\t\t\t\t\t\tcolors[i].im = allocimage(display, Rect(0,0,1,1), RGB24, 1, colors[i].rgb<<8 | 0xff);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfree(s);\n\t\t\tif(n != 2)\n\t\t\t\tbreak;\n\t\t}\n\t\tif(display->locking && !init)\n\t\t\tunlockdisplay(display);\n\t\tBterm(in);\n\t\tif(!init)\n\t\t\tthemechanged();\n\t\treturn 0;\n\t}\n\n\treturn -1;\n}\n\nstatic void\nplumbproc(void *)\n{\n\tint f;\n\tPlumbmsg *m;\n\n\tthreadsetname(\"theme/plumb\");\n\tif ((f = plumbopen(themeplumb, OREAD)) >= 0) {\n\t\twhile ((m = plumbrecv(f)) != nil) {\n\t\t\tloadtheme(m->data, 0);\n\t\t\tthemechanged();\n\t\t\tplumbfree(m);\n\t\t}\n\t}\n\n\tthreadexits(nil);\n}\n\nvoid\nthemeinit(void)\n{\n\tchar *s;\n\tint i;\n\n\tif((s = getenv(\"theme\")) != nil){\n\t\tif(loadtheme(s, 1) != 0)\n\t\t\tsysfatal(\"theme load failed: %r\");\n\t\tfree(s);\n\t}\n\tfor(i = 0; i < Numcolors; i++){\n\t\tif(colors[i].im == nil)\n\t\t\tcolors[i].im = allocimage(display, Rect(0,0,1,1), RGB24, 1, colors[i].rgb<<8 | 0xff);\n\t}\n\tif((themeplumb = getenv(\"themeplumb\")) != nil)\n\t\tproccreate(plumbproc, nil, 4096);\n}\n", "source": "orca/theme.c", "file_type": "c"}
{"text": "#![no_std]\n#![feature(asm)]\n#![feature(abi_x86_interrupt)]\n#![feature(allocator_api)]\n#![feature(alloc_error_handler)]\n#![feature(const_fn)]\n\nextern crate volatile;\nextern crate lazy_static;\nextern crate spin;\nextern crate x86_64;\nextern crate multiboot2;\nextern crate pic8259_simple;\nextern crate pc_keyboard;\nextern crate alloc;\n#[macro_use]\nextern crate once;\n#[macro_use]\nextern crate bitflags;\nextern crate byteorder;\n\npub mod vga;\npub mod interrupts;\npub mod memory;\npub mod gdt;\npub mod tar;\npub mod initrd;\npub mod nine_p;\npub mod dev;\npub mod namespace;\n\nuse core::panic::PanicInfo;\nuse memory::heap_allocator::Allocator;\nuse alloc::boxed::Box;\n\npub fn hlt_loop() -> ! {\n    loop {\n        x86_64::instructions::hlt();\n    }\n}\n\n#[panic_handler]\nfn panic(info: &PanicInfo) -> ! {\n    x86_64::instructions::interrupts::disable();\n    println!(\"{}\", info);\n    hlt_loop();\n}\n\n#[alloc_error_handler]\nfn alloc_error(info: core::alloc::Layout) -> ! {\n    x86_64::instructions::interrupts::disable();\n    println!(\"Allocation failed: {:?}\", info);\n    hlt_loop();\n}\n\npub const HEAP_START: usize = 0o_000_001_000_000_0000;\npub const HEAP_SIZE: usize = 100 * 1024; // 100 KiB\npub const INITRD_START: usize = 0o_000_002_000_000_0000;\n\n#[global_allocator]\nstatic HEAP_ALLOCATOR: Allocator = Allocator::empty();\n\nfn enable_nxe_bit() {\n    use x86_64::registers::model_specific::{Efer, EferFlags};\n\n    unsafe {\n        let mut efer = Efer::read();\n        efer.set(EferFlags::NO_EXECUTE_ENABLE, true);\n        Efer::write(efer);\n    }\n}\n\nfn enable_write_protect_bit() {\n    use x86_64::registers::control::{Cr0, Cr0Flags};\n\n    unsafe {\n        let mut cr0 = Cr0::read();\n        cr0.set(Cr0Flags::WRITE_PROTECT, true);\n        Cr0::write(cr0);\n    };\n}\n\npub fn init<'a>(multiboot_information_p: usize) -> initrd::InitRD<'a> {\n    vga::WRITER.lock().clear_screen();\n    println!(\"Starting planRust\");\n    let boot_info = unsafe { multiboot2::load(multiboot_information_p) };\n    let init_rd = memory::init(boot_info);\n    unsafe {\n        HEAP_ALLOCATOR.lock().init(HEAP_START, HEAP_START + HEAP_SIZE);\n    }\n    gdt::init();\n    interrupts::init_idt();\n    unsafe { interrupts::PICS.lock().initialize() };\n    x86_64::instructions::interrupts::enable();\n    init_rd\n}\n\n#[no_mangle]\npub extern \"C\" fn rust_start(multiboot_information_p: usize) -> ! {\n    unsafe {\n        asm!(\"mov ax, 0\n        mov ss, ax\n        mov ds, ax\n        mov es, ax\n        mov fs, ax\n        mov gs, ax\" :::: \"intel\");\n    }\n\n    enable_nxe_bit();\n    enable_write_protect_bit();\n\n    let init_rd = init(multiboot_information_p);\n    let init_rd_server = initrd::InitRDServer::new('/', \"initrd\", init_rd);\n\n    dev::insert_dev_driver(Box::new(init_rd_server));\n\n    let mut root_namespace = namespace::Namespace::new();\n\n    root_namespace.bind(\"/\", \"#/\");\n\n    let root = root_namespace.open_file(\"#/\").unwrap();\n\n    let root_fid = root.0.fid_pool().get_fid();\n    println!(\"{:?}\", root.0.server().lock().walk(root.1, root_fid, &[]));\n    println!(\"{:?}\", root.0.server().lock().open(root_fid, &nine_p::FileMode::new(nine_p::FileAccessMode::Read, false, false)));\n    println!(\"{:?}\", root.0.server().lock().read(root_fid, 0, 1000));\n    println!(\"{:?}\", root.0.server().lock().clunk(root_fid));\n    root.0.fid_pool().clunk_fid(root_fid);\n    drop(root_fid);\n    let test_fid = root.0.fid_pool().get_fid();\n    println!(\"{:?}\", root.0.server().lock().walk(root.1, test_fid, &[\"test\"]));\n    println!(\"{:?}\", root.0.server().lock().open(test_fid, &nine_p::FileMode::new(nine_p::FileAccessMode::Read, false, false)));\n    println!(\"{:?}\", root.0.server().lock().read(test_fid, 0, 1000));\n    println!(\"{:?}\", root.0.server().lock().clunk(test_fid));\n    root.0.fid_pool().clunk_fid(test_fid);\n    drop(test_fid);\n\n    println!(\"It did not crash\");\n    hlt_loop();\n}", "source": "plan_rust/src/lib.rs", "file_type": "rc"}
{"text": "mod dir_reader;\n\nuse x86_64::VirtAddr;\nuse core::slice;\nuse alloc::collections;\nuse crate::tar;\nuse crate::println;\nuse crate::nine_p;\nuse alloc::vec::Vec;\nuse alloc::borrow::ToOwned;\nuse alloc::boxed::Box;\nuse alloc::string::{ToString, String};\n\n\nfn tar_to_qid(tar_type: tar::headers::FileType) -> nine_p::qidpool::QidType {\n    match tar_type {\n        tar::headers::FileType::Regular => nine_p::qidpool::QidType::FILE,\n        tar::headers::FileType::Directory => nine_p::qidpool::QidType::DIRECTORY,\n        _ => panic!(\"initrd can't handle this file type\")\n    }\n}\n\n#[derive(Debug)]\npub struct InitRD<'a> {\n    headers: Option<Vec<tar::TarEntry<'a>>>,\n    start: VirtAddr,\n    end: VirtAddr\n}\n\nimpl<'a> InitRD<'a> {\n    pub fn new(start: VirtAddr, end: VirtAddr) -> Self {\n        Self {\n            headers: None,\n            start,\n            end\n        }\n    }\n\n    fn data(&self) -> &'a [u8] {\n        unsafe { slice::from_raw_parts(self.start.as_ptr(), (self.end - self.start) as usize) }\n    }\n\n    fn headers(&mut self) -> Vec<tar::TarEntry<'a>> {\n        if let Some(h) = &self.headers {\n            return h.clone()\n        }\n        self.headers = Some(tar::find_headers(self.data()));\n        self.headers.clone().unwrap()\n    }\n\n    pub fn dump(&mut self) {\n        println!(\"{:?}\", self.headers());\n    }\n\n    fn list_dir(&mut self, path: &str) -> Vec<tar::TarEntry<'a>> {\n        if path == \"/\" {\n            self.headers().into_iter()\n                .filter(|entry| !entry.header().name.contains(\"/\"))\n                .collect()\n        } else {\n            self.headers().into_iter().filter(|entry| {\n                let h = entry.header();\n                let name = &h.name;\n                if !name.starts_with(path) {\n                    return false;\n                } else {\n                    let after: Vec<_> = name.split(path).collect();\n                    let after = after[1..].into_iter().fold(String::new(), |a, b| a + path + b);\n                    return !after.contains(\"/\");\n                }\n            }).collect()\n        }\n    }\n\n    pub fn stat(&mut self, path: &str) -> Option<tar::TarEntry<'a>> {\n        if path == \"/\" {\n            unimplemented!();\n        } else {\n            let file: Vec<tar::TarEntry> = self.headers().into_iter().filter(|entry| {\n                let name = \"/\".to_owned() + &entry.header().name;\n                name.as_str() == path\n            }).collect();\n            match file.len() {\n                1 => Some(file[0].clone()),\n                _ => None\n            }\n        }\n    }\n}\n\n#[derive(Debug)]\npub struct InitRDServer<'a> {\n    init_rd: InitRD<'a>,\n    name: char,\n    description: &'static str,\n    session_fid: collections::BTreeMap<nine_p::Fid, nine_p::Session>,\n    qid_pool: nine_p::qidpool::Pool,\n    files: collections::BTreeMap<nine_p::Fid, nine_p::File<'a>>,\n}\n\nimpl<'a> InitRDServer<'a> {\n    pub fn new(name: char, description: &'static str, init_rd: InitRD<'a>) -> Self {\n        Self {\n            init_rd,\n            name,\n            description,\n            session_fid: collections::BTreeMap::new(),\n            qid_pool: nine_p::qidpool::Pool::new(),\n            files: collections::BTreeMap::new(),\n        }\n    }\n\n    fn check_fid(&self, fid: nine_p::Fid) -> nine_p::Result<()> {\n        if !self.files.contains_key(&fid) {\n            return Err(nine_p::DevError::NoFid);\n        }\n\n        if !self.files.contains_key(&fid) {\n            return Err(nine_p::DevError::NoFid);\n        }\n        Ok(())\n    }\n\n    fn check_fid_in_use(&self, fid: nine_p::Fid) -> nine_p::Result<()> {\n        if self.files.contains_key(&fid) {\n            return Err(nine_p::DevError::FidInUse);\n        }\n\n        if self.files.contains_key(&fid) {\n            return Err(nine_p::DevError::FidInUse);\n        }\n        Ok(())\n    }\n}\n\nimpl<'a> nine_p::NinePServer for InitRDServer<'a> {\n    fn name(&self) -> char {\n        self.name\n    }\n\n    fn description(&self) -> &'static str {\n        self.description\n    }\n\n    fn auth(&mut self, _afid: nine_p::Fid, _uname: &str, _aname: &str) -> nine_p::Result<nine_p::qidpool::Qid> {\n        Err(nine_p::DevError::AuthNotNeeded)\n    }\n\n    fn attach(&mut self, fid: nine_p::Fid, afid: nine_p::Fid, uname: &str, aname: &str) -> nine_p::Result<nine_p::qidpool::Qid> {\n        if afid != 0 {\n            return Err(nine_p::DevError::AuthNotNeeded);\n        }\n\n        let session = nine_p::Session::new(uname, aname);\n\n        self.check_fid_in_use(fid)?;\n\n        self.session_fid.insert(fid, session);\n        self.files.insert(fid, nine_p::File::new(\"/\", false, None));\n\n        let qid = self.qid_pool.put(\"/\", nine_p::qidpool::QidType::DIRECTORY);\n        Ok(qid)\n    }\n\n    fn clunk(&mut self, fid: nine_p::Fid) -> nine_p::Result<()> {\n        self.files.remove(&fid);\n        self.session_fid.remove(&fid);\n        Ok(())\n    }\n\n    fn open(&mut self, fid: nine_p::Fid, mode: &nine_p::FileMode) -> nine_p::Result<(nine_p::qidpool::Qid, u32)> {\n        self.check_fid(fid)?;\n\n        if mode.remove_on_close() {\n            return Err(nine_p::DevError::PermissionDenied);\n        }\n\n        let file = self.files.get_mut(&fid).unwrap();\n        let qid = self.qid_pool.get(&file.name()).unwrap();\n\n        if mode.truncate() || mode.remove_on_close() {\n            return Err(nine_p::DevError::PermissionDenied);\n        }\n\n        if qid.qid_type().contains(nine_p::qidpool::QidType::DIRECTORY) {\n            if mode.access() != nine_p::FileAccessMode::Read {\n                return Err(nine_p::DevError::PermissionDenied);\n            }\n\n            let entries = self.init_rd.list_dir(&file.name());\n            let rwc = dir_reader::Reader::new(self.qid_pool.clone(), entries);\n            let rwsc = nine_p::RWCWrapper::new(Box::new(rwc));\n            file.set_rwc(Box::new(rwsc));\n        } else {\n            if !(mode.access() == nine_p::FileAccessMode::Read || mode.access() == nine_p::FileAccessMode::Execute) {\n                return Err(nine_p::DevError::PermissionDenied);\n            }\n\n            let entry = self.init_rd.stat(&file.name()).unwrap();\n            file.set_rwc(Box::new(entry.data()));\n        }\n\n        Ok((qid, 0))\n    }\n\n    fn walk(&mut self, fid: nine_p::Fid, new_fid: nine_p::Fid, names: &[&str]) -> nine_p::Result<Vec<nine_p::qidpool::Qid>> {\n        self.check_fid(fid)?;\n\n        if fid != new_fid {\n            self.check_fid_in_use(new_fid)?;\n        }\n\n        let session = { self.session_fid.get(&fid).unwrap().clone() };\n        let mut out_qid = Vec::<nine_p::qidpool::Qid>::new();\n        let file = { self.files.get(&fid).unwrap().clone() };\n        let qid = self.qid_pool.get(&file.name()).unwrap();\n        let mut path = file.name();\n\n        let err_exit = |err: nine_p::DevError, out: Vec<nine_p::qidpool::Qid>| {\n            if out.len() == 0 {\n                return Err(err);\n            } else {\n                return Ok(out);\n            }\n        };\n\n        fn handle_element(path: &str, name: &str) -> String {\n            if name != \"..\" {\n                let mut path = path.to_string();\n                path.push_str(\"/\");\n                path.push_str(name);\n                path.to_string()\n            } else {\n                let elems: Vec<_> = path.split('/').collect();\n                elems[..elems.len() - 1].into_iter().fold(String::new(), |a, b| a + \"/\" + b)\n            }\n        }\n\n        if names.len() > 0 {\n            path = path.trim_end_matches('/').to_string();\n            if !qid.qid_type().contains(nine_p::qidpool::QidType::DIRECTORY) {\n                return Err(nine_p::DevError::NotADir);\n            } else if let Some(_) = file.rwc() {\n                return Err(nine_p::DevError::FileOpen);\n            } else {\n                for name in names {\n                    match out_qid.last() {\n                        Some(q) => {\n                            if q.qid_type().contains(nine_p::qidpool::QidType::DIRECTORY) {\n                                return Ok(out_qid);\n                            }\n                        }\n                        None => {}\n                    }\n                    path = handle_element(&path, name);\n                    match self.init_rd.stat(&path) {\n                        Some(e) => {\n                            let qid = self.qid_pool.put(&path, tar_to_qid(e.header().typeflag.clone())).to_owned();\n                            out_qid.push(qid);\n                        }\n                        None => return err_exit(nine_p::DevError::NoSuchFile, out_qid)\n                    }\n                }\n            }\n        }\n\n        self.session_fid.insert(new_fid, session);\n        self.files.insert(new_fid, nine_p::File::new(&path, false, None));\n\n        Ok(out_qid)\n    }\n\n    fn read(&mut self, fid: nine_p::Fid, offset: u64, count: usize) -> nine_p::Result<Vec<u8>> {\n        self.check_fid(fid)?;\n\n        let file = self.files.get_mut(&fid).unwrap();\n        nine_p::default_read(file, offset, count)\n    }\n\n    fn remove(&mut self, fid: nine_p::Fid) -> nine_p::Result<()> {\n        self.files.remove(&fid);\n        self.session_fid.remove(&fid);\n        Err(nine_p::DevError::PermissionDenied)\n    }\n\n    fn stat(&self) -> nine_p::Result<()> {\n        unimplemented!()\n    }\n}", "source": "plan_rust/src/initrd/mod.rs", "file_type": "rc"}
{"text": "use alloc::string::String;\nuse alloc::vec::Vec;\nuse alloc::vec;\nuse byteorder::{LittleEndian, ByteOrder};\nuse alloc::borrow::ToOwned;\n\npub struct Dir {\n    dir_type: u16,\n    dev: u32,\n    qid: super::qidpool::Qid,\n    mode: u32,\n    atime: u32,\n    mtime: u32,\n    length: u64,\n    name: String,\n    uid: String,\n    gid: String,\n    muid: String,\n}\n\nfn write_u16(vec: &mut Vec<u8>, n: u16) {\n    let mut buf = [0; 2];\n    LittleEndian::write_u16(&mut buf, n);\n    vec.extend_from_slice(&buf);\n}\n\nfn write_u32(vec: &mut Vec<u8>, n: u32) {\n    let mut buf = [0; 4];\n    LittleEndian::write_u32(&mut buf, n);\n    vec.extend_from_slice(&buf);\n}\n\nfn write_u64(vec: &mut Vec<u8>, n: u64) {\n    let mut buf = [0; 8];\n    LittleEndian::write_u64(&mut buf, n);\n    vec.extend_from_slice(&buf);\n}\n\nimpl Dir {\n    pub fn new(dir_type: u16, dev: u32, qid: &super::qidpool::Qid, mode: u32, atime: u32, mtime: u32, length: u64, name: &str, uid: &str, gid: &str, muid: &str) -> Self {\n        Self {\n            dir_type,\n            dev,\n            qid: *qid,\n            mode,\n            atime,\n            mtime,\n            length,\n            name: name.to_owned(),\n            uid: uid.to_owned(),\n            gid: gid.to_owned(),\n            muid: muid.to_owned()\n        }\n    }\n\n    pub fn as_bytes(&self) -> Vec<u8> {\n        let name_len = self.name.len() as u16;\n        let uid_len = self.uid.len() as u16;\n        let gid_len = self.gid.len() as u16;\n        let muid_len = self.muid.len() as u16;\n        let len = 48 + name_len + uid_len + gid_len + muid_len;\n\n        let mut out = vec![];\n\n        write_u16(&mut out, len);\n        write_u16(&mut out, self.dir_type);\n        write_u32(&mut out, self.dev);\n        out.extend_from_slice(&self.qid.as_bytes());\n        write_u32(&mut out, self.mode);\n        write_u32(&mut out, self.atime);\n        write_u32(&mut out, self.mtime);\n        write_u64(&mut out, self.length);\n\n        write_u16(&mut out, name_len);\n        out.extend_from_slice(&self.name.clone().into_bytes());\n\n        write_u16(&mut out, uid_len);\n        out.extend_from_slice(&self.uid.clone().into_bytes());\n\n        write_u16(&mut out, gid_len);\n        out.extend_from_slice(&self.gid.clone().into_bytes());\n\n        write_u16(&mut out, muid_len);\n        out.extend_from_slice(&self.muid.clone().into_bytes());\n\n        out\n    }\n}", "source": "plan_rust/src/nine_p/dir.rs", "file_type": "rc"}
{"text": "pub mod headers;\nuse core::slice;\nuse alloc::vec::Vec;\nuse self::headers::TAR_BLOCKSIZE;\n\n#[derive(Debug, Clone)]\npub struct TarEntry<'a> {\n    header: headers::TarHeader,\n    data: &'a [u8]\n}\n\nimpl<'a> TarEntry<'a> {\n    pub fn header(&self) -> &headers::TarHeader {\n        &self.header\n    }\n    pub fn data(&self) -> &'a [u8] {\n        &self.data\n    }\n}\n\npub fn find_headers(data: &[u8]) -> Vec<TarEntry> {\n    let mut data = data;\n    if data.len() % (TAR_BLOCKSIZE as usize) != 0 {\n        panic!(\"wrong length for tar file\");\n    }\n\n    let mut header_blocks = Vec::new();\n    let mut contiguous_empty_blocks = 0;\n    while contiguous_empty_blocks < 2 {\n        let chunk = data.split_at(TAR_BLOCKSIZE as usize);\n        data = chunk.1;\n        let chunk = chunk.0;\n        let mut chunk_a: [u8; TAR_BLOCKSIZE as usize] = [0; TAR_BLOCKSIZE as usize];\n        chunk_a.copy_from_slice(chunk);\n        match read_header(&chunk_a) {\n            Some(header) => {\n                let mut readcount = 0;\n                let data_start = data.as_ptr();\n                while readcount < header.size as u64 {\n                    readcount += TAR_BLOCKSIZE;\n                    let chunk = data.split_at(TAR_BLOCKSIZE as usize);\n                    data = chunk.1;\n                }\n                let data_slice = unsafe { slice::from_raw_parts(data_start, header.size as usize) };\n                header_blocks.push(TarEntry {\n                    header,\n                    data: data_slice\n                });\n            }\n            None => contiguous_empty_blocks += 1,\n        }\n    }\n\n    header_blocks\n}\n\nfn read_header(chunk: &[u8; TAR_BLOCKSIZE as usize]) -> Option<headers::TarHeader> {\n    if chunk.iter().all(|i| *i == 0) {\n        return None;\n    }\n\n    Some(chunk.into())\n}\n", "source": "plan_rust/src/tar/mod.rs", "file_type": "rc"}
{"text": "use x86_64::align_up;\nuse core::convert::TryInto;\nuse alloc::alloc::{Layout, GlobalAlloc, AllocErr};\nuse core::mem;\nuse core::mem::size_of;\nuse core::ptr::NonNull;\nuse core::ops::Deref;\nuse spin::Mutex;\n\npub struct Heap {\n    bottom: usize,\n    size: usize,\n    holes: HoleList,\n}\n\nimpl Heap {\n    pub const fn empty() -> Heap {\n        Heap {\n            bottom: 0,\n            size: 0,\n            holes: HoleList::empty(),\n        }\n    }\n\n    pub unsafe fn init(&mut self, heap_bottom: usize, heap_size: usize) {\n        self.bottom = heap_bottom;\n        self.size = heap_size;\n        self.holes = HoleList::new(heap_bottom, heap_size);\n    }\n\n    pub unsafe fn new(heap_bottom: usize, heap_size: usize) -> Heap {\n        Heap {\n            bottom: heap_bottom,\n            size: heap_size,\n            holes: HoleList::new(heap_bottom, heap_size),\n        }\n    }\n\n\n    pub fn allocate_first_fit(&mut self, layout: Layout) -> Result<NonNull<u8>, AllocErr> {\n        let mut size = layout.size();\n        if size < HoleList::min_size() {\n            size = HoleList::min_size();\n        }\n        let size = align_up(size.try_into().unwrap(),\n                            mem::align_of::<Hole>().try_into().unwrap());\n        let layout = Layout::from_size_align(size.try_into().unwrap(),\n                                             layout.align()).unwrap();\n\n        self.holes.allocate_first_fit(layout)\n    }\n\n\n    pub unsafe fn deallocate(&mut self, ptr: NonNull<u8>, layout: Layout) {\n        let mut size = layout.size();\n        if size < HoleList::min_size() {\n            size = HoleList::min_size();\n        }\n        let size = align_up(size.try_into().unwrap(),\n                            mem::align_of::<Hole>().try_into().unwrap());\n        let layout = Layout::from_size_align(size.try_into().unwrap(),\n                                             layout.align()).unwrap();\n\n        self.holes.deallocate(ptr, layout);\n    }\n\n    pub fn bottom(&self) -> usize {\n        self.bottom\n    }\n\n    pub fn size(&self) -> usize {\n        self.size\n    }\n\n    pub fn top(&self) -> usize {\n        self.bottom + self.size\n    }\n\n    pub unsafe fn extend(&mut self, by: usize) {\n        let top = self.top();\n        let layout = Layout::from_size_align(by, 1).unwrap();\n        self.holes\n            .deallocate(NonNull::new_unchecked(top as *mut u8), layout);\n        self.size += by;\n    }\n}\n\npub struct HoleList {\n    first: Hole,\n}\n\nimpl HoleList {\n    pub const fn empty() -> HoleList {\n        HoleList {\n            first: Hole {\n                size: 0,\n                next: None,\n            },\n        }\n    }\n\n    pub unsafe fn new(hole_addr: usize, hole_size: usize) -> HoleList {\n        assert_eq!(size_of::<Hole>(), Self::min_size());\n\n        let ptr = hole_addr as *mut Hole;\n        ptr.write(Hole {\n            size: hole_size,\n            next: None,\n        });\n\n        HoleList {\n            first: Hole {\n                size: 0,\n                next: Some(&mut *ptr),\n            },\n        }\n    }\n\n    pub fn allocate_first_fit(&mut self, layout: Layout) -> Result<NonNull<u8>, AllocErr> {\n        assert!(layout.size() >= Self::min_size());\n\n        allocate_first_fit(&mut self.first, layout).map(|allocation| {\n            if let Some(padding) = allocation.front_padding {\n                deallocate(&mut self.first, padding.addr, padding.size);\n            }\n            if let Some(padding) = allocation.back_padding {\n                deallocate(&mut self.first, padding.addr, padding.size);\n            }\n            NonNull::new(allocation.info.addr as *mut u8).unwrap()\n        })\n    }\n\n\n    pub unsafe fn deallocate(&mut self, ptr: NonNull<u8>, layout: Layout) {\n        deallocate(&mut self.first, ptr.as_ptr() as usize, layout.size())\n    }\n\n    pub fn min_size() -> usize {\n        size_of::<usize>() * 2\n    }\n}\n\npub struct Hole {\n    size: usize,\n    next: Option<&'static mut Hole>,\n}\n\nimpl Hole {\n    fn info(&self) -> HoleInfo {\n        HoleInfo {\n            addr: self as *const _ as usize,\n            size: self.size,\n        }\n    }\n}\n\n#[derive(Debug, Clone, Copy)]\nstruct HoleInfo {\n    addr: usize,\n    size: usize,\n}\n\nstruct Allocation {\n    info: HoleInfo,\n    front_padding: Option<HoleInfo>,\n    back_padding: Option<HoleInfo>,\n}\n\nfn split_hole(hole: HoleInfo, required_layout: Layout) -> Option<Allocation> {\n    let required_size = required_layout.size();\n    let required_align = required_layout.align();\n\n    let (aligned_addr, front_padding) = if hole.addr ==\n        align_up(hole.addr.try_into().unwrap(), required_align.try_into().unwrap())\n            .try_into().unwrap() {\n        // hole has already the required alignment\n        (hole.addr, None)\n    } else {\n        // the required alignment causes some padding before the allocation\n        let aligned_addr: usize =\n            align_up((hole.addr + HoleList::min_size()).try_into().unwrap(),\n                     required_align.try_into().unwrap()).try_into().unwrap();\n        (\n            aligned_addr,\n            Some(HoleInfo {\n                addr: hole.addr,\n                size: aligned_addr - hole.addr,\n            }),\n        )\n    };\n\n    let aligned_hole = {\n        if aligned_addr + required_size > hole.addr + hole.size {\n            // hole is too small\n            return None;\n        }\n        HoleInfo {\n            addr: aligned_addr,\n            size: hole.size - (aligned_addr - hole.addr),\n        }\n    };\n\n    let back_padding = if aligned_hole.size == required_size {\n        // the aligned hole has exactly the size that's needed, no padding accrues\n        None\n    } else if aligned_hole.size - required_size < HoleList::min_size() {\n        // we can't use this hole since its remains would form a new, too small hole\n        return None;\n    } else {\n        // the hole is bigger than necessary, so there is some padding behind the allocation\n        Some(HoleInfo {\n            addr: aligned_hole.addr + required_size,\n            size: aligned_hole.size - required_size,\n        })\n    };\n\n    Some(Allocation {\n        info: HoleInfo {\n            addr: aligned_hole.addr,\n            size: required_size,\n        },\n        front_padding,\n        back_padding,\n    })\n}\n\nfn allocate_first_fit(mut previous: &mut Hole, layout: Layout) -> Result<Allocation, AllocErr> {\n    loop {\n        let allocation: Option<Allocation> = previous\n            .next\n            .as_mut()\n            .and_then(|current| split_hole(current.info(), layout.clone()));\n        match allocation {\n            Some(allocation) => {\n                // hole is big enough, so remove it from the list by updating the previous pointer\n                previous.next = previous.next.as_mut().unwrap().next.take();\n                return Ok(allocation);\n            }\n            None if previous.next.is_some() => {\n                // try next hole\n                previous = move_helper(previous).next.as_mut().unwrap();\n            }\n            None => {\n                // this was the last hole, so no hole is big enough -> allocation not possible\n                return Err(AllocErr);\n            }\n        }\n    }\n}\n\nfn deallocate(mut hole: &mut Hole, addr: usize, mut size: usize) {\n    loop {\n        assert!(size >= HoleList::min_size());\n\n        let hole_addr = if hole.size == 0 {\n            // It's the dummy hole, which is the head of the HoleList. It's somewhere on the stack,\n            // so it's address is not the address of the hole. We set the addr to 0 as it's always\n            // the first hole.\n            0\n        } else {\n            // tt's a real hole in memory and its address is the address of the hole\n            hole as *mut _ as usize\n        };\n\n        // Each freed block must be handled by the previous hole in memory. Thus the freed\n        // address must be always behind the current hole.\n        assert!(\n            hole_addr + hole.size <= addr,\n            \"invalid deallocation (probably a double free)\"\n        );\n\n        // get information about the next block\n        let next_hole_info = hole.next.as_ref().map(|next| next.info());\n\n        match next_hole_info {\n            Some(next) if hole_addr + hole.size == addr && addr + size == next.addr => {\n                // block fills the gap between this hole and the next hole\n                // before:  ___XXX____YYYYY____    where X is this hole and Y the next hole\n                // after:   ___XXXFFFFYYYYY____    where F is the freed block\n\n                hole.size += size + next.size; // merge the F and Y blocks to this X block\n                hole.next = hole.next.as_mut().unwrap().next.take(); // remove the Y block\n            }\n            _ if hole_addr + hole.size == addr => {\n                // block is right behind this hole but there is used memory after it\n                // before:  ___XXX______YYYYY____    where X is this hole and Y the next hole\n                // after:   ___XXXFFFF__YYYYY____    where F is the freed block\n\n                // or: block is right behind this hole and this is the last hole\n                // before:  ___XXX_______________    where X is this hole and Y the next hole\n                // after:   ___XXXFFFF___________    where F is the freed block\n\n                hole.size += size; // merge the F block to this X block\n            }\n            Some(next) if addr + size == next.addr => {\n                // block is right before the next hole but there is used memory before it\n                // before:  ___XXX______YYYYY____    where X is this hole and Y the next hole\n                // after:   ___XXX__FFFFYYYYY____    where F is the freed block\n\n                hole.next = hole.next.as_mut().unwrap().next.take(); // remove the Y block\n                size += next.size; // free the merged F/Y block in next iteration\n                continue;\n            }\n            Some(next) if next.addr <= addr => {\n                // block is behind the next hole, so we delegate it to the next hole\n                // before:  ___XXX__YYYYY________    where X is this hole and Y the next hole\n                // after:   ___XXX__YYYYY__FFFF__    where F is the freed block\n\n                hole = move_helper(hole).next.as_mut().unwrap(); // start next iteration at next hole\n                continue;\n            }\n            _ => {\n                // block is between this and the next hole\n                // before:  ___XXX________YYYYY_    where X is this hole and Y the next hole\n                // after:   ___XXX__FFFF__YYYYY_    where F is the freed block\n\n                // or: this is the last hole\n                // before:  ___XXX_________    where X is this hole\n                // after:   ___XXX__FFFF___    where F is the freed block\n\n                let new_hole = Hole {\n                    size: size,\n                    next: hole.next.take(), // the reference to the Y block (if it exists)\n                };\n                // write the new hole to the freed memory\n                let ptr = addr as *mut Hole;\n                unsafe { ptr.write(new_hole) };\n                // add the F block as the next block of the X block\n                hole.next = Some(unsafe { &mut *ptr });\n            }\n        }\n        break;\n    }\n}\n\nfn move_helper<T>(x: T) -> T {\n    x\n}\n\npub struct Allocator(Mutex<Heap>);\n\nimpl Allocator {\n    pub const fn empty() -> Allocator {\n        Allocator(Mutex::new(Heap::empty()))\n    }\n}\n\nimpl Deref for Allocator {\n    type Target = Mutex<Heap>;\n\n    fn deref(&self) -> &Mutex<Heap> {\n        &self.0\n    }\n}\n\nunsafe impl GlobalAlloc for Allocator {\n    unsafe fn alloc(&self, layout: Layout) -> *mut u8 {\n        self.0\n            .lock()\n            .allocate_first_fit(layout)\n            .ok()\n            .map_or(0 as *mut u8, |allocation| allocation.as_ptr())\n    }\n\n    unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout) {\n        self.0\n            .lock()\n            .deallocate(NonNull::new_unchecked(ptr), layout)\n    }\n}", "source": "plan_rust/src/memory/heap_allocator.rs", "file_type": "rc"}
{"text": "use core::ops::{Deref, DerefMut};\nuse x86_64::registers::control;\nuse x86_64::instructions::tlb;\nuse x86_64::ux::u9;\nuse x86_64::structures::paging::{Page, PageTable, RecursivePageTable, PhysFrame, PageTableFlags};\nuse super::temporary_page::TemporaryPage;\n\npub struct ActivePageTable<'a> {\n    mapper: RecursivePageTable<'a>,\n}\n\nimpl<'a> Deref for ActivePageTable<'a> {\n    type Target = RecursivePageTable<'a>;\n\n    fn deref(&self) -> &RecursivePageTable<'a> {\n        &self.mapper\n    }\n}\n\nimpl<'a> DerefMut for ActivePageTable<'a> {\n    fn deref_mut(&mut self) -> &mut RecursivePageTable<'a> {\n        &mut self.mapper\n    }\n}\n\nfn page_table<'a>() -> &'a mut PageTable {\n    let recursive_index = u9::new(511);\n    let recursive_page_table_addr = Page::from_page_table_indices(\n        recursive_index,\n        recursive_index,\n        recursive_index,\n        recursive_index,\n    )\n        .start_address();\n    let page_table = unsafe { &mut *(recursive_page_table_addr.as_mut_ptr()) };\n    page_table\n}\n\nimpl<'a> ActivePageTable<'a> {\n    pub unsafe fn new() -> ActivePageTable<'a> {\n        let page_table = page_table();\n        ActivePageTable {\n            mapper: RecursivePageTable::new(page_table).expect(\"recursive page table creation failed\"),\n        }\n    }\n\n    pub fn with<F>(&mut self, table: &mut InactivePageTable, temporary_page: &mut TemporaryPage, f: F)\n        where F: FnOnce(&mut RecursivePageTable<'a>)\n    {\n        {\n            let backup = control::Cr3::read().0;\n\n            // map temporary_page to current p4 table\n            let p4_table = temporary_page.map_table_frame(backup.clone(), self);\n\n            // overwrite recursive mapping\n            page_table()[511].set_frame(table.p4_frame.clone(), PageTableFlags::PRESENT | PageTableFlags::WRITABLE);\n            tlb::flush_all();\n\n            // execute f in the new context\n            f(self);\n\n            p4_table[511].set_frame(backup, PageTableFlags::PRESENT | PageTableFlags::WRITABLE);\n            tlb::flush_all();\n        }\n\n        temporary_page.unmap(self);\n    }\n\n\n    pub fn switch(&mut self, new_table: InactivePageTable) -> InactivePageTable {\n        let cr3 = control::Cr3::read();\n        let old_table = InactivePageTable {\n            p4_frame: cr3.0,\n        };\n        unsafe {\n            control::Cr3::write(new_table.p4_frame, cr3.1);\n        }\n        old_table\n    }\n}\n\npub struct InactivePageTable {\n    pub p4_frame: PhysFrame,\n}\n\nimpl InactivePageTable {\n    pub fn new(frame: PhysFrame,\n               active_table: &mut ActivePageTable,\n               temporary_page: &mut TemporaryPage)\n               -> InactivePageTable {\n        {\n            let table = temporary_page.map_table_frame(frame.clone(), active_table);\n            // now we are able to zero the table\n            table.zero();\n            // set up recursive mapping for the table\n            table[511].set_frame(frame.clone(), PageTableFlags::PRESENT | PageTableFlags::WRITABLE);\n        }\n        temporary_page.unmap(active_table);\n\n        InactivePageTable { p4_frame: frame }\n    }\n}", "source": "plan_rust/src/memory/paging.rs", "file_type": "rc"}
{"text": "use crate::config::Configuration;\nuse config::{apply_to_build_step, apply_to_clippy_step, apply_to_qemu_step};\nuse std::{\n    env, fmt,\n    path::{Path, PathBuf},\n    process::{self, Command},\n    str::FromStr,\n};\nuse target_lexicon::Triple;\n\nmod config;\n\ntype DynError = Box<dyn std::error::Error>;\ntype Result<T> = std::result::Result<T, DynError>;\n\n#[derive(Clone, Copy, Debug, PartialEq)]\npub enum Profile {\n    Debug,\n    Release,\n}\n\nimpl Profile {\n    fn from(matches: &clap::ArgMatches) -> Self {\n        if matches.get_flag(\"release\") { Profile::Release } else { Profile::Debug }\n    }\n\n    fn dir(&self) -> &'static str {\n        match self {\n            Profile::Debug => \"debug\",\n            Profile::Release => \"release\",\n        }\n    }\n}\n\nimpl fmt::Display for Profile {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, \"{self:?}\")\n    }\n}\n\n#[derive(Clone, Copy, Debug, PartialEq, clap::ValueEnum)]\nenum Arch {\n    Aarch64,\n    Riscv64,\n    X86_64,\n}\n\nimpl Arch {\n    fn from(matches: &clap::ArgMatches) -> Self {\n        *matches.get_one::<Arch>(\"arch\").unwrap_or(&Arch::X86_64)\n    }\n\n    fn qemu_system(&self) -> String {\n        env_or(\n            \"QEMU\",\n            match self {\n                Arch::Aarch64 => \"qemu-system-aarch64\",\n                Arch::Riscv64 => \"qemu-system-riscv64\",\n                Arch::X86_64 => \"qemu-system-x86_64\",\n            },\n        )\n    }\n\n    fn target(&self) -> String {\n        env_or(\"TARGET\", format!(\"{}-unknown-none-elf\", self.to_string().to_lowercase()).as_str())\n    }\n}\n\nimpl fmt::Display for Arch {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, \"{self:?}\")\n    }\n}\n\nstruct RustupState {\n    installed_targets: Vec<Triple>,\n    curr_toolchain: String,\n}\n\nimpl RustupState {\n    /// Runs rustup command to get a list of all installed toolchains.\n    /// Also caches the current toolchain.\n    fn new() -> Self {\n        Self {\n            installed_targets: Self::installed_rustup_targets().unwrap(),\n            curr_toolchain: env::var(\"RUSTUP_TOOLCHAIN\").unwrap(),\n        }\n    }\n\n    /// Call `rustup target list --installed` to get all installed target triples\n    fn installed_rustup_targets() -> Result<Vec<Triple>> {\n        let output =\n            Command::new(\"rustup\").arg(\"target\").arg(\"list\").arg(\"--installed\").output()?;\n        if !output.status.success() {\n            return Err(String::from_utf8(output.stdout.clone())?.into());\n        }\n\n        Ok(String::from_utf8(output.stdout.clone())?.lines().flat_map(Triple::from_str).collect())\n    }\n\n    /// For the given arch, return a compatible toolchain triple that is\n    /// installed and can be used by cargo check.  It will prefer the default\n    /// toolchain if it's a match, otherwise it will look for the\n    /// <arch-unknown-linux-gnu> toolchain.\n    fn std_supported_target(&self, arch: &str) -> Option<&Triple> {\n        let arch = Self::target_arch(arch);\n        self.installed_targets.iter().filter(|&t| t.architecture.to_string() == arch).find(|&t| {\n            self.curr_toolchain.ends_with(&t.to_string())\n                || t.to_string() == arch.to_owned() + \"-unknown-linux-gnu\"\n        })\n    }\n\n    /// Return the arch in a form compatible with the supported targets and toolchains\n    fn target_arch(arch: &str) -> &str {\n        match arch {\n            \"riscv64\" => \"riscv64gc\",\n            _ => arch,\n        }\n    }\n}\n\nfn main() {\n    let matches = clap::Command::new(\"xtask\")\n        .version(\"0.1.0\")\n        .author(\"The r9 Authors\")\n        .about(\"Build support for the r9 operating system\")\n        .arg_required_else_help(true)\n        .subcommand(\n            clap::Command::new(\"build\").about(\"Builds r9\").args(&[\n                clap::arg!(--release \"Build release version\").conflicts_with(\"debug\"),\n                clap::arg!(--debug \"Build debug version (default)\").conflicts_with(\"release\"),\n                clap::arg!(--arch <arch> \"Target architecture\")\n                    .value_parser(clap::builder::EnumValueParser::<Arch>::new()),\n                clap::arg!(--config <name> \"Configuration\")\n                    .value_parser(clap::builder::NonEmptyStringValueParser::new())\n                    .default_value(\"default\"),\n                clap::arg!(--verbose \"Print commands\"),\n            ]),\n        )\n        .subcommand(\n            clap::Command::new(\"expand\").about(\"Expands r9 macros\").args(&[\n                clap::arg!(--release \"Build release version\").conflicts_with(\"debug\"),\n                clap::arg!(--debug \"Build debug version (default)\").conflicts_with(\"release\"),\n                clap::arg!(--arch <arch> \"Target architecture\")\n                    .value_parser(clap::builder::EnumValueParser::<Arch>::new()),\n                clap::arg!(--verbose \"Print commands\"),\n            ]),\n        )\n        .subcommand(\n            clap::Command::new(\"kasm\").about(\"Emits r9 assembler\").args(&[\n                clap::arg!(--release \"Build release version\").conflicts_with(\"debug\"),\n                clap::arg!(--debug \"Build debug version (default)\").conflicts_with(\"release\"),\n                clap::arg!(--arch <arch> \"Target architecture\")\n                    .value_parser(clap::builder::EnumValueParser::<Arch>::new()),\n                clap::arg!(--verbose \"Print commands\"),\n            ]),\n        )\n        .subcommand(\n            clap::Command::new(\"dist\").about(\"Builds a multibootable r9 image\").args(&[\n                clap::arg!(--release \"Build a release version\").conflicts_with(\"debug\"),\n                clap::arg!(--debug \"Build a debug version\").conflicts_with(\"release\"),\n                clap::arg!(--arch <arch> \"Target architecture\")\n                    .value_parser(clap::builder::EnumValueParser::<Arch>::new()),\n                clap::arg!(--config <name> \"Configuration\")\n                    .value_parser(clap::builder::NonEmptyStringValueParser::new())\n                    .default_value(\"default\"),\n                clap::arg!(--verbose \"Print commands\"),\n            ]),\n        )\n        .subcommand(clap::Command::new(\"test\").about(\"Runs unit tests\").args(&[\n            clap::arg!(--release \"Build a release version\").conflicts_with(\"debug\"),\n            clap::arg!(--debug \"Build a debug version\").conflicts_with(\"release\"),\n            clap::arg!(--json \"Output messages as json\"),\n            clap::arg!(--verbose \"Print commands\"),\n        ]))\n        .subcommand(\n            clap::Command::new(\"clippy\").about(\"Runs clippy\").args(&[\n                clap::arg!(--release \"Build a release version\").conflicts_with(\"debug\"),\n                clap::arg!(--debug \"Build a debug version\").conflicts_with(\"release\"),\n                clap::arg!(--arch <arch> \"Target architecture\")\n                    .value_parser(clap::builder::EnumValueParser::<Arch>::new()),\n                clap::arg!(--config <name> \"Configuration\")\n                    .value_parser(clap::builder::NonEmptyStringValueParser::new())\n                    .default_value(\"default\"),\n                clap::arg!(--verbose \"Print commands\"),\n            ]),\n        )\n        .subcommand(clap::Command::new(\"check\").about(\"Runs check\").args(&[\n            clap::arg!(--json \"Output messages as json\"),\n            clap::arg!(--verbose \"Print commands\"),\n        ]))\n        .subcommand(\n            clap::Command::new(\"qemu\").about(\"Run r9 under QEMU\").args(&[\n                clap::arg!(--release \"Build a release version\").conflicts_with(\"debug\"),\n                clap::arg!(--debug \"Build a debug version\").conflicts_with(\"release\"),\n                clap::arg!(--arch <arch> \"Target architecture\")\n                    .value_parser(clap::builder::EnumValueParser::<Arch>::new()),\n                clap::arg!(--gdb \"Wait for gdb connection on start\"),\n                clap::arg!(--kvm \"Run with KVM\"),\n                clap::arg!(--config <name> \"Configuration\")\n                    .value_parser(clap::builder::NonEmptyStringValueParser::new())\n                    .default_value(\"default\"),\n                clap::arg!(--verbose \"Print commands\"),\n                clap::arg!(--dump_dtb <file> \"Dump the DTB from QEMU to a file\")\n                    .value_parser(clap::value_parser!(String)),\n            ]),\n        )\n        .subcommand(clap::Command::new(\"clean\").about(\"Cargo clean\"))\n        .get_matches();\n\n    if let Err(e) = match matches.subcommand() {\n        Some((\"build\", m)) => BuildStep::new(m).run(),\n        Some((\"expand\", m)) => ExpandStep::new(m).run(),\n        Some((\"kasm\", m)) => KasmStep::new(m).run(),\n        Some((\"dist\", m)) => {\n            let s1 = BuildStep::new(m);\n            let s2 = DistStep::new(m);\n            s1.run().and_then(|_| s2.run())\n        }\n        Some((\"test\", m)) => TestStep::new(m).run(),\n        Some((\"clippy\", m)) => ClippyStep::new(m).run(),\n        Some((\"check\", m)) => CheckStep::new(m).run(),\n        Some((\"qemu\", m)) => {\n            let s1 = BuildStep::new(m);\n            let s2 = DistStep::new(m);\n            let s3 = QemuStep::new(m);\n            s1.run().and_then(|_| s2.run()).and_then(|_| s3.run())\n        }\n        Some((\"clean\", _)) => CleanStep::new().run(),\n        _ => Err(\"bad subcommand\".into()),\n    } {\n        eprintln!(\"{e}\");\n        process::exit(1);\n    }\n}\n\nfn env_or(var: &str, default: &str) -> String {\n    let default = default.to_string();\n    env::var(var).unwrap_or(default)\n}\n\nfn cargo() -> String {\n    env_or(\"CARGO\", \"cargo\")\n}\n\nfn objcopy() -> String {\n    let llvm_objcopy = {\n        let toolchain = env_or(\"RUSTUP_TOOLCHAIN\", \"nightly-x86_64-unknown-none\");\n\n        // find host architecture by taking last 3 segments from toolchain\n        let mut arch_segments: Box<[_]> = toolchain.split('-').rev().take(3).collect();\n        arch_segments.reverse();\n        let host = arch_segments.join(\"-\");\n\n        let home = env_or(\"RUSTUP_HOME\", \"\");\n        let mut path = PathBuf::from(home);\n        path.push(\"toolchains\");\n        path.push(toolchain);\n        path.push(\"lib\");\n        path.push(\"rustlib\");\n        path.push(host);\n        path.push(\"bin\");\n        path.push(\"llvm-objcopy\");\n        if path.exists() {\n            path.into_os_string().into_string().unwrap()\n        } else {\n            \"llvm-objcopy\".into()\n        }\n    };\n    env_or(\"OBJCOPY\", &llvm_objcopy)\n}\n\nfn load_config(arch: Arch, matches: &clap::ArgMatches) -> Configuration {\n    let default = \"default\".to_string();\n    let config_file = matches.try_get_one(\"config\").ok().flatten().unwrap_or(&default);\n    Configuration::load(format!(\n        \"{}/{}/lib/config_{}.toml\",\n        workspace().display(),\n        arch.to_string().to_lowercase(),\n        config_file\n    ))\n}\n\nfn verbose(matches: &clap::ArgMatches) -> bool {\n    matches.get_flag(\"verbose\")\n}\n\nstruct BuildStep {\n    arch: Arch,\n    config: Configuration,\n    profile: Profile,\n    verbose: bool,\n}\n\nimpl BuildStep {\n    fn new(matches: &clap::ArgMatches) -> Self {\n        let arch = Arch::from(matches);\n        let config = load_config(arch, matches);\n        let profile = Profile::from(matches);\n        let verbose = verbose(matches);\n\n        Self { arch, config, profile, verbose }\n    }\n\n    fn run(self) -> Result<()> {\n        let mut cmd = Command::new(cargo());\n        cmd.arg(\"build\");\n\n        apply_to_build_step(\n            &mut cmd,\n            &self.config,\n            &self.arch.target(),\n            &self.profile,\n            workspace().to_str().unwrap(),\n        );\n\n        cmd.current_dir(workspace());\n        cmd.arg(\"--workspace\");\n        cmd.arg(\"--exclude\").arg(\"xtask\");\n        exclude_other_arches(self.arch, &mut cmd);\n        if self.profile == Profile::Release {\n            cmd.arg(\"--release\");\n        }\n        cmd.arg(\"-Z\").arg(\"build-std=core,alloc\");\n        if self.verbose {\n            println!(\"Executing {cmd:?}\");\n        }\n        let status = annotated_status(&mut cmd)?;\n        if !status.success() {\n            return Err(\"build kernel failed\".into());\n        }\n        Ok(())\n    }\n}\n\nstruct DistStep {\n    arch: Arch,\n    profile: Profile,\n    verbose: bool,\n}\n\nimpl DistStep {\n    fn new(matches: &clap::ArgMatches) -> Self {\n        let arch = Arch::from(matches);\n        let profile = Profile::from(matches);\n        let verbose = verbose(matches);\n        Self { arch, profile, verbose }\n    }\n\n    fn run(self) -> Result<()> {\n        match self.arch {\n            Arch::Aarch64 => {\n                // Qemu needs a flat binary in order to handle device tree files correctly\n                let mut cmd = Command::new(objcopy());\n                cmd.arg(\"-O\");\n                cmd.arg(\"binary\");\n                cmd.arg(format!(\"target/{}/{}/aarch64\", self.arch.target(), self.profile.dir()));\n                cmd.arg(format!(\n                    \"target/{}/{}/aarch64-qemu\",\n                    self.arch.target(),\n                    self.profile.dir()\n                ));\n                cmd.current_dir(workspace());\n                if self.verbose {\n                    println!(\"Executing {cmd:?}\");\n                }\n                let status = annotated_status(&mut cmd)?;\n                if !status.success() {\n                    return Err(\"objcopy failed\".into());\n                }\n\n                // Compress the binary.  We do this because they're much faster when used\n                // for netbooting and qemu also accepts them.\n                let mut cmd = Command::new(\"gzip\");\n                cmd.arg(\"-k\");\n                cmd.arg(\"-f\");\n                cmd.arg(format!(\n                    \"target/{}/{}/aarch64-qemu\",\n                    self.arch.target(),\n                    self.profile.dir()\n                ));\n                cmd.current_dir(workspace());\n                if self.verbose {\n                    println!(\"Executing {cmd:?}\");\n                }\n                let status = annotated_status(&mut cmd)?;\n                if !status.success() {\n                    return Err(\"gzip failed\".into());\n                }\n            }\n            Arch::X86_64 => {\n                let mut cmd = Command::new(objcopy());\n                cmd.arg(\"--input-target=elf64-x86-64\");\n                cmd.arg(\"--output-target=elf32-i386\");\n                cmd.arg(format!(\"target/{}/{}/x86_64\", self.arch.target(), self.profile.dir()));\n                cmd.arg(format!(\"target/{}/{}/r9.elf32\", self.arch.target(), self.profile.dir()));\n                cmd.current_dir(workspace());\n                if self.verbose {\n                    println!(\"Executing {cmd:?}\");\n                }\n                let status = annotated_status(&mut cmd)?;\n                if !status.success() {\n                    return Err(\"objcopy failed\".into());\n                }\n            }\n            Arch::Riscv64 => {\n                // Qemu needs a flat binary in order to handle device tree files correctly\n                let mut cmd = Command::new(objcopy());\n                cmd.arg(\"-O\");\n                cmd.arg(\"binary\");\n                cmd.arg(format!(\"target/{}/{}/riscv64\", self.arch.target(), self.profile.dir()));\n                cmd.arg(format!(\n                    \"target/{}/{}/riscv64-qemu\",\n                    self.arch.target(),\n                    self.profile.dir()\n                ));\n                cmd.current_dir(workspace());\n                if self.verbose {\n                    println!(\"Executing {cmd:?}\");\n                }\n                let status = annotated_status(&mut cmd)?;\n                if !status.success() {\n                    return Err(\"objcopy failed\".into());\n                }\n            }\n        };\n\n        Ok(())\n    }\n}\n\nstruct QemuStep {\n    arch: Arch,\n    config: Configuration,\n    profile: Profile,\n    wait_for_gdb: bool,\n    kvm: bool,\n    dump_dtb: String,\n    verbose: bool,\n}\n\nimpl QemuStep {\n    fn new(matches: &clap::ArgMatches) -> Self {\n        let arch = Arch::from(matches);\n        let config = load_config(arch, matches);\n        let profile = Profile::from(matches);\n        let wait_for_gdb = matches.get_flag(\"gdb\");\n        let kvm = matches.get_flag(\"kvm\");\n        let dump_dtb: String = matches\n            .try_get_one::<String>(\"dump_dtb\")\n            .ok()\n            .flatten()\n            .unwrap_or(&\"\".to_string())\n            .clone();\n        let verbose = verbose(matches);\n\n        Self { arch, config, profile, wait_for_gdb, kvm, dump_dtb, verbose }\n    }\n\n    fn run(self) -> Result<()> {\n        let target = self.arch.target();\n        let dir = self.profile.dir();\n        let qemu_system = self.arch.qemu_system();\n\n        if self.kvm && self.arch != Arch::X86_64 {\n            return Err(\"KVM only supported under x86-64\".into());\n        }\n\n        match self.arch {\n            Arch::Aarch64 => {\n                let mut cmd = Command::new(qemu_system);\n\n                apply_to_qemu_step(&mut cmd, &self.config);\n\n                // TODO Choose UART at cmdline\n                // If using UART0 (PL011), this enables serial\n                cmd.arg(\"-nographic\");\n\n                // If using UART1 (MiniUART), this enables serial\n                cmd.arg(\"-serial\");\n                cmd.arg(\"null\");\n                cmd.arg(\"-serial\");\n                cmd.arg(\"mon:stdio\");\n\n                if self.wait_for_gdb {\n                    cmd.arg(\"-s\").arg(\"-S\");\n                }\n                // Show exception level change events in stdout\n                cmd.arg(\"-d\");\n                cmd.arg(\"int\");\n                cmd.arg(\"-kernel\");\n                cmd.arg(format!(\"target/{target}/{dir}/aarch64-qemu.gz\"));\n                cmd.current_dir(workspace());\n                if self.verbose {\n                    println!(\"Executing {cmd:?}\");\n                }\n                let status = annotated_status(&mut cmd)?;\n                if !status.success() {\n                    return Err(\"qemu failed\".into());\n                }\n            }\n            Arch::Riscv64 => {\n                let mut cmd = Command::new(qemu_system);\n                cmd.arg(\"-nographic\");\n                //cmd.arg(\"-curses\");\n                // cmd.arg(\"-bios\").arg(\"none\");\n                let dump_dtb = &self.dump_dtb;\n                if !dump_dtb.is_empty() {\n                    cmd.arg(\"-machine\").arg(format!(\"virt,dumpdtb={dump_dtb}\"));\n                } else {\n                    cmd.arg(\"-machine\").arg(\"virt\");\n                }\n                cmd.arg(\"-cpu\").arg(\"rv64\");\n                // FIXME: This is not needed as of now, and will only work once the\n                // FIXME: disk.bin is also taken care of. Doesn't exist by default.\n                if false {\n                    cmd.arg(\"-drive\").arg(\"file=disk.bin,format=raw,id=hd0\");\n                    cmd.arg(\"-device\").arg(\"virtio-blk-device,drive=hd0\");\n                }\n                cmd.arg(\"-netdev\").arg(\"type=user,id=net0\");\n                cmd.arg(\"-device\").arg(\"virtio-net-device,netdev=net0\");\n                cmd.arg(\"-smp\").arg(\"4\");\n                cmd.arg(\"-m\").arg(\"1024M\");\n                cmd.arg(\"-serial\").arg(\"mon:stdio\");\n                if self.wait_for_gdb {\n                    cmd.arg(\"-s\").arg(\"-S\");\n                }\n                cmd.arg(\"-d\").arg(\"guest_errors,unimp\");\n                cmd.arg(\"-kernel\");\n                cmd.arg(format!(\"target/{target}/{dir}/riscv64\"));\n                cmd.current_dir(workspace());\n                if self.verbose {\n                    println!(\"Executing {cmd:?}\");\n                }\n                let status = annotated_status(&mut cmd)?;\n                if !status.success() {\n                    return Err(\"qemu failed\".into());\n                }\n            }\n            Arch::X86_64 => {\n                let mut cmd = Command::new(qemu_system);\n                cmd.arg(\"-nographic\");\n                // cmd.arg(\"-display\");\n                // cmd.arg(\"curses\");\n                if self.kvm {\n                    cmd.arg(\"-accel\").arg(\"kvm\");\n                    cmd.arg(\"-cpu\").arg(\"host,pdpe1gb,xsaveopt,fsgsbase,apic,msr\");\n                } else {\n                    cmd.arg(\"-M\").arg(\"q35\");\n                    cmd.arg(\"-cpu\").arg(\"qemu64,pdpe1gb,xsaveopt,fsgsbase,apic,msr\");\n                }\n                cmd.arg(\"-smp\");\n                cmd.arg(\"8\");\n                cmd.arg(\"-s\");\n                cmd.arg(\"-m\");\n                cmd.arg(\"8192\");\n                if self.wait_for_gdb {\n                    cmd.arg(\"-s\").arg(\"-S\");\n                }\n                //cmd.arg(\"-device\");\n                //cmd.arg(\"ahci,id=ahci0\");\n                //cmd.arg(\"-drive\");\n                //cmd.arg(\"id=sdahci0,file=sdahci0.img,if=none\");\n                //cmd.arg(\"-device\");\n                //cmd.arg(\"ide-hd,drive=sdahci0,bus=ahci0.0\");\n                cmd.arg(\"-kernel\");\n                cmd.arg(format!(\"target/{target}/{dir}/r9.elf32\"));\n                cmd.current_dir(workspace());\n                if self.verbose {\n                    println!(\"Executing {cmd:?}\");\n                }\n                let status = annotated_status(&mut cmd)?;\n                if !status.success() {\n                    return Err(\"qemu failed\".into());\n                }\n            }\n        };\n\n        Ok(())\n    }\n}\n\nstruct ExpandStep {\n    arch: Arch,\n    profile: Profile,\n    verbose: bool,\n}\n\nimpl ExpandStep {\n    fn new(matches: &clap::ArgMatches) -> Self {\n        let arch = Arch::from(matches);\n        let profile = Profile::from(matches);\n        let verbose = verbose(matches);\n\n        Self { arch, profile, verbose }\n    }\n\n    fn run(self) -> Result<()> {\n        let mut cmd = Command::new(cargo());\n        cmd.current_dir(workspace());\n        cmd.arg(\"rustc\");\n        cmd.arg(\"-Z\").arg(\"build-std=core,alloc\");\n        cmd.arg(\"-p\").arg(self.arch.to_string().to_lowercase());\n        cmd.arg(\"--target\").arg(format!(\"lib/{}.json\", self.arch.target()));\n        cmd.arg(\"--\");\n        cmd.arg(\"-Z\").arg(\"unpretty=expanded\");\n        if self.profile == Profile::Release {\n            cmd.arg(\"--release\");\n        }\n        if self.verbose {\n            println!(\"Executing {cmd:?}\");\n        }\n        let status = annotated_status(&mut cmd)?;\n        if !status.success() {\n            return Err(\"build kernel failed\".into());\n        }\n        Ok(())\n    }\n}\n\nstruct KasmStep {\n    arch: Arch,\n    profile: Profile,\n    verbose: bool,\n}\n\nimpl KasmStep {\n    fn new(matches: &clap::ArgMatches) -> Self {\n        let arch = Arch::from(matches);\n        let profile = Profile::from(matches);\n        let verbose = verbose(matches);\n\n        Self { arch, profile, verbose }\n    }\n\n    fn run(self) -> Result<()> {\n        let mut cmd = Command::new(cargo());\n        cmd.current_dir(workspace());\n        cmd.arg(\"rustc\");\n        cmd.arg(\"-Z\").arg(\"build-std=core,alloc\");\n        cmd.arg(\"-p\").arg(self.arch.to_string().to_lowercase());\n        cmd.arg(\"--target\").arg(format!(\"lib/{}.json\", self.arch.target()));\n        cmd.arg(\"--\").arg(\"--emit\").arg(\"asm\");\n        if self.profile == Profile::Release {\n            cmd.arg(\"--release\");\n        }\n        if self.verbose {\n            println!(\"Executing {cmd:?}\");\n        }\n        let status = annotated_status(&mut cmd)?;\n        if !status.success() {\n            return Err(\"build kernel failed\".into());\n        }\n        Ok(())\n    }\n}\n\n/// Run tests for the current host toolchain.\nstruct TestStep {\n    json_output: bool,\n    verbose: bool,\n}\n\nimpl TestStep {\n    fn new(matches: &clap::ArgMatches) -> Self {\n        let json_output = matches.get_flag(\"json\");\n        let verbose = verbose(matches);\n\n        Self { json_output, verbose }\n    }\n\n    fn run(self) -> Result<()> {\n        let mut all_cmd_args = Vec::new();\n\n        all_cmd_args.push(vec![\n            \"test\".to_string(),\n            \"--package\".to_string(),\n            \"port\".to_string(),\n            \"--lib\".to_string(),\n        ]);\n\n        let rustup_state = RustupState::new();\n\n        let arch = std::env::consts::ARCH;\n        if let Some(target) = rustup_state.std_supported_target(arch) {\n            all_cmd_args.push(vec![\n                \"test\".to_string(),\n                \"--package\".to_string(),\n                arch.to_string(),\n                \"--bins\".to_string(),\n                \"--target\".to_string(),\n                target.to_string(),\n            ]);\n        }\n\n        for cmd_args in all_cmd_args {\n            let mut cmd = Command::new(cargo());\n            cmd.current_dir(workspace());\n\n            cmd.args(cmd_args);\n            if self.json_output {\n                cmd.arg(\"--message-format=json\").arg(\"--quiet\");\n            }\n\n            if self.verbose {\n                println!(\"Executing {cmd:?}\");\n            }\n            let status = annotated_status(&mut cmd)?;\n            if !status.success() {\n                return Err(\"test failed\".into());\n            }\n        }\n        Ok(())\n    }\n}\n\nstruct ClippyStep {\n    arch: Arch,\n    config: Configuration,\n    profile: Profile,\n    verbose: bool,\n}\n\nimpl ClippyStep {\n    fn new(matches: &clap::ArgMatches) -> Self {\n        let arch = Arch::from(matches);\n        let config = load_config(arch, matches);\n        let profile = Profile::from(matches);\n        let verbose = verbose(matches);\n\n        Self { arch, config, profile, verbose }\n    }\n\n    fn run(self) -> Result<()> {\n        let mut cmd = Command::new(cargo());\n        cmd.arg(\"clippy\");\n\n        apply_to_clippy_step(&mut cmd, &self.config);\n\n        cmd.current_dir(workspace());\n        cmd.arg(\"--workspace\");\n        exclude_other_arches(self.arch, &mut cmd);\n        if self.profile == Profile::Release {\n            cmd.arg(\"--release\");\n        }\n        if self.verbose {\n            println!(\"Executing {cmd:?}\");\n        }\n        let status = annotated_status(&mut cmd)?;\n        if !status.success() {\n            return Err(\"clippy failed\".into());\n        }\n        Ok(())\n    }\n}\n\n/// Run check for all packages for all relevant toolchains.\n/// This assumes that the <arch>-unknown-linux-gnu toolchain has been installed\n/// for any arch we care about.\nstruct CheckStep {\n    json_output: bool,\n    verbose: bool,\n}\n\nimpl CheckStep {\n    fn new(matches: &clap::ArgMatches) -> Self {\n        let json_output = matches.get_flag(\"json\");\n        let verbose = verbose(matches);\n\n        Self { json_output, verbose }\n    }\n\n    fn run(self) -> Result<()> {\n        // To run check for bins and lib we use the default toolchain, which has\n        // been set to the OS-independent arch toolchain in each Cargo.toml file.\n        // The same applies to tests and benches for non-arch-specific lib packages.\n        let bins_lib_package_cmd_args = vec![\n            vec![\n                \"check\".to_string(),\n                \"--package\".to_string(),\n                \"aarch64\".to_string(),\n                \"--bins\".to_string(),\n            ],\n            vec![\n                \"check\".to_string(),\n                \"--package\".to_string(),\n                \"riscv64\".to_string(),\n                \"--bins\".to_string(),\n            ],\n            vec![\n                \"check\".to_string(),\n                \"--package\".to_string(),\n                \"x86_64\".to_string(),\n                \"--bins\".to_string(),\n            ],\n            vec![\n                \"check\".to_string(),\n                \"--package\".to_string(),\n                \"port\".to_string(),\n                \"--lib\".to_string(),\n                \"--tests\".to_string(),\n                \"--benches\".to_string(),\n            ],\n        ];\n\n        let rustup_state = RustupState::new();\n\n        // However, running check for tests and benches in arch packages requires\n        // that we use a toolchain with `std`, so we need an OS-specific toolchain.\n        // If the arch matches that of the current toolchain, then that will be used\n        // for check.  Otherwise we'll always default to <arch>-unknown-linux-gnu.\n        let mut benches_tests_package_cmd_args = Vec::new();\n\n        for arch in [\"aarch64\", \"riscv64\", \"x86_64\"] {\n            let Some(target) = rustup_state.std_supported_target(arch) else {\n                continue;\n            };\n\n            benches_tests_package_cmd_args.push(vec![\n                \"check\".to_string(),\n                \"--package\".to_string(),\n                arch.to_string(),\n                \"--tests\".to_string(),\n                \"--benches\".to_string(),\n                \"--target\".to_string(),\n                target.to_string(),\n            ]);\n        }\n\n        for cmd_args in [bins_lib_package_cmd_args, benches_tests_package_cmd_args].concat() {\n            let mut cmd = Command::new(cargo());\n            cmd.args(cmd_args);\n            if self.json_output {\n                cmd.arg(\"--message-format=json\").arg(\"--quiet\");\n            }\n            cmd.current_dir(workspace());\n\n            if self.verbose {\n                println!(\"Executing {cmd:?}\");\n            }\n            let status = annotated_status(&mut cmd)?;\n            if !status.success() {\n                return Err(\"check failed\".into());\n            }\n        }\n        Ok(())\n    }\n}\n\nstruct CleanStep {}\n\nimpl CleanStep {\n    fn new() -> Self {\n        Self {}\n    }\n\n    fn run(self) -> Result<()> {\n        let mut cmd = Command::new(cargo());\n        cmd.current_dir(workspace());\n        cmd.arg(\"clean\");\n        let status = annotated_status(&mut cmd)?;\n        if !status.success() {\n            return Err(\"clean failed\".into());\n        }\n        Ok(())\n    }\n}\n\nfn workspace() -> PathBuf {\n    Path::new(&env!(\"CARGO_MANIFEST_DIR\")).ancestors().nth(1).unwrap().to_path_buf()\n}\n\n/// Exclude architectures other than the one being built\nfn exclude_other_arches(arch: Arch, cmd: &mut Command) {\n    match arch {\n        Arch::Aarch64 => {\n            cmd.arg(\"--exclude\").arg(\"riscv64\");\n            cmd.arg(\"--exclude\").arg(\"x86_64\");\n        }\n        Arch::Riscv64 => {\n            cmd.arg(\"--exclude\").arg(\"aarch64\");\n            cmd.arg(\"--exclude\").arg(\"x86_64\");\n        }\n        Arch::X86_64 => {\n            cmd.arg(\"--exclude\").arg(\"aarch64\");\n            cmd.arg(\"--exclude\").arg(\"riscv64\");\n        }\n    }\n}\n\n/// Annotates the error result with the calling binary's name.\nfn annotated_status(cmd: &mut Command) -> Result<process::ExitStatus> {\n    Ok(cmd.status().map_err(|e| format!(\"{}: {}\", cmd.get_program().to_string_lossy(), e))?)\n}\n", "source": "R9/xtask/src/main.rs", "file_type": "rc"}
{"text": "/// Test\n///\nuse crate::{Command, Profile};\n\nuse serde::{Deserialize, Serialize};\nuse std::{\n    collections::HashMap,\n    fs::{self, File, create_dir_all},\n    io::Write,\n    process::exit,\n};\n\n/// build section\n#[derive(Debug, Serialize, Deserialize)]\npub struct Build {\n    /// The buildflags controls build-time operations and compiler settings.\n    pub buildflags: Option<Vec<String>>,\n\n    /// A list of custom flags to pass to all compiler invocations that Cargo performs.\n    pub rustflags: Option<Vec<String>>,\n\n    /// Build for the given architecture.\n    pub target: String,\n}\n\n/// Config section\n/// currently available configuration sections are dev, ip, link, nodev, nouart\n/// the section name is becomes the prefix for the configuration option\n/// example usage for section \"dev\"\n/// ```toml\n///  dev = [\n///     'arch',\n///     'cap',\n///     'foo=\"baz\"'\n///  ]\n/// ```\n///  this will create the following configuration options\n///  dev_arch, dev_cap and dev_foo=\"baz\"\n///\n/// usage example:\n///  ```rust\n/// #[cfg(dev_arch)]\n/// pub mod devarch;\n/// ```\n/// ```rust\n/// #[cfg(dev_foo = \"baz\")]\n/// pub mod foobaz;\n/// ```\n#[derive(Debug, Serialize, Deserialize)]\npub struct Config {\n    pub dev: Option<Vec<String>>,\n    pub features: Option<Vec<String>>,\n    pub ip: Option<Vec<String>>,\n    pub link: Option<Vec<String>>,\n    pub nodev: Option<Vec<String>>,\n    pub nouart: Option<Vec<String>>,\n\n    /// platform/board possible values: empty, raspi3b, vfive2, nezha, virt etc.\n    ///\n    /// example usage\n    /// \u00b4\u00b4\u00b4rust\n    /// #[cfg(platform = \"virt\")]\n    /// pub mod virt;\n    /// ```\n    pub platform: Option<String>,\n\n    /// Filepath of DTB file relative to crate\n    pub dtb: Option<String>,\n}\n\n/// Qemu section\n/// Affects arguments to be passed to qemu - doesn't affect build artefacts.\n#[derive(Debug, Serialize, Deserialize)]\npub struct Qemu {\n    /// Machine (`-M`) value for qemu: raspi3b, raspi4b, etc.\n    pub machine: Option<String>,\n\n    /// Filepath of DTB file relative to crate\n    pub dtb: Option<String>,\n}\n\n/// the TOML document\n#[derive(Debug, Serialize, Deserialize)]\npub struct Configuration {\n    pub build: Option<Build>,\n    pub config: Option<Config>,\n    pub link: Option<HashMap<String, String>>,\n    pub qemu: Option<Qemu>,\n}\n\nimpl Configuration {\n    pub fn load(filename: String) -> Self {\n        let contents = match fs::read_to_string(filename.clone()) {\n            Ok(c) => c,\n            Err(_) => {\n                eprintln!(\"Could not read file `{filename}`\");\n                exit(1);\n            }\n        };\n        let config: Configuration = match toml::from_str(&contents) {\n            Ok(d) => d,\n            Err(e) => {\n                eprintln!(\"TOML: Unable to load data from `{filename}`\");\n                eprintln!(\"{e}\");\n                exit(1);\n            }\n        };\n        config\n    }\n}\n\nfn apply_build(cmd: &mut Command, rustflags: &mut Vec<String>, config: &Configuration) {\n    if let Some(config) = &config.build {\n        let target = &config.target;\n        cmd.arg(\"--target\").arg(target);\n\n        if let Some(flags) = &config.buildflags {\n            // add the buildflags to the command\n            for f in flags {\n                cmd.arg(f);\n            }\n        }\n\n        if let Some(flags) = &config.rustflags {\n            // store the passed rustflags temporarily\n            for f in flags {\n                rustflags.push(f.to_string());\n            }\n        }\n    }\n}\n\nfn apply_platform_config(cmd: &mut Command, rustflags: &mut Vec<String>, config: &Configuration) {\n    if let Some(config) = &config.config {\n        // if the target will use features make them available\n        if let Some(features) = &config.features {\n            let mut joined = features.join(\",\");\n            if !features.is_empty() && joined.is_empty() {\n                joined = features.first().unwrap().into();\n            }\n            cmd.arg(format!(\"--features={joined}\"));\n        }\n\n        if let Some(platform) = &config.platform {\n            rustflags.push(\"--cfg\".into());\n            rustflags.push(format!(\"platform=\\\"{platform}\\\"\"));\n        }\n\n        if let Some(devices) = &config.dev {\n            // get all [config] 'dev' settings\n            for dev in devices {\n                rustflags.push(\"--cfg\".into());\n\n                // prefix the setting\n                rustflags.push(format!(\"dev_{dev}\"));\n            }\n        }\n\n        if let Some(ips) = &config.ip {\n            // get all [config] 'ip' settings\n            for ip in ips {\n                rustflags.push(\"--cfg\".into());\n\n                // prefix the setting\n                rustflags.push(format!(\"ip_{ip}\"));\n            }\n        }\n        if let Some(links) = &config.link {\n            // get all [config] 'link' settings\n            for link in links {\n                rustflags.push(\"--cfg\".into());\n\n                // prefix the setting\n                rustflags.push(format!(\"link_{link}\"));\n            }\n        }\n\n        if let Some(nodevs) = &config.nodev {\n            // get all [config] 'nodev' settings\n            for nodev in nodevs {\n                rustflags.push(\"--cfg\".into());\n\n                // prefix the setting\n                rustflags.push(format!(\"nodev_{nodev}\"));\n            }\n        }\n\n        if let Some(nouarts) = &config.nouart {\n            // get all [config] 'nodev' settings\n            for nouart in nouarts {\n                rustflags.push(\"--cfg\".into());\n\n                // prefix the setting\n                rustflags.push(format!(\"nouart_{nouart}\"));\n            }\n        }\n    }\n}\n\nfn apply_link(\n    rustflags: &mut Vec<String>,\n    config: &Configuration,\n    target: &str,\n    profile: &Profile,\n    workspace_path: &str,\n) {\n    // we don't need to handle the linker script for clippy\n    if let Some(link) = &config.link {\n        let filename = link[\"script\"].clone();\n\n        // do we have a linker script ?\n        if !filename.is_empty() {\n            let mut contents = match fs::read_to_string(format!(\"{workspace_path}/{filename}\")) {\n                Ok(c) => c,\n                Err(_) => {\n                    eprintln!(\"Could not read file `{filename}`\");\n                    exit(1);\n                }\n            };\n\n            // replace the placeholders with the values from the TOML\n            if let Some(link) = &config.link {\n                for l in link.iter() {\n                    match l.0.as_str() {\n                        \"arch\" => contents = contents.replace(\"${ARCH}\", l.1),\n                        \"load-address\" => contents = contents.replace(\"${LOAD-ADDRESS}\", l.1),\n                        \"script\" => {} // do nothing for the script option\n                        _ => eprintln!(\"ignoring unknown option '{} = {}'\", l.0, l.1),\n                    }\n                }\n            }\n\n            // construct the path to the target directory\n            let path = format!(\n                \"{}/target/{}/{}\",\n                workspace_path,\n                target,\n                profile.to_string().to_lowercase()\n            );\n\n            // make sure the target directory exists\n            if !std::path::Path::new(&path).exists() {\n                // if not, create it\n                let _ = create_dir_all(&path);\n            }\n\n            // everything is setup, now create the linker script\n            // in the target directory\n            let mut file = File::create(format!(\"{path}/kernel.ld\")).unwrap();\n            let _ = file.write_all(contents.as_bytes());\n\n            // pass the script path to the rustflags\n            rustflags.push(format!(\"-Clink-args=-T{path}/kernel.ld\"));\n        }\n    }\n}\n\nfn apply_qemu_config(cmd: &mut Command, config: &Configuration) {\n    if let Some(config) = &config.qemu {\n        if let Some(machine) = &config.machine {\n            cmd.arg(\"-M\");\n            cmd.arg(machine);\n        }\n        if let Some(dtb) = &config.dtb {\n            cmd.arg(\"-dtb\");\n            cmd.arg(dtb);\n        }\n    }\n}\n\nfn apply_rustflags(cmd: &mut Command, rustflags: &[String]) {\n    // pass the collected rustflags\n    // !! this overrides the build.rustflags from the target Cargo.toml !!\n    if !rustflags.is_empty() {\n        let flat = rustflags.join(\" \");\n        cmd.arg(\"--config\");\n        cmd.arg(format!(\"build.rustflags='{flat}'\"));\n    }\n}\n\npub fn apply_to_clippy_step(cmd: &mut Command, config: &Configuration) {\n    let mut rustflags: Vec<String> = Vec::new();\n    apply_platform_config(cmd, &mut rustflags, config);\n    apply_rustflags(cmd, &rustflags);\n}\n\npub fn apply_to_build_step(\n    cmd: &mut Command,\n    config: &Configuration,\n    target: &str,\n    profile: &Profile,\n    workspace_path: &str,\n) {\n    let mut rustflags: Vec<String> = Vec::new();\n    apply_build(cmd, &mut rustflags, config);\n    apply_platform_config(cmd, &mut rustflags, config);\n    apply_link(&mut rustflags, config, target, profile, workspace_path);\n    apply_rustflags(cmd, &rustflags);\n}\n\npub fn apply_to_qemu_step(cmd: &mut Command, config: &Configuration) {\n    apply_qemu_config(cmd, config);\n}\n", "source": "R9/xtask/src/config.rs", "file_type": "rc"}
{"text": "#![allow(clippy::upper_case_acronyms)]\n#![allow(internal_features)]\n#![cfg_attr(not(any(test)), no_std)]\n#![cfg_attr(not(test), no_main)]\n#![feature(alloc_error_handler)]\n#![feature(core_intrinsics)]\n#![feature(sync_unsafe_cell)]\n#![forbid(unsafe_op_in_unsafe_fn)]\n\nmod allocator;\nmod devcons;\nmod deviceutil;\nmod io;\nmod kmem;\nmod mailbox;\nmod pagealloc;\nmod param;\nmod registers;\nmod swtch;\nmod trap;\nmod uartmini;\nmod uartpl011;\nmod vm;\nmod vmdebug;\n\nextern crate alloc;\n\nuse alloc::boxed::Box;\nuse core::ptr::null_mut;\nuse kmem::{boottext_range, bss_range, data_range, rodata_range, text_range, total_kernel_range};\nuse param::KZERO;\nuse port::mem::{PhysRange, VirtRange};\nuse port::println;\nuse port::{fdt::DeviceTree, mem::PhysAddr};\nuse vm::{Entry, RootPageTableType, VaMapping};\n\n#[cfg(not(test))]\ncore::arch::global_asm!(include_str!(\"l.S\"));\n\nfn print_memory_range(name: &str, range: &PhysRange) {\n    let size = range.size();\n    println!(\"  {name}{range} ({size:#x})\");\n}\n\nfn print_binary_sections() {\n    println!(\"Binary sections:\");\n    print_memory_range(\"boottext:\\t\", &boottext_range());\n    print_memory_range(\"text:\\t\\t\", &text_range());\n    print_memory_range(\"rodata:\\t\", &rodata_range());\n    print_memory_range(\"data:\\t\\t\", &data_range());\n    print_memory_range(\"bss:\\t\\t\", &bss_range());\n    print_memory_range(\"total:\\t\", &total_kernel_range());\n}\n\nfn print_memory_info() {\n    println!(\"Memory usage:\");\n    let (used, total) = pagealloc::usage_bytes();\n    println!(\"  Used:\\t\\t{used:#016x}\");\n    println!(\"  Total:\\t{total:#016x}\");\n}\n\n// https://github.com/raspberrypi/documentation/blob/develop/documentation/asciidoc/computers/raspberry-pi/revision-codes.adoc\nfn print_pi_name(board_revision: u32) {\n    let name = match board_revision {\n        0xa21041 => \"Raspberry Pi 2B\",\n        0xa02082 => \"Raspberry Pi 3B\",\n        0xb03115 => \"Raspberry Pi 4B\",\n        0xa220a0 => \"Raspberry Compute Module 3\",\n        _ => \"Unrecognised\",\n    };\n    println!(\"  Board Name:\\t{name}\");\n}\n\nfn print_board_info() {\n    println!(\"Board information:\");\n    let board_revision = mailbox::get_board_revision();\n    print_pi_name(board_revision);\n    println!(\"  Board Rev:\\t{board_revision:#010x}\");\n    let model = mailbox::get_board_model();\n    println!(\"  Board Model:\\t{model:#010x}\");\n    let serial = mailbox::get_board_serial();\n    println!(\"  Serial Num:\\t{serial:#010x}\");\n    let mailbox::MacAddress { a, b, c, d, e, f } = mailbox::get_board_macaddr();\n    println!(\"  MAC Address:\\t{a:02x}:{b:02x}:{c:02x}:{d:02x}:{e:02x}:{f:02x}\");\n    let fw_revision = mailbox::get_firmware_revision();\n    println!(\"  Firmware Rev:\\t{fw_revision:#010x}\");\n}\n\nfn print_stacks() {\n    unsafe extern \"C\" {\n        static interruptstackbase: [u64; 0];\n        static interruptstacksz: [u64; 0];\n    }\n\n    let interrupt_stack_base = unsafe { interruptstackbase.as_ptr().addr() };\n    let interrupt_stack_max = interrupt_stack_base + unsafe { interruptstacksz.as_ptr().addr() };\n    let range = VirtRange(interrupt_stack_base..interrupt_stack_max);\n    let range_size = range.size();\n    println!(\"Interrupt stack:\\t {range} ({range_size:#x})\");\n}\n\n/// dtb_va is the virtual address of the DTB structure.  The physical address is\n/// assumed to be dtb_va-KZERO.\n#[unsafe(no_mangle)]\npub extern \"C\" fn main9(dtb_va: usize) {\n    trap::init();\n\n    // Parse the DTB before we set up memory so we can correctly map it\n    let dt = unsafe { DeviceTree::from_usize(dtb_va).unwrap() };\n    let dtb_physrange = PhysRange::with_pa_len(PhysAddr::new((dtb_va - KZERO) as u64), dt.size());\n\n    // Try to set up the miniuart so we can log as early as possible.\n    devcons::init(&dt, true);\n\n    println!();\n    println!(\"r9 from the Internet\");\n    println!(\"DTB found at: {:#x}\", dtb_va);\n    println!(\"midr_el1: {:?}\", registers::MidrEl1::read());\n\n    print_stacks();\n\n    print_binary_sections();\n\n    pagealloc::init_page_allocator();\n\n    // Map address space accurately using rust VM code to manage page tables\n    unsafe {\n        vm::init_kernel_page_tables(&dt, dtb_physrange);\n        vm::switch(vm::kernel_pagetable(), RootPageTableType::Kernel);\n\n        vm::init_user_page_tables();\n        vm::switch(vm::user_pagetable(), RootPageTableType::User);\n    }\n\n    // From this point we can use the global allocator\n\n    devcons::init(&dt, false);\n    mailbox::init(&dt);\n\n    print_board_info();\n    print_memory_info();\n\n    // vmdebug::print_recursive_tables(RootPageTableType::Kernel);\n    // vmdebug::print_recursive_tables(RootPageTableType::User);\n\n    {\n        let page_table = vm::kernel_pagetable();\n        let entry = Entry::rw_kernel_data();\n        for i in 0..3 {\n            let alloc_result = pagealloc::allocate_virtpage(\n                page_table,\n                \"testkernel\",\n                entry,\n                VaMapping::Offset(KZERO),\n                RootPageTableType::Kernel,\n            );\n            match alloc_result {\n                Ok(_allocated_page) => {}\n                Err(err) => {\n                    println!(\"Error allocating page in kernel space ({i}): {:?}\", err);\n                    break;\n                }\n            }\n        }\n    }\n\n    // vmdebug::print_recursive_tables(RootPageTableType::Kernel);\n    // vmdebug::print_recursive_tables(RootPageTableType::User);\n\n    println!(\"Set up a user process\");\n\n    test_sysexit();\n\n    vmdebug::print_recursive_tables(RootPageTableType::Kernel);\n    vmdebug::print_recursive_tables(RootPageTableType::User);\n\n    let _b = Box::new(\"ddododo\");\n\n    println!(\"looping now\");\n\n    #[allow(clippy::empty_loop)]\n    loop {}\n}\n\nmod runtime;\n\nfn test_sysexit() {\n    let page_table = vm::user_pagetable();\n\n    // Allocate pages for a user process\n    let user_text = {\n        let user_text = pagealloc::allocate_virtpage(\n            page_table,\n            \"usertext\",\n            Entry::rw_user_text(),\n            VaMapping::Addr(0x1000),\n            RootPageTableType::User,\n        )\n        .expect(\"couldn't allocate user_text\");\n\n        // Machine code and assembly to call syscall exit\n        //   00 00 80 D2    ; mov x0, #0\n        //   21 00 80 D2    ; mov x1, #1\n        //   61 00 00 D4    ; svc #3\n        let proc_text_bytes: [u8; 12] =\n            [0x00, 0x00, 0x80, 0xd2, 0x21, 0x00, 0x80, 0xd2, 0x61, 0x00, 0x00, 0xd4];\n        user_text.0[..proc_text_bytes.len()].copy_from_slice(&proc_text_bytes);\n        user_text\n    };\n    let user_text_va = user_text as *const _ as u64;\n\n    let user_stack = pagealloc::allocate_virtpage(\n        page_table,\n        \"userstack\",\n        Entry::rw_user_data(),\n        VaMapping::Addr(KZERO - 0x1000),\n        RootPageTableType::User,\n    )\n    .expect(\"couldn't allocate user_stack\");\n\n    // Executing user process!\n    println!(\"Executing user process\");\n    let proc_stack = unsafe { core::slice::from_raw_parts_mut(user_stack, 4096) };\n\n    // Initialise a Context struct on the process stack, at the end of the proc_stack_buffer.\n    let ps_addr = &proc_stack as *const _ as u64;\n    let proc_stack_initial_ctx = ps_addr + (4096 - size_of::<swtch::Context>()) as u64;\n    let proc_context_ptr: *mut swtch::Context = proc_stack_initial_ctx as *mut swtch::Context;\n\n    // Need to push a context object onto the stack, with x30 populated at the\n    // address of proc_textbuf\n    let proc_context_ref: &mut swtch::Context = unsafe { &mut *proc_context_ptr };\n    proc_context_ref.set_stack_pointer(&proc_context_ptr as *const _ as u64);\n    proc_context_ref.set_return(user_text_va);\n\n    let mut kernel_context: *mut swtch::Context = null_mut();\n    let kernel_context_ptr: *mut *mut swtch::Context = &mut kernel_context;\n\n    //println!(\"proc ctx: {:#?}\", proc_context_ref);\n\n    unsafe { swtch::swtch(kernel_context_ptr, &*proc_context_ptr) };\n\n    //println!(\"x30: {:#016x}\", proc_context_ref.x30);\n}\n", "source": "R9/aarch64/src/main.rs", "file_type": "rc"}
{"text": "use core::ptr::NonNull;\n\nuse crate::deviceutil::{self, map_device_register};\nuse crate::io::{read_reg, write_reg};\nuse crate::vm;\nuse port::Result;\nuse port::fdt::DeviceTree;\nuse port::mcslock::{Lock, LockNode};\nuse port::mem::{PhysAddr, PhysRange, VirtRange};\n\n#[cfg(not(test))]\nuse port::println;\n\nconst MBOX_READ: usize = 0x00;\nconst MBOX_STATUS: usize = 0x18;\nconst MBOX_WRITE: usize = 0x20;\n\nconst MBOX_FULL: u32 = 0x8000_0000;\nconst MBOX_EMPTY: u32 = 0x4000_0000;\n\nstatic MAILBOX: Lock<Option<Mailbox>> = Lock::new(\"mailbox\", None);\n\n/// Mailbox init.  Mainly initialises a lock to ensure only one mailbox request\n/// can be made at a time.\npub fn init(dt: &DeviceTree) {\n    match Mailbox::new(dt) {\n        Ok(mbox) => {\n            let node = LockNode::new();\n            let mut mailbox = MAILBOX.lock(&node);\n            *mailbox = Some(mbox);\n        }\n        Err(msg) => {\n            println!(\"can't initialise mailbox: {:?}\", msg);\n        }\n    }\n}\n\n/// https://developer.arm.com/documentation/ddi0306/b/CHDGHAIG\n/// https://github.com/raspberrypi/firmware/wiki/Mailbox-property-interface\nstruct Mailbox {\n    pub mbox_virtrange: VirtRange,\n    req_buffer_va: VirtRange,\n    req_buffer_pa: PhysRange,\n}\n\nimpl Mailbox {\n    fn new(dt: &DeviceTree) -> Result<Self> {\n        // Allocate a page of device memory for the mailbox request/response buffer\n        // TODO Split this into multiple buffers to allow parallel requests.\n        let (req_buffer_va, req_buffer_pa) =\n            deviceutil::alloc_device_page(\"mailboxbuf\", vm::PageSize::Page4K)?;\n\n        let mbox_physrange = Self::find_mbox_physrange(dt)?;\n        let mbox = match map_device_register(\"mailbox\", mbox_physrange, vm::PageSize::Page4K) {\n            Ok(mbox_virtrange) => Ok(Mailbox { mbox_virtrange, req_buffer_va, req_buffer_pa }),\n            Err(msg) => {\n                println!(\"can't map mailbox {:?}\", msg);\n                Err(\"can't create mailbox\")\n            }\n        }?;\n\n        Ok(mbox)\n    }\n\n    /// Get the physical range required for this device\n    fn find_mbox_physrange(dt: &DeviceTree) -> Result<PhysRange> {\n        dt.find_compatible(\"brcm,bcm2835-mbox\")\n            .next()\n            .and_then(|uart| dt.property_translated_reg_iter(uart).next())\n            .and_then(|reg| reg.regblock())\n            .map(|reg| PhysRange::from(&reg))\n            .ok_or(\"can't find mbox\")\n    }\n\n    fn request<T, U>(&self)\n    where\n        T: Copy,\n        U: Copy,\n    {\n        // Read status register until full flag not set\n        while (read_reg(&self.mbox_virtrange, MBOX_STATUS) & MBOX_FULL) != 0 {}\n\n        // Write the request address combined with the channel to the write register\n        let channel = ChannelId::ArmToVc as u32;\n        let uart_mbox_u32 = self.req_buffer_pa.start().addr() as u32;\n        let r = (uart_mbox_u32 & !0xF) | channel;\n        write_reg(&self.mbox_virtrange, MBOX_WRITE, r);\n\n        // Wait for response\n        // FIXME: two infinite loops - could go awry\n        loop {\n            while (read_reg(&self.mbox_virtrange, MBOX_STATUS) & MBOX_EMPTY) != 0 {}\n            let response = read_reg(&self.mbox_virtrange, MBOX_READ);\n            if response == r {\n                break;\n            }\n        }\n    }\n}\n\n#[repr(u8)]\nenum ChannelId {\n    ArmToVc = 8,\n}\n\n#[repr(C)]\n#[derive(Debug, Clone, Copy)]\nstruct Request<T> {\n    size: u32, // size in bytes\n    code: u32, // request code (0)\n    tags: T,\n}\n\n#[repr(C)]\n#[derive(Debug, Clone, Copy)]\nstruct Response<T> {\n    size: u32, // size in bytes\n    code: u32, // response code\n    tags: T,\n}\n\n#[repr(C)]\n#[derive(Debug, Clone, Copy)]\nstruct Tag<T> {\n    tag_id0: TagId,\n    tag_buffer_size0: u32,\n    tag_code0: u32,\n    body: T,\n    end_tag: u32,\n}\n\n#[repr(C, align(16))]\n#[derive(Clone, Copy)]\nunion Message<T: Copy, U: Copy> {\n    request: Request<T>,\n    response: Response<U>,\n}\n\ntype MessageWithTags<T, U> = Message<Tag<T>, Tag<U>>;\n\nfn request<T, U>(code: u32, tags: &Tag<T>) -> U\nwhere\n    T: Copy,\n    U: Copy,\n{\n    let size = size_of::<Message<T, U>>() as u32;\n    let node = LockNode::new();\n    MAILBOX\n        .lock(&node)\n        .as_mut()\n        .map(|mb| {\n            let msg = unsafe {\n                let page_va_ptr = mb.req_buffer_va.start() as u64 as *mut MessageWithTags<T, U>;\n                core::intrinsics::volatile_set_memory(page_va_ptr, 0, 1);\n                let msg = NonNull::new_unchecked(page_va_ptr).as_mut();\n                msg.request.size = size;\n                msg.request.code = code;\n                msg.request.tags = *tags;\n                msg\n            };\n\n            mb.request::<T, U>();\n            unsafe { msg.response.tags.body }\n        })\n        .expect(\"mailbox not initialised\")\n}\n\n// https://github.com/raspberrypi/firmware/wiki/Mailbox-property-interface#tags-arm-to-vc\n#[repr(u32)]\n#[derive(Debug, Clone, Copy)]\nenum TagId {\n    GetFirmwareRevision = 0x0000_0001,\n    GetBoardModel = 0x0001_0001,\n    GetBoardRevision = 0x0001_0002,\n    GetBoardMacAddress = 0x0001_0003,\n    GetBoardSerial = 0x0001_0004,\n    GetArmMemory = 0x0001_0005,\n    GetVcMemory = 0x0001_0006,\n    SetClockRate = 0x0003_8002,\n}\n\n#[repr(C)]\n#[derive(Debug, Clone, Copy)]\nstruct SetClockRateRequest {\n    clock_id: u32,\n    rate_hz: u32,\n    skip_setting_turbo: u32,\n}\n\n#[repr(C)]\n#[derive(Debug, Clone, Copy)]\nstruct SetClockRateResponse {\n    clock_id: u32,\n    rate_hz: u32,\n}\n\n#[allow(dead_code)]\npub fn set_clock_rate(clock_id: u32, rate_hz: u32, skip_setting_turbo: u32) {\n    let tags = Tag::<SetClockRateRequest> {\n        tag_id0: TagId::SetClockRate,\n        tag_buffer_size0: 12,\n        tag_code0: 0,\n        body: SetClockRateRequest { clock_id, rate_hz, skip_setting_turbo },\n        end_tag: 0,\n    };\n    let _: SetClockRateResponse = request(0, &tags);\n}\n\n#[repr(C)]\n#[derive(Debug, Clone, Copy)]\nstruct EmptyRequest {}\n\n#[repr(C)]\n#[derive(Debug, Clone, Copy)]\nstruct MemoryResponse {\n    base_addr: u32,\n    size: u32,\n}\n\n#[repr(C)]\n#[derive(Debug, Clone, Copy)]\n#[allow(dead_code)]\npub struct MemoryInfo {\n    pub start: u32,\n    pub size: u32,\n    pub end: u32,\n}\n\n#[allow(dead_code)]\npub fn get_arm_memory() -> PhysRange {\n    let tags = Tag::<EmptyRequest> {\n        tag_id0: TagId::GetArmMemory,\n        tag_buffer_size0: 12,\n        tag_code0: 0,\n        body: EmptyRequest {},\n        end_tag: 0,\n    };\n    let res: MemoryResponse = request(0, &tags);\n    let start = res.base_addr;\n    let size = res.size;\n    let end = start + size;\n\n    PhysRange::new(PhysAddr::new(start as u64), PhysAddr::new(end as u64))\n}\n\n#[allow(dead_code)]\npub fn get_vc_memory() -> PhysRange {\n    let tags = Tag::<EmptyRequest> {\n        tag_id0: TagId::GetVcMemory,\n        tag_buffer_size0: 12,\n        tag_code0: 0,\n        body: EmptyRequest {},\n        end_tag: 0,\n    };\n    let res: MemoryResponse = request(0, &tags);\n    let start = res.base_addr;\n    let size = res.size;\n    let end = start + size;\n\n    PhysRange::new(PhysAddr::new(start as u64), PhysAddr::new(end as u64))\n}\n\npub fn get_firmware_revision() -> u32 {\n    let tags = Tag::<EmptyRequest> {\n        tag_id0: TagId::GetFirmwareRevision,\n        tag_buffer_size0: 4,\n        tag_code0: 0,\n        body: EmptyRequest {},\n        end_tag: 0,\n    };\n    request::<_, u32>(0, &tags)\n}\n\npub fn get_board_model() -> u32 {\n    let tags = Tag::<EmptyRequest> {\n        tag_id0: TagId::GetBoardModel,\n        tag_buffer_size0: 4,\n        tag_code0: 0,\n        body: EmptyRequest {},\n        end_tag: 0,\n    };\n    request::<_, u32>(0, &tags)\n}\n\npub fn get_board_revision() -> u32 {\n    let tags = Tag::<EmptyRequest> {\n        tag_id0: TagId::GetBoardRevision,\n        tag_buffer_size0: 4,\n        tag_code0: 0,\n        body: EmptyRequest {},\n        end_tag: 0,\n    };\n    request::<_, u32>(0, &tags)\n}\n\n#[repr(C)]\n#[derive(Debug, Clone, Copy)]\npub struct MacAddress {\n    pub a: u8,\n    pub b: u8,\n    pub c: u8,\n    pub d: u8,\n    pub e: u8,\n    pub f: u8,\n}\n\npub fn get_board_macaddr() -> MacAddress {\n    let tags = Tag::<EmptyRequest> {\n        tag_id0: TagId::GetBoardMacAddress,\n        tag_buffer_size0: 6,\n        tag_code0: 0,\n        body: EmptyRequest {},\n        end_tag: 0,\n    };\n    request::<_, MacAddress>(0, &tags)\n}\n\npub fn get_board_serial() -> u64 {\n    let tags = Tag::<EmptyRequest> {\n        tag_id0: TagId::GetBoardSerial,\n        tag_buffer_size0: 8,\n        tag_code0: 0,\n        body: EmptyRequest {},\n        end_tag: 0,\n    };\n    // FIXME: Treating this a `u64` gets us a memory address. Pointer fun ahead.\n    // Wrapping in a struct holding a single u64 doesn't work either.\n    let res: [u32; 2] = request(0, &tags);\n    ((res[0] as u64) << 32) | res[1] as u64\n}\n", "source": "R9/aarch64/src/mailbox.rs", "file_type": "rc"}
{"text": "#![cfg(not(test))]\n\nextern crate alloc;\n\nuse alloc::alloc::Layout;\nuse core::panic::PanicInfo;\n\n#[cfg(not(test))]\nuse port::println;\n\n// TODO\n//  - Add qemu integration test\n#[panic_handler]\npub fn panic(info: &PanicInfo) -> ! {\n    println!(\"{}\\n\", info);\n\n    #[allow(clippy::empty_loop)]\n    loop {}\n}\n\n#[alloc_error_handler]\nfn oom(_layout: Layout) -> ! {\n    panic!(\"oom\");\n}\n", "source": "R9/aarch64/src/runtime.rs", "file_type": "rc"}
{"text": "#![allow(non_upper_case_globals)]\n\n/// Recursive page table implementation for aarch64.\n/// Note that currently there are a lot of assumptions that we're dealing with\n/// 4KiB tables here, although it supports various sizes of pages.\nuse crate::{\n    kmem::{\n        boottext_range, bss_range, data_range, from_ptr_to_physaddr_offset_from_kzero,\n        physaddr_as_ptr_mut_offset_from_kzero, rodata_range, text_range,\n    },\n    pagealloc,\n    param::KZERO,\n};\nuse bitstruct::bitstruct;\nuse core::{fmt, ptr, sync::atomic::Ordering};\nuse core::{ptr::write_volatile, sync::atomic::AtomicUsize};\nuse num_enum::{FromPrimitive, IntoPrimitive};\nuse port::{\n    fdt::DeviceTree,\n    mem::{PAGE_SIZE_1G, PAGE_SIZE_2M, PAGE_SIZE_4K, PhysAddr, PhysRange, VirtRange},\n    pagealloc::PageAllocError,\n};\n\n#[cfg(not(test))]\nuse port::println;\n\nstatic mut KERNEL_PAGETABLE: RootPageTable = RootPageTable::empty();\nstatic mut USER_PAGETABLE: RootPageTable = RootPageTable::empty();\n\npub fn kernel_pagetable() -> &'static mut RootPageTable {\n    unsafe { &mut *ptr::addr_of_mut!(KERNEL_PAGETABLE) }\n}\n\npub fn user_pagetable() -> &'static mut RootPageTable {\n    unsafe { &mut *ptr::addr_of_mut!(USER_PAGETABLE) }\n}\n\n#[allow(dead_code)]\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum PageSize {\n    Page4K,\n    Page2M,\n    Page1G,\n}\n\nimpl PageSize {\n    pub const fn size(&self) -> usize {\n        match self {\n            PageSize::Page4K => PAGE_SIZE_4K,\n            PageSize::Page2M => PAGE_SIZE_2M,\n            PageSize::Page1G => PAGE_SIZE_1G,\n        }\n    }\n}\n\n#[repr(C, align(4096))]\n#[derive(Clone, Copy)]\npub struct PhysPage4K([u8; PAGE_SIZE_4K]);\n\nimpl PhysPage4K {\n    pub fn clear(&mut self) {\n        unsafe {\n            core::intrinsics::volatile_set_memory(&mut self.0, 0u8, 1);\n        }\n    }\n}\n\n#[repr(C, align(4096))]\n#[derive(Clone, Copy)]\npub struct VirtPage4K(pub [u8; PAGE_SIZE_4K]);\n\nimpl VirtPage4K {}\n\n#[derive(Debug, IntoPrimitive, FromPrimitive)]\n#[repr(u8)]\npub enum Mair {\n    #[num_enum(default)]\n    Normal = 0,\n    Device = 1,\n}\n\n#[derive(Debug, IntoPrimitive, FromPrimitive)]\n#[repr(u8)]\npub enum AccessPermission {\n    #[num_enum(default)]\n    PrivRw = 0,\n    AllRw = 1,\n    PrivRo = 2,\n    AllRo = 3,\n}\n\n#[derive(Debug, IntoPrimitive, FromPrimitive)]\n#[repr(u8)]\npub enum Shareable {\n    #[num_enum(default)]\n    Non = 0, // Non-shareable (single core)\n    Unpredictable = 1, // Unpredictable!\n    Outer = 2,         // Outer shareable (shared across CPUs, GPU)\n    Inner = 3,         // Inner shareable (shared across CPUs)\n}\n\nbitstruct! {\n    /// AArch64 supports various granule and page sizes.  We assume 48-bit\n    /// addresses.  This is documented in the 'Translation table descriptor\n    /// formats' section of the Arm Architecture Reference Manual.\n    /// The virtual address translation breakdown is documented in the 'Translation\n    /// Process' secrtion of the Arm Architecture Reference Manual.\n    #[derive(Copy, Clone, PartialEq)]\n    #[repr(transparent)]\n    pub struct Entry(pub u64) {\n        pub valid: bool = 0;\n        pub page_or_table: bool = 1;\n        pub mair_index: Mair = 2..5;\n        pub non_secure: bool = 5;\n        pub access_permission: AccessPermission = 6..8;\n        pub shareable: Shareable = 8..10;\n        pub accessed: bool = 10; // Was accessed by code\n        pub addr: u64 = 12..48;\n        pub pxn: bool = 53; // Privileged eXecute Never\n        pub uxn: bool = 54; // Unprivileged eXecute Never\n    }\n}\n\nimpl Entry {\n    pub const fn empty() -> Entry {\n        Entry(0)\n    }\n\n    pub fn rw_kernel_data() -> Self {\n        Entry(0)\n            .with_access_permission(AccessPermission::PrivRw)\n            .with_shareable(Shareable::Inner)\n            .with_accessed(true)\n            .with_uxn(true)\n            .with_pxn(true)\n            .with_mair_index(Mair::Normal)\n            .with_valid(true)\n    }\n\n    pub fn ro_kernel_data() -> Self {\n        Entry(0)\n            .with_access_permission(AccessPermission::PrivRo)\n            .with_shareable(Shareable::Inner)\n            .with_accessed(true)\n            .with_uxn(true)\n            .with_pxn(true)\n            .with_mair_index(Mair::Normal)\n            .with_valid(true)\n    }\n\n    pub fn ro_kernel_text() -> Self {\n        Entry(0)\n            .with_access_permission(AccessPermission::PrivRo)\n            .with_shareable(Shareable::Inner)\n            .with_accessed(true)\n            .with_uxn(true)\n            .with_pxn(false)\n            .with_mair_index(Mair::Normal)\n            .with_valid(true)\n    }\n\n    pub fn rw_device() -> Self {\n        Entry(0)\n            .with_access_permission(AccessPermission::PrivRw)\n            .with_shareable(Shareable::Inner)\n            .with_accessed(true)\n            .with_uxn(true)\n            .with_pxn(true)\n            .with_mair_index(Mair::Device)\n            .with_valid(true)\n    }\n\n    pub fn rw_user_text() -> Self {\n        Entry(0)\n            .with_access_permission(AccessPermission::AllRw)\n            .with_shareable(Shareable::Inner)\n            .with_accessed(true)\n            .with_uxn(false)\n            .with_pxn(true)\n            .with_mair_index(Mair::Normal)\n            .with_valid(true)\n    }\n\n    pub fn rw_user_data() -> Self {\n        Entry(0)\n            .with_access_permission(AccessPermission::AllRw)\n            .with_shareable(Shareable::Inner)\n            .with_accessed(true)\n            .with_uxn(true)\n            .with_pxn(true)\n            .with_mair_index(Mair::Normal)\n            .with_valid(true)\n    }\n\n    const fn with_phys_addr(self, pa: PhysAddr) -> Self {\n        Entry(self.0).with_addr(pa.addr() >> 12)\n    }\n\n    pub fn is_table(self, level: Level) -> bool {\n        self.page_or_table() && level != Level::Level3\n    }\n}\n\nimpl fmt::Debug for Entry {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"Entry: {:#x} \", self.addr() << 12)?;\n        if self.valid() {\n            write!(f, \" Valid\")?;\n        } else {\n            write!(f, \" Invalid\")?;\n        }\n        if self.page_or_table() {\n            write!(f, \" Page/Table\")?;\n        } else {\n            write!(f, \" Block\")?;\n        }\n        write!(f, \" {:?}\", self.mair_index())?;\n        if self.non_secure() {\n            write!(f, \" NonSecure\")?;\n        } else {\n            write!(f, \" Secure\")?;\n        }\n        write!(f, \" {:?} {:?}\", self.access_permission(), self.shareable())?;\n        if self.accessed() {\n            write!(f, \" Accessed\")?;\n        }\n        if self.pxn() {\n            write!(f, \" PXN\")?;\n        }\n        if self.uxn() {\n            write!(f, \" UXN\")?;\n        }\n        Ok(())\n    }\n}\n\n/// Levels start at the lowest number (most significant) and increase from\n/// there.  Four levels would support (for example) 4kiB granules with 4KiB\n/// pages using Level0 - Level3, while three would support 2MiB pages with the\n/// same size granules, using only Level0 - Level2.\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum Level {\n    Level0,\n    Level1,\n    Level2,\n    Level3,\n}\n\nimpl Level {\n    /// Returns the next level to translate\n    pub fn next(&self) -> Option<Level> {\n        match self {\n            Level::Level0 => Some(Level::Level1),\n            Level::Level1 => Some(Level::Level2),\n            Level::Level2 => Some(Level::Level3),\n            Level::Level3 => None,\n        }\n    }\n\n    pub fn depth(&self) -> usize {\n        match self {\n            Level::Level0 => 0,\n            Level::Level1 => 1,\n            Level::Level2 => 2,\n            Level::Level3 => 3,\n        }\n    }\n}\n\npub fn va_index(va: usize, level: Level) -> usize {\n    match level {\n        Level::Level0 => (va >> 39) & 0x1ff,\n        Level::Level1 => (va >> 30) & 0x1ff,\n        Level::Level2 => (va >> 21) & 0x1ff,\n        Level::Level3 => (va >> 12) & 0x1ff,\n    }\n}\n\n/// Return the virtual address for the page table at level `level` for the\n/// given virtual address, assuming the use of recursive page tables.\nfn recursive_table_addr(pgtype: RootPageTableType, va: usize, level: Level) -> usize {\n    let indices_mask = 0x0000_ffff_ffff_f000;\n    let indices = va & indices_mask;\n    let shift = match level {\n        Level::Level0 => 36,\n        Level::Level1 => 27,\n        Level::Level2 => 18,\n        Level::Level3 => 9,\n    };\n    let recursive_indices = match level {\n        Level::Level0 => (511 << 39) | (511 << 30) | (511 << 21) | (511 << 12),\n        Level::Level1 => (511 << 39) | (511 << 30) | (511 << 21),\n        Level::Level2 => (511 << 39) | (511 << 30),\n        Level::Level3 => 511 << 39,\n    };\n    let msbits = match pgtype {\n        RootPageTableType::Kernel => 0xffff_0000_0000_0000,\n        RootPageTableType::User => 0x0000_0000_0000_0000,\n    };\n    msbits | recursive_indices | ((indices >> shift) & indices_mask)\n}\n\n#[derive(Debug)]\n#[allow(dead_code)]\npub enum PageTableError {\n    AllocationFailed(PageAllocError),\n    EntryIsNotTable,\n    PhysRangeIsZero,\n    PhysRangeIsNotOnPageBoundary,\n}\n\nimpl From<PageAllocError> for PageTableError {\n    fn from(err: PageAllocError) -> PageTableError {\n        PageTableError::AllocationFailed(err)\n    }\n}\n\n#[repr(C, align(4096))]\npub struct Table {\n    pub entries: [Entry; 512],\n}\n\nimpl Table {\n    /// Return a mutable entry from the table based on the virtual address and\n    /// the level.  (It uses the level to extract the index from the correct\n    /// part of the virtual address).\n    pub fn entry_mut(&mut self, level: Level, va: usize) -> Result<&mut Entry, PageTableError> {\n        let idx = va_index(va, level);\n        Ok(&mut self.entries[idx])\n    }\n\n    /// Return the next table in the walk.  If it doesn't exist, create it.\n    fn next_mut(\n        &mut self,\n        alloc_page: fn() -> Result<PhysAddr, PageAllocError>,\n        pgtype: RootPageTableType,\n        level: Level,\n        va: usize,\n    ) -> Result<&mut Table, PageTableError> {\n        // Try to get a valid page table entry.  If it doesn't exist, create it.\n        let index = va_index(va, level);\n        let mut entry = self.entries[index];\n        if !entry.valid() {\n            // Create a new page table and write the entry into the parent table\n            let page_pa = alloc_page();\n            let page_pa = match page_pa {\n                Ok(p) => p,\n                Err(err) => {\n                    println!(\"error:vm:next_mut:can't allocate physpage\");\n                    return Err(PageTableError::AllocationFailed(err));\n                }\n            };\n            entry = Entry::rw_kernel_data().with_phys_addr(page_pa).with_page_or_table(true);\n            unsafe {\n                write_volatile(&mut self.entries[index], entry);\n            }\n\n            // Clear out the new page\n            let recursive_page_addr = recursive_table_addr(pgtype, va, level.next().unwrap());\n            let page = unsafe { &mut *(recursive_page_addr as *mut PhysPage4K) };\n            page.clear();\n        } else if !entry.is_table(level) {\n            println!(\"error:vm:next_mut:entry is not a valid table entry:{entry:?} {level:?}\");\n            return Err(PageTableError::EntryIsNotTable);\n        }\n\n        // Return the address of the next table as a recursive address\n        let recursive_page_addr = recursive_table_addr(pgtype, va, level.next().unwrap());\n        Ok(unsafe { &mut *(recursive_page_addr as *mut Table) })\n    }\n}\n\nimpl fmt::Debug for Table {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, \"{:x}\", (self as *const Self).addr())\n    }\n}\n\npub enum VaMapping {\n    Addr(usize),   // Map to exact virtual address\n    Offset(usize), // Map to offset of physical address\n}\n\nimpl VaMapping {\n    fn map(&self, pa: PhysAddr) -> usize {\n        match self {\n            Self::Addr(va) => *va,\n            Self::Offset(offset) => (pa.addr() as usize).wrapping_add(*offset),\n        }\n    }\n}\n\npub type RootPageTable = Table;\n\nimpl RootPageTable {\n    pub const fn empty() -> RootPageTable {\n        RootPageTable { entries: [Entry::empty(); 512] }\n    }\n\n    /// Ensure there's a mapping from va to entry, creating any intermediate\n    /// page tables that don't already exist.  If a mapping already exists,\n    /// replace it.\n    /// root_page_table should be a direct va - not a recursive va.\n    fn map_to(\n        &mut self,\n        alloc_page: fn() -> Result<PhysAddr, PageAllocError>,\n        entry: Entry,\n        va: usize,\n        page_size: PageSize,\n        root_page_table: &mut RootPageTable,\n        pgtype: RootPageTableType,\n    ) -> Result<(), PageTableError> {\n        // We change the last entry of the root page table to the address of\n        // self for the duration of this method.  This allows us to work with\n        // this hierarchy of pagetables even if it's not the current translation\n        // table.  We *must* return it to its original state on exit.\n        // TODO Only do this if self != kernel_root()\n        let old_recursive_entry = root_page_table.entries[511];\n        let temp_recursive_entry = Entry::rw_kernel_data()\n            .with_phys_addr(from_ptr_to_physaddr_offset_from_kzero(self))\n            .with_page_or_table(true);\n\n        unsafe {\n            write_volatile(&mut root_page_table.entries[511], temp_recursive_entry);\n            // TODO Need to invalidate the single cache entry\n            invalidate_all_tlb_entries();\n        };\n\n        let dest_entry = match page_size {\n            PageSize::Page4K => self\n                .next_mut(alloc_page, pgtype, Level::Level0, va)\n                .and_then(|t1| t1.next_mut(alloc_page, pgtype, Level::Level1, va))\n                .and_then(|t2| t2.next_mut(alloc_page, pgtype, Level::Level2, va))\n                .and_then(|t3| t3.entry_mut(Level::Level3, va)),\n            PageSize::Page2M => self\n                .next_mut(alloc_page, pgtype, Level::Level0, va)\n                .and_then(|t1| t1.next_mut(alloc_page, pgtype, Level::Level1, va))\n                .and_then(|t2| t2.entry_mut(Level::Level2, va)),\n            PageSize::Page1G => self\n                .next_mut(alloc_page, pgtype, Level::Level0, va)\n                .and_then(|t1| t1.entry_mut(Level::Level1, va)),\n        };\n        let dest_entry = match dest_entry {\n            Ok(e) => e,\n            Err(err) => {\n                println!(\n                    \"error:vm:map_to:couldn't find page table entry. va:{:#x} err:{:?}\",\n                    va, err\n                );\n                return Err(err);\n            }\n        };\n\n        // Entries at level 3 should have the page flag set\n        let entry =\n            if page_size == PageSize::Page4K { entry.with_page_or_table(true) } else { entry };\n\n        unsafe {\n            write_volatile(dest_entry, entry);\n            // Return the recursive entry to its original state\n            write_volatile(&mut root_page_table.entries[511], old_recursive_entry);\n            // TODO Need to invalidate the single cache entry (+ optionally the recursive entry)\n            invalidate_all_tlb_entries();\n        }\n\n        Ok(())\n    }\n\n    /// Map the physical range using the requested page size.\n    /// This aligns on page size boundaries, and rounds the requested range so\n    /// that both the alignment requirements are met and the requested range are\n    /// covered.\n    /// TODO Assuming some of these requests are dynamic, but should not fail,\n    /// we should fall back to the smaller page sizes if the requested size fails.\n    pub fn map_phys_range(\n        &mut self,\n        alloc_page: fn() -> Result<PhysAddr, PageAllocError>,\n        debug_name: &str,\n        range: &PhysRange,\n        va_mapping: VaMapping,\n        entry: Entry,\n        page_size: PageSize,\n        pgtype: RootPageTableType,\n    ) -> Result<VirtRange, PageTableError> {\n        if !range.start().is_multiple_of(page_size.size() as u64)\n            || !range.end().is_multiple_of(page_size.size() as u64)\n        {\n            println!(\n                \"error:vm:map_phys_range:range not on page boundary. debug_name:{debug_name} range:{range} page_size:{page_size:?}\",\n            );\n            return Err(PageTableError::PhysRangeIsNotOnPageBoundary);\n        }\n\n        let root_page_table = root_page_table(pgtype);\n\n        let mut startva = None;\n        let mut endva = 0;\n        let mut currva = 0;\n        for pa in range.step_by_rounded(page_size.size()) {\n            if startva.is_none() {\n                currva = va_mapping.map(pa);\n                startva = Some(currva);\n            } else {\n                currva += page_size.size();\n            }\n            endva = currva + page_size.size();\n            self.map_to(\n                alloc_page,\n                entry.with_phys_addr(pa),\n                currva,\n                page_size,\n                root_page_table,\n                pgtype,\n            )?;\n        }\n        startva.map(|startva| VirtRange(startva..endva)).ok_or(PageTableError::PhysRangeIsZero)\n    }\n}\n\n// TODO this needs to be a real virtual address allocator...\nstatic next_free_device_page_va: AtomicUsize = AtomicUsize::new(KZERO + 0x100000000000);\npub fn next_free_device_page4k() -> VaMapping {\n    next_free_device_page_va\n        .fetch_update(Ordering::Relaxed, Ordering::Relaxed, |current| {\n            Some(current + PageSize::Page4K.size())\n        })\n        .map(VaMapping::Addr)\n        .expect(\"next_free_device_page4k: unable to return new va\")\n}\n\n/// Return the root user or kernel level page table\npub fn root_page_table(pgtype: RootPageTableType) -> &'static mut RootPageTable {\n    let page_table_pa = match pgtype {\n        RootPageTableType::User => ttbr0_el1(),\n        RootPageTableType::Kernel => ttbr1_el1(),\n    };\n    unsafe { &mut *physaddr_as_ptr_mut_offset_from_kzero::<RootPageTable>(page_table_pa) }\n}\n\npub unsafe fn init_kernel_page_tables(dt: &DeviceTree, dtb_physrange: PhysRange) {\n    // We use recursive page tables, but we have to be careful in the init call,\n    // since the kpage_table is not currently pointed to by ttbr1_el1.  Any\n    // recursive addressing of (511, 511, 511, 511) always points to the\n    // physical address of the root page table, which isn't what we want here\n    // because kpage_table hasn't been switched to yet.\n    unsafe { init_empty_root_page_table(kernel_pagetable()) };\n\n    // We only use the first memory range for now.\n    // TODO Handle multiple memory ranges\n    let available_mem = dt\n        .find_device_type(\"memory\")\n        .flat_map(|memory| dt.property_translated_reg_iter(memory).flat_map(|r| r.regblock()))\n        .map(|memory| PhysRange::from(&memory))\n        .next()\n        .expect(\"No memory range found in device tree\");\n    println!(\"Physical Memory:\");\n    println!(\"  {}\", &available_mem);\n\n    // TODO leave the first page unmapped to catch null pointer dereferences in unsafe code\n    let custom_map = {\n        // The DTB range might not end on a page boundary, so round up.\n        let dtb_page_size = PageSize::Page4K;\n        let dtb_physrange = dtb_physrange.round(dtb_page_size.size());\n\n        let text_physrange = boottext_range().add(&text_range());\n        let ro_data_physrange = rodata_range();\n        let data_physrange = data_range().add(&bss_range());\n\n        let mut map = [\n            (\"DTB\", dtb_physrange, Entry::ro_kernel_data(), dtb_page_size),\n            (\"Kernel Text\", text_physrange, Entry::ro_kernel_text(), PageSize::Page2M),\n            (\"Kernel RO Data\", ro_data_physrange, Entry::ro_kernel_data(), PageSize::Page2M),\n            (\"Kernel Data\", data_physrange, Entry::rw_kernel_data(), PageSize::Page2M),\n        ];\n        map.sort_by_key(|a| a.1.start());\n        map\n    };\n\n    println!(\"Memory map ranges:\");\n    for (name, range, flags, page_size) in custom_map.iter() {\n        let mapped_virtrange = kernel_pagetable()\n            .map_phys_range(\n                pagealloc::allocate_physpage,\n                name,\n                range,\n                VaMapping::Offset(KZERO),\n                *flags,\n                *page_size,\n                RootPageTableType::Kernel,\n            )\n            .expect(\"error:init:mapping failed\");\n\n        println!(\"  {:16}{} to {}\", name, range, mapped_virtrange);\n    }\n    println!(\"Memory map details:\");\n    for (name, _, flags, page_size) in custom_map.iter() {\n        println!(\"  {:16}flags: {:?} page_size: {:?}\", name, flags, page_size);\n    }\n\n    if let Err(err) = pagealloc::free_unused_ranges(&available_mem, custom_map.map(|m| m.1).iter())\n    {\n        panic!(\"error:Couldn't mark unused pages as free: err: {:?}\", err);\n    }\n}\n\npub unsafe fn init_user_page_tables() {\n    unsafe { init_empty_root_page_table(user_pagetable()) };\n}\n\n/// Given an empty, statically allocated page table.  We need to write a\n/// recursive entry in the last entry.  To do this, we need to know the physical\n/// address, but all we have is the virtual address\nunsafe fn init_empty_root_page_table(root_page_table: &mut RootPageTable) {\n    unsafe {\n        let entry = Entry::rw_kernel_data()\n            .with_phys_addr(from_ptr_to_physaddr_offset_from_kzero(root_page_table))\n            .with_page_or_table(true);\n        write_volatile(&mut root_page_table.entries[511], entry);\n    }\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum RootPageTableType {\n    User,\n    Kernel,\n}\n\n/// Return the root user-level page table physical address\nfn ttbr0_el1() -> PhysAddr {\n    #[cfg(not(test))]\n    {\n        let mut addr: u64;\n        unsafe {\n            core::arch::asm!(\"mrs {value}, ttbr0_el1\", value = out(reg) addr);\n        }\n        PhysAddr::new(addr)\n    }\n    #[cfg(test)]\n    PhysAddr::new(0)\n}\n\n/// Return the root kernel page table physical address\nfn ttbr1_el1() -> PhysAddr {\n    #[cfg(not(test))]\n    {\n        let mut addr: u64;\n        unsafe {\n            core::arch::asm!(\"mrs {value}, ttbr1_el1\", value = out(reg) addr);\n        }\n        PhysAddr::new(addr)\n    }\n    #[cfg(test)]\n    PhysAddr::new(0)\n}\n\n// TODO this should just call invalidate_all_tlb_entries afterwards?\n#[allow(unused_variables)]\npub unsafe fn switch(page_table: &RootPageTable, pgtype: RootPageTableType) {\n    #[cfg(not(test))]\n    unsafe {\n        let pt_phys = from_ptr_to_physaddr_offset_from_kzero(page_table).addr();\n        // https://forum.osdev.org/viewtopic.php?t=36412&p=303237\n        match pgtype {\n            RootPageTableType::User => {\n                core::arch::asm!(\n                    \"msr ttbr0_el1, {pt_phys}\",\n                    \"tlbi vmalle1is\", // invalidate all TLB entries\n                    \"dsb ish\",      // ensure write has completed\n                    \"isb\",          // synchronize context and ensure that no instructions\n                                    // are fetched using the old translation\n                    pt_phys = in(reg) pt_phys);\n            }\n            RootPageTableType::Kernel => {\n                core::arch::asm!(\n                    \"msr ttbr1_el1, {pt_phys}\",\n                    \"tlbi vmalle1is\", // invalidate all TLB entries\n                    \"dsb ish\",      // ensure write has completed\n                    \"isb\",          // synchronize context and ensure that no instructions\n                                    // are fetched using the old translation\n                    pt_phys = in(reg) pt_phys);\n            }\n        }\n    }\n}\n\n#[allow(unused_variables)]\npub unsafe fn invalidate_all_tlb_entries() {\n    #[cfg(not(test))]\n    unsafe {\n        // https://forum.osdev.org/viewtopic.php?t=36412&p=303237\n        core::arch::asm!(\n            \"tlbi vmalle1is\", // invalidate all TLB entries\n            \"dsb ish\",        // ensure write has completed\n            \"isb\"             // synchronize context and ensure that no instructions\n                              // are fetched using the old translation\n        );\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::vmdebug::va_indices;\n\n    use super::*;\n\n    #[test]\n    fn can_break_down_va() {\n        assert_eq!(va_indices(0xffff8000049fd000), (256, 0, 36, 509));\n    }\n\n    #[test]\n    fn test_to_use_for_debugging_vaddrs() {\n        // assert_eq!(va_indices(0xffffffffffe00000), (256, 0, 36, 509));\n        // assert_eq!(va_indices(0xfffffffffff00000), (256, 0, 36, 509));\n        // assert_eq!(va_indices(0xffffffffe0000000), (256, 0, 36, 509));\n        // assert_eq!(va_indices(0x1000), (0, 0, 0, 1));\n    }\n\n    #[test]\n    fn test_recursive_table_addr() {\n        assert_eq!(va_indices(0xffff800008000000), (256, 0, 64, 0));\n        assert_eq!(\n            va_indices(recursive_table_addr(\n                RootPageTableType::Kernel,\n                0xffff800008000000,\n                Level::Level0\n            )),\n            (511, 511, 511, 511)\n        );\n        assert_eq!(\n            va_indices(recursive_table_addr(\n                RootPageTableType::Kernel,\n                0xffff800008000000,\n                Level::Level1\n            )),\n            (511, 511, 511, 256)\n        );\n        assert_eq!(\n            va_indices(recursive_table_addr(\n                RootPageTableType::Kernel,\n                0xffff800008000000,\n                Level::Level2\n            )),\n            (511, 511, 256, 0)\n        );\n        assert_eq!(\n            va_indices(recursive_table_addr(\n                RootPageTableType::Kernel,\n                0xffff800008000000,\n                Level::Level3\n            )),\n            (511, 256, 0, 64)\n        );\n        assert_eq!(\n            va_indices(recursive_table_addr(\n                RootPageTableType::Kernel,\n                0xffff800008000000,\n                Level::Level3\n            )),\n            (511, 256, 0, 64)\n        );\n    }\n}\n", "source": "R9/aarch64/src/vm.rs", "file_type": "rc"}
{"text": "use core::fmt;\n\nuse crate::registers::EsrEl1;\nuse port::println;\n\n#[cfg(not(test))]\ncore::arch::global_asm!(include_str!(\"trap.S\"));\n\npub fn init() {\n    #[cfg(not(test))]\n    unsafe {\n        // Set up a vector table for any exception that is taken to EL1, then enable IRQ\n        core::arch::asm!(\n            \"adr {tmp}, exception_vectors\",\n            \"msr vbar_el1, {tmp}\",\n            \"msr DAIFClr, #2\",\n            tmp = out(reg) _,\n        );\n    }\n}\n\n/// Register frame at time interrupt was taken\n#[repr(C, align(16))]\npub struct TrapFrame {\n    x0: u64,\n    x1: u64,\n    x2: u64,\n    x3: u64,\n    x4: u64,\n    x5: u64,\n    x6: u64,\n    x7: u64,\n    x8: u64,\n    x9: u64,\n    x10: u64,\n    x11: u64,\n    x12: u64,\n    x13: u64,\n    x14: u64,\n    x15: u64,\n    x16: u64,\n    x17: u64,\n    x18: u64,\n    x19: u64,\n    x20: u64,\n    x21: u64,\n    x22: u64,\n    x23: u64,\n    x24: u64,\n    x25: u64,\n    x26: u64,\n    x27: u64,\n    x28: u64,\n    frame_pointer: u64, // x29\n    link_register: u64, // x30\n    esr_el1: EsrEl1,\n    elr_el1: u64,\n    far_el1: u64,\n    interrupt_type: u64,\n}\n\nimpl fmt::Debug for TrapFrame {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_struct(\"TrapFrame\")\n            .field(\"x0\", &format_args!(\"{:#018x}\", self.x0))\n            .field(\"x1\", &format_args!(\"{:#018x}\", self.x1))\n            .field(\"x2\", &format_args!(\"{:#018x}\", self.x2))\n            .field(\"x3\", &format_args!(\"{:#018x}\", self.x3))\n            .field(\"x4\", &format_args!(\"{:#018x}\", self.x4))\n            .field(\"x5\", &format_args!(\"{:#018x}\", self.x5))\n            .field(\"x6\", &format_args!(\"{:#018x}\", self.x6))\n            .field(\"x7\", &format_args!(\"{:#018x}\", self.x7))\n            .field(\"x8\", &format_args!(\"{:#018x}\", self.x8))\n            .field(\"x9\", &format_args!(\"{:#018x}\", self.x9))\n            .field(\"x10\", &format_args!(\"{:#018x}\", self.x10))\n            .field(\"x11\", &format_args!(\"{:#018x}\", self.x11))\n            .field(\"x12\", &format_args!(\"{:#018x}\", self.x12))\n            .field(\"x13\", &format_args!(\"{:#018x}\", self.x13))\n            .field(\"x14\", &format_args!(\"{:#018x}\", self.x14))\n            .field(\"x15\", &format_args!(\"{:#018x}\", self.x15))\n            .field(\"x16\", &format_args!(\"{:#018x}\", self.x16))\n            .field(\"x17\", &format_args!(\"{:#018x}\", self.x17))\n            .field(\"x18\", &format_args!(\"{:#018x}\", self.x18))\n            .field(\"x19\", &format_args!(\"{:#018x}\", self.x19))\n            .field(\"x20\", &format_args!(\"{:#018x}\", self.x20))\n            .field(\"x21\", &format_args!(\"{:#018x}\", self.x21))\n            .field(\"x22\", &format_args!(\"{:#018x}\", self.x22))\n            .field(\"x23\", &format_args!(\"{:#018x}\", self.x23))\n            .field(\"x24\", &format_args!(\"{:#018x}\", self.x24))\n            .field(\"x25\", &format_args!(\"{:#018x}\", self.x25))\n            .field(\"x26\", &format_args!(\"{:#018x}\", self.x26))\n            .field(\"x27\", &format_args!(\"{:#018x}\", self.x27))\n            .field(\"x28\", &format_args!(\"{:#018x}\", self.x28))\n            .field(\"x29 (frame_pointer)\", &format_args!(\"{:#018x}\", self.frame_pointer))\n            .field(\"x30 (link_register)\", &format_args!(\"{:#018x}\", self.link_register))\n            .field(\"esr_el1\", &format_args!(\"{:#?}\", self.esr_el1))\n            .field(\"elr_el1\", &format_args!(\"{:#018?}\", self.elr_el1))\n            .field(\"far_el1\", &format_args!(\"{:#018?}\", self.far_el1))\n            .field(\"interrupt_type\", &format_args!(\"{}\", self.interrupt_type))\n            .finish()\n    }\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn trap_unsafe(frame: *mut TrapFrame) {\n    unsafe { trap(frame.as_mut().unwrap()) }\n}\n\nfn trap(frame: &mut TrapFrame) {\n    if frame.esr_el1.ec() == 0x15 {\n        // Syscall\n        let syscallid = frame.esr_el1.iss();\n        println!(\"Syscall {syscallid}\");\n    } else {\n        println!(\"{:#?}\", frame);\n        println!(\"Unhandled interrupt\");\n    }\n\n    loop {\n        core::hint::spin_loop();\n    }\n}\n", "source": "R9/aarch64/src/trap.rs", "file_type": "rc"}
{"text": "use crate::param::KZERO;\nuse port::mem::{PhysAddr, PhysRange};\n\n// These map to definitions in kernel.ld\nunsafe extern \"C\" {\n    static eboottext: [u64; 0];\n    static text: [u64; 0];\n    static etext: [u64; 0];\n    static rodata: [u64; 0];\n    static erodata: [u64; 0];\n    static data: [u64; 0];\n    static edata: [u64; 0];\n    static bss: [u64; 0];\n    static ebss: [u64; 0];\n    static end: [u64; 0];\n    static early_pagetables: [u64; 0];\n    static eearly_pagetables: [u64; 0];\n}\n\nfn base_addr() -> usize {\n    KZERO\n}\n\nfn eboottext_addr() -> usize {\n    unsafe { eboottext.as_ptr().addr() }\n}\n\nfn text_addr() -> usize {\n    unsafe { text.as_ptr().addr() }\n}\n\nfn etext_addr() -> usize {\n    unsafe { etext.as_ptr().addr() }\n}\n\nfn rodata_addr() -> usize {\n    unsafe { rodata.as_ptr().addr() }\n}\n\nfn erodata_addr() -> usize {\n    unsafe { erodata.as_ptr().addr() }\n}\n\nfn data_addr() -> usize {\n    unsafe { data.as_ptr().addr() }\n}\n\nfn edata_addr() -> usize {\n    unsafe { edata.as_ptr().addr() }\n}\n\nfn bss_addr() -> usize {\n    unsafe { bss.as_ptr().addr() }\n}\n\nfn ebss_addr() -> usize {\n    unsafe { ebss.as_ptr().addr() }\n}\n\nfn end_addr() -> usize {\n    unsafe { end.as_ptr().addr() }\n}\n\nfn early_pagetables_addr() -> usize {\n    unsafe { early_pagetables.as_ptr().addr() }\n}\n\nfn eearly_pagetables_addr() -> usize {\n    unsafe { eearly_pagetables.as_ptr().addr() }\n}\n\npub fn boottext_range() -> PhysRange {\n    PhysRange(from_virt_to_physaddr(base_addr())..from_virt_to_physaddr(eboottext_addr()))\n}\n\npub fn text_range() -> PhysRange {\n    PhysRange(from_virt_to_physaddr(text_addr())..from_virt_to_physaddr(etext_addr()))\n}\n\npub fn rodata_range() -> PhysRange {\n    PhysRange(from_virt_to_physaddr(rodata_addr())..from_virt_to_physaddr(erodata_addr()))\n}\n\npub fn data_range() -> PhysRange {\n    PhysRange(from_virt_to_physaddr(data_addr())..from_virt_to_physaddr(edata_addr()))\n}\n\npub fn bss_range() -> PhysRange {\n    PhysRange(from_virt_to_physaddr(bss_addr())..from_virt_to_physaddr(ebss_addr()))\n}\n\npub fn total_kernel_range() -> PhysRange {\n    PhysRange(from_virt_to_physaddr(base_addr())..from_virt_to_physaddr(end_addr()))\n}\n\n/// Transform the physical address to a virtual address, under the assumption that\n/// the virtual address is the physical address offset from KZERO.\npub const fn physaddr_as_ptr_mut_offset_from_kzero<T>(pa: PhysAddr) -> *mut T {\n    (pa.addr() as usize).wrapping_add(KZERO) as *mut T\n}\n\n/// Given a virtual address, return the physical address.  Makes a massive assumption\n/// that the code is mapped offset to KZERO, so should be used with extreme care.\n/// TODO: Remove this altogether, otherwise it'll get used when it shouldn't.\nfn from_virt_to_physaddr(va: usize) -> PhysAddr {\n    debug_assert!(va >= KZERO, \"from_virt_to_physaddr: va {va} must be >= KZERO ({KZERO})\");\n    PhysAddr::new((va - KZERO) as u64)\n}\n\n/// Given an address, return the physical address.  Makes a massive assumption\n/// that the code is mapped offset to KZERO, so should be used with extreme care.\npub fn from_ptr_to_physaddr_offset_from_kzero<T>(a: *const T) -> PhysAddr {\n    from_virt_to_physaddr(a.addr())\n}\n\npub fn early_pages_range() -> PhysRange {\n    PhysRange::new(\n        from_virt_to_physaddr(early_pagetables_addr()),\n        from_virt_to_physaddr(eearly_pagetables_addr()),\n    )\n}\n", "source": "R9/aarch64/src/kmem.rs", "file_type": "rc"}
{"text": "//!! Debug tools for VM code\n\n#[cfg(not(test))]\nuse port::println;\n\nuse crate::vm::{Entry, Level, RootPageTable, RootPageTableType, Table};\n\n#[derive(Clone, Copy, Debug, PartialEq)]\nstruct PteIndices {\n    pgtype: RootPageTableType,\n    l0: Option<usize>,\n    l1: Option<usize>,\n    l2: Option<usize>,\n    l3: Option<usize>,\n}\n\nimpl PteIndices {\n    #[cfg(test)]\n    fn new(\n        pgtype: RootPageTableType,\n        l0: Option<usize>,\n        l1: Option<usize>,\n        l2: Option<usize>,\n        l3: Option<usize>,\n    ) -> Self {\n        Self { pgtype, l0, l1, l2, l3 }\n    }\n\n    fn none(pgtype: RootPageTableType) -> Self {\n        Self { pgtype, l0: None, l1: None, l2: None, l3: None }\n    }\n\n    fn with_next_index(&self, i: usize) -> Option<Self> {\n        if self.l0.is_none() {\n            Some(Self { pgtype: self.pgtype, l0: Some(i), l1: None, l2: None, l3: None })\n        } else if self.l1.is_none() {\n            Some(Self { pgtype: self.pgtype, l0: self.l0, l1: Some(i), l2: None, l3: None })\n        } else if self.l2.is_none() {\n            Some(Self { pgtype: self.pgtype, l0: self.l0, l1: self.l1, l2: Some(i), l3: None })\n        } else if self.l3.is_none() {\n            Some(Self { pgtype: self.pgtype, l0: self.l0, l1: self.l1, l2: self.l2, l3: Some(i) })\n        } else {\n            None\n        }\n    }\n\n    fn last_index(&self) -> Option<usize> {\n        if self.l3.is_some() {\n            self.l3\n        } else if self.l2.is_some() {\n            self.l2\n        } else if self.l1.is_some() {\n            self.l1\n        } else {\n            self.l0\n        }\n    }\n\n    fn as_va(&self) -> usize {\n        let mut va = match self.pgtype {\n            RootPageTableType::Kernel => 0xffff_0000_0000_0000,\n            RootPageTableType::User => 0x0000_0000_0000_0000,\n        };\n\n        va |= if let Some(i) = self.l0 { i << 39 } else { 0 };\n        va |= if let Some(i) = self.l1 { i << 30 } else { 0 };\n        va |= if let Some(i) = self.l2 { i << 21 } else { 0 };\n        va |= if let Some(i) = self.l3 { i << 12 } else { 0 };\n\n        va\n    }\n}\n\n/// Return recursive virtual addresses for the current kernel or user page tables.\n/// This depends on the recursive entry of root page tables to have been set up correctly.\nfn recursive_root_page_table_va(pgtype: RootPageTableType) -> usize {\n    match pgtype {\n        RootPageTableType::User => 0x0000_ffff_ffff_f000,\n        RootPageTableType::Kernel => 0xffff_ffff_ffff_f000,\n    }\n}\n\n/// Return the current kernel or user page table.\n/// This depends on the recursive entry of root page tables to have been set up correctly.\nfn recursive_root_page_table(pgtype: RootPageTableType) -> &'static mut RootPageTable {\n    let ptr = recursive_root_page_table_va(pgtype) as *mut RootPageTable;\n    unsafe { &mut *ptr }\n}\n\n/// Recursively write out all the tables and all its children\npub fn print_recursive_tables(pgtype: RootPageTableType) {\n    let root_page_table = recursive_root_page_table(pgtype);\n    println!(\"Root va:{:018p}\", root_page_table);\n    print_table_at_level(\n        root_page_table,\n        Level::Level0,\n        recursive_root_page_table_va(pgtype),\n        pgtype,\n        PteIndices::none(pgtype),\n    );\n}\n\n/// Recursively write out the table and all its children\nfn print_table_at_level(\n    page_table: &Table,\n    level: Level,\n    table_va: usize,\n    pgtype: RootPageTableType,\n    pte_indices: PteIndices,\n) {\n    let indent = 2 + level.depth() * 2;\n    for i in 0..512 {\n        let pte = page_table.entries[i];\n        if !pte.valid() {\n            continue;\n        }\n\n        if !pte.is_table(level) {\n            if let Some(pte_indices) = pte_indices.with_next_index(i) {\n                print_pte_page(indent, pte_indices, pte);\n            }\n        } else if i != 511 {\n            // Recurse into child table (unless it's the recursive index)\n            let child_table_va = match pgtype {\n                RootPageTableType::User => ((table_va << 9) | (i << 12)) & 0x0000_ffff_ffff_ffff,\n                RootPageTableType::Kernel => (table_va << 9) | (i << 12),\n            };\n            print_pte_table(indent, i, pte, child_table_va);\n\n            if let Some(next_level_pte_indices) = pte_indices.with_next_index(i) {\n                let next_nevel = level.next().unwrap();\n                let child_table = unsafe { &*(child_table_va as *const RootPageTable) };\n                print_table_at_level(\n                    child_table,\n                    next_nevel,\n                    child_table_va,\n                    pgtype,\n                    next_level_pte_indices,\n                );\n            }\n        }\n    }\n}\n\n/// Helper to print out page PTE\nfn print_pte_page(indent: usize, pte_indices: PteIndices, pte: Entry) {\n    println!(\n        \"{:indent$}[{:03}] Entry va:{:#018x} -> {:?} (pte:{:#016x})\",\n        \"\",\n        pte_indices.last_index().unwrap_or(0),\n        pte_indices.as_va(),\n        pte,\n        pte.0,\n    );\n}\n\n/// Helper to print out table PTE\nfn print_pte_table(indent: usize, i: usize, pte: Entry, table_va: usize) {\n    println!(\n        \"{:indent$}[{:03}] Table va:{:#018x} {:?} (pte:{:#016x})\",\n        \"\", i, table_va, pte, pte.0,\n    );\n}\n\n/// Returns a tuple of page table indices for the given virtual address\n#[cfg(test)]\npub fn va_indices(va: usize) -> (usize, usize, usize, usize) {\n    use crate::vm::va_index;\n\n    (\n        va_index(va, Level::Level0),\n        va_index(va, Level::Level1),\n        va_index(va, Level::Level2),\n        va_index(va, Level::Level3),\n    )\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_pte_indices() {\n        let p = PteIndices::none(RootPageTableType::User);\n        assert_eq!(p, PteIndices::none(RootPageTableType::User));\n\n        let p = p.with_next_index(1).unwrap();\n        assert_eq!(p, PteIndices::new(RootPageTableType::User, Some(1), None, None, None));\n\n        let p = p.with_next_index(2).unwrap();\n        assert_eq!(p, PteIndices::new(RootPageTableType::User, Some(1), Some(2), None, None));\n\n        let p = p.with_next_index(3).unwrap();\n        assert_eq!(p, PteIndices::new(RootPageTableType::User, Some(1), Some(2), Some(3), None));\n\n        let p = p.with_next_index(4).unwrap();\n        assert_eq!(p, PteIndices::new(RootPageTableType::User, Some(1), Some(2), Some(3), Some(4)));\n\n        let p = PteIndices::new(RootPageTableType::Kernel, Some(15), Some(0), Some(400), Some(4));\n        assert_eq!(va_indices(p.as_va()), (15, 0, 400, 4));\n\n        let p = PteIndices::new(RootPageTableType::User, Some(0), Some(10), Some(40), Some(23));\n        assert_eq!(va_indices(p.as_va()), (0, 10, 40, 23));\n\n        let va = 0x0000000000001000;\n        assert_eq!(va_indices(va), (0, 0, 0, 1));\n    }\n}\n", "source": "R9/aarch64/src/vmdebug.rs", "file_type": "rc"}
{"text": "#![feature(alloc_error_handler)]\n#![feature(fn_align)]\n#![feature(sync_unsafe_cell)]\n#![cfg_attr(not(any(test)), no_std)]\n#![cfg_attr(not(test), no_main)]\n#![allow(clippy::upper_case_acronyms)]\n#![forbid(unsafe_op_in_unsafe_fn)]\n\nmod allocator;\nmod cpu;\nmod dat;\nmod devcons;\nmod node0;\nmod pio;\nmod proc;\nmod syscall;\nmod trap;\nmod uart16550;\nmod vsvm;\n\nuse proc::{Label, swtch};\n\n#[cfg(not(test))]\ncore::arch::global_asm!(include_str!(\"l.S\"), options(att_syntax));\n\nuse port::println;\n\nstatic mut THRSTACK: [u64; 1024] = [0; 1024];\nstatic mut CTX: u64 = 0;\nstatic mut THR: u64 = 0;\n\nfn jumpback() {\n    println!(\"in a thread\");\n    unsafe {\n        let thr = &mut *(THR as *mut Label);\n        let ctx = &mut *(CTX as *mut Label);\n        swtch(thr, ctx);\n    }\n}\n\n#[cfg_attr(not(test), unsafe(no_mangle))]\npub extern \"C\" fn main(mach: &mut dat::Mach, _mbdata: u64) {\n    unsafe {\n        vsvm::init(mach);\n    }\n    syscall::init();\n    let x = trap::splhi();\n    devcons::init();\n    println!();\n    println!(\"r9 from the Internet\");\n    println!(\"looping now\");\n    let mut ctx = Label::new();\n    let mut thr = Label::new();\n    thr.pc = jumpback as usize as u64;\n    unsafe {\n        thr.sp = &mut THRSTACK[1023] as *mut _ as u64;\n        CTX = &mut ctx as *mut _ as u64;\n        THR = &mut thr as *mut _ as u64;\n        swtch(&mut ctx, &mut thr);\n    }\n    println!(\"came out the other side of a context switch\");\n    trap::splx(x);\n    loop {\n        trap::spllo();\n    }\n}\n\nmod runtime;\n", "source": "R9/x86_64/src/main.rs", "file_type": "rc"}
{"text": "#![cfg(not(test))]\n\nextern crate alloc;\n\nuse alloc::alloc::Layout;\nuse core::panic::PanicInfo;\n\n#[panic_handler]\npub fn panic(_info: &PanicInfo) -> ! {\n    #[allow(clippy::empty_loop)]\n    loop {}\n}\n\n#[alloc_error_handler]\nfn oom(_layout: Layout) -> ! {\n    panic!(\"oom\");\n}\n", "source": "R9/x86_64/src/runtime.rs", "file_type": "rc"}
{"text": "use crate::cpu;\nuse crate::dat::Ureg;\nuse crate::dat::{UREG_CS_OFFSET, UREG_TRAPNO_OFFSET};\n\nuse core::arch::naked_asm;\n\npub const DEBUG_TRAPNO: u8 = 1;\npub const NMI_TRAPNO: u8 = 2;\npub const BREAKPOINT_TRAPNO: u8 = 3;\npub const DOUBLE_FAULT_TRAPNO: u8 = 8;\n\ntype Thunk = unsafe extern \"C\" fn();\n\n#[repr(transparent)]\npub struct Stub(usize);\n\nimpl Stub {\n    /// Returns a function pointer that represents a stub.\n    pub unsafe fn as_thunk(&self) -> Thunk {\n        unsafe { core::mem::transmute::<usize, Thunk>(self.0) }\n    }\n}\n\nmacro_rules! gen_stub {\n    () => {\n        r#\".balign 8; pushq $0; callq {intrcommon};\"#\n    };\n    (err) => {\n        r#\".balign 8; callq {intrcommon};\"#\n    };\n}\n\nmacro_rules! gen_trap_stub {\n    // These cases include hardware-generated error words\n    // on the trap frame\n    (8) => {\n        gen_stub!(err)\n    };\n    (10) => {\n        gen_stub!(err)\n    };\n    (11) => {\n        gen_stub!(err)\n    };\n    (12) => {\n        gen_stub!(err)\n    };\n    (13) => {\n        gen_stub!(err)\n    };\n    (14) => {\n        gen_stub!(err)\n    };\n    (17) => {\n        gen_stub!(err)\n    };\n    // No hardware error\n    ($num:literal) => {\n        gen_stub!()\n    };\n}\n\npub fn stubs() -> &'static [Stub; 256] {\n    unsafe { &*(intr_stubs as usize as *const [Stub; 256]) }\n}\n\n/// intr_stubs is just a container for interrupt stubs.  It is\n/// a naked function for convenience.\n///\n/// # Safety\n///\n/// Container for thunks.\n#[unsafe(link_section = \".trap\")]\n#[unsafe(naked)]\n#[rustc_align(4096)]\npub unsafe extern \"C\" fn intr_stubs() -> ! {\n    use seq_macro::seq;\n    naked_asm!(\n        seq!(N in 0..=255 {\n            concat!( #( gen_trap_stub!(N), )* )\n        }),\n        intrcommon = sym intrcommon, options(att_syntax))\n}\n\n/// intrcommon builds up a Ureg structure at the top of the\n/// current proc's kernel stack.\n///\n/// # Safety\n///\n/// Common trap handler.  Called from interrupt/exception stub.\n#[unsafe(link_section = \".trap\")]\n#[unsafe(naked)]\npub unsafe extern \"C\" fn intrcommon() -> ! {\n    naked_asm!(r#\"\n        // Allocate space to save registers.\n        subq $((4 + 15) * 8), %rsp\n        // Save the general purpose registers.\n        movq %r15, 14*8(%rsp);\n        movq %r14, 13*8(%rsp);\n        movq %r13, 12*8(%rsp);\n        movq %r12, 11*8(%rsp);\n        movq %r11, 10*8(%rsp);\n        movq %r10, 9*8(%rsp);\n        movq %r9, 8*8(%rsp);\n        movq %r8, 7*8(%rsp);\n        movq %rbp, 6*8(%rsp);\n        movq %rdi, 5*8(%rsp);\n        movq %rsi, 4*8(%rsp);\n        movq %rdx, 3*8(%rsp);\n        movq %rcx, 2*8(%rsp);\n        movq %rbx, 1*8(%rsp);\n        movq %rax, 0*8(%rsp);\n        // Save the x86 segmentation registers.  Uses %rdi\n        // as a scratch register, so we do this after we've\n        // saved the GP registers..  Note that the 32-bit\n        // `movl` zero-extends the segmentation register and\n        // clears the upper bits of %rdi.  We use this\n        // because the result has a denser encoding than\n        // other instruction sequences.\n        movl %gs, %edi;\n        movq %rdi, 18*8(%rsp);\n        movl %fs, %edi;\n        movq %rdi, 17*8(%rsp);\n        movl %es, %edi;\n        movq %rdi, 16*8(%rsp);\n        movl %ds, %edi;\n        movq %rdi, 15*8(%rsp);\n        // Fix up the trap number.  We got here via a CALL,\n        // so hardware pushed the address after the CALLQ\n        // instruction onto the stack.  But we know that\n        // each stub is aligned to an 8-byte boundary, at\n        // some offset based on the vector number relative\n        // to the 4096-byte aligned start of the trap stub\n        // array.  Further, each stub is shorter than 8\n        // bytes in length.  Thus, we can compute the\n        // vector number by dividing the return address by\n        // 8, masking off the high bits, and storing it back\n        // into the save area.\n        //\n        // The vector number is an argument to the trap\n        // function, along with the address of the Ureg\n        // we have built at the top of the stack.\n        shrw $3, {trapno_offset}(%rsp);\n        movzbl {trapno_offset}(%rsp), %edi;\n        movq %rdi, {trapno_offset}(%rsp);\n        movq %rsp, %rsi;\n        // If we're already in kernel mode, don't swap %gs.\n        cmpq ${ktext_sel}, {cs_offset}(%rsp);\n        je 1f;\n        swapgs;\n        1:\n        callq {trap};\n        // If we're returning to kernel mode, don't swap %gs.\n        cmpq ${ktext_sel}, {cs_offset}(%rsp);\n        je 1f;\n        swapgs;\n        1:\n        // Restore the general purpose registers.\n        movq 0*8(%rsp), %rax;\n        movq 1*8(%rsp), %rbx;\n        movq 2*8(%rsp), %rcx;\n        movq 3*8(%rsp), %rdx;\n        movq 4*8(%rsp), %rsi;\n        movq 5*8(%rsp), %rdi;\n        movq 6*8(%rsp), %rbp;\n        movq 7*8(%rsp), %r8;\n        movq 8*8(%rsp), %r9;\n        movq 9*8(%rsp), %r10;\n        movq 10*8(%rsp), %r11;\n        movq 11*8(%rsp), %r12;\n        movq 12*8(%rsp), %r13;\n        movq 13*8(%rsp), %r14;\n        movq 14*8(%rsp), %r15;\n        // Restore the segmentation registers.\n        movw 15*8(%rsp), %ds;\n        movw 16*8(%rsp), %es;\n        // %gs is restored via swapgs above.  The system never changes\n        // it, so we don't bother restoring it here.  %fs is special.\n        // We do save and restore it, for TLS if anyone ever uses green\n        // threads.\n        movw 17*8(%rsp), %fs;\n        // movw 18*8(%rsp), %gs;\n        // Pop registers, alignment word and error.\n        addq $((2 + 4 + 15) * 8), %rsp;\n        // Go back to whence you came.\n        iretq\n        \"#,\n        ktext_sel = const 8,\n        cs_offset = const UREG_CS_OFFSET,\n        trapno_offset = const UREG_TRAPNO_OFFSET,\n        trap = sym trap,\n        options(att_syntax))\n}\n\npub enum IntrStatus {\n    Disabled = 0,\n    Enabled = 1,\n}\n\n#[inline(always)]\nfn intrstatus() -> IntrStatus {\n    let flags = cpu::flags();\n    if flags.intr() { IntrStatus::Enabled } else { IntrStatus::Disabled }\n}\n\npub fn spllo() -> IntrStatus {\n    let prev_level = intrstatus();\n    cpu::sti();\n    prev_level\n}\n\npub fn splhi() -> IntrStatus {\n    let prev_level = intrstatus();\n    cpu::cli();\n    prev_level\n}\n\npub fn splx(x: IntrStatus) -> IntrStatus {\n    match x {\n        IntrStatus::Disabled => splhi(),\n        IntrStatus::Enabled => spllo(),\n    }\n}\n\nextern \"C\" fn trap(vector: u8, trap_frame: &mut Ureg) -> u32 {\n    unsafe { core::arch::asm!(\"cli;hlt;\") };\n    crate::println!(\"trap {vector}\");\n    crate::println!(\"frame: {trap_frame:#x?}\");\n    unsafe { core::arch::asm!(\"cli;hlt;\") };\n    0\n}\n", "source": "R9/x86_64/src/trap.rs", "file_type": "rc"}
{"text": "//! Initialization for ccNUMA node 0 and CPU 0 Mach\n//!\n//! Setup of the initial address space for node 0 and the Mach\n//! for CPU 0 is tedious.  Plan 9 does this in assembly code,\n//! but we prefer to do it in Rust.\n//!\n//! But in order to do it in Rust, we need a virtual address\n//! space to execute from, as this is all 64-bit code that must\n//! execute from long mode.  What to do?  Fortunately, early\n//! boot forces the processor through a mode where we can call\n//! rust code and create that address space.\n//!\n//! The assembly boot strap code needs to have access to an\n//! identity mapping for the initial jump into long mode, and we\n//! hardcode such a mapping covering the low 4GiB of the address\n//! space, along with mapping the kernel image at its linked\n//! addresses.  In this mode, kernel text is mapped at its\n//! expected address range, but memory is still addressible at\n//! physical addresses via the identity mapping, and we can\n//! call this code to construct the address space for node 0 and\n//! Mach 0, and remap the kernel, before we jump into `main`.\n//!\n//! The argument is a raw pointer to an array of \"low memory\"\n//! page frames, which we understand cover the second megabyte\n//! of RAM, and will provide the memory both for our early page\n//! tables as well as the Mach and per-node data for node 0.\n//!\n//! One further complication remains: recall that our stack will\n//! \"live\" in the Mach; where, then, is our stack, while running\n//! this code?  Once fully booted, we will steal the page at\n//! physical address 0x7000 to hold the startup code where any\n//! additional CPUs will begin executing on startup.  Since we\n//! are running well before any of that happens, we pre-use that\n//! page as our initial stack for executing this code.\n//!\n//! The return value is the physical address of the newly\n//! initialized PML4.\n\nuse crate::dat::{Gdt, HPA, Idt, Mach, PTable, Page, Tss};\nuse crate::trap;\n\nconst X: u64 = 0 << 63;\nconst NX: u64 = 1 << 63;\nconst L: u64 = 1 << 7;\nconst RO: u64 = 0 << 1;\nconst RW: u64 = 1 << 1;\nconst P: u64 = 1 << 0;\n\nfn map_mach(pml1: &mut PTable, zp: HPA, idt: HPA, gdt: HPA, phys: [HPA; 29]) {\n    const START: usize = 256;\n    const LEN: usize = 64;\n    let pml1 = &mut pml1.array_mut()[START..START + LEN];\n    // Exception stacks and guard pages.\n    for k in [0, 2, 4, 6].into_iter() {\n        pml1[k] = NX | phys[k / 2].0 | RW | P;\n        pml1[k + 1] = 0;\n    }\n    // Zero page.\n    pml1[8] = NX | zp.0 | RO | P;\n    // Empty space between the zero page and Mach stack\n    for pte in &mut pml1[9..16].iter_mut() {\n        *pte = 0;\n    }\n    // Mach stack\n    for k in 16..32 {\n        pml1[k] = NX | phys[k - 12].0 | RW | P;\n    }\n    // The actual in-use Mach data\n    pml1[32] = NX | phys[20].0 | RW | P;\n\n    // The page tables in the Mac\n    for k in 33..40 {\n        pml1[k] = NX | phys[k - 12].0 | RW | P;\n    }\n    // TSS is on a page by itself.\n    pml1[40] = NX | phys[28].0 | RW | P;\n    // The IDT.\n    pml1[41] = NX | idt.0 | RO | P;\n    // Empty space between the IDT and GDT.\n    for pte in &mut pml1[42..48].iter_mut() {\n        *pte = 0;\n    }\n    // The GDT.\n    pml1[48] = NX | gdt.0 | RW | P;\n    for pte in &mut pml1[49..] {\n        *pte = NX | zp.0 | RO | P;\n    }\n}\n\nfn ptr2hpa<T>(ptr: *const T) -> HPA {\n    HPA(ptr.addr() as u64)\n}\n\n#[unsafe(no_mangle)]\npub unsafe extern \"C\" fn init0(lomem: *mut Page) -> HPA {\n    let debug_stack = ptr2hpa(lomem.wrapping_add(0));\n    let kpml3 = unsafe { &mut *lomem.add(1).cast::<PTable>() };\n    let bp_stack = ptr2hpa(lomem.wrapping_add(2));\n    let kpml2 = unsafe { &mut *lomem.add(3).cast::<PTable>() };\n    let df_stack = ptr2hpa(lomem.wrapping_add(4));\n    let kpml1 = unsafe { &mut *lomem.add(5).cast::<PTable>() };\n    let nmi_stack = ptr2hpa(lomem.wrapping_add(6));\n    let ncpml3 = unsafe { &mut *lomem.add(7).cast::<PTable>() }; // CPU/Node region\n    let zero_page = unsafe { &mut *lomem.add(8).cast::<PTable>() };\n    // Node region\n    let npml2 = unsafe { &mut *lomem.add(9).cast::<PTable>() };\n    let npml1 = unsafe { &mut *lomem.add(10).cast::<PTable>() };\n    // CPU Region\n    let cpml2 = unsafe { &mut *lomem.add(11).cast::<PTable>() };\n    let cpml1 = unsafe { &mut *lomem.add(12).cast::<PTable>() };\n    let arch_page = ptr2hpa(lomem.wrapping_add(13));\n    let idt = unsafe { &mut *lomem.add(14).cast::<Idt>() };\n    let gdt_page = unsafe { &mut *lomem.add(15) };\n    // The kstack occupies lomem pages 16..32.\n    // Following that are the page table structures that we\n    // construct to map the kernel and point to the kernel\n    // page tables in the recursive region.\n    let mach_page = ptr2hpa(lomem.wrapping_add(32));\n    let pml4 = unsafe { &mut *lomem.add(33).cast::<PTable>() };\n    let pml3 = unsafe { &mut *lomem.add(34).cast::<PTable>() };\n    let pml2 = unsafe { &mut *lomem.add(35).cast::<PTable>() };\n    let pml1 = unsafe { &mut *lomem.add(36).cast::<PTable>() };\n    let mpml3 = unsafe { &mut *lomem.add(37).cast::<PTable>() };\n    let mpml2 = unsafe { &mut *lomem.add(38).cast::<PTable>() };\n    let mpml1 = unsafe { &mut *lomem.add(39).cast::<PTable>() };\n\n    const KCPUZERO: usize = 0xffff_ff00_0000_0000;\n    const KMACH: usize = KCPUZERO + 0x0100_0000;\n    const KMACHTSS: usize = KMACH + core::mem::offset_of!(Mach, tss);\n    idt.init(trap::stubs());\n    Gdt::init_in(gdt_page, KMACHTSS as *mut Tss);\n    let mut phys = [HPA::from_phys(0); 29];\n    phys[0] = debug_stack;\n    phys[1] = bp_stack;\n    phys[2] = df_stack;\n    phys[3] = nmi_stack;\n    for k in 16..32 {\n        phys[k - 12] = ptr2hpa(lomem.wrapping_add(k));\n    }\n    phys[20] = mach_page;\n    phys[21] = ptr2hpa(pml4);\n    phys[22] = ptr2hpa(pml3);\n    phys[23] = ptr2hpa(pml2);\n    phys[24] = ptr2hpa(pml1);\n    phys[25] = ptr2hpa(mpml3);\n    phys[26] = ptr2hpa(mpml2);\n    phys[27] = ptr2hpa(mpml1);\n    phys[28] = arch_page;\n    map_mach(cpml1, ptr2hpa(zero_page), ptr2hpa(idt), ptr2hpa(gdt_page), phys);\n\n    // These assignments set up the recursive mapping region so\n    // that the PML4 is itself mapped.\n    pml4.array_mut()[508] = NX | ptr2hpa(pml3).0 | RW | P;\n    pml3.array_mut()[508] = NX | ptr2hpa(pml2).0 | RW | P;\n    pml2.array_mut()[508] = NX | ptr2hpa(pml1).0 | RW | P;\n    pml1.array_mut()[508] = NX | ptr2hpa(pml4).0 | RW | P;\n\n    // Map the kernel.\n    pml4.array_mut()[511] = X | ptr2hpa(kpml3).0 | RW | P;\n    kpml3.array_mut()[510] = X | ptr2hpa(kpml2).0 | RW | P;\n    kpml2.array_mut()[0] = NX | ptr2hpa(kpml1).0 | RW | P;\n    kpml2.array_mut()[1] = X | 0x0020_0000 | L | RO | P;\n    kpml2.array_mut()[2] = NX | 0x0040_0000 | L | RO | P;\n    kpml2.array_mut()[3] = NX | 0x0060_0000 | L | RW | P;\n    kpml1.array_mut()[0] = NX | 0x0000_0000 | RW | P;\n    kpml1.array_mut()[7] = NX | 0x0007_0000 | RW | P;\n    for k in 32..64 {\n        kpml1.array_mut()[k] = NX | (k as u64 * 4096) | RW | P;\n    }\n\n    // Map the CPU/node area\n    pml4.array_mut()[510] = NX | ptr2hpa(ncpml3).0 | RW | P;\n    ncpml3.array_mut()[0] = NX | ptr2hpa(cpml2).0 | RW | P;\n    cpml2.array_mut()[0] = NX | ptr2hpa(cpml1).0 | RW | P;\n    ncpml3.array_mut()[256] = NX | ptr2hpa(npml2).0 | RW | P;\n    npml2.array_mut()[0] = NX | ptr2hpa(npml1).0 | RW | P;\n\n    // These assignments set up the empty page tables that\n    // cover the \"Mapping Region\", which is what Hypatia calls\n    // the \"Linkage Segment\").\n    pml4.array_mut()[509] = NX | ptr2hpa(mpml3).0 | RW | P;\n    mpml3.array_mut()[511] = NX | ptr2hpa(mpml2).0 | RW | P;\n    mpml2.array_mut()[511] = NX | ptr2hpa(mpml1).0 | RW | P;\n\n    // Set up the recursive region.\n    //\n    // Within the recurisve region:\n    //  1. The right-most PML1 maps the PML4 and non-rec PML3s\n    //  2. The right-most PML2 roots rec PML3 and non-rec PML2s\n    //  3. The right-most PML3 roots rec PML2 and non-rec PML1s\n    // At each level, the index for each sub-tree is the PML3\n    // index.  Within those sublevels, indices are for the next\n    // higher actual map address.\n    pml1.array_mut()[511] = NX | ptr2hpa(kpml3).0 | RW | P;\n    pml1.array_mut()[510] = NX | ptr2hpa(ncpml3).0 | RW | P;\n    pml1.array_mut()[509] = NX | ptr2hpa(mpml3).0 | RW | P;\n\n    // Map the mapping region tables into the recursive region.\n    let mpml1_rpml2 = unsafe { &mut *lomem.add(40).cast::<PTable>() };\n    let mpml1_rpml1 = unsafe { &mut *lomem.add(41).cast::<PTable>() };\n    let mpml2_rpml1 = unsafe { &mut *lomem.add(42).cast::<PTable>() };\n\n    pml3.array_mut()[509] = NX | ptr2hpa(mpml1_rpml2).0 | RW | P;\n    mpml1_rpml2.array_mut()[511] = NX | ptr2hpa(mpml1_rpml1).0 | RW | P;\n    mpml1_rpml1.array_mut()[511] = NX | ptr2hpa(mpml1).0 | RW | P;\n    pml2.array_mut()[509] = NX | ptr2hpa(mpml2_rpml1).0 | RW | P;\n    mpml2_rpml1.array_mut()[511] = NX | ptr2hpa(mpml2).0 | RW | P;\n\n    // Map the for CPU/node region tables.\n    let ncpml2_rpml1 = unsafe { &mut *lomem.add(43).cast::<PTable>() };\n    let ncpml1_rpml2 = unsafe { &mut *lomem.add(44).cast::<PTable>() };\n    let cpml1_rpml1 = unsafe { &mut *lomem.add(45).cast::<PTable>() };\n    let npml1_rpml1 = unsafe { &mut *lomem.add(46).cast::<PTable>() };\n\n    pml3.array_mut()[510] = NX | ptr2hpa(ncpml1_rpml2).0 | RW | P;\n    ncpml1_rpml2.array_mut()[0] = NX | ptr2hpa(cpml1_rpml1).0 | RW | P;\n    cpml1_rpml1.array_mut()[0] = NX | ptr2hpa(cpml1).0 | RW | P;\n    ncpml1_rpml2.array_mut()[256] = NX | ptr2hpa(npml1_rpml1).0 | RW | P;\n    npml1_rpml1.array_mut()[0] = NX | ptr2hpa(npml1).0 | RW | P;\n\n    pml2.array_mut()[510] = NX | ptr2hpa(ncpml2_rpml1).0 | RW | P;\n    ncpml2_rpml1.array_mut()[0] = NX | ptr2hpa(cpml2).0 | RW | P;\n    ncpml2_rpml1.array_mut()[256] = NX | ptr2hpa(npml2).0 | RW | P;\n\n    // Map the kernel tables.\n    let kpml2_rpml1 = unsafe { &mut *lomem.add(47).cast::<PTable>() };\n    let kpml1_rpml2 = unsafe { &mut *lomem.add(48).cast::<PTable>() };\n    let kpml1_rpml1 = unsafe { &mut *lomem.add(49).cast::<PTable>() };\n\n    pml3.array_mut()[511] = NX | ptr2hpa(kpml1_rpml2).0 | RW | P;\n    kpml1_rpml2.array_mut()[510] = NX | ptr2hpa(kpml1_rpml1).0 | RW | P;\n    kpml1_rpml1.array_mut()[0] = NX | ptr2hpa(kpml1).0 | RW | P;\n    pml2.array_mut()[511] = NX | ptr2hpa(kpml2_rpml1).0 | RW | P;\n    kpml2_rpml1.array_mut()[0] = NX | ptr2hpa(kpml2).0 | RW | P;\n\n    ptr2hpa(pml4)\n}\n", "source": "R9/x86_64/src/node0.rs", "file_type": "rc"}
{"text": "use port::fdt::{DeviceTree, Range, RangeMapping, RegBlock, TranslatedReg};\n\nstatic TEST1_DTB: &[u8] = include_bytes!(\"../lib/test/fdt/test1.dtb\");\n\n#[test]\nfn find_by_path() {\n    let dt = DeviceTree::new(TEST1_DTB).unwrap();\n\n    // Find the first node.  Next token should not be the same node.\n    let root = dt.find_by_path(\"/\").unwrap();\n    assert_eq!(dt.node_name(&root).unwrap(), \"\");\n\n    // Misc lookups\n    let soc = dt.find_by_path(\"/soc\").unwrap();\n    assert_eq!(dt.node_name(&soc).unwrap(), \"soc\");\n\n    let eth = dt.find_by_path(\"/reserved-memory/linux,cma\").unwrap();\n    assert_eq!(dt.node_name(&eth).unwrap(), \"linux,cma\");\n\n    assert_eq!(dt.find_by_path(\"/bar\"), None);\n    assert_eq!(dt.find_by_path(\"/reserved-memory/foo\"), None);\n}\n\n#[test]\nfn traverse_tree() {\n    let dt = DeviceTree::new(TEST1_DTB).unwrap();\n\n    let root = dt.root().unwrap();\n    assert_eq!(dt.node_name(&root).unwrap(), \"\");\n    assert_eq!(root.depth(), 0);\n\n    let aliases = dt.children(&root).nth(0).unwrap();\n    assert_eq!(dt.node_name(&aliases).unwrap(), \"aliases\");\n    assert_eq!(aliases.depth(), 1);\n\n    let soc = dt.children(&root).nth(4).unwrap();\n    assert_eq!(dt.node_name(&soc).unwrap(), \"soc\");\n    assert_eq!(soc.depth(), 1);\n    let uart = dt.children(&soc).nth(4).unwrap();\n    assert_eq!(dt.node_name(&uart).unwrap(), \"serial@7e201000\");\n    assert_eq!(uart.depth(), 2);\n\n    let uart_parent = dt.parent(&uart).unwrap();\n    assert_eq!(dt.node_name(&uart_parent).unwrap(), \"soc\");\n    assert_eq!(uart_parent, soc);\n}\n\n#[test]\nfn find_compatible() {\n    let dt = DeviceTree::new(TEST1_DTB).unwrap();\n\n    // Simple test for compatible where there's only a single match in the string list\n    let mut dma_iter = dt.find_compatible(\"shared-dma-pool\");\n    let dma = dma_iter.next().unwrap();\n    assert_eq!(dt.node_name(&dma).unwrap(), \"linux,cma\");\n    assert_eq!(dma.depth(), 2);\n    assert!(dma_iter.next().is_none());\n\n    // First, then second matching compatible strings for the same element\n    assert_eq!(\n        dt.find_compatible(\"arm,pl011\").flat_map(|n| dt.node_name(&n)).collect::<Vec<&str>>(),\n        vec![\"serial@7e201000\"]\n    );\n    assert_eq!(\n        dt.find_compatible(\"arm,primecell\").flat_map(|n| dt.node_name(&n)).collect::<Vec<&str>>(),\n        vec![\"serial@7e201000\"]\n    );\n\n    // Find multiple matching nodes\n    assert_eq!(\n        dt.find_compatible(\"brcm,bcm2835-sdhci\")\n            .flat_map(|n| dt.node_name(&n))\n            .collect::<Vec<&str>>(),\n        vec![\"mmc@7e300000\", \"mmcnr@7e300000\"]\n    );\n\n    // Doesn't find substrings\n    assert!(\n        dt.find_compatible(\"arm\").flat_map(|n| dt.node_name(&n)).collect::<Vec<&str>>().is_empty()\n    );\n\n    // No match\n    assert!(\n        dt.find_compatible(\"xxxx\").flat_map(|n| dt.node_name(&n)).collect::<Vec<&str>>().is_empty()\n    );\n}\n\n#[test]\nfn get_cells() {\n    let dt = DeviceTree::new(TEST1_DTB).unwrap();\n\n    let node = dt.find_by_path(\"/reserved-memory\").unwrap();\n    assert_eq!(\n        dt.property(&node, \"#address-cells\").and_then(|p| dt.property_value_as_u32(&p)),\n        Some(1)\n    );\n    assert_eq!(\n        dt.property(&node, \"#size-cells\").and_then(|p| dt.property_value_as_u32(&p)),\n        Some(1)\n    );\n\n    let node = dt.find_by_path(\"/soc/spi@7e204000\").unwrap();\n    assert_eq!(\n        dt.property(&node, \"#address-cells\").and_then(|p| dt.property_value_as_u32(&p)),\n        Some(1)\n    );\n    assert_eq!(\n        dt.property(&node, \"#size-cells\").and_then(|p| dt.property_value_as_u32(&p)),\n        Some(0)\n    );\n}\n\n#[test]\nfn iterate_over_children() {\n    let dt = DeviceTree::new(TEST1_DTB).unwrap();\n\n    let children = dt\n        .find_by_path(\"/thermal-zones\")\n        .iter()\n        .flat_map(|resmem| dt.children(resmem))\n        .flat_map(|n| dt.node_name(&n))\n        .collect::<Vec<&str>>();\n\n    assert_eq!(children, vec![\"cpu-thermal\"]);\n}\n\n#[test]\nfn iterate_over_device_types() {\n    let dt = DeviceTree::new(TEST1_DTB).unwrap();\n\n    let cpus = dt.find_device_type(\"cpu\").flat_map(|n| dt.node_name(&n)).collect::<Vec<&str>>();\n    assert_eq!(cpus, vec![\"cpu@0\", \"cpu@1\", \"cpu@2\", \"cpu@3\"]);\n}\n\n#[test]\nfn get_reg() {\n    let dt = DeviceTree::new(TEST1_DTB).unwrap();\n\n    let uart = dt.find_by_path(\"/soc/serial@7e201000\").unwrap();\n    let uart_reg_raw = dt\n        .property(&uart, \"reg\")\n        .map(|p| dt.property_value_as_u32_iter(&p).collect::<Vec<u32>>())\n        .unwrap();\n    assert_eq!(uart_reg_raw, vec![0x7e20_1000, 0x200]);\n\n    // Basic case - 1 addr and 1 length\n    let uart_reg = dt.property_reg_iter(uart).collect::<Vec<RegBlock>>();\n    assert_eq!(uart_reg, vec![RegBlock { addr: 0x7e20_1000, len: Some(0x200) }]);\n\n    // Example with no length\n    let spidev = dt.find_by_path(\"/soc/spi@7e204000/spidev@0\").unwrap();\n    let spidev_reg = dt.property_reg_iter(spidev).collect::<Vec<RegBlock>>();\n    assert_eq!(spidev_reg, vec![RegBlock { addr: 0x0, len: None }]);\n\n    // Example with > 1 reg\n    let watchdog = dt.find_by_path(\"/soc/watchdog@7e100000\").unwrap();\n    let watchdog_reg = dt.property_reg_iter(watchdog).collect::<Vec<RegBlock>>();\n    assert_eq!(\n        watchdog_reg,\n        vec![\n            RegBlock { addr: 0x7e100000, len: Some(0x114) },\n            RegBlock { addr: 0x7e00a000, len: Some(0x24) }\n        ]\n    );\n}\n\n#[test]\nfn get_ranges() {\n    let dt = DeviceTree::new(TEST1_DTB).unwrap();\n\n    // Get raw reg\n    let uart = dt.find_by_path(\"/soc/serial@7e201000\").unwrap();\n    let uart_reg = dt.property_reg_iter(uart).collect::<Vec<RegBlock>>();\n    assert_eq!(uart_reg, vec![RegBlock { addr: 0x7e20_1000, len: Some(0x200) }]);\n\n    // Get ranges for parent\n    let soc = dt.parent(&uart).unwrap();\n    let soc_ranges = dt.property_range_iter(soc).collect::<Vec<Range>>();\n    assert_eq!(\n        soc_ranges,\n        vec![\n            Range::Translated(RangeMapping {\n                child_bus_addr: 0x7e000000,\n                parent_bus_addr: 0x3f000000,\n                len: 0x1000000\n            }),\n            Range::Translated(RangeMapping {\n                child_bus_addr: 0x40000000,\n                parent_bus_addr: 0x40000000,\n                len: 0x1000\n            }),\n        ]\n    );\n}\n\n#[test]\nfn get_translated_reg() {\n    let dt = DeviceTree::new(TEST1_DTB).unwrap();\n\n    // Get translated reg, based on parent ranges\n    let uart = dt.find_by_path(\"/soc/serial@7e201000\").unwrap();\n    let uart_reg = dt.property_translated_reg_iter(uart).collect::<Vec<TranslatedReg>>();\n    assert_eq!(\n        uart_reg,\n        vec![TranslatedReg::Translated(RegBlock { addr: 0x3f20_1000, len: Some(0x200) })]\n    );\n}\n", "source": "R9/port/tests/fdt_test.rs", "file_type": "rc"}
{"text": "use crate::Result;\nuse crate::mcslock::{Lock, LockNode};\nuse core::fmt;\n\nconst fn ctrl(b: u8) -> u8 {\n    b - b'@'\n}\n\n#[allow(dead_code)]\nconst BACKSPACE: u8 = ctrl(b'H');\n#[allow(dead_code)]\nconst DELETE: u8 = 0x7F;\n#[allow(dead_code)]\nconst CTLD: u8 = ctrl(b'D');\n#[allow(dead_code)]\nconst CTLP: u8 = ctrl(b'P');\n#[allow(dead_code)]\nconst CTLU: u8 = ctrl(b'U');\n\npub trait Uart {\n    fn putb(&self, b: u8);\n}\n\nstatic CONS: Lock<Option<&'static mut dyn Uart>> = Lock::new(\"cons\", None);\n\n/// Console is what should be used in almost all cases, as it ensures threadsafe\n/// use of the console.\npub struct Console;\n\nimpl Console {\n    pub fn set_uart<F>(uart_fn: F)\n    where\n        F: FnOnce() -> Result<&'static mut dyn Uart>,\n    {\n        let node = LockNode::new();\n        let mut cons = CONS.lock(&node);\n        *cons = uart_fn().ok();\n    }\n\n    pub fn putstr(&mut self, s: &str) {\n        // XXX: Just for testing.\n\n        let node = LockNode::new();\n        let mut uart_guard = CONS.lock(&node);\n        if let Some(uart) = uart_guard.as_deref_mut() {\n            for b in s.bytes() {\n                putb(uart, b);\n            }\n        }\n    }\n}\n\nimpl fmt::Write for Console {\n    fn write_str(&mut self, s: &str) -> fmt::Result {\n        self.putstr(s);\n        Ok(())\n    }\n}\n\npub fn print(args: fmt::Arguments) {\n    // XXX: Just for testing.\n    use fmt::Write;\n    let mut cons: Console = Console {};\n    cons.write_fmt(args).unwrap();\n}\n\n#[macro_export]\nmacro_rules! println {\n    () => ($crate::print!(\"\\n\"));\n    ($($arg:tt)*) => ($crate::print!(\"{}\\n\", format_args!($($arg)*)));\n}\n\n#[macro_export]\nmacro_rules! print {\n    ($($args:tt)*) => {{\n        $crate::devcons::print(format_args!($($args)*))\n    }};\n}\n\nfn putb(uart: &mut dyn Uart, b: u8) {\n    if b == b'\\n' {\n        uart.putb(b'\\r');\n    } else if b == BACKSPACE {\n        uart.putb(b);\n        uart.putb(b' ');\n    }\n    uart.putb(b);\n}\n", "source": "R9/port/src/devcons.rs", "file_type": "rc"}
{"text": "#![allow(clippy::too_long_first_doc_paragraph)]\n\nuse core::{ffi::CStr, mem};\n\n#[derive(Debug)]\npub enum ParseError {\n    InvalidHeader,\n    InvalidMagic,\n    BufferTooSmall,\n    InvalidToken,\n}\n\ntype Result<T> = core::result::Result<T, ParseError>;\n\n/// Extract u32 from bytes\nfn bytes_to_u32(bytes: &[mem::MaybeUninit<u8>]) -> Option<u32> {\n    let maybe_uninit_bytes = bytes.get(..4)?;\n    let init_bytes = unsafe { maybe_uninit_bytes.assume_init_ref() };\n    Some(u32::from_be_bytes(init_bytes.try_into().unwrap()))\n}\n\n/// Extract u32 from bytes + offset\nfn bytes_to_u32_offset(bytes: &[mem::MaybeUninit<u8>], offset: usize) -> Option<u32> {\n    let maybe_uninit_bytes = bytes.get(offset..offset + 4)?;\n    let init_bytes = unsafe { maybe_uninit_bytes.assume_init_ref() };\n    Some(u32::from_be_bytes(init_bytes.try_into().unwrap()))\n}\n\n/// Extract u64 from bytes\nfn bytes_to_u64(bytes: &[mem::MaybeUninit<u8>]) -> Option<u64> {\n    let maybe_uninit_bytes = bytes.get(..8)?;\n    let init_bytes = unsafe { maybe_uninit_bytes.assume_init_ref() };\n    Some(u64::from_be_bytes(init_bytes.try_into().unwrap()))\n}\n\n/// Extract u32 from bytes, but cast as u64\nfn bytes_to_u32_as_u64(bytes: &[mem::MaybeUninit<u8>]) -> Option<u64> {\n    let maybe_uninit_bytes = bytes.get(..4)?;\n    let init_bytes = unsafe { maybe_uninit_bytes.assume_init_ref() };\n    Some(u32::from_be_bytes(init_bytes.try_into().unwrap()).into())\n}\n\nfn align4(n: usize) -> usize {\n    n + (0usize.wrapping_sub(n) & 3)\n}\n\n/// DeviceTree is the class entrypoint to the Devicetree operations.\n/// This code focuses only on parsing a Flattened Devicetree without using the heap.\n/// The Devicetree specification can be found here:\n/// https://www.devicetree.org/specifications/\n#[derive(Debug)]\npub struct DeviceTree<'a> {\n    data: &'a [mem::MaybeUninit<u8>], // Reference to the underlying data in memory\n    header: FdtHeader,                // Parsed structure of the header\n}\n\nimpl<'a> DeviceTree<'a> {\n    /// Create new DeviceTree based on memory pointed to by data.\n    /// Result is error if the header can't be parsed correctly.\n    pub fn new(data: &'a [u8]) -> Result<Self> {\n        let uninit_data =\n            unsafe { core::mem::transmute::<&[u8], &[core::mem::MaybeUninit<u8>]>(data) };\n        FdtHeader::new(uninit_data, false).map(|header| Self { data: uninit_data, header })\n    }\n\n    pub fn size(&self) -> usize {\n        self.header.totalsize as usize\n    }\n\n    /// Given a pointer to the dtb as a usize, return a DeviceTree struct.\n    ///\n    /// # Safety\n    /// The caller must ensure that `ptr` is a valid virtual address.\n    pub unsafe fn from_usize(ptr: usize) -> Result<Self> {\n        let u8ptr = ptr as *const mem::MaybeUninit<u8>;\n\n        // Extract the real length from the header\n        let dtb_buf_for_header: &[mem::MaybeUninit<u8>] =\n            unsafe { core::slice::from_raw_parts(u8ptr, size_of::<FdtHeader>()) };\n        let dtb_for_header = FdtHeader::new(dtb_buf_for_header, true)\n            .map(|header| Self { data: dtb_buf_for_header, header })?;\n        let len = dtb_for_header.header.totalsize as usize;\n\n        // Extract the buffer for real\n        let dtb_buf: &[mem::MaybeUninit<u8>] = unsafe { core::slice::from_raw_parts(u8ptr, len) };\n        FdtHeader::new(dtb_buf, false).map(|header| Self { data: dtb_buf, header })\n    }\n\n    /// Return slice containing `structs` area in FDT\n    fn structs(&self) -> &[mem::MaybeUninit<u8>] {\n        let start = self.header.off_dt_struct as usize;\n        let size: usize = self.header.size_dt_struct as usize;\n        &self.data[start..(start + size)]\n    }\n\n    /// Return slice containing `strings` area in FDT (all null terminated)\n    fn strings(&self) -> &'a [mem::MaybeUninit<u8>] {\n        let start = self.header.off_dt_strings as usize;\n        let size: usize = self.header.size_dt_strings as usize;\n        &self.data[start..(start + size)]\n    }\n\n    pub fn root(&self) -> Option<Node> {\n        self.node_from_index(0, 0)\n    }\n\n    pub fn children<'b>(&'b self, parent: &'b Node) -> impl Iterator<Item = Node> + 'b {\n        // Start searching linearly after node.start (which points to the start of the parent)\n        let mut i = parent.next_token_start;\n        let child_depth = parent.depth + 1;\n\n        core::iter::from_fn(move || {\n            let child = self.node_from_index(i, child_depth)?;\n            if parent.encloses(&child) {\n                i = child.start + child.total_len;\n                Some(child)\n            } else {\n                None\n            }\n        })\n    }\n\n    /// Find the parent of child.\n    pub fn parent(&self, child: &Node) -> Option<Node> {\n        // Search from the root of the tree down using the depth and the bounds of the nodes\n        // to find the parent.\n        fn find_parent(dt: &DeviceTree, node: Node, child: &Node) -> Option<Node> {\n            if !node.encloses(child) || node.depth >= child.depth {\n                return None;\n            }\n            // At this point, we enclose the child, and we're higher up\n            if node.depth + 1 < child.depth {\n                // Descend into children\n                for c in dt.children(&node) {\n                    if let Some(found_parent) = find_parent(dt, c, child) {\n                        return Some(found_parent);\n                    }\n                }\n            }\n            // Must be the parent\n            Some(node)\n        }\n\n        let root = self.root();\n        root.and_then(|n| find_parent(self, n, child))\n    }\n\n    pub fn node_name(&self, node: &Node) -> Option<&str> {\n        Self::inline_str(self.structs(), node.name_start)\n    }\n\n    pub fn property(&self, node: &Node, prop_name: &str) -> Option<Property> {\n        self.properties(node).find(|p| self.property_name(p) == Some(prop_name))\n    }\n\n    pub fn property_name(&self, prop: &Property) -> Option<&str> {\n        Self::inline_str(self.strings(), prop.name_start)\n    }\n\n    pub fn property_value_bytes(&self, prop: &Property) -> Option<&[mem::MaybeUninit<u8>]> {\n        let value_end = prop.value_start + prop.value_len;\n        self.structs().get(prop.value_start..value_end)\n    }\n\n    pub fn property_value_as_u32(&self, prop: &Property) -> Option<u32> {\n        let value_end = prop.value_start + prop.value_len;\n        self.structs().get(prop.value_start..value_end).and_then(bytes_to_u32)\n    }\n\n    pub fn property_value_as_u32_iter(&self, prop: &Property) -> impl Iterator<Item = u32> + '_ {\n        let mut value_i = prop.value_start;\n        let value_end = prop.value_start + prop.value_len;\n        core::iter::from_fn(move || {\n            if value_i >= value_end {\n                return None;\n            }\n            let (start, end) = (value_i, value_i + 4);\n            value_i = end;\n            self.structs().get(start..end).and_then(bytes_to_u32)\n        })\n    }\n\n    /// Return the node's #address-cells and #size-cells values as a tuple\n    fn node_address_size_cells(&self, node: Option<Node>) -> (usize, usize) {\n        let address_cells = node\n            .and_then(|n| self.property(&n, \"#address-cells\"))\n            .and_then(|p| self.property_value_as_u32(&p))\n            .unwrap_or(2) as usize;\n        let size_cells = node\n            .and_then(|n| self.property(&n, \"#size-cells\"))\n            .and_then(|p| self.property_value_as_u32(&p))\n            .unwrap_or(1) as usize;\n        (address_cells, size_cells)\n    }\n\n    fn consume_cells(&self, value_i: usize, num_cells: usize) -> Option<u64> {\n        let bytes_fn = if num_cells == 1 { bytes_to_u32_as_u64 } else { bytes_to_u64 };\n        let start = value_i;\n        let end = value_i + (num_cells * 4);\n        self.structs().get(start..end).and_then(bytes_fn)\n    }\n\n    /// Return the reg values as u64 whether the size is 1 or 2 cells.\n    /// Doesn't support > 2 cells.\n    pub fn property_reg_iter(&self, node: Node) -> impl Iterator<Item = RegBlock> + '_ {\n        // Get the address-cells and size-cells from the parent\n        let parent = self.parent(&node);\n        let (address_cells, size_cells) = self.node_address_size_cells(parent);\n\n        // If reg doesn't exist, start and len will be zero and None will be returned from the iter\n        let prop = self.property(&node, \"reg\");\n        let (value_start, value_len) = prop.map_or((0, 0), |p| (p.value_start, p.value_len));\n        let mut value_i = value_start;\n        let value_end = value_start + value_len;\n\n        core::iter::from_fn(move || {\n            // size_cells may be 0 for reg (implies no len)\n            if address_cells == 0 || address_cells > 2 || size_cells > 2 {\n                return None;\n            }\n\n            let address_size = address_cells * 4;\n            let len_size = size_cells * 4;\n\n            // End if not enough bytes to parse address and len\n            let remaining = value_end - value_i;\n            if (address_size + len_size) > remaining {\n                return None;\n            }\n\n            let addr = self.consume_cells(value_i, address_cells)?;\n            value_i += address_size;\n\n            let len = if size_cells > 0 { self.consume_cells(value_i, size_cells) } else { None };\n            value_i += len_size;\n\n            Some(RegBlock { addr, len })\n        })\n    }\n\n    /// Return the ranges values as u64 whether the size is 1 or 2 cells.\n    /// Doesn't support > 2 cells.\n    pub fn property_range_iter(&self, node: Node) -> impl Iterator<Item = Range> + '_ {\n        // Get the address-cells and size-cells from the parent\n        let parent = self.parent(&node);\n        let (parent_address_cells, _) = self.node_address_size_cells(parent);\n        let (address_cells, size_cells) = self.node_address_size_cells(Some(node));\n\n        // If ranges doesn't exist, start and len will be zero and None will be returned from the iter\n        let prop = self.property(&node, \"ranges\");\n        let (value_start, value_len) = prop.map_or((0, 0), |p| (p.value_start, p.value_len));\n        let mut value_i = value_start;\n        let value_end = value_start + value_len;\n\n        // If the length is zero, handle the identity range as a special case\n        let is_identity = value_i == value_end;\n        let mut identity_returned = false;\n\n        core::iter::from_fn(move || {\n            if is_identity {\n                if !identity_returned {\n                    identity_returned = true;\n                    return Some(Range::Identity);\n                }\n                return None;\n            }\n\n            // size_cells must not be 0 for ranges\n            if address_cells == 0 || size_cells == 0 || address_cells > 2 || size_cells > 2 {\n                return None;\n            }\n            if parent_address_cells == 0 || parent_address_cells > 2 {\n                return None;\n            }\n\n            let address_size = address_cells * 4;\n            let parent_address_size = parent_address_cells * 4;\n            let len_size = size_cells * 4;\n\n            // End if not enough bytes to parse 2x address and len\n            let remaining = value_end - value_i;\n            if (address_size + parent_address_size + len_size) > remaining {\n                return None;\n            }\n\n            let child_bus_addr = self.consume_cells(value_i, address_cells)?;\n            value_i += address_size;\n\n            let parent_bus_addr = self.consume_cells(value_i, parent_address_cells)?;\n            value_i += parent_address_size;\n\n            let len = self.consume_cells(value_i, size_cells)?;\n            value_i += len_size;\n\n            Some(Range::Translated(RangeMapping { child_bus_addr, parent_bus_addr, len }))\n        })\n    }\n\n    /// Get the reg values, translated by ranges of the parent\n    pub fn property_translated_reg_iter(\n        &self,\n        node: Node,\n    ) -> impl Iterator<Item = TranslatedReg> + '_ {\n        let mut reg_iter = self.property_reg_iter(node);\n        let mut curr_reg = reg_iter.next();\n\n        // Work on each reg element in turn\n        core::iter::from_fn(move || {\n            if let Some(reg) = curr_reg {\n                curr_reg = reg_iter.next();\n\n                // Walk from child to parents, translating by ranges at each step\n                let mut translated_reg = reg;\n                let mut curr_parent = self.parent(&node);\n                while curr_parent.is_some() {\n                    if let Some(parent) = curr_parent {\n                        if parent.is_root() {\n                            return Some(TranslatedReg::Translated(translated_reg));\n                        }\n\n                        // Find a range containing the regblock\n                        let mut translated = false;\n                        for range in self.property_range_iter(parent) {\n                            if let Some(new_reg) = range.translate(translated_reg) {\n                                translated_reg = new_reg;\n                                translated = true;\n                                break;\n                            }\n                        }\n\n                        if !translated {\n                            return Some(TranslatedReg::Unreachable);\n                        }\n\n                        curr_parent = self.parent(&parent);\n                    }\n                }\n            }\n            None\n        })\n    }\n\n    fn property_value_contains(&self, prop: &Property, bytes_to_find: &str) -> bool {\n        if let Some(uninit_value) = self.property_value_bytes(prop) {\n            let init_value = unsafe { uninit_value.assume_init_ref() };\n            return init_value.split(|b| *b == b'\\0').any(|bs| bs == bytes_to_find.as_bytes());\n        }\n        false\n    }\n\n    /// Return the node specified by the path, or None\n    pub fn find_by_path(&self, path: &str) -> Option<Node> {\n        fn find_subpath<'a, I>(\n            dt: &DeviceTree,\n            path_iter: &mut I,\n            node: &Node,\n            curr_path_element: Option<&str>,\n        ) -> Option<Node>\n        where\n            I: Iterator<Item = &'a str>,\n        {\n            // Found the end of the path, so return the node\n            let node_name = dt.node_name(node);\n            if curr_path_element == node_name {\n                let next_path_element = path_iter.next();\n                if next_path_element.is_none() {\n                    return Some(*node);\n                }\n                // Matching element on path, so recurse into children\n                for child in dt.children(node) {\n                    let found_node = find_subpath(dt, path_iter, &child, next_path_element);\n                    if found_node.is_some() {\n                        return found_node;\n                    }\n                }\n            }\n\n            None\n        }\n\n        // Prime the recursion with the first element of the path\n        let mut path_iter = path.split_terminator('/');\n        let next_path_element = path_iter.next();\n\n        self.root().and_then(|node| find_subpath(self, &mut path_iter, &node, next_path_element))\n    }\n\n    /// Return the first node matching the compatible string 'comp'\n    pub fn find_compatible(&'a self, comp: &'a str) -> impl Iterator<Item = Node> + 'a {\n        // Iterate over all nodes.  For each node, iterate over all properties until we find a 'compatible'\n        // property.  The 'compatible' property contains a list of null terminated strings.  If we find a matching\n        // string, then return the node, otherwise return None.\n        self.nodes().filter(|n| {\n            if let Some(comp_prop) = self.property(n, \"compatible\") {\n                return self.property_value_contains(&comp_prop, comp);\n            }\n            false\n        })\n    }\n\n    /// Return iterator of nodes matching the device_type string 'device_type'\n    pub fn find_device_type(&'a self, device_type: &'a str) -> impl Iterator<Item = Node> + 'a {\n        self.nodes().filter(|n| {\n            if let Some(prop) = self.property(n, \"device_type\") {\n                return self.property_value_contains(&prop, device_type);\n            }\n            false\n        })\n    }\n\n    fn inline_str(bytes: &[mem::MaybeUninit<u8>], start: usize) -> Option<&str> {\n        let maybe_uninit_bytes = bytes.get(start..)?;\n        let init_bytes = unsafe { maybe_uninit_bytes.assume_init_ref() };\n        let cstr = CStr::from_bytes_until_nul(init_bytes).ok()?;\n        cstr.to_str().ok()\n    }\n\n    fn node_from_index(&self, start: usize, node_depth: usize) -> Option<Node> {\n        // Iterate through data, finding the start index of the beginning of the\n        // FDT_BEGIN_NODE token, and the index of the end of the FDT_END_NODE token.\n        let structs = self.structs();\n        let mut i = start;\n        let mut begin_node_ctx: Option<FdtBeginNodeContext> = None;\n        let mut next_token_start = 0;\n        let mut depth = node_depth;\n\n        while i < structs.len() {\n            let token = Self::parse_token(structs, i);\n\n            match token {\n                Some(FdtToken::BeginNode(ctx)) => {\n                    if depth == node_depth {\n                        // Found the actual start of the next node\n                        begin_node_ctx.replace(ctx);\n                        next_token_start = i + ctx.total_len;\n                    }\n                    depth += 1;\n                    i += ctx.total_len;\n                }\n                Some(FdtToken::EndNode(ctx)) => {\n                    depth -= 1;\n                    if depth == node_depth {\n                        return begin_node_ctx.map(|begin_ctx| Node {\n                            start: begin_ctx.start,\n                            name_start: begin_ctx.name_start,\n                            next_token_start,\n                            total_len: (ctx.start + ctx.total_len) - begin_ctx.start,\n                            depth: node_depth,\n                        });\n                    }\n                    i += ctx.total_len;\n                }\n                Some(FdtToken::Prop(ctx)) => {\n                    i += ctx.total_len;\n                }\n                Some(FdtToken::Nop(ctx) | FdtToken::End(ctx)) => {\n                    i += ctx.total_len;\n                }\n                None => return None, // Shouldn't get here normally, so just None\n            }\n        }\n        // Node returned at FDT_END_NODE\n        None\n    }\n\n    /// Linearly iterate over the nodes in the order they occur in the flattened device tree\n    pub fn nodes(&self) -> impl Iterator<Item = Node> + '_ {\n        let structs = self.structs();\n        let mut i = 0;\n        let mut depth = 0;\n\n        // On each iteration, i should be at or before the next node token we expect.\n        // This is achieved by setting it to next_token_start when the end node token is found.\n        // next_token_start is set when the first begin node token of the iteration is found, and\n        // points to the next token after that begin node token.\n\n        core::iter::from_fn(move || {\n            let mut node_depth = 0;\n            let mut next_token_start = 0;\n            let mut begin_node_ctx: Option<FdtBeginNodeContext> = None;\n\n            while i < structs.len() {\n                let token = Self::parse_token(structs, i);\n                if let Some(token) = token {\n                    match token {\n                        FdtToken::BeginNode(ctx) => {\n                            if begin_node_ctx.is_none() {\n                                begin_node_ctx.replace(ctx);\n                                node_depth = depth;\n                                next_token_start = i + ctx.total_len;\n                            }\n                            depth += 1;\n                            i += ctx.total_len;\n                        }\n\n                        FdtToken::EndNode(ctx) => {\n                            if begin_node_ctx.is_some() && (depth - 1) == node_depth {\n                                // Reset i for the next node iteration\n                                i = next_token_start;\n                                let new_node = begin_node_ctx.take().map(|begin_ctx| Node {\n                                    start: begin_ctx.start,\n                                    name_start: begin_ctx.name_start,\n                                    next_token_start,\n                                    total_len: (ctx.start + ctx.total_len) - begin_ctx.start,\n                                    depth: node_depth,\n                                });\n                                return new_node;\n                            }\n\n                            depth -= 1;\n                            i += ctx.total_len;\n                        }\n                        FdtToken::Prop(ctx) => {\n                            i += ctx.total_len;\n                        }\n                        FdtToken::Nop(ctx) | FdtToken::End(ctx) => {\n                            i += ctx.total_len;\n                        }\n                    }\n                } else {\n                    return None;\n                }\n            }\n            None\n        })\n    }\n\n    /// Linearly iterate over the properties of a node in the order they occur in the flattened device tree\n    fn properties(&self, node: &Node) -> impl Iterator<Item = Property> + '_ {\n        let structs = self.structs();\n        let end_i = node.start + node.total_len;\n        let mut i = node.next_token_start;\n\n        core::iter::from_fn(move || {\n            while i < end_i {\n                let token = Self::parse_token(structs, i);\n\n                // Node properties come before any children\n                match token {\n                    Some(FdtToken::Prop(ctx)) => {\n                        i += ctx.total_len;\n                        return Some(Property {\n                            start: ctx.start,\n                            name_start: ctx.name_start,\n                            value_start: ctx.value_start,\n                            value_len: ctx.value_len,\n                            total_len: ctx.total_len,\n                        });\n                    }\n                    Some(FdtToken::Nop(ctx)) => {\n                        i += ctx.total_len;\n                    }\n                    _ => return None,\n                }\n            }\n            None\n        })\n    }\n\n    fn parse_token(structs: &[mem::MaybeUninit<u8>], i: usize) -> Option<FdtToken> {\n        let token = structs.get(i..).and_then(bytes_to_u32);\n\n        match token {\n            Some(0x1) => {\n                // Null terminated string follow token\n                let str_size = structs\n                    .get((i + 4)..)\n                    .and_then(|bs| unsafe { bs.assume_init_ref().iter().position(|&b| b == 0) })\n                    .map(|sz| align4(sz + 1))\n                    .unwrap_or(0);\n                Some(FdtToken::BeginNode(FdtBeginNodeContext {\n                    start: i,\n                    name_start: i + 4,\n                    total_len: 4 + str_size,\n                }))\n            }\n            Some(0x2) => Some(FdtToken::EndNode(FdtTokenContext { start: i, total_len: 4 })),\n            Some(0x3) => {\n                let len = structs.get((i + 4)..).and_then(bytes_to_u32).unwrap_or(0);\n                let nameoff = structs.get((i + 8)..).and_then(bytes_to_u32).unwrap_or(0);\n                Some(FdtToken::Prop(FdtPropContext {\n                    start: i,\n                    name_start: nameoff as usize,\n                    value_start: i + 12,\n                    value_len: len as usize,\n                    total_len: 12 + align4(len as usize),\n                }))\n            }\n            Some(0x4) => Some(FdtToken::Nop(FdtTokenContext { start: i, total_len: 4 })),\n            Some(0x9) => Some(FdtToken::End(FdtTokenContext { start: i, total_len: 4 })),\n            _ => None,\n        }\n    }\n}\n\n/// Flattened Devicetree header structure, as documented in the spec\n#[derive(Debug)]\n#[allow(dead_code)]\nstruct FdtHeader {\n    magic: u32,\n    totalsize: u32,\n    off_dt_struct: u32,\n    off_dt_strings: u32,\n    off_mem_rsvmap: u32,\n    version: u32,\n    last_comp_version: u32,\n    boot_cpuid_phys: u32,\n    size_dt_strings: u32,\n    size_dt_struct: u32,\n}\n\nimpl FdtHeader {\n    /// Read FdtHeader from the stream, returning it in a Result if it passes validation,\n    /// otherwise returns an error.\n    /// Set ignore_size to true if you're only loading a portion of the buffer\n    /// (e.g. in order to work out the size of the buffer before casting to a slice).\n    fn new(data: &[mem::MaybeUninit<u8>], ignore_size: bool) -> Result<Self> {\n        fn new_header(data: &[mem::MaybeUninit<u8>]) -> Option<FdtHeader> {\n            Some(FdtHeader {\n                magic: bytes_to_u32_offset(data, 0)?,\n                totalsize: bytes_to_u32_offset(data, 4)?,\n                off_dt_struct: bytes_to_u32_offset(data, 8)?,\n                off_dt_strings: bytes_to_u32_offset(data, 12)?,\n                off_mem_rsvmap: bytes_to_u32_offset(data, 16)?,\n                version: bytes_to_u32_offset(data, 20)?,\n                last_comp_version: bytes_to_u32_offset(data, 24)?,\n                boot_cpuid_phys: bytes_to_u32_offset(data, 28)?,\n                size_dt_strings: bytes_to_u32_offset(data, 32)?,\n                size_dt_struct: bytes_to_u32_offset(data, 36)?,\n            })\n        }\n\n        let len = data.len() as u32;\n        new_header(data)\n            .ok_or(ParseError::InvalidHeader)\n            .and_then(|h| (h.magic == 0xd00dfeed).then_some(h).ok_or(ParseError::InvalidMagic))\n            .and_then(|h| {\n                (len == h.totalsize || ignore_size).then_some(h).ok_or(ParseError::BufferTooSmall)\n            })\n    }\n}\n\n/// Token represents one of 5 tokens in the FDT specification.  The names and IDs correspond\n/// to those in the specification.\n#[derive(Debug, Copy, Clone)]\nenum FdtToken {\n    BeginNode(FdtBeginNodeContext), // Start of a new node\n    EndNode(FdtTokenContext),       // End of current node\n    Prop(FdtPropContext),           // New property in current node\n    Nop(FdtTokenContext),           // To be ignored\n    End(FdtTokenContext),           // End of FDT structure\n}\n\n#[derive(Debug, Copy, Clone)]\nstruct FdtBeginNodeContext {\n    start: usize,      // Start of token in buffer\n    total_len: usize,  // Number of bytes for token, name and alignment\n    name_start: usize, // Start of node name in sturcts buffer\n}\n\n#[derive(Debug, Copy, Clone)]\nstruct FdtPropContext {\n    start: usize,       // Start of token in buffer\n    total_len: usize,   // Number of bytes for token, len, nameoff, value and alignment\n    name_start: usize,  // Start of node name in strings buffer\n    value_start: usize, // Start of property value\n    value_len: usize,   // Size of property value\n}\n\n#[derive(Debug, Copy, Clone)]\nstruct FdtTokenContext {\n    start: usize,     // Start of token in buffer\n    total_len: usize, // Number of bytes for token\n}\n\n#[derive(Debug, PartialEq, Copy, Clone)]\npub struct Node {\n    start: usize,            // Start index in structs of node (Start of FDT_BEGIN_NODE)\n    name_start: usize,       // Start of node name in structs buffer\n    next_token_start: usize, // Start index of token after FDT_BEGIN_NODE\n    total_len: usize,        // Total length of node\n    depth: usize,            // Depth of node, with 0 being the root\n}\n\nimpl Node {\n    fn encloses(&self, child: &Node) -> bool {\n        let parent_starts_before_child = self.start <= child.start;\n        let parent_ends_after_child =\n            (self.start + self.total_len) >= (child.start + child.total_len);\n        parent_starts_before_child && parent_ends_after_child\n    }\n\n    fn is_root(&self) -> bool {\n        self.depth == 0\n    }\n\n    pub fn depth(&self) -> usize {\n        self.depth\n    }\n}\n\n#[derive(Debug, PartialEq, Copy, Clone)]\npub struct Property {\n    start: usize,       // Start index in structs of node (Start of FDT_BEGIN_NODE)\n    name_start: usize,  // Start of node name in strings buffer\n    value_start: usize, // Start index of property value\n    value_len: usize,   // Size of property value\n    total_len: usize,   // Total length of property\n}\n\n#[derive(Debug, PartialEq, Copy, Clone)]\npub struct RegBlock {\n    pub addr: u64,\n    pub len: Option<u64>,\n}\n\nimpl RegBlock {\n    pub fn from_addr(addr: u64) -> RegBlock {\n        RegBlock { addr, len: None }\n    }\n\n    pub fn with_offset(self, offset: u64) -> RegBlock {\n        RegBlock { addr: self.addr + offset, len: self.len }\n    }\n}\n\n#[derive(Debug, PartialEq, Copy, Clone)]\npub enum TranslatedReg {\n    Translated(RegBlock),\n    Unreachable,\n}\n\nimpl TranslatedReg {\n    pub fn regblock(&self) -> Option<RegBlock> {\n        match self {\n            TranslatedReg::Translated(regblock) => Some(*regblock),\n            _ => None,\n        }\n    }\n}\n\n#[derive(Debug, PartialEq, Copy, Clone)]\npub struct RangeMapping {\n    pub child_bus_addr: u64,\n    pub parent_bus_addr: u64,\n    pub len: u64,\n}\n\n#[derive(Debug, PartialEq, Copy, Clone)]\npub enum Range {\n    Identity,\n    Translated(RangeMapping),\n}\n\nimpl Range {\n    /// Attempt to translate the given RegBlock.  If it can't be mapped, return None.\n    fn translate(&self, r: RegBlock) -> Option<RegBlock> {\n        match self {\n            Range::Identity => Some(r),\n            Range::Translated(map) => {\n                if r.addr >= map.child_bus_addr && r.addr < map.child_bus_addr + map.len {\n                    let addr = r.addr - map.child_bus_addr + map.parent_bus_addr;\n                    return Some(RegBlock { addr, len: r.len });\n                }\n                None\n            }\n        }\n    }\n}\n", "source": "R9/port/src/fdt.rs", "file_type": "rc"}
{"text": "#![cfg(not(test))]\n\nextern crate alloc;\n\nuse alloc::alloc::Layout;\nuse core::arch::asm;\nuse core::panic::PanicInfo;\n\nuse port::{print, println};\n\n#[unsafe(no_mangle)]\nextern \"C\" fn eh_personality() {}\n\n#[panic_handler]\nfn panic(info: &PanicInfo) -> ! {\n    print!(\"Panic: \");\n    if let Some(p) = info.location() {\n        println!(\"line {}, file {}: {}\", p.line(), p.file(), info.message());\n    } else {\n        println!(\"no information available.\");\n    }\n    abort();\n}\n\n#[unsafe(no_mangle)]\nextern \"C\" fn abort() -> ! {\n    loop {\n        unsafe {\n            asm!(\"wfi\");\n        }\n    }\n}\n\n#[alloc_error_handler]\nfn oom(_layout: Layout) -> ! {\n    panic!(\"oom\");\n}\n", "source": "R9/riscv64/src/runtime.rs", "file_type": "rc"}
{"text": "//! SBI interface.\n//!\n//! Chapter 5: Legacy Extensions\n\n#![allow(dead_code)]\n\nconst SBI_SET_TIMER: usize = 0;\nconst SBI_CONSOLE_PUTCHAR: usize = 1;\nconst SBI_CONSOLE_GETCHAR: usize = 2;\nconst _SBI_CLEAR_IPI: usize = 3;\nconst _SBI_SEND_IPI: usize = 4;\nconst _SBI_REMOTE_FENCE_I: usize = 5;\nconst _SBI_REMOTE_SFENCE_VMA: usize = 6;\nconst _SBI_REMOTE_SFENCE_VMA_ASID: usize = 7;\nconst SBI_SHUTDOWN: usize = 8;\n\n#[cfg(target_arch = \"riscv64\")]\nfn sbi_call_legacy(eid: usize, arg0: usize, arg1: usize, arg2: usize) -> usize {\n    let ret;\n    unsafe {\n        core::arch::asm!(\n            \"ecall\",\n            inlateout(\"x10\") arg0 => ret,\n            in(\"x11\") arg1,\n            in(\"x12\") arg2,\n            in(\"x17\") eid\n        );\n    }\n    ret\n}\n\n#[cfg(not(target_arch = \"riscv64\"))]\nfn sbi_call_legacy(_eid: usize, _arg0: usize, _arg1: usize, _arg2: usize) -> usize {\n    0\n}\n\npub fn _set_timer(timer: usize) {\n    sbi_call_legacy(SBI_SET_TIMER, timer, 0, 0);\n}\n\n#[deprecated = \"expected to be deprecated; no replacement\"]\npub fn _consputb(c: u8) {\n    sbi_call_legacy(SBI_CONSOLE_PUTCHAR, c as usize, 0, 0);\n}\n\n#[deprecated = \"expected to be deprecated; no replacement\"]\npub fn _consgetb() -> u8 {\n    sbi_call_legacy(SBI_CONSOLE_GETCHAR, 0, 0, 0).try_into().unwrap()\n}\n\npub fn shutdown() -> ! {\n    sbi_rt::system_reset(sbi_rt::Shutdown, sbi_rt::NoReason);\n    loop {\n        unsafe { core::arch::asm!(\"wfi\") }\n    }\n}\n", "source": "R9/riscv64/src/sbi.rs", "file_type": "rc"}
{"text": "/* Copyright (c) 1998 Lucent Technologies - All rights reserved. */\n#include <u.h>\n#include \"errors.h\"\n\n/*\n * BLOCKSIZE is relatively small to keep memory consumption down.\n */\n\n#define BLOCKSIZE   2048\n#define RUNESIZE    sizeof(wchar_t)\n#define NDISC       5\n#define NBUFFILES   3+2*NDISC   /* plan 9+undo+snarf+NDISC*(transcript+buf) */\n#define NSUBEXP 10\n\n#define INFINITY    0x7FFFFFFFL\n#define INCR        25\n#define STRSIZE     (2*BLOCKSIZE)\n\ntypedef int64_t        Posn;       /* file position or address */\ntypedef uint64_t      Mod;        /* modification number */\n\ntypedef struct Address  Address;\ntypedef struct Block    Block;\ntypedef struct Buffer   Buffer;\ntypedef struct File File;\ntypedef struct List List;\ntypedef struct Mark Mark;\ntypedef struct Range    Range;\ntypedef struct Rangeset Rangeset;\ntypedef struct String   String;\n\ntypedef enum\n{\n    Clean =     ' ',\n    Dirty =     '\\'',\n    Unread =    '-',\n    Readerr =   '~'\n} state_t;\n\nstruct Range\n{\n    Posn    p1, p2;\n};\n\nstruct Rangeset\n{\n    Range   p[NSUBEXP];\n};\n\nstruct Address\n{\n    Range   r;\n    File    *f;\n};\n\nstruct List\n{\n    int nalloc;\n    int nused;\n    union{\n        void    *listp;\n        Block   *blkp;\n        int64_t    *longp;\n        uint8_t*  *uint8_tp;\n        String* *stringp;\n        File*   *filep;\n        int64_t    listv;\n    }g;\n};\n\n#define listptr     g.listp\n#define blkptr      g.blkp\n#define longptr     g.longp\n#define uint8_tpptr   g.uint8_tp\n#define stringpptr  g.stringp\n#define filepptr    g.filep\n#define listval     g.listv\n\nstruct String\n{\n    int16_t   n;\n    int16_t   size;\n    wchar_t    *s;\n};\n\nstruct Gapbuffer;\nstruct Buffer\n{\n    Posn nrunes;\n    struct Gapbuffer *gb;\n};\n\n#define NGETC   128\n\nstruct File\n{\n    Buffer  *buf;       /* cached disc storage */\n    Buffer  *transcript;    /* what's been done */\n    Posn    markp;      /* file pointer to start of latest change */\n    Mod     mod;        /* modification stamp */\n    Posn    nrunes;     /* total length of file */\n    Posn    hiposn;     /* highest address touched this Mod */\n    Address dot;        /* current position */\n    Address ndot;       /* new current position after update */\n    Range   tdot;       /* what terminal thinks is current range */\n    Range   mark;       /* tagged spot in text (don't confuse with Mark) */\n    List    *rasp;      /* map of what terminal's got */\n    String  name;       /* file name */\n    int16_t tag;        /* for communicating with terminal */\n    state_t state;      /* Clean, Dirty, Unread, or Readerr*/\n    bool    closeok;    /* ok to close file? */\n    bool    deleted;    /* delete at completion of command */\n    bool    marked;     /* file has been Fmarked at least once; once\n                 * set, this will never go off as undo doesn't\n                 * revert to the dawn of time */\n    int64_t    dev;        /* file system from which it was read */\n    int64_t    qid;        /* file from which it was read */\n    int64_t    date;       /* time stamp of plan9 file */\n    Posn    cp1, cp2;   /* Write-behind cache positions and */\n    String  cache;      /* string */\n    wchar_t    getcbuf[NGETC];\n    char mbbuf[BUFSIZ];  /* partial character during read */\n    size_t mblen; /* number of bytes in partial character */\n    mbstate_t ps; /* state of multibyte decoding */\n    int ngetc;\n    int getci;\n    Posn    getcp;\n};\n\nstruct Mark\n{\n    Posn    p;\n    Range   dot;\n    Range   mark;\n    Mod m;\n    int16_t   s1;\n};\n\n/*\n * The precedent to any message in the transcript.\n * The component structures must be an integral number of Runes long.\n */\nunion Hdr\n{\n    struct _csl\n    {\n        int16_t   c;\n        int16_t   s;\n        int64_t    l;\n    }csl;\n    struct _cs\n    {\n        int16_t   c;\n        int16_t   s;\n    }cs;\n    struct _cll\n    {\n        int16_t   c;\n        int64_t    l;\n        int64_t    l1;\n    }cll;\n    Mark    mark;\n};\n\n#define Fgetc(f)  ((--(f)->ngetc<0)? Fgetcload(f, (f)->getcp) : (f)->getcbuf[(f)->getcp++, (f)->getci++])\n#define Fbgetc(f) (((f)->getci<=0)? Fbgetcload(f, (f)->getcp) : (f)->getcbuf[--(f)->getcp, --(f)->getci])\n\nvoid    Bterm(Buffer*);\nvoid    Bdelete(Buffer*, Posn, Posn);\nvoid    Bflush(Buffer*);\nvoid    Binsert(Buffer*, String*, Posn);\nBuffer  *Bopen(void);\nint Bread(Buffer*, wchar_t*, int, Posn);\nint Fbgetcload(File*, Posn);\nint Fbgetcset(File*, Posn);\nint64_t    Fchars(File*, wchar_t*, Posn, Posn);\nvoid    Fclose(File*);\nvoid    Fdelete(File*, Posn, Posn);\nint Fgetcload(File*, Posn);\nint Fgetcset(File*, Posn);\nvoid    Finsert(File*, String*, Posn);\nFile    *Fopen(void);\nvoid    Fsetname(File*, String*);\nvoid    Fstart(void);\nint Fupdate(File*, int, int);\nint Read(FILE *, void*, int);\nint plan9(File*, int, String*, int);\nint Write(FILE *, void*, int);\nint bexecute(File*, Posn);\nvoid    cd(String*);\nvoid    closefiles(File*, String*);\nvoid    closeio(Posn);\nvoid    cmdloop(void);\nvoid    cmdupdate(void);\nvoid    compile(String*);\nvoid    copy(File*, Address);\nFile    *current(File*);\nvoid    delete(File*);\nvoid    delfile(File*);\nvoid    dellist(List*, int);\nvoid    doubleclick(File*, Posn);\nvoid    dprint(wchar_t *, ...);\nvoid    edit(File*, int);\nvoid    *emalloc(uint64_t);\nvoid    *erealloc(void*, uint64_t);\nvoid    error(Err);\nvoid    error_c(Err, int);\nvoid    error_s(Err, char*);\nint execute(File*, Posn, Posn);\nint filematch(File*, String*);\nvoid    filename(File*);\nvoid    freebufs(void);\nvoid    freecmd(void);\nvoid    freecmdlists(void);\nFile    *getfile(String*);\nint getname(File*, String*, bool);\nint64_t    getnum(void);\nvoid    hiccough(char*);\nvoid    inslist(List*, int, int64_t);\nAddress lineaddr(Posn, Address, int);\nvoid    listfree(List*);\nvoid    load(File*);\nFile    *lookfile(String*, bool);\nvoid    lookorigin(File*, Posn, Posn, int64_t);\nint lookup(int);\nvoid    move(File*, Address);\nvoid    moveto(File*, Range);\nFile    *newfile(void);\nvoid    nextmatch(File*, String*, Posn, int);\nint newtmp(void);\nvoid    panic(char*);\nvoid    printposn(File*, int);\nvoid    print_ss(char*, String*, String*);\nvoid    print_s(char*, String*);\nint rcv(void);\nRange   rdata(List*, Posn, Posn);\nPosn    readio(File*, bool*, bool);\nvoid    rescue(void);\nvoid    resetcmd(void);\nvoid    resetsys(void);\nvoid    resetxec(void);\nvoid    rgrow(List*, Posn, Posn);\nvoid    samerr(char*);\nvoid    settempfile(void);\nvoid    scram(void);\nint     skipbl(void);\nvoid    snarf(File*, Posn, Posn, Buffer*, bool);\nvoid    sortname(File*);\nvoid    startup(char*, bool, bool);\nvoid    state(File*, state_t);\nint statfd(int, uint64_t*, uint64_t*, int64_t*, int64_t*, int64_t*);\nint statfile(char*, uint64_t*, uint64_t*, int64_t*, int64_t*, int64_t*);\nvoid    Straddc(String*, wchar_t);\nvoid    Strclose(String*);\nint Strcmp(String*, String*);\nvoid    Strdelete(String*, Posn, Posn);\nvoid    Strdupl(String*, wchar_t*);\nvoid    Strduplstr(String*, String*);\nvoid    Strinit(String*);\nvoid    Strinit0(String*);\nvoid    Strinsert(String*, String*, Posn);\nvoid    Strinsure(String*, uint64_t);\nvoid    Strzero(String*);\nint Strlen(wchar_t*);\nchar    *Strtoc(String*);\nvoid    syserror(char*);\nvoid    telldot(File*);\nvoid    tellpat(void);\nString  *tmpcstr(char*);\nString  *tmprstr(wchar_t*, int);\nvoid    freetmpstr(String*);\nvoid    termcommand(void);\nvoid    termwrite(wchar_t *);\nFile    *tofile(String*);\nvoid    toterminal(File*, int);\nvoid    trytoclose(File*);\nvoid    trytoquit(void);\nint undo(void);\nvoid    update(void);\nint waitfor(int);\nvoid    warn(Warn);\nvoid    warn_s(Warn, char*);\nvoid    warn_SS(Warn, String*, String*);\nvoid    warn_S(Warn, String*);\nint whichmenu(File*);\nvoid    writef(File*);\nPosn    writeio(File*);\nvoid    flushio(void);\nbool canlocksocket(const char *);\n\nextern wchar_t samname[];  /* compiler dependent */\nextern wchar_t *left[];\nextern wchar_t *right[];\n\nextern char *rsamname;  /* globals */\nextern char *samterm;\nextern char *sh;\nextern char *shpath;\nextern wchar_t genbuf[];\nextern char *genc;\nextern FILE *io;\nextern bool  patset;\nextern bool  quitok;\nextern Address  addr;\nextern Buffer   *undobuf;\nextern Buffer   *snarfbuf;\nextern Buffer   *plan9buf;\nextern List file;\nextern List tempfile;\nextern File *cmd;\nextern File *curfile;\nextern File *lastfile;\nextern Mod  modnum;\nextern Posn cmdpt;\nextern Posn cmdptadv;\nextern Rangeset sel;\nextern String   cmdstr;\nextern String   genstr;\nextern String   lastpat;\nextern String   lastregexp;\nextern String   plan9cmd;\nextern bool  downloaded;\nextern bool  eof;\nextern bool  bpipeok;\nextern bool  panicking;\nextern wchar_t empty[];\nextern int  termlocked;\nextern bool  noflush;\n\n#include \"mesg.h\"\n\nvoid    outTs(Hmesg, int);\nvoid    outT0(Hmesg);\nvoid    outTl(Hmesg, int64_t);\nvoid    outTslS(Hmesg, int, int64_t, String*);\nvoid    outTS(Hmesg, String*);\nvoid    outTsS(Hmesg, int, String*);\nvoid    outTsllS(Hmesg, int, int64_t, int64_t, String*);\nvoid    outTsll(Hmesg, int, int64_t, int64_t);\nvoid    outTsl(Hmesg, int, int64_t);\nvoid    outTsv(Hmesg, int, int64_t);\nvoid    outstart(Hmesg);\nvoid    outcopy(int, void*);\nvoid    outshort(int);\nvoid    outlong(int64_t);\nvoid    outsend(void);\nvoid    outflush(void);\n", "source": "sam/sam/sam.h", "file_type": "h"}
{"text": "#include <u.h>\n\n/* Copyright (c) 1998 Lucent Technologies - All rights reserved. */\ntypedef struct Addr Addr;\ntypedef struct Cmd Cmd;\nstruct Addr\n{\n    char    type;   /* # (char addr), l (line addr), / ? . $ + - , ; */\n    union{\n        String  *re;\n        Addr    *aleft;     /* left side of , and ; */\n    } g;\n    Posn    num;\n    Addr    *next;          /* or right side of , and ; */\n};\n\n#define are g.re\n#define left    g.aleft\n\nstruct Cmd\n{\n    Addr    *addr;          /* address (range of text) */\n    String  *re;            /* regular expression for e.g. 'x' */\n    union{\n        Cmd *cmd;       /* target of x, g, {, etc. */\n        String  *text;      /* text of a, c, i; rhs of s */\n        Addr    *addr;      /* address for m, t */\n    } g;\n    Cmd *next;          /* pointer to next element in {} */\n    int16_t   num;\n    uint16_t  flag;           /* whatever */\n    uint16_t  cmdc;           /* command character; 'x' etc. */\n};\n\n#define ccmd    g.cmd\n#define ctext   g.text\n#define caddr   g.addr\n\nextern struct cmdtab{\n    uint16_t  cmdc;       /* command character */\n    uint8_t   text;       /* takes a textual argument? */\n    uint8_t   regexp;     /* takes a regular expression? */\n    uint8_t   addr;       /* takes an address (m or t)? */\n    uint8_t   defcmd;     /* default command; 0==>none */\n    uint8_t   defaddr;    /* default address */\n    uint8_t   count;      /* takes a count e.g. s2/// */\n    wchar_t *token;     /* takes text terminated by one of these */\n    bool (*fn)(File*, Cmd*); /* function to call with parse tree */\n}cmdtab[];\n\nenum Defaddr{   /* default addresses */\n    aNo,\n    aDot,\n    aAll\n};\n\nbool nl_cmd(File*, Cmd*), a_cmd(File*, Cmd*), b_cmd(File*, Cmd*);\nbool c_cmd(File*, Cmd*), cd_cmd(File*, Cmd*), d_cmd(File*, Cmd*);\nbool D_cmd(File*, Cmd*), e_cmd(File*, Cmd*);\nbool f_cmd(File*, Cmd*), g_cmd(File*, Cmd*), i_cmd(File*, Cmd*);\nbool k_cmd(File*, Cmd*), m_cmd(File*, Cmd*), n_cmd(File*, Cmd*);\nbool p_cmd(File*, Cmd*), q_cmd(File*, Cmd*);\nbool P_cmd(File*, Cmd*), P_cmd(File*, Cmd*);\nbool s_cmd(File*, Cmd*), u_cmd(File*, Cmd*), w_cmd(File*, Cmd*);\nbool x_cmd(File*, Cmd*), X_cmd(File*, Cmd*), plan9_cmd(File*, Cmd*);\nbool eq_cmd(File*, Cmd*);\n\n\nString  *getregexp(int);\nAddr    *newaddr(void);\nAddress address(Addr*, Address, int);\nint cmdexec(File*, Cmd*);\n", "source": "sam/sam/parse.h", "file_type": "h"}
{"text": "/* Copyright (c) 1998 Lucent Technologies - All rights reserved. */\n#include <u.h>\n#include <libg.h>\n#include \"libgint.h\"\n\nBitmap*\nballoc(Rectangle r, int ldepth)\n{\n    Bitmap *b;\n\n    b = _balloc(r, ldepth);\n    bitblt(b, r.min, b, r, Zero);\n    return b;\n}\n\nBitmap*\n_balloc(Rectangle r, int ldepth)\n{\n    int id;\n    Bitmap *b;\n    int ld;\n    Rectangle rx;\n\n    b = (Bitmap *)calloc(1, sizeof(Bitmap));\n    if(b == 0)\n        berror(\"balloc malloc\");\n    if (ldepth == 0)\n        ld = 0;\n    else\n        ld = screen.ldepth;\n    rx = r;\n    if (Dx(rx) == 0)\n        rx.max.x++;\n    if (Dy(rx) == 0)\n        rx.max.y++;\n    id = (int) XCreatePixmap(_dpy, (Drawable)screen.id,\n            Dx(rx), Dy(rx), _ld2d[ld]);\n    b->ldepth = ldepth;\n    b->r = r;\n    b->clipr = r;\n    b->id = id;\n    b->cache = 0;\n    if(ldepth == 0)\n        b->flag = DP1|BL1;\n    else\n        b->flag = screen.flag&BL1;\n    if(r.min.x==0 && r.min.y ==0)\n        b->flag |= ZORG;\n    else\n        b->flag |= SHIFT;\n    return b;\n}\n\nvoid\nbfree(Bitmap *b)\n{\n    if (b->fd)\n        XftDrawDestroy(b->fd);\n    XFreePixmap(_dpy, (Pixmap)b->id);\n    free(b);\n}\n", "source": "sam/libXg/balloc.c", "file_type": "c"}
{"text": "/* Copyright (c) 1998 Lucent Technologies - All rights reserved. */\n#include <u.h>\n#include <libg.h>\n\nint rectclip(Rectangle *rp, Rectangle b)        /* first by reference, second by value */\n{\n    Rectangle *bp = &b;\n    /*\n     * Expand rectXrect() in line for speed\n     */\n    if((rp->min.x<bp->max.x && bp->min.x<rp->max.x &&\n        rp->min.y<bp->max.y && bp->min.y<rp->max.y)==0)\n        return 0;\n    /* They must overlap */\n    if(rp->min.x < bp->min.x)\n        rp->min.x = bp->min.x;\n    if(rp->min.y < bp->min.y)\n        rp->min.y = bp->min.y;\n    if(rp->max.x > bp->max.x)\n        rp->max.x = bp->max.x;\n    if(rp->max.y > bp->max.y)\n        rp->max.y = bp->max.y;\n    return 1;\n}\n", "source": "sam/libXg/rectclip.c", "file_type": "c"}
{"text": "/* Copyright (c) 1998 Lucent Technologies - All rights reserved. */\n#include <u.h>\n#include <libg.h>\n#include \"libgint.h\"\n#include <X11/Intrinsic.h>\n\n#include <stdio.h>\nvoid\nwrbitmap(Bitmap *b, int miny, int maxy, unsigned char *data)\n{\n    XImage *im;\n    int w, h, inld, outld, l, offset, px;\n    GC g;\n    char *tdata;\n\n    w = Dx(b->r);\n    h = maxy - miny;\n    inld = b->ldepth;\n    outld = (b->ldepth == 0) ? 0 : screen.ldepth;\n    px = 1<<(3-outld);  /* pixels per byte */\n    /* set l to number of bytes of data per scan line */\n    if(b->r.min.x >= 0)\n        offset = b->r.min.x % px;\n    else\n        offset = px - b->r.min.x % px;\n    l = (-b->r.min.x+px-1)/px;\n    if(b->r.max.x >= 0)\n        l += (b->r.max.x+px-1)/px;\n    else\n        l -= b->r.max.x/px;\n    l *= h;\n\n    tdata = (char *)malloc(l);\n    if (tdata == (char *) 0)\n            berror(\"wrbitmap malloc\");\n    if (inld == outld)\n        memcpy((void*)tdata, (void*)data, l);\n    else\n        _ldconvert((char*)data, inld, tdata, outld, w, h);\n\n    im = XCreateImage(_dpy, 0, 1 << outld, ZPixmap, 0, tdata, w, h, 8, 0);\n\n    /* Botched interface to XCreateImage doesn't let you set these: */\n    im->bitmap_bit_order = MSBFirst;\n    im->byte_order = MSBFirst;\n\n    g = _getfillgc(S, b, ~0);\n    XSetBackground(_dpy, g, b->flag&DP1 ? 0 : _bgpixel);\n    XPutImage(_dpy, (Drawable)b->id, g, im, offset, 0, 0, miny - b->r.min.y, w-offset, h);\n    XDestroyImage(im);\n}\n", "source": "sam/libXg/wrbitmap.c", "file_type": "c"}
{"text": "/* Copyright (c) 1998 Lucent Technologies - All rights reserved. */\n#include <u.h>\n#include <libg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include \"libgint.h\"\n\n#define Font xFont\n#define Event xEvent\n\n#include <X11/Intrinsic.h>\n#include <X11/StringDefs.h>\n#include <X11/Shell.h>\n#include <X11/XKBlib.h>\n#include <X11/extensions/XInput.h>\n#include \"Gwin.h\"\n\n#undef Font\n#undef Event\n\n/* default colors */\n#ifndef MAX_BACKGROUNDS\n    #define MAX_BACKGROUNDS 20\n#endif\n\n#ifndef DEFAULT_FOREGROUND\n    #define DEFAULT_FOREGROUND \"#000000\"\n#endif\n\n#ifndef DEFAULT_BACKGROUND\n    #define DEFAULT_BACKGROUND \"#ffffff\"\n#endif\n\n#ifndef DEFAULT_BORDER\n    #define DEFAULT_BORDER \"#000000\"\n#endif\n\n/* libg globals */\nXIM xim;\nXIC xic;\nBitmap  screen;\nXftFont *font;\nXftColor fontcolor;\nchar fontspec[1024] = {0};\nchar foregroundspec[1024] = {0};\nchar backgroundspec[1024] = {0};\nchar borderspec[1024] = {0};\n\n/* implementation globals */\nextern char *machine;\nDisplay     *_dpy;\nWidget      _toplevel;\nWindow _topwindow;\nuint64_t _bgpixels[MAX_BACKGROUNDS];\nint _nbgs;\nuint64_t   _fgpixel, _bgpixel, _borderpixel;\nXColor      _fgcolor, _bgcolor, _bordercolor;\nint     _ld2d[6] = { 1, 2, 4, 8, 16, 24 };\nuint64_t   _ld2dmask[6] = { 0x1, 0x3, 0xF, 0xFF, 0xFFFF, 0x00FFFFFF };\nColormap    _libg_cmap;\nint     _cmap_installed;\n\n/* xbinit implementation globals */\nstatic XtAppContext app;\nstatic Widget widg;\nstatic bool exposed = 0;\nstatic Atom wm_take_focus;\nstatic Mouse lastmouse;\n\ntypedef struct Ebuf {\n    struct Ebuf *next;\n    int     n;\n    unsigned char   buf[4];\n} Ebuf;\n\ntypedef struct Esrc {\n    bool issocket;\n    bool inuse;\n    int size;\n    int count;\n    Ebuf    *head;\n    Ebuf    *tail;\n} Esrc;\n\n#define MAXINPUT    1024        /* number of queued input events */\n#define MAXSRC      10\n\nstatic Esrc esrc[MAXSRC];\nstatic int  nsrc;\n\n\nstatic int einitcalled = 0;\nstatic int Smouse = -1;\nstatic int Skeyboard = -1;\n\n\nstatic void reshaped(int, int, int, int);\nstatic void gotchar(int, int, int, int, int, const char *);\nstatic void gotmouse(Gwinmouse *);\nstatic int  ilog2(int);\n\nstatic Ebuf *ebread(Esrc *);\nstatic Ebuf *ebadd(Esrc *, bool);\nstatic void focinit(Widget);\nstatic void wmproto(Widget, XEvent *, String *, Cardinal *);\nstatic void waitevent(void);\n\nstatic Errfunc  onerr;\n\nString _fallbacks[] = {\n    \"*gwin.width: 400\",\n    \"*gwin.height: 400\",\n    NULL\n};\n\nstatic char *shelltrans = \n    \"<ClientMessage> WM_PROTOCOLS : WMProtocolAction()\";\nstatic XtActionsRec wmpactions[] = {\n    {\"WMProtocolAction\", wmproto}\n};\n\nBitmap  *darkgrey;\n\nstatic uint8_t darkgreybits[] = {\n    0xDD, 0xDD, 0x77, 0x77, 0xDD, 0xDD, 0x77, 0x77,\n    0xDD, 0xDD, 0x77, 0x77, 0xDD, 0xDD, 0x77, 0x77,\n    0xDD, 0xDD, 0x77, 0x77, 0xDD, 0xDD, 0x77, 0x77,\n    0xDD, 0xDD, 0x77, 0x77, 0xDD, 0xDD, 0x77, 0x77,\n};\n\nvoid\nfreefont(void)\n{\n    if (font)\n        XftFontClose(_dpy, font);\n}\n\nvoid\nxtbinit(Errfunc f, char *class, int *pargc, char **argv, char **fallbacks)\n{\n    int n;\n    char *p;\n    int compose;\n\n    if(!class && argv[0]){\n        p = strrchr(argv[0], '/');\n        if(p)\n            class = XtNewString(p+1);\n        else\n            class = XtNewString(argv[0]);\n        if(class[0] >= 'a' && class[0] <= 'z')\n            class[0] += 'A' - 'a';\n    }\n    onerr = f;\n    if (!fallbacks)\n        fallbacks = _fallbacks;\n\n    char name[512] = {0};\n    snprintf(name, sizeof(name) - 1, \"samterm on %s\", machine);\n    Arg args[] ={\n        {XtNinput, true},\n        {XtNtitle, (XtArgVal)name},\n        {XtNiconName, (XtArgVal)name},\n    };\n    _toplevel = XtAppInitialize(&app, class,\n            NULL, 0,\n            pargc, argv, fallbacks, args, XtNumber(args));\n\n    n = 0;\n    XtSetArg(args[n], XtNreshaped, reshaped);   n++;\n    XtSetArg(args[n], XtNgotchar, gotchar);     n++;\n    XtSetArg(args[n], XtNgotmouse, gotmouse);   n++;\n    widg = XtCreateManagedWidget(\"gwin\", gwinWidgetClass, _toplevel, args, n);\n\n    _dpy = XtDisplay(widg);\n    XAllocNamedColor(_dpy, DefaultColormap(_dpy, DefaultScreen(_dpy)),\n                     foregroundspec[0] ? foregroundspec : getenv(\"FOREGROUND\") ? getenv(\"FOREGROUND\") : DEFAULT_FOREGROUND, &_fgcolor, &_fgcolor);\n    XAllocNamedColor(_dpy, DefaultColormap(_dpy, DefaultScreen(_dpy)),\n                     borderspec[0] ? borderspec : getenv(\"BORDER\") ? getenv(\"BORDER\") : DEFAULT_BORDER, &_bordercolor, &_bordercolor);\n    char bgspec[1024] = {0};\n    strncpy(bgspec, backgroundspec[0] ? backgroundspec : getenv(\"BACKGROUND\") ? getenv(\"BACKGROUND\") : DEFAULT_BACKGROUND, sizeof(bgspec) - 1);\n\n    char *bgc = NULL;\n    for (bgc = strtok(bgspec, \":\"); bgc != NULL && _nbgs < MAX_BACKGROUNDS; bgc = strtok(NULL, \":\")){\n        XColor xc = {0};\n        if (XAllocNamedColor(_dpy, DefaultColormap(_dpy, DefaultScreen(_dpy)), bgc, &xc, &xc))\n            _bgpixels[_nbgs++] = xc.pixel;\n    }\n\n    if (_nbgs == 0)\n        _bgpixels[_nbgs++] = ~_fgcolor.pixel;\n\n    _bgpixel = _bgpixels[0];\n\n    n = 0;\n    XtSetArg(args[n], XtNcomposeMod, &compose); n++;\n    XtGetValues(widg, args, n);\n\n    if (compose < 0 || compose > 5) {\n        n = 0;\n        XtSetArg(args[n], XtNcomposeMod, 0);    n++;\n        XtSetValues(widg, args, n);\n    }\n\n    initcursors();\n    atexit(freebindings);\n    atexit(freechords);\n\n    if ((xim = XOpenIM(_dpy, NULL, NULL, NULL)) == NULL) {\n        XSetLocaleModifiers(\"@im=local\");\n        if ((xim =  XOpenIM(_dpy, NULL, NULL, NULL)) == NULL) {\n            XSetLocaleModifiers(\"@im=\");\n            if ((xim = XOpenIM(_dpy, NULL, NULL, NULL)) == NULL) {\n                fprintf(stderr, \"could not open input method\\n\");\n                exit(EXIT_FAILURE);\n            }\n        }\n    }\n\n    font = XftFontOpenName(_dpy, DefaultScreen(_dpy), fontspec[0] ? fontspec : getenv(\"FONT\") ? getenv(\"FONT\") : \"monospace\");\n    screen.id = 0;\n    XtRealizeWidget(_toplevel);\n    _topwindow = XtWindow(_toplevel);\n    atexit(freefont);\n\n    pid_t pid = getpid();\n    XChangeProperty(_dpy, XtWindow(_toplevel), XInternAtom(_dpy, \"_NET_WM_PID\", False), XA_CARDINAL, 32, PropModeReplace, (unsigned char *)&pid, 1);\n\n    _fgpixel = _fgcolor.pixel;\n    _borderpixel = _bordercolor.pixel;\n\n    XRenderColor xrcolor = {0};\n    xrcolor.red = _fgcolor.red;\n    xrcolor.green = _fgcolor.green;\n    xrcolor.blue = _fgcolor.blue;\n    xrcolor.alpha = 65535;\n    XftColorAllocValue(_dpy, DefaultVisual(_dpy, DefaultScreen(_dpy)), DefaultColormap(_dpy, DefaultScreen(_dpy)), &xrcolor, &fontcolor);\n\n    screen.id = (int) XtWindow(widg);\n    screen.ldepth = ilog2(DefaultDepth(_dpy, DefaultScreen(_dpy)));\n    screen.flag = SCR;\n    if(_fgpixel != 0)\n        screen.flag |= BL1;\n    /* leave screen rect at all zeros until reshaped() sets it */\n    while(!exposed) {\n        XFlush(_dpy);\n        XtAppProcessEvent(app, XtIMXEvent);\n    }\n\n    darkgrey = balloc(Rect(0, 0, 16, 16), 0);\n    wrbitmap(darkgrey, 0, 16, darkgreybits);\n\n    XFlush(_dpy);\n    focinit(_toplevel);\n}\n\nstatic void\nfocinit(Widget w)\n{\n    XrmValue src, dst;\n\n    src.addr = \"WM_TAKE_FOCUS\";\n    src.size = strlen((char *)src.addr)+1;\n    dst.addr = (XtPointer) &wm_take_focus;\n    dst.size = sizeof(Atom);\n    XtConvertAndStore(w, XtRString, &src, XtRAtom, &dst);\n    XSetWMProtocols(XtDisplay(w), XtWindow(w), &wm_take_focus, 1);\n    XtAppAddActions(app, wmpactions, XtNumber(wmpactions));\n    XtAugmentTranslations(w, XtParseTranslationTable(shelltrans));\n}\n\nstatic void\nwmproto(Widget w, XEvent *e , String *p, Cardinal *np)\n{\n    Time t;\n\n    if(e->type == ClientMessage &&\n          (Atom)(e->xclient.data.l[0]) == wm_take_focus) {\n        t = (Time) e->xclient.data.l[1];\n        XtCallAcceptFocus(widg, &t);\n    }\n}\n\nstatic void\nreshaped(int minx, int miny, int maxx, int maxy)\n{\n    Ebuf *eb;\n\n    screen.r = Rect(minx, miny, maxx, maxy);\n    screen.clipr = screen.r;\n    if (screen.id) {\n        exposed = true;\n        ereshaped(screen.r);\n    }\n    if(einitcalled){\n        /*\n         * Cause a mouse event, so programs like sam\n         * will get out of eread and REALLY do the reshape\n         */\n        eb = ebadd(&esrc[Smouse], false);\n        if (eb == 0)\n            berror(\"eballoc can't malloc\");\n        memcpy((void*)eb->buf, (void*)&lastmouse, sizeof lastmouse);\n        esrc[Smouse].count++;\n    }\n}\n\nstatic void\ngotchar(int c, int kind, int target, int x, int y, const char *arg)\n{\n    Ebuf *eb;\n    Keystroke k;\n\n    if(!einitcalled || Skeyboard == -1)\n        return;\n    eb = ebadd(&esrc[Skeyboard], false);\n    if (eb == NULL)\n        berror(\"eballoc can't malloc\");\n    k.c = c;\n    k.k = kind;\n    k.t = target;\n    k.p = Pt(x, y);\n    k.a = arg;\n    memcpy(eb->buf, &k, sizeof(Keystroke));\n    esrc[Skeyboard].count++;\n}\n\nstatic void\ngotmouse(Gwinmouse *gm)\n{\n    Ebuf *eb;\n    Mouse m;\n\n    if(!einitcalled || Smouse == -1)\n        return;\n    m.buttons = gm->buttons;\n    m.xy.x = gm->xy.x;\n    m.xy.y = gm->xy.y;\n    m.msec = gm->msec;\n    lastmouse = m;\n    eb = ebadd(&esrc[Smouse], false);\n    if (eb == 0)\n        berror(\"eballoc can't malloc\");\n    memcpy((void*)eb->buf, (void*)&m, sizeof m);\n    esrc[Smouse].count++;\n}\n\nstatic void\ngotinput(XtPointer cldata, int *pfd, XtInputId *id)\n{\n    Ebuf *eb, *lasttail, *newe;\n    Esrc *es;\n    int n;\n\n    if(!einitcalled)\n        return;\n    es = (Esrc *)cldata;\n    if (es->count >= MAXINPUT)\n        return;\n    lasttail = es->tail;\n    eb = ebadd(es, false);\n    if (eb == 0)\n        return;\n    if(es->size){\n        if (es->issocket){\n            struct sockaddr addr;\n            socklen_t len;\n            int fd = accept(*pfd, &addr, &len);\n            n = read(fd, (char *)eb->buf, es->size);\n            close(fd);\n        } else\n            n = read(*pfd, (char *)eb->buf, es->size);\n        if (n < 0)\n            n = 0;\n        if(n < es->size) {\n            newe = realloc(eb, sizeof(Ebuf)+n);\n            newe->n = n;\n            if (es->head == eb)\n                es->head = newe;\n            else\n                lasttail->next = newe;\n            es->tail = newe;\n        }\n    }\n    es->count++;\n}\n\nstatic int\nilog2(int n)\n{\n    int i, v;\n\n    for(i=0, v=1; i < 6; i++, v<<=1)\n        if(n <= v)\n            break;\n    return i;\n}\n\n\nvoid\nrdcolmap(Bitmap *b, RGB *map)\n{\n    XColor cols[256];\n    int i, n, depth;\n    Colormap cmap;\n    Arg args[2];\n\n    if (_cmap_installed) {\n        cmap = _libg_cmap;\n    } else {\n        i = 0;\n        XtSetArg(args[i], XtNcolormap, &cmap);  i++;\n        XtGetValues(_toplevel, args, i);\n    }\n\n    depth = _ld2d[screen.ldepth];\n    n = 1 << depth;\n    if (depth == 1) {\n        map[0].red = map[0].green = map[0].blue = ~0;\n        map[1].red = map[1].green = map[1].blue = 0;\n    }\n    else {\n        if (n > 256) {\n            berror(\"rdcolmap bitmap too deep\");\n            return;\n        }\n        for (i = 0; i < n; i++)\n            cols[i].pixel = i;\n        XQueryColors(_dpy, cmap, cols, n);\n        for (i = 0; i < n; i++) {\n            map[i].red = (cols[i].red << 16) | cols[i].red;\n            map[i].green = (cols[i].green << 16) | cols[i].green;\n            map[i].blue = (cols[i].blue << 16) | cols[i].blue;\n        }\n    }\n}\n\nvoid\nwrcolmap(Bitmap *b, RGB *map)\n{\n    int i, n, depth;\n    Screen *scr;\n    XColor cols[256];\n    Arg args[2];\n    XVisualInfo vi;\n    Window w;\n\n    scr = XtScreen(_toplevel);\n    depth = _ld2d[screen.ldepth];\n    n = 1 << depth;\n    if (n > 256) {\n        berror(\"wrcolmap bitmap too deep\");\n        return;\n    } else if (depth > 1) {\n        for (i = 0; i < n; i++) {\n            cols[i].red = map[i].red >> 16;\n            cols[i].green = map[i].green >> 16;\n            cols[i].blue = map[i].blue >> 16;\n            cols[i].pixel = i;\n            cols[i].flags = DoRed|DoGreen|DoBlue;\n        }\n        if (!XMatchVisualInfo(_dpy, XScreenNumberOfScreen(scr),\n                    depth, PseudoColor, &vi)) {\n            berror(\"wrcolmap can't get visual\");\n            return;\n        }\n        w = XtWindow(_toplevel);\n        _libg_cmap = XCreateColormap(_dpy, w, vi.visual, AllocAll);\n        XStoreColors(_dpy, _libg_cmap, cols, n);\n\n        i = 0;\n        XtSetArg(args[i], XtNcolormap, _libg_cmap); i++;\n        XtSetValues(_toplevel, args, i);\n        _cmap_installed = 1;\n    }\n}\n\nvoid\neinit(uint64_t keys)\n{\n    /*\n     * Make sure Smouse = ilog2(Emouse) and Skeyboard == ilog2(Ekeyboard)\n     */\n    nsrc = 0;\n    if(keys&Emouse){\n        Smouse = 0;\n        esrc[Smouse].inuse = true;\n        esrc[Smouse].size = sizeof(Mouse);\n        esrc[Smouse].count = 0;\n        nsrc = Smouse+1;\n    }\n    if(keys&Ekeyboard){\n        Skeyboard = 1;\n        esrc[Skeyboard].inuse = true;\n        esrc[Skeyboard].size = sizeof(Keystroke);\n        esrc[Skeyboard].count = 0;\n        if(Skeyboard >= nsrc)\n            nsrc = Skeyboard+1;\n    }\n    einitcalled = 1;\n}\n\nuint64_t\nestart(uint64_t key, int fd, size_t n, bool issocket)\n{\n    int i;\n\n    if(fd < 0)\n        berror(\"bad fd to estart\");\n    if(n <= 0 || n > EMAXMSG)\n        n = EMAXMSG;\n    for(i=0; i<MAXSRC; i++)\n        if((key & ~(1<<i)) == 0 && !esrc[i].inuse){\n            if(nsrc <= i)\n                nsrc = i+1;\n            esrc[i].inuse = true;\n            esrc[i].issocket = issocket;\n            esrc[i].size = n;\n            esrc[i].count = 0;\n            XtAppAddInput(app, fd, (XtPointer)XtInputReadMask,\n                gotinput, (XtPointer) &esrc[i]);\n            return 1<<i;\n        }\n    return 0;\n}\n\nuint64_t\nevent(Event *e)\n{\n    return eread(~0L, e);\n}\n\nuint64_t\neread(uint64_t keys, Event *e)\n{\n    Ebuf *eb;\n    int i;\n\n    if(keys == 0)\n        return 0;\n        /* Give Priority to X events */\n    if (XtAppPending(app) & XtIMXEvent)\n        XtAppProcessEvent(app, XtIMXEvent);\n\n    for(;;){\n        for(i=0; i<nsrc; i++)\n            if((keys & (1<<i)) && esrc[i].head){\n                if(i == Smouse)\n                    e->mouse = emouse();\n                else if(i == Skeyboard)\n                    e->keystroke = ekbd();\n                else {\n                    eb = ebread(&esrc[i]);\n                    e->n = eb->n;\n                    if(e->n > 0)\n                        memcpy((void*)e->data, (void*)eb->buf, e->n);\n                    free(eb);\n                }\n                return 1<<i;\n            }\n        waitevent();\n    }\n}\n\nMouse\nemouse(void)\n{\n    Mouse m;\n    Ebuf *eb;\n\n    if(!esrc[Smouse].inuse)\n        berror(\"mouse events not selected\");\n    eb = ebread(&esrc[Smouse]);\n    memcpy((void*)&m, (void*)eb->buf, sizeof(Mouse));\n    free(eb);\n    return m;\n}\n\nKeystroke\nekbd(void)\n{\n    Ebuf *eb;\n    Keystroke k;\n\n    if(!esrc[Skeyboard].inuse)\n        berror(\"keyboard events not selected\");\n    eb = ebread(&esrc[Skeyboard]);\n    memcpy(&k, eb->buf, sizeof(Keystroke));\n    free(eb);\n    return k;\n}\n\nvoid\npushkbd(int c)\n{\n    Ebuf *eb;\n    Keystroke k;\n\n    if(!einitcalled || Skeyboard == -1)\n        return;\n    eb = ebadd(&esrc[Skeyboard], true);\n    if (eb == 0)\n        berror(\"eballoc can't malloc\");\n    k.c = c;\n    k.k = Kraw;\n    memcpy(eb->buf, &k, sizeof(Keystroke));\n    esrc[Skeyboard].count++;\n}\n\nint\necanread(uint64_t keys)\n{\n    int i;\n\n    for(;;){\n        for(i=0; i<nsrc; i++){\n            if((keys & (1<<i)) && esrc[i].head)\n                return 1<<i;\n        }\n        if(XtAppPending(app))\n            waitevent();\n        else\n            return 0;\n    }\n}\n\nint\necanmouse(void)\n{\n    if(Smouse == -1)\n        berror(\"mouse events not selected\");\n    return ecanread(Emouse);\n}\n\nint\necankbd(void)\n{\n    if(Skeyboard == -1)\n        berror(\"keyboard events not selected\");\n    return ecanread(Ekeyboard);\n}\n\nstatic Ebuf*\nebread(Esrc *s)\n{\n    Ebuf *eb;\n\n    while(s->head == 0)\n        waitevent();\n    eb = s->head;\n    if(s == &esrc[Smouse]) {\n        while(eb->next) {\n            s->head = eb->next;\n            s->count--;\n            free(eb);\n            eb = s->head;\n        }\n    }\n    s->head = s->head->next;\n    if(s->head == 0) {\n        s->tail = 0;\n        s->count = 0;\n    } else\n        s->count--;\n    return eb;\n}\n\nstatic inline void\nebappend(Ebuf *b, Esrc *s)\n{\n    if (s->tail){\n        s->tail->next = b;\n        s->tail = b;\n    } else\n        s->head = s->tail = b;\n}\n\nstatic inline void\nebprepend(Ebuf *b, Esrc *s)\n{\n    b->next = s->head;\n    s->head = b;\n}\n\nstatic Ebuf*\nebadd(Esrc *s, bool prepend)\n{\n    Ebuf *eb;\n    int m;\n\n    m = sizeof(Ebuf);\n    if(s->size > 1)\n        m += (s->size-1);   /* overestimate, because of alignment */\n    eb = (Ebuf *)malloc(m);\n    if(eb) {\n        eb->next = 0;\n        eb->n = s->size;\n        if (prepend)\n            ebprepend(eb, s);\n        else\n            ebappend(eb, s);\n    }\n    return eb;\n}\n\nvoid\nberror(char *s)\n{\n    if(onerr)\n        (*onerr)(s);\n    else{\n        fprintf(stderr, \"libg error: %s:\\n\", s);\n        exit(1);\n    }\n}\n\nvoid\nbflush(void)\n{\n    while(XtAppPending(app) & XtIMXEvent)\n        waitevent();\n}\n\nstatic void\nwaitevent(void)\n{\n    XFlush(_dpy);\n    if (XtAppPending(app) & XtIMXEvent)\n        XtAppProcessEvent(app, XtIMXEvent);\n    else\n        XtAppProcessEvent(app, XtIMAll);\n}\n        \nint\nsnarfswap(char *s, int n, char **t)\n{\n    *t = GwinSelectionSwap(widg, s);\n    if (*t)\n        return strlen(*t);\n    return 0;\n}\n\nint scrpix(int *w, int *h)\n{\n    if (w)\n        *w = WidthOfScreen(XtScreen(_toplevel));\n    if (h)\n        *h = HeightOfScreen(XtScreen(_toplevel));\n    return 1;\n}\n\n#ifdef DEBUG\n/* for debugging */\nprintgc(char *msg, GC g)\n{\n    XGCValues v;\n\n    XGetGCValues(_dpy, g, GCFunction|GCForeground|GCBackground|GCFont|\n            GCTile|GCFillStyle|GCStipple, &v);\n    fprintf(stderr, \"%s: gc %x\\n\", msg, g);\n    fprintf(stderr, \"  fg %d bg %d func %d fillstyle %d font %x tile %x stipple %x\\n\",\n        v.foreground, v.background, v.function, v.fill_style,\n        v.font, v.tile, v.stipple);\n}\n#endif\n\nvoid\nraisewindow(void)\n{\n    XEvent e;\n    Atom a = XInternAtom(_dpy, \"_NET_ACTIVE_WINDOW\", True);\n\n    XRaiseWindow(_dpy, _topwindow);\n\n    if (a != None){\n        memset(&e, 0, sizeof(XEvent));\n        e.type = ClientMessage;\n        e.xclient.window = _topwindow;\n        e.xclient.message_type = a;\n        e.xclient.format = 32;\n        e.xclient.data.l[0] = 1;\n        e.xclient.data.l[1] = CurrentTime;\n        e.xclient.data.l[2] = None;\n        e.xclient.data.l[3] = 0;\n        e.xclient.data.l[4] = 0;\n\n        XSendEvent(_dpy, DefaultRootWindow(_dpy), False,\n                   SubstructureRedirectMask | SubstructureNotifyMask, &e);\n    }\n\n    XFlush(_dpy);\n}\n\nuint64_t\ngetbg(void)\n{\n    static int i = 0;\n\n    if (i >= _nbgs)\n        i = 0;\n\n    return _bgpixels[i++];\n}\n\n", "source": "sam/libXg/xtbinit.c", "file_type": "c"}
{"text": "/* Copyright (c) 1998 Lucent Technologies - All rights reserved. */\n#include <u.h>\n#include <libg.h>\n#include \"libgint.h\"\n\nenum\n{\n    Margin = 3,     /* outside to text */\n    Border = 2,     /* outside to selection boxes */\n    Blackborder = 1,    /* width of outlining border */\n    Vspacing = 1,       /* extra spacing between lines of text */\n    Maxunscroll = 25,   /* maximum #entries before scrolling turns on */\n    Nscroll = 20,       /* number entries in scrolling part */\n    Scrollwid = 14,     /* width of scroll bar */\n    Gap = 4         /* between text and scroll bar */\n};\n\nextern Bitmap *darkgrey;\n\nstatic int\nfontheight() {\n    return font->ascent + font->descent;\n}\n\n/*\n * r is a rectangle holding the text elements.\n * return the rectangle, including its black edge, holding element i.\n */\nstatic Rectangle\nmenurect(Rectangle r, int i)\n{\n    if(i < 0)\n        return Rect(0, 0, 0, 0);\n    r.min.y += (fontheight()+Vspacing)*i;\n    r.max.y = r.min.y+fontheight()+Vspacing;\n    return inset(r, Border-Margin);\n}\n\n/*\n * r is a rectangle holding the text elements.\n * return the element number containing p.\n */\nstatic int\nmenusel(Rectangle r, Point p)\n{\n    if(!ptinrect(p, r))\n        return -1;\n    return (p.y-r.min.y)/(fontheight()+Vspacing);\n}\n\n/*\n * menur is a rectangle holding all the highlightable text elements.\n * track mouse while inside the box, return what's selected when button\n * is raised, -1 as soon as it leaves box.\n * invariant: nothing is highlighted on entry or exit.\n */\nstatic int\nmenuscan(int but, Mouse *m, Rectangle menur, int lasti)\n{\n    int i;\n    Rectangle r;\n\n    r = menurect(menur, lasti);\n    bitblt(&screen, r.min, &screen, r, F&~D);\n    *m = emouse();\n    while(m->buttons & (1<<(but-1))){\n        *m = emouse();\n        i = menusel(menur, m->xy);\n        if(i == lasti)\n            continue;\n        bitblt(&screen, r.min, &screen, r, F&~D);\n        if(i == -1)\n            return i;\n        r = menurect(menur, i);\n        bitblt(&screen, r.min, &screen, r, F&~D);\n        lasti = i;\n    }\n    return lasti;\n}\n\nvoid\nmenupaint(Menu *menu, Rectangle textr, int off, int nitemdrawn)\n{\n    int i;\n    Point pt;\n    Rectangle r;\n    char *item;\n\n    r = inset(textr, Border-Margin);\n    bitblt(&screen, r.min, &screen, r, 0);\n    pt = Pt(textr.min.x+textr.max.x, textr.min.y);\n    for(i = 0; i<nitemdrawn; i++, pt.y += fontheight()+Vspacing){\n        item = menu->item? menu->item[i+off] : (*menu->gen)(i+off);\n        string(&screen,\n            Pt((pt.x-strwidth(font, item))/2, pt.y),\n            font, item, S);\n    }\n}\n\nstatic void\nmenuscrollpaint(Rectangle scrollr, int off, int nitem, int nitemdrawn)\n{\n    Rectangle r;\n\n    bitblt(&screen, scrollr.min, &screen, scrollr, 0);\n    r.min.x = scrollr.min.x;\n    r.max.x = scrollr.max.x;\n    r.min.y = scrollr.min.y + (Dy(scrollr)*off)/nitem;\n    r.max.y = scrollr.min.y + (Dy(scrollr)*(off+nitemdrawn))/nitem;\n    if(r.max.y < r.min.y+2)\n        r.max.y = r.min.y+2;\n    border(&screen, r, 1, F, _bgpixel);\n    if(darkgrey)\n        texture(&screen, inset(r, 1), darkgrey, S);\n}\n\nint\nmenuhit(int but, Mouse *m, Menu *menu)\n{\n    int i, nitem, nitemdrawn, maxwid, lasti, off, noff, wid, screenitem;\n    bool scrolling;\n    Rectangle r, menur, sc, textr, scrollr;\n    Bitmap *b;\n    Point pt;\n    char *item;\n    extern unsigned int cursor;\n    unsigned int oldcursor = cursor;\n\n    cursorswitch(ArrowCursor);\n    sc = screen.clipr;\n    clipr(&screen, screen.r);\n    maxwid = 0;\n    for(nitem = 0;\n        (item = menu->item? menu->item[nitem] : (*menu->gen)(nitem));\n        nitem++){\n        i = strwidth(font, item);\n        if(i > maxwid)\n            maxwid = i;\n    }\n    if(menu->lasthit<0 || menu->lasthit>=nitem)\n        menu->lasthit = 0;\n    screenitem = (Dy(screen.r)-10)/(fontheight()+Vspacing);\n    if(nitem>Maxunscroll || nitem>screenitem){\n        scrolling = true;\n        nitemdrawn = Nscroll;\n        if(nitemdrawn > screenitem)\n            nitemdrawn = screenitem;\n        wid = maxwid + Gap + Scrollwid;\n        off = menu->lasthit - nitemdrawn/2;\n        if(off < 0)\n            off = 0;\n        if(off > nitem-nitemdrawn)\n            off = nitem-nitemdrawn;\n        lasti = menu->lasthit-off;\n    }else{\n        scrolling = false;\n        nitemdrawn = nitem;\n        wid = maxwid;\n        off = 0;\n        lasti = menu->lasthit;\n    }\n    r = inset(Rect(0, 0, wid, nitemdrawn*(fontheight()+Vspacing)), -Margin);\n    r = rsubp(r, Pt(wid/2, lasti*(fontheight()+Vspacing)+fontheight()/2));\n    r = raddp(r, m->xy);\n    pt = Pt(0, 0);\n    if(r.max.x>screen.r.max.x)\n        pt.x = screen.r.max.x-r.max.x;\n    if(r.max.y>screen.r.max.y)\n        pt.y = screen.r.max.y-r.max.y;\n    if(r.min.x<screen.r.min.x)\n        pt.x = screen.r.min.x-r.min.x;\n    if(r.min.y<screen.r.min.y)\n        pt.y = screen.r.min.y-r.min.y;\n    menur = raddp(r, pt);\n    textr.max.x = menur.max.x-Margin;\n    textr.min.x = textr.max.x-maxwid;\n    textr.min.y = menur.min.y+Margin;\n    textr.max.y = textr.min.y + nitemdrawn*(fontheight()+Vspacing);\n    if(scrolling){\n        scrollr = inset(menur, Border);\n        scrollr.max.x = scrollr.min.x+Scrollwid;\n    }else\n        scrollr = Rect(0, 0, 0, 0);\n\n    b = balloc(menur, screen.ldepth);\n    if(b == 0)\n        b = &screen;\n    bitblt(b, menur.min, &screen, menur, S);\n    bitblt(&screen, menur.min, &screen, menur, 0);\n    border(&screen, menur, Blackborder, F, _bgpixel);\n    r = menurect(textr, lasti);\n    cursorset(divpt(add(r.min, r.max), 2));\n    menupaint(menu, textr, off, nitemdrawn);\n    if(scrolling)\n        menuscrollpaint(scrollr, off, nitem, nitemdrawn);\n    r = menurect(textr, lasti);\n    cursorset(divpt(add(r.min, r.max), 2));\n    menupaint(menu, textr, off, nitemdrawn);\n    if(scrolling)\n        menuscrollpaint(scrollr, off, nitem, nitemdrawn);\n    while(m->buttons & (1<<(but-1))){\n        lasti = menuscan(but, m, textr, lasti);\n        if(lasti >= 0)\n            break;\n        while(!ptinrect(m->xy, textr) && (m->buttons & (1<<(but-1)))){\n            if(scrolling && ptinrect(m->xy, scrollr)){\n                noff = ((m->xy.y-scrollr.min.y)*nitem)/Dy(scrollr);\n                noff -= nitemdrawn/2;\n                if(noff < 0)\n                    noff = 0;\n                if(noff > nitem-nitemdrawn)\n                    noff = nitem-nitemdrawn;\n                if(noff != off){\n                    off = noff;\n                    menupaint(menu, textr, off, nitemdrawn);\n                    menuscrollpaint(scrollr, off, nitem, nitemdrawn);\n                }\n            }\n            *m = emouse();\n        }\n    }\n    bitblt(&screen, menur.min, b, menur, S);\n    if(b != &screen)\n        bfree(b);\n    clipr(&screen, sc);\n    if(lasti >= 0){\n        menu->lasthit = lasti+off;\n        return cursorswitch(oldcursor), menu->lasthit;\n    }\n    cursorswitch(oldcursor);\n    return -1;\n}\n", "source": "sam/libXg/menuhit.c", "file_type": "c"}
{"text": "/* Copyright (c) 1998 Lucent Technologies - All rights reserved. */\n#include <u.h>\n#include <libg.h>\n#include <stdio.h>\n#include <X11/IntrinsicP.h>\n#include <X11/StringDefs.h>\n#include <X11/Xatom.h>\n#include <X11/XKBlib.h>\n#include <X11/keysym.h>\n\n#include \"GwinP.h\"\n#include \"libgint.h\"\n\nconst char *clipatom = \"PRIMARY\";\n\n/* Forward declarations */\nstatic void Realize(Widget, XtValueMask *, XSetWindowAttributes *);\nstatic void Resize(Widget);\nstatic void Redraw(Widget, XEvent *, Region);\nstatic void Mappingaction(Widget, XEvent *, String *, Cardinal*);\nstatic void Keyaction(Widget, XEvent *, String *, Cardinal*);\nstatic void Mouseaction(Widget, XEvent *, String *, Cardinal*);\nstatic String SelectSwap(Widget, String);\n\n/* Data */\n\n#define Offset(field) XtOffsetOf(GwinRec, gwin.field)\n\nstatic XtResource resources[] = {\n    {XtNforeground, XtCForeground, XtRPixel, sizeof(Pixel),\n        Offset(foreground), XtRString, (XtPointer)XtDefaultForeground},\n    {XtNscrollForwardR, XtCScrollForwardR, XtRBoolean, sizeof(Boolean),\n        Offset(forwardr), XtRImmediate, (XtPointer)true},\n    {XtNreshaped, XtCReshaped, XtRFunction, sizeof(Reshapefunc),\n        Offset(reshaped), XtRFunction, (XtPointer) NULL},\n    {XtNgotchar, XtCGotchar, XtRFunction, sizeof(Charfunc),\n        Offset(gotchar), XtRFunction, (XtPointer) NULL},\n    {XtNgotmouse, XtCGotmouse, XtRFunction, sizeof(Mousefunc),\n        Offset(gotmouse), XtRFunction, (XtPointer) NULL},\n    {XtNselection, XtCSelection, XtRString, sizeof(String),\n        Offset(selection), XtRString, (XtPointer) NULL},\n};\n#undef Offset\n\nstatic XtActionsRec actions[] = {\n    {\"key\", Keyaction},\n    {\"mouse\", Mouseaction},\n    {\"mapping\", Mappingaction}\n};\n\nstatic char tms[] =\n    \"<Key> : key() \\n\\\n    <Motion> : mouse() \\n\\\n    <BtnDown> : mouse() \\n\\\n    <BtnUp> : mouse() \\n\\\n    <Mapping> : mapping() \\n\";\n\n/* Class record declaration */\n\nGwinClassRec gwinClassRec = {\n  /* Core class part */\n   {\n    /* superclass         */    (WidgetClass)&widgetClassRec,\n    /* class_name         */    \"Gwin\",\n    /* widget_size        */    sizeof(GwinRec),\n    /* class_initialize   */    NULL,\n    /* class_part_initialize*/  NULL,\n    /* class_inited       */    false,\n    /* initialize         */    NULL,\n    /* initialize_hook    */    NULL,\n    /* realize            */    Realize,\n    /* actions            */    actions,\n    /* num_actions        */    XtNumber(actions),\n    /* resources          */    resources,\n    /* num_resources      */    XtNumber(resources),\n    /* xrm_class          */    NULLQUARK,\n    /* compress_motion    */    true,\n    /* compress_exposure  */    XtExposeCompressMultiple,\n    /* compress_enterleave*/    true,\n    /* visible_interest   */    false,\n    /* destroy            */    NULL,\n    /* resize             */    Resize,\n    /* expose             */    Redraw,\n    /* set_values         */    NULL,\n    /* set_values_hook    */    NULL,\n    /* set_values_almost  */    XtInheritSetValuesAlmost,\n    /* get_values_hook    */    NULL,\n    /* accept_focus       */    XtInheritAcceptFocus,\n    /* version            */    XtVersion,\n    /* callback_offsets   */    NULL,\n    /* tm_table           */    tms,\n    /* query_geometry       */  XtInheritQueryGeometry,\n    /* display_accelerator  */  NULL,\n    /* extension            */  NULL\n   },\n  /* Gwin class part */\n   {\n    /* select_swap    */    SelectSwap,\n   }\n};\n\n/* Class record pointer */\nWidgetClass gwinWidgetClass = (WidgetClass) &gwinClassRec;\n\nstatic XModifierKeymap *modmap;\nstatic int keypermod;\nextern XIC xic;\nextern XIM xim;\n\nstatic void\nRealize(Widget w, XtValueMask *valueMask, XSetWindowAttributes *attrs)\n{\n    *valueMask |= CWBackingStore;\n    attrs->backing_store = Always;\n\n    XtCreateWindow(w, InputOutput, (Visual *)0, *valueMask, attrs);\n    XtSetKeyboardFocus(w->core.parent, w);\n    if ((modmap = XGetModifierMapping(XtDisplay(w))))\n        keypermod = modmap->max_keypermod;\n\n    Resize(w);\n\n    xic = XCreateIC(xim, XNInputStyle, XIMPreeditNothing | XIMStatusNothing,\n                    XNClientWindow, XtWindow(w), XNFocusWindow, XtWindow(w), NULL);\n    if (!xic){\n        fprintf(stderr, \"could not create input context\\n\");\n        exit(EXIT_FAILURE);\n    }\n}\n\nstatic void\nResize(Widget w)\n{\n    if(XtIsRealized(w))\n        (*(XtClass(w)->core_class.expose))(w, (XEvent *)NULL, (Region)NULL);\n}\n\nstatic void\nRedraw(Widget w, XEvent *e, Region r)\n{\n    Reshapefunc f;\n\n    f = ((GwinWidget)w)->gwin.reshaped;\n    if(f)\n        (*f)(w->core.x, w->core.y,\n            w->core.x+w->core.width, w->core.y+w->core.height);\n}\n\nstatic void\nMappingaction(Widget w, XEvent *e, String *p, Cardinal *np)\n{\n    if (modmap)\n        XFreeModifiermap(modmap);\n    modmap = XGetModifierMapping(e->xany.display);\n    if (modmap)\n        keypermod = modmap->max_keypermod;\n}\n\ntypedef struct Unikeysym Unikeysym;\nstruct Unikeysym{\n    KeySym keysym;\n    uint16_t value;\n};\n\nUnikeysym unikeysyms[] ={\n    #include \"unikeysyms.h\"\n    {0, 0}\n};\n\nuint16_t\nkeysymtoshort(KeySym k)\n{\n    for (Unikeysym *ks = unikeysyms; ks->keysym != 0; ks++){\n        if (k == ks->keysym)\n            return ks->value;\n    }\n\n    return k;\n}\n\ntypedef struct Keymapping Keymapping;\nstruct Keymapping{\n    Keymapping *next;\n    int m;\n    KeySym s;\n    int k;\n    int c;\n    char a[];\n};\n\nstatic Keymapping *keymappings = NULL;\n\nint\ninstallbinding(int m, KeySym s, int k, int c, const char *a)\n{\n    if (m < 0 || s == NoSymbol || k < 0 || c < 0)\n        return -1;\n\n    a = a ? a : \"\";\n    Keymapping *km = calloc(1, sizeof(Keymapping) + strlen(a) + 1);\n    if (!km)\n        return -1;\n\n    km->m = m;\n    km->s = s;\n    km->k = k;\n    km->c = c;\n    strcpy(km->a, a);\n    km->next = keymappings;\n    keymappings = km;\n\n    return 0;\n}\n\nint\nremovebinding(int m, KeySym s)\n{\n    if (m < 0 || s == NoSymbol)\n        return -1;\n\n    for (Keymapping *km = keymappings; km; km = km->next){\n        if (km->m == m && km->s == s)\n            km->c = Cdefault;\n    }\n\n    return 0;\n}\n\nvoid\nfreebindings(void)\n{\n    Keymapping *m = keymappings;\n    while (m){\n        Keymapping *n = m->next;\n        free(m);\n        m = n;\n    }\n}\n\nstatic void\nKeyaction(Widget w, XEvent *e, String *p, Cardinal *np)\n{\n    extern XIC xic;\n    int kind = Kraw;\n\n    int c, len, minmod;\n    KeySym k, mk;\n    Charfunc f;\n    Modifiers md;\n    Status s;\n    wchar_t buf[32] = {0};\n\n    c = 0;\n    len = 0;\n\n    /* Translate the keycode into a key symbol. */\n    if(e->xany.type != KeyPress)\n        return;\n\n    len = XwcLookupString(xic, &e->xkey, buf, 32, &k, &s);\n    if (IsModifierKey(k))\n        return;\n\n    /* Check to see if it's a specially-handled key first. */\n    for (Keymapping *m = keymappings; m; m = m->next){\n        KeySym u = NoSymbol;\n        KeySym l = NoSymbol;\n        XConvertCase(k, &l, &u);\n\n        /* Note that magic bit manipulation here - we want to check that the\n         * modifiers that are specified for the binding are all pressed, but\n         * we allow other modifiers to be as well. This is because when NumLock\n         * is on, it's always added to the modifier mask.\n         */\n        if (l == m->s || m->s == XK_VoidSymbol){\n            if (m->m == 0 || (m->m & ~e->xkey.state) == 0){\n                switch (m->c){\n                    case Cnone:\n                        return;\n\n                    case Cdefault:\n                        continue;\n\n                    default:\n                        f = ((GwinWidget)w)->gwin.gotchar;\n                        if (f)\n                            (*f)(m->c, m->k, Tcurrent, 0, 0, m->a);\n                        return;\n                }\n            }\n        }\n    }\n\n    c = keysymtoshort(k);\n    f = ((GwinWidget)w)->gwin.gotchar;\n    if(f && c)\n        (*f)(c? c : buf[0], kind, Tcurrent, 0, 0, NULL);\n}\n\ntypedef struct Chordmapping Chordmapping;\nstruct Chordmapping{\n    Chordmapping *next;\n    int s1;\n    int s2;\n    int c;\n    int t;\n    const char *a;\n};\n\nstatic Chordmapping *chordmap = NULL;\n\nint\ninstallchord(int s1, int s2, int c, int t, const char *a)\n{\n    if (s1 < 0 || s2 < 0 || c < 0 || (t != Tmouse && t != Tcurrent))\n        return -1;\n\n    Chordmapping *m = calloc(1, sizeof(Chordmapping));\n    if (!m)\n        return -1;\n\n    m->s1 = s1;\n    m->s2 = s2;\n    m->c = c;\n    m->t = t;\n    m->a = a;\n\n    m->next = chordmap;\n    chordmap = m;\n    return 0;\n}\n\nint\nremovechord(int s1, int s2)\n{\n    if (s1 < 0 || s2 < 0)\n        return -1;\n\n    for (Chordmapping *m = chordmap; m; m = m->next){\n        if (m->s1 == s1 && m->s2 == s2)\n            m->c = Cdefault;\n    }\n\n    return 0;\n}\n\nvoid\nfreechords(void)\n{\n    Chordmapping *m = chordmap;\n    while (m){\n        Chordmapping *n = m->next;\n        free(m);\n        m = n;\n    }\n}\n\nstatic void\nMouseaction(Widget w, XEvent *e, String *p, Cardinal *np)\n{\n    int s = 0;\n    int ps = 0; /* the previous state */\n    int ob = 0;\n    static bool chording = false;\n    Charfunc kf;\n\n    XButtonEvent *be = (XButtonEvent *)e;\n    XMotionEvent *me = (XMotionEvent *)e;\n    Gwinmouse m;\n    Mousefunc f;\n\n    switch(e->type){\n    case ButtonPress:\n        m.xy.x = be->x;\n        m.xy.y = be->y;\n        m.msec = be->time;\n        ps = s = be->state;\n        switch(be->button){\n        case 1: s |= Button1Mask; break;\n        case 2: s |= Button2Mask; break;\n        case 3: s |= Button3Mask; break;\n        case 4: s |= Button4Mask; break;\n        case 5: s |= Button5Mask; break;\n        }\n        break;\n    case ButtonRelease:\n        m.xy.x = be->x;\n        m.xy.y = be->y;\n        m.msec = be->time;\n        ps = s = be->state;\n        switch(be->button){\n        case 1: s &= ~Button1Mask; break;\n        case 2: s &= ~Button2Mask; break;\n        case 3: s &= ~Button3Mask; break;\n        case 4: s &= ~Button4Mask; break;\n        case 5: s &= ~Button5Mask; break;\n        }\n        break;\n    case MotionNotify:\n        ps = s = me->state;\n        m.xy.x = me->x;\n        m.xy.y = me->y;\n        m.msec = me->time;\n        break;\n    default:\n        return;\n    }\n\n    m.buttons = 0;\n\n    if(ps & Button1Mask) ob |= 1;\n    if(ps & Button2Mask) ob |= 2;\n    if(ps & Button3Mask) ob |= (s & ShiftMask) ? 2 : 4;\n    if(ps & Button4Mask) ob |= 8;\n    if(ps & Button5Mask) ob |= 16;\n\n    if(s & Button1Mask) m.buttons |= 1;\n    if(s & Button2Mask) m.buttons |= 2;\n    if(s & Button3Mask) m.buttons |= (s & ShiftMask) ? 2 : 4;\n    if(s & Button4Mask) m.buttons |= 8;\n    if(s & Button5Mask) m.buttons |= 16;\n\n    if (!m.buttons)\n        chording = false;\n\n    /* Check to see if it's a chord first. */\n    for (Chordmapping *cm = chordmap; cm; cm = cm->next){\n        if (ob == cm->s1 && m.buttons == cm->s2){\n            switch (cm->c){\n                case Cdefault:\n                    continue;\n\n                case Cnone:\n                    break;\n\n                default:\n                    kf = ((GwinWidget)w)->gwin.gotchar;\n                    if (kf)\n                        (*kf)(cm->c, Kcommand, cm->t, m.xy.x, m.xy.y, NULL);\n        \n                    m.buttons = 0;\n                    chording = true;\n                    break;\n            }\n        }\n    }\n\n    if (chording)\n        m.buttons = 0;\n\n    f = ((GwinWidget)w)->gwin.gotmouse;\n    if(f)\n        (*f)(&m);\n}\n\nstatic void\nSelCallback(Widget w, XtPointer cldata, Atom *sel, Atom *seltype,\n    XtPointer val, uint64_t *len, int *fmt)\n{\n    GwinWidget gw = (GwinWidget)w;\n    XTextProperty p = {0};\n    char *ls[2] = {(char *)val, NULL};\n\n    gw->gwin.selxfered = true;\n    if (*seltype == 0){\n        if (gw->gwin.selection == NULL)\n            gw->gwin.selection = strdup(\"\");\n        return;\n    }\n\n    if(gw->gwin.selection){\n        XtFree(gw->gwin.selection);\n        gw->gwin.selection = NULL;\n    }\n\n    if(*seltype != XInternAtom(_dpy, \"UTF8_STRING\", 0))\n        return;\n\n    if (XmbTextListToTextProperty(_dpy, ls, 1, XUTF8StringStyle, &p) != Success)\n        return;\n\n    gw->gwin.selection = strdup(p.value);\n    XtFree(val);\n    XFree(p.value);\n}\n\nstatic Boolean\nSendSel(Widget w, Atom *sel, Atom *target, Atom *rtype, XtPointer *ans,\n        uint64_t *anslen, int *ansfmt)\n{\n    GwinWidget gw = (GwinWidget)w;\n    XTextProperty p = {0};\n    char *ls[2] = {NULL, NULL};\n\n    if ((*target == XA_STRING) ||\n        (*target == XInternAtom(_dpy, \"UTF8_STRING\", 0))){\n        ls[0] = gw->gwin.selection? gw->gwin.selection : \"\";\n        if (XmbTextListToTextProperty(_dpy, ls, 1, XUTF8StringStyle, &p) != Success)\n            return false;\n\n        *rtype = p.encoding;\n        *ans = (XtPointer) XtNewString(p.value);\n        *anslen = p.nitems;\n        *ansfmt = p.format;\n        XFree(p.value);\n        return true;\n    }\n\n    return false;\n}\n\nstatic String\nSelectSwap(Widget w, String s)\n{\n    GwinWidget gw;\n    String ans;\n\n    gw = (GwinWidget)w;\n    gw->gwin.selxfered = false;\n    XtGetSelectionValue(w, XInternAtom(_dpy, clipatom, 0), XInternAtom(_dpy, \"UTF8_STRING\", 0), SelCallback, 0,\n            XtLastTimestampProcessed(XtDisplay(w)));\n\n    while(gw->gwin.selxfered == false)\n        XtAppProcessEvent(XtWidgetToApplicationContext(w) , XtIMAll);\n    ans = gw->gwin.selection;\n    gw->gwin.selection = XtMalloc(strlen(s)+1);\n    strcpy(gw->gwin.selection, s);\n\n    XtOwnSelection(w, XInternAtom(_dpy, clipatom, 0), XtLastTimestampProcessed(XtDisplay(w)),\n            SendSel, NULL, NULL);\n\n    return ans;\n}\n\n/* The returned answer should be free()ed when no longer needed */\nString\nGwinSelectionSwap(Widget w, String s)\n{\n    XtCheckSubclass(w, gwinWidgetClass, NULL);\n    return (*((GwinWidgetClass) XtClass(w))->gwin_class.select_swap)(w, s);\n}\n", "source": "sam/libXg/gwin.c", "file_type": "c"}
{"text": "/* Copyright (c) 1998 Lucent Technologies - All rights reserved. */\n#include <u.h>\n#include <libg.h>\n#include \"libgint.h\"\n\n/*\n * Only allow cursor to move within screen Bitmap\n */\nvoid\ncursorset(Point p)\n{\n    /* motion will be relative to window origin */\n    p = sub(p, screen.r.min);\n    XWarpPointer(_dpy, None, (Window)screen.id, 0, 0, 0, 0, p.x, p.y);\n}\n", "source": "sam/libXg/cursorset.c", "file_type": "c"}
{"text": "/* Copyright (c) 1998 Lucent Technologies - All rights reserved. */\n#include <u.h>\n#include <libg.h>\n\nPoint\nadd(Point a, Point b)\n{\n    a.x += b.x;\n    a.y += b.y;\n    return a;\n}\n\nPoint\nsub(Point a, Point b)\n{\n    a.x -= b.x;\n    a.y -= b.y;\n    return a;\n}\n\nRectangle\ninset(Rectangle r, int n)\n{\n    r.min.x += n;\n    r.min.y += n;\n    r.max.x -= n;\n    r.max.y -= n;\n    return r;\n}\n\nPoint\ndivpt(Point a, int b)\n{\n    a.x /= b;\n    a.y /= b;\n    return a;\n}\n\nPoint\nmul(Point a, int b)\n{\n    a.x *= b;\n    a.y *= b;\n    return a;\n}\n\nRectangle\nrsubp(Rectangle r, Point p)\n{\n    r.min.x -= p.x;\n    r.min.y -= p.y;\n    r.max.x -= p.x;\n    r.max.y -= p.y;\n    return r;\n}\n\nRectangle\nraddp(Rectangle r, Point p)\n{\n    r.min.x += p.x;\n    r.min.y += p.y;\n    r.max.x += p.x;\n    r.max.y += p.y;\n    return r;\n}\n\nRectangle\nrmul(Rectangle r, int a)\n{\n    if (a != 1) {\n        r.min.x *= a;\n        r.min.y *= a;\n        r.max.x *= a;\n        r.max.y *= a;\n    }\n    return r;\n}\n\nRectangle\nrdiv(Rectangle r, int a)\n{\n    if (a != 1) {\n        r.min.x /= a;\n        r.min.y /= a;\n        r.max.x /= a;\n        r.max.y /= a;\n    }\n    return r;\n}\n\nRectangle\nrshift(Rectangle r, int a)\n{\n    if (a > 0) {\n        r.min.x <<= a;\n        r.min.y <<= a;\n        r.max.x <<= a;\n        r.max.y <<= a;\n    }\n    else if (a < 0) {\n        a = -a;\n        r.min.x >>= a;\n        r.min.y >>= a;\n        r.max.x >>= a;\n        r.max.y >>= a;\n    }\n    return r;\n}\n\nint\neqpt(Point p, Point q)\n{\n    return p.x==q.x && p.y==q.y;\n}\n\nint\neqrect(Rectangle r, Rectangle s)\n{\n    return r.min.x==s.min.x && r.max.x==s.max.x &&\n           r.min.y==s.min.y && r.max.y==s.max.y;\n}\n\nint\nrectXrect(Rectangle r, Rectangle s)\n{\n    return r.min.x<s.max.x && s.min.x<r.max.x &&\n           r.min.y<s.max.y && s.min.y<r.max.y;\n}\n\nint\nrectinrect(Rectangle r, Rectangle s)\n{\n    /* !ptinrect(r.min, s) in line for speed */\n    if(!(r.min.x>=s.min.x && r.min.x<s.max.x &&\n        r.min.y>=s.min.y && r.min.y<s.max.y))\n            return 0;\n    return r.max.x<=s.max.x && r.max.y<=s.max.y;\n}\n\nint\nptinrect(Point p, Rectangle r)\n{\n    return p.x>=r.min.x && p.x<r.max.x &&\n           p.y>=r.min.y && p.y<r.max.y;\n}\n\nRectangle\nrcanon(Rectangle r)\n{\n    int t;\n    if (r.max.x < r.min.x) {\n        t = r.min.x;\n        r.min.x = r.max.x;\n        r.max.x = t;\n    }\n    if (r.max.y < r.min.y) {\n        t = r.min.y;\n        r.min.y = r.max.y;\n        r.max.y = t;\n    }\n    return r;\n}\n\nRectangle\nRect(int x1, int y1, int x2, int y2)\n{\n    Rectangle r;\n\n    r.min.x = x1;\n    r.min.y = y1;\n    r.max.x = x2;\n    r.max.y = y2;\n    return r;\n}\n\nRectangle\nRpt(Point p1, Point p2)\n{\n    Rectangle r;\n\n    r.min = p1;\n    r.max = p2;\n    return r;\n}\n\nPoint\nPt(int x, int y)\n{\n    Point p;\n\n    p.x = x;\n    p.y = y;\n    return p;\n}\n", "source": "sam/libXg/arith.c", "file_type": "c"}
{"text": "/* Copyright (c) 1998 Lucent Technologies - All rights reserved. */\n#include <u.h>\n#include <libg.h>\n#include \"libgint.h\"\n\nstatic void\ngrabcursor(void)\n{\n    raisewindow();\n\n    /* Grab X server with an limp wrist. */\n    while (XGrabPointer(_dpy, screen.id, False,\n            ButtonPressMask|ButtonReleaseMask|\n            ButtonMotionMask|StructureNotifyMask,\n        GrabModeAsync, GrabModeAsync, None, None, CurrentTime)\n            != GrabSuccess)\n        sleep(2);\n\n    /* Grab the keyboard too */\n    XSetInputFocus(_dpy, screen.id, RevertToParent, CurrentTime);\n}\n\nstatic void\nungrabcursor(void)\n{\n    XUngrabPointer(_dpy, CurrentTime);\n}\n\nRectangle\ngetrect(int but, Mouse *m){\n    Rectangle r, rc;\n\n    but = 1<<(but-1);\n    cursorswitch(SweepCursor);\n    while(m->buttons)\n        *m = emouse();\n    grabcursor();\n    while(!(m->buttons & but)){\n        *m = emouse();\n        if(m->buttons & (7^but))\n            goto Return;\n    }\n    r.min = m->xy;\n    r.max = m->xy;\n    do{\n        rc = rcanon(r);\n        border(&screen, rc, 2, F&~D, _bgpixel);\n        *m = emouse();\n        border(&screen, rc, 2, F&~D, _bgpixel);\n        r.max = m->xy;\n    }while(m->buttons & but);\n\n    Return:\n    cursorswitch(DefaultCursor);\n    if(m->buttons & (7^but)){\n        rc.min.x = rc.max.x = 0;\n        rc.min.y = rc.max.y = 0;\n        while(m->buttons)\n            *m = emouse();\n    }\n    ungrabcursor();\n    return rc;\n}\n", "source": "sam/libXg/getrect.c", "file_type": "c"}
{"text": "/* Copyright (c) 1998 Lucent Technologies - All rights reserved. */\n#include <u.h>\n#include <libg.h>\n#include \"libgint.h\"\n\n/*\n * Libg applications are written assuming that black is ~0\n * and white is 0.  Some screens use the reverse convention.\n * We get the effect the application desired by seeing what\n * happens if both the source and dest are converted to the\n * black==~0 convention, and then converting the dest back\n * to whatever convention it uses.\n *\n * Offscreen bitmaps of depth 1 use the black==~0 convention.\n *\n * Bitmaps of depth > 1 are probably in color.  Libg operations that\n * would produce a 1 should produce the foreground color, and\n * libg operations that would produce a 0 should produce the background\n * color.  Operations that use bitmaps of depth > 1 as source\n * should interpret the foreground pixel as \"black\" (1) and the\n * background pixel as \"white\" (0).  It is hard to make this work,\n * but the important cases are Fcodes Zero, F, S, and S^D, so\n * we make sure that those work.  When a fill value is given for\n * a bitmap of depth > 1, assume ~0 means foreground, but otherwise\n * take any other value literally (assume it came from rgbpix).\n * This may be wrong for the case of 0, but libg programmers\n * usually use Fcode Zero instead of passing 0 with Fcode S.\n *\n * We assume there are at most two depths of bitmaps: depth 1\n * and depth of the screen.\n */\n\n/*\n * gx func code corresponding to libg func code when both\n * source and dest use 1 for black.  This is a straight translation.\n */\nstatic int gx[16] = {\n    GXclear,        /* Zero */\n    GXnor,          /* DnorS */\n    GXandInverted,      /* DandnotS */\n    GXcopyInverted,     /* notS */\n    GXandReverse,       /* notDandS */\n    GXinvert,       /* notD */\n    GXxor,          /* DxorS */\n    GXnand,         /* DnandS */\n    GXand,          /* DandS */\n    GXequiv,        /* DxnorS */\n    GXnoop,         /* D */\n    GXorInverted,       /* DornotS */\n    GXcopy,         /* S */\n    GXorReverse,        /* notDorS */\n    GXor,           /* DorS */\n    GXset,          /* F */\n};\n\n/*\n * gx func code corresponding to libg func code when 0 means black\n * in dst and 1 means black in src. These means the table has op'\n * where dst <- dst op' src == not ( not(dst)  op  src ).\n * The comment on each line is op, in Fcode terms.\n */\nstatic int d0s1gx[16] = {\n    GXset,          /* Zero */\n    GXorReverse,        /* DnorS */\n    GXor,           /* DandnotS */\n    GXcopy,         /* notS */\n    GXnand,         /* notDandS */\n    GXinvert,       /* notD */\n    GXxor,          /* DxorS */\n    GXandReverse,       /* DnandS */\n    GXorInverted,       /* DandS */\n    GXequiv,        /* DxnorS */\n    GXnoop,         /* D */\n    GXand,          /* DornotS */\n    GXcopyInverted,     /* S */\n    GXnor,          /* notDorS */\n    GXandInverted,      /* DorS */\n    GXclear,        /* F */\n};\n/*\n * gx func code corresponding to libg func code when 1 means black\n * in dst and 0 means black in src. These means the table has op'\n * where dst <- dst op' src == dst  op  not(src) )\n * The comment on each line is op, in Fcode terms.\n */\nstatic int d1s0gx[16] = {\n    GXclear,        /* Zero */\n    GXandReverse,       /* DnorS */\n    GXand,          /* DandnotS */\n    GXcopy,         /* notS */\n    GXnor,          /* notDandS */\n    GXinvert,       /* notD */\n    GXequiv,        /* DxorS */\n    GXorReverse,        /* DnandS */\n    GXandInverted,      /* DandS */\n    GXxor,          /* DxnorS */\n    GXnoop,         /* D */\n    GXor,           /* DornotS */\n    GXcopyInverted,     /* S */\n    GXnand,         /* notDorS */\n    GXorInverted,       /* DorS */\n    GXset,          /* F */\n};\n\n/*\n * gx func code corresponding to libg func code when 0 means black\n * in both the src and the dst. These means the table has op'\n * where dst <- dst op' src == not (not(dst)  op  not(src)) )\n * The comment on each line is op, in Fcode terms.\n */\nstatic int d0s0gx[16] = {\n    GXset,          /* Zero */\n    GXnand,         /* DnorS */\n    GXorInverted,       /* DandnotS */\n    GXcopyInverted,     /* notS */\n    GXorReverse,        /* notDandS */\n    GXinvert,       /* notD */\n    GXequiv,        /* DxorS */\n    GXnor,          /* DnandS */\n    GXor,           /* DandS */\n    GXxor,          /* DxnorS */\n    GXnoop,         /* D */\n    GXandInverted,      /* DornotS */\n    GXcopy,         /* S */\n    GXandReverse,       /* notDorS */\n    GXand,          /* DorS */\n    GXclear,        /* F */\n};\n\n/*\n * 1 for those Fcodes that are degenerate (don't involve src)\n */\nstatic int degengc[16] = {\n    1,          /* Zero */\n    0,          /* DnorS */\n    0,          /* DandnotS */\n    0,          /* notS */\n    0,          /* notDandS */\n    1,          /* notD */\n    0,          /* DxorS */\n    0,          /* DnandS */\n    0,          /* DandS */\n    0,          /* DxnorS */\n    1,          /* D */\n    0,          /* DornotS */\n    0,          /* S */\n    0,          /* notDorS */\n    0,          /* DorS */\n    1,          /* F */\n};\n\n/*\n * GCs are all for same screen, and depth is either 1 or screen depth.\n * Return a GC for the depth of b, with values as specified by gcv.\n *\n * Also, set (or unset) the clip rectangle if necessary.\n * (This implementation should be improved if setting a clip rectangle is not rare).\n */\nGC\n_getgc(Bitmap *b, uint64_t gcvm, XGCValues *pgcv)\n{\n    static GC gc0, gcn;\n    static bool clipset = false;\n    GC g;\n    XRectangle xr;\n\n    g = (b->ldepth==0)? gc0 : gcn;\n    if(!g){\n        g = XCreateGC(_dpy, (Drawable)b->id, gcvm, pgcv);\n        if(b->ldepth==0)\n            gc0 = g;\n        else\n            gcn = g;\n    } else\n        XChangeGC(_dpy, g, gcvm, pgcv);\n    if(b->flag&CLIP){\n        xr.x = b->clipr.min.x;\n        xr.y = b->clipr.min.y;\n        xr.width = Dx(b->clipr);\n        xr.height = Dy(b->clipr);\n        if(b->flag&SHIFT){\n            xr.x -= b->r.min.x;\n            xr.y -= b->r.min.y;\n        }\n        XSetClipRectangles(_dpy, g, 0, 0, &xr, 1, YXBanded);\n        clipset = true;\n    }else if(clipset){\n        pgcv->clip_mask = None;\n        XChangeGC(_dpy, g, GCClipMask, pgcv);\n        clipset = false;\n    }\n    return g;\n}\n\n/*\n * Return a GC that will fill bitmap b using a pixel value v and Fcode f.\n * Pixel value v is according to libg convention, so 0 means\n * white (or background) and ~0 means black (or foreground).\n */\nGC\n_getfillgc(Fcode f, Bitmap *b, uint64_t val)\n{\n    return _getfillgc2(f, b, val, _fgpixel, _bgpixel);\n}\n\nGC\n_getfillgc2(Fcode f, Bitmap *b, uint64_t val, uint64_t fg, uint64_t bg)\n{\n    int xf, m;\n    uint64_t v, spix, vmax;\n    XGCValues gcv;\n\n    f &= F;\n    vmax = _ld2dmask[b->ldepth];\n    v = val & vmax;\n    spix = v;\n    xf = GXcopy;\n    m = b->flag;\n    if(m & DP1){\n        xf = (m&BL1)? gx[f] : d0s1gx[f];\n    }else{\n        switch(f){\n        case Zero:\n        labZero:\n            spix = bg;\n            break;\n        case F:\n        labF:\n            spix = fg;\n            break;\n        case D:\n        labD:\n            xf = GXnoop;\n            break;\n        case notD:\n        labnotD:\n            xf = GXxor;\n            spix = fg^bg;\n            break;\n        case S:\n            if(val == ~0)\n                spix = fg;\n            else\n                spix = v;\n            break;\n        case notS:\n            if(val == ~0)\n                spix = bg;\n            else\n                spix = v;\n            break;\n        case DxorS:\n            xf = GXxor;\n            if(val == ~0)\n                spix = fg^bg;\n            else\n                spix = v;\n            break;\n        case DxnorS:\n            xf = GXxor;\n            if(val == 0)\n                spix = fg^bg;\n            else\n                spix = v;\n            break;\n        default:\n            /* hard to do anything other than v==0 or v==~0 case */\n            if(v < vmax-v){\n                /* v is closer to 0 than vmax */\n                switch(f&~S){\n                case D&~S:  goto labD;\n                case notD&~S:   goto labnotD;\n                case Zero&~S:   goto labZero;\n                case F&~S:  goto labF;\n                }\n            }else{\n                /* v is closer to vmax than 0 */\n                switch(f&S){\n                case D&S:   goto labD;\n                case notD&S:    goto labnotD;\n                case Zero&S:    goto labZero;\n                case F&S:   goto labF;\n                }\n            }\n            \n        }\n    }\n    gcv.foreground = spix;\n    gcv.function = xf;\n    return _getgc(b, GCForeground|GCFunction, &gcv);\n}\n\n/*\n * Return a GC to be used to copy an area from bitmap sb to\n * bitmap db.  Sometimes the calling function shouldn't use\n * XCopyArea, but instead should use XCopyPlane or XFillRectangle.\n * The *bltfunc arg is set to one of UseCopyArea, UseCopyPlane,\n * UseFillRectangle.\n */\nGC\n_getcopygc(Fcode f, Bitmap *db, Bitmap *sb, int *bltfunc)\n{\n    return _getcopygc2(f, db, sb, bltfunc, _fgpixel, _bgpixel);\n}\n\nGC\n_getcopygc2(Fcode f, Bitmap *db, Bitmap *sb, int *bltfunc, uint64_t fg, uint64_t bg)\n{\n    uint64_t spix, df, sf;\n    int xf, c;\n    XGCValues gcv;\n    uint64_t gcvm;\n\n    spix = xf = 0;\n    f &= F;\n    gcvm = 0;\n    df = db->flag;\n    if(degengc[f]){\n        *bltfunc = UseFillRectangle;\n        if(df&SCR || !(df&DP1)){\n            // nothing XXX\n        }else{\n            /* must be DP1 and BL1 */\n            fg = 1;\n            bg = 0;\n        }\n        switch(f){\n        case Zero:\n            xf = GXcopy;\n            spix = bg;\n            break;\n        case F:\n            xf = GXcopy;\n            spix = fg;\n            break;\n        case D:\n            xf = GXnoop;\n            spix = fg;\n            break;\n        case notD:\n            xf = GXxor;\n            spix = fg^bg;\n            break;\n        default:\n            /* ignored */\n            break;\n        }\n        gcv.function = xf;\n        gcv.foreground = spix;\n        gcvm = GCFunction|GCForeground;\n    }else{\n        /* src is involved in f */\n\n#define code(f1,f2) ((((f1)&(DP1|BL1))<<2)|((f2)&(DP1|BL1)))\n\n        sf = sb->flag;\n        c = code(df,sf);\n        *bltfunc = UseCopyArea;\n        switch(code(df,sf)){\n        case code(DP1|BL1,DP1|BL1):\n        case code(BL1,BL1):\n            xf = gx[f];\n            break;\n        case code(DP1|BL1,DP1):\n            xf = d1s0gx[f];\n            break;\n        case code(DP1,DP1|BL1):\n            xf = d0s1gx[f];\n            break;\n        case code(DP1,DP1):\n        case code(0,0):\n            xf = d0s0gx[f];\n            break;\n        default:\n            /*\n             * One bitmap has depth 1, the other has screen depth.\n             * We know the bitmap must have BL1.\n             * CopyPlane must be used; it won't really work\n             * for more than fcode==S.\n             */\n\n            *bltfunc = UseCopyPlane;\n            xf = GXcopy;\n            switch(c){\n\n            case code(0,DP1|BL1):\n            case code(BL1,DP1|BL1):\n                // nothing XXX\n                break;\n            case code(DP1|BL1,0):\n                fg = 0;\n                bg = 1;\n                break;\n            case code(DP1|BL1,BL1):\n                fg = 1;\n                bg = 0;\n                break;\n            default:\n                berror(\"bad combination of copy bitmaps\");\n            }\n            gcv.foreground = fg;\n            gcv.background = bg;\n            gcvm |= GCForeground|GCBackground;\n        }\n        gcv.function = xf;\n        gcvm |= GCFunction;\n    \n#undef code\n    }\n\n    return _getgc(db, gcvm, &gcv);\n}\n", "source": "sam/libXg/gcs.c", "file_type": "c"}
{"text": "/* Copyright (c) 1998 Lucent Technologies - All rights reserved. */\n#include <u.h>\n#include <libg.h>\n#include \"libgint.h\"\n\n#include <X11/cursorfont.h>\n\nextern Window _topwindow;\n\nstatic Cursor arrow;\nstatic Cursor sweep;\nstatic Cursor crosshair;\nstatic Cursor pirate;\nstatic Cursor watch;\nstatic Cursor defcursor;\n\nvoid\ncursorswitch(unsigned int c)\n{\n    Cursor i = defcursor;\n\n    switch (c){\n        case ArrowCursor:    i = arrow;     break;\n        case SweepCursor:    i = sweep;     break;\n        case BullseyeCursor: i = crosshair; break;\n        case DeadCursor:     i = pirate;    break;\n        case LockCursor:     i = watch;     break;\n        default:             i = defcursor; break;\n    }\n\n    XDefineCursor(_dpy, _topwindow, i);\n}\n\nvoid\ninitcursors(void)\n{\n    sweep = XCreateFontCursor(_dpy, XC_sizing);\n    crosshair = XCreateFontCursor(_dpy, XC_crosshair);\n    pirate = XCreateFontCursor(_dpy, XC_pirate);\n    watch = XCreateFontCursor(_dpy, XC_watch);\n    arrow = XCreateFontCursor(_dpy, XC_left_ptr);\n    defcursor = XCreateFontCursor(_dpy, XC_xterm);\n}\n\n", "source": "sam/libXg/cursorswitch.c", "file_type": "c"}
{"text": "/* Copyright (c) 1998 Lucent Technologies - All rights reserved. */\n#include <u.h>\n#include <libg.h>\n#include \"libgint.h\"\n\nvoid\ntexture(Bitmap *d, Rectangle r, Bitmap *s, Fcode f)\n{\n    int x, y, w, h, bfunc;\n    GC g;\n\n    x = r.min.x;\n    y = r.min.y;\n    if(d->flag&SHIFT){\n        x -= d->r.min.x;\n        y -= d->r.min.y;\n    }\n    g = _getcopygc(f, d, s, &bfunc);\n    if(d->flag&SHIFT){\n        XSetTSOrigin(_dpy, g, -d->r.min.x, -d->r.min.y);\n    }else\n        XSetTSOrigin(_dpy, g, 0, 0);\n    w = Dx(r);\n    h = Dy(r);\n    if(bfunc == UseFillRectangle){\n        /* source isn't involved at all */\n        XFillRectangle(_dpy, (Drawable)d->id, g, x, y, w, h);\n    }else if(bfunc == UseCopyArea){\n        XSetTile(_dpy, g, (Drawable)s->id);\n        XSetFillStyle(_dpy, g, FillTiled);\n        XFillRectangle(_dpy, (Drawable)d->id, g, x, y, w, h);\n        XSetFillStyle(_dpy, g, FillSolid);\n    }else{\n        if(s->ldepth != 0)\n            berror(\"unsupported texture\");\n        XSetStipple(_dpy, g, (Drawable)s->id);\n        XSetFillStyle(_dpy, g, FillOpaqueStippled);\n        XFillRectangle(_dpy, (Drawable)d->id, g, x, y, w, h);\n        XSetFillStyle(_dpy, g, FillSolid);\n    }\n}\n", "source": "sam/libXg/texture.c", "file_type": "c"}
{"text": "/* Copyright (c) 1998 Lucent Technologies - All rights reserved. */\n#include <u.h>\n#include <libg.h>\n#include \"libgint.h\"\n\nvoid\nbitblt(Bitmap *d, Point p, Bitmap *s, Rectangle r, Fcode f)\n{\n    bitblt2(d, p, s, r, f, _fgpixel, _bgpixel);\n}\n\nvoid\nbitblt2(Bitmap *d, Point p, Bitmap *s, Rectangle r, Fcode f, uint64_t fg, uint64_t bg)\n{\n    int sx, sy, dx, dy, bfunc;\n    GC g;\n    uint64_t plane;\n    Bitmap *btmp;\n\n    if (fg == 0)\n        fg = _fgpixel;\n\n    if (bg == 0)\n        bg = _bgpixel;\n\n    if(Dx(r)<=0 || Dy(r)<=0)\n        return;\n    sx = r.min.x;\n    sy = r.min.y;\n    if(s->flag&SHIFT){\n        sx -= s->r.min.x;\n        sy -= s->r.min.y;\n    }\n    dx = p.x;\n    dy = p.y;\n    if(d->flag&SHIFT){\n        dx -= d->r.min.x;\n        dy -= d->r.min.y;\n    }\n    g = _getcopygc2(f, d, s, &bfunc, fg, bg);\n    if(bfunc == UseCopyArea)\n        XCopyArea(_dpy, (Drawable)s->id, (Drawable)d->id, g,\n            sx, sy, Dx(r), Dy(r), dx, dy);\n    else if(bfunc == UseFillRectangle){\n        XFillRectangle(_dpy, (Drawable)d->id, g,\n            dx, dy, Dx(r), Dy(r));\n    }else{\n        /* bfunc == UseCopyPlane */\n        plane = _ld2dmask[s->ldepth];\n        plane &= ~(plane>>1);\n        if(0/*f == S*/)\n            XCopyPlane(_dpy, (Drawable)s->id, (Drawable)d->id, g,\n                sx, sy, Dx(r), Dy(r), dx, dy, plane);\n        else {\n            /*\n             * CopyPlane can only do func code S,\n             * so copy src rect into a bitmap with the same depth\n             * as the dest, then do the bitblt from the tmp.\n             * This won't recurse again because we only get\n             * UseCopyPlane with differing bitmap depths\n             */\n            btmp = _balloc(Rect(0,0,Dx(r),Dy(r)), d->ldepth);\n            XCopyPlane(_dpy, (Drawable)s->id, (Drawable)btmp->id, g,\n                sx, sy, Dx(r), Dy(r), 0, 0, plane);\n            bitblt(d, p, btmp, btmp->r, f);\n            bfree(btmp);\n        }\n    }\n    XFlush(_dpy);\n}\n", "source": "sam/libXg/bitblt.c", "file_type": "c"}
{"text": "/* Copyright (c) 1998 Lucent Technologies - All rights reserved. */\n#include <u.h>\n#include <libg.h>\n#include \"libgint.h\"\n\nvoid\n_ldconvert(char *in, int inld, char *out, int outld, int w, int h)\n{\n    int a, b, i, j, i1, j1, j2, mask;\n    int ind, inl, outd, outl;\n    int hh, ww;\n    char    *p, *q;\n\n    i1 = 8 >> inld;\n    j1 = 8 >> outld;\n    ind = 1 << inld;\n    outd = 1 << outld;\n    inl = ((w << inld) + 7)/8;\n    outl = ((w << outld) + 7)/8;\n    b = 0;\n\n    if (ind > outd) {\n        mask = 256 - (256 >> outd);\n        for (hh = 0; hh < h; hh++, in += inl, out += outl)\n            for (p = in, q = out, ww = 0; ww < w; ww++) {\n                for (j = j1; j > 0; ) {\n                    a = *p++;\n                    for (i = i1; i > 0; i--, j--) {\n                        b |= a & mask;\n                        a <<= ind;\n                        b <<= outd;\n                    }\n                }\n                *q++ = (b >> 8);\n            }\n    } else {\n        j2 = 1 << (outld - inld);\n        mask = 256 - (256 >> ind);\n        for (hh = 0; hh < h; hh++, in += inl, out += outl)\n            for (p = in, q = out, ww = 0; ww < w; ww++) {\n                a = *p++;\n                for (i = i1; i > 0; ) {\n                    for (j = j1; j > 0; j--, i--) {\n                        b |= a & mask;\n                        a <<= ind;\n                        b <<= outd;\n                    }\n                    for (j = j2; j > 0; j--)\n                        b |= (b << ind);\n                    *q++ = (b >> 8);\n                }\n            }\n    }\n}\n", "source": "sam/libXg/ldconvert.c", "file_type": "c"}
{"text": "/* Copyright (c) 1998 Lucent Technologies - All rights reserved. */\n#include <u.h>\n#include <libg.h>\n\nextern uint64_t _borderpixel;\n\nvoid\nborder(Bitmap *l, Rectangle r, int i, Fcode c, uint64_t bg)\n{\n    if(i > 0){\n        bitblt2(l, r.min,\n            l, Rect(r.min.x, r.min.y, r.max.x, r.min.y+i), c, _borderpixel, bg);\n        bitblt2(l, Pt(r.min.x, r.max.y-i),\n            l, Rect(r.min.x, r.max.y-i, r.max.x, r.max.y), c, _borderpixel, bg);\n        bitblt2(l, Pt(r.min.x, r.min.y+i),\n            l, Rect(r.min.x, r.min.y+i, r.min.x+i, r.max.y-i), c, _borderpixel, bg);\n        bitblt2(l, Pt(r.max.x-i, r.min.y+i),\n            l, Rect(r.max.x-i, r.min.y+i, r.max.x, r.max.y-i), c, _borderpixel, bg);\n    }else if(i < 0){\n        bitblt2(l, Pt(r.min.x, r.min.y+i),\n            l, Rect(r.min.x, r.min.y+i, r.max.x, r.min.y), c, _borderpixel, bg);\n        bitblt2(l, Pt(r.min.x, r.max.y),\n            l, Rect(r.min.x, r.max.y, r.max.x, r.max.y-i), c, _borderpixel, bg);\n        bitblt2(l, Pt(r.min.x+i, r.min.y+i),\n            l, Rect(r.min.x+i, r.min.y+i, r.min.x, r.max.y-i), c, _borderpixel, bg);\n        bitblt2(l, Pt(r.max.x, r.min.y+i),\n            l, Rect(r.max.x, r.min.y+i, r.max.x-i, r.max.y-i), c, _borderpixel, bg);\n    }\n}\n", "source": "sam/libXg/border.c", "file_type": "c"}
{"text": "/* Copyright (c) 1998 Lucent Technologies - All rights reserved. */\n#include <u.h>\n#include <string.h>\n\nint\nchartorune(wchar_t *rune, char *str)\n{\n    int r = mbtowc(rune, str, strlen(str));\n    if (r < 0){\n        *rune = UNICODE_REPLACEMENT_CHAR;\n        return 1;\n    }\n    return r;\n}\n", "source": "sam/libXg/rune.c", "file_type": "c"}
{"text": "/* Copyright (c) 1998 Lucent Technologies - All rights reserved. */\n#include <string.h>\n#include <u.h>\n#include <libg.h>\n#include \"libgint.h\"\n\nPoint\nstring(Bitmap *b, Point p, XftFont *ft, char *s, Fcode f)\n{\n    size_t length = strlen(s);\n    int x = p.x;\n    int y = p.y;\n\n    x = p.x;\n    y = p.y;\n    if (b->flag & SHIFT){\n        x -= b->r.min.x;\n        y -= b->r.min.y;\n    }\n    y += ft->ascent;\n\n    if (!b->fd)\n        b->fd = XftDrawCreate(_dpy, (Drawable)(b->id), DefaultVisual(_dpy, DefaultScreen(_dpy)), DefaultColormap(_dpy, DefaultScreen(_dpy)));\n    XftDrawStringUtf8(b->fd, &fontcolor, ft, x, y, (FcChar8 *)s, length);\n\n    x += strwidth(ft, s);\n\n    p.x = (b->flag & SHIFT) ? x + b->r.min.x : x;\n    p.x = x + b->r.min.x;\n    return p;\n}\n\n\nint64_t\nstrwidth(XftFont *f, char *s)\n{\n    XGlyphInfo extents = {0};\n    XftTextExtentsUtf8(_dpy, f, (FcChar8 *)s, strlen(s), &extents);\n\n    return extents.xOff;\n}\n\nint64_t\ncharwidth(XftFont *f, wchar_t r)\n{\n    char chars[MB_LEN_MAX + 1] = {0};\n\n    if (runetochar(chars, r) < 0)\n        return 0;\n\n    return strwidth(f, chars);\n}\n", "source": "sam/libXg/string.c", "file_type": "c"}
{"text": "/* Copyright (c) 1998 Lucent Technologies - All rights reserved. */\n#include <u.h>\n#include <libg.h>\n#include \"libgint.h\"\n\n/*\n * The screen data structure should always be up to date\n * (Not true in the Plan 9 library, which is why this\n * function exists).\n */\nRectangle\nbscreenrect(Rectangle *clipr)\n{\n    if(clipr)\n        *clipr = screen.clipr;\n    return screen.r;\n}\n", "source": "sam/libXg/bscreenrect.c", "file_type": "c"}
{"text": "/* Copyright (c) 1998 Lucent Technologies - All rights reserved. */\n#include <u.h>\n#include <libg.h>\n#include \"libgint.h\"\n\nint\nclipr(Bitmap *d, Rectangle r)\n{\n    if(rectclip(&r, d->r) == 0)\n        return 0;\n    d->clipr = r;\n    if(r.min.x != d->r.min.x ||\n       r.min.y != d->r.min.y ||\n       r.max.x != d->r.max.x ||\n       r.max.y != d->r.max.y)\n        d->flag |= CLIP;\n    else\n        d->flag &= ~CLIP;\n    return 1;\n}\n", "source": "sam/libXg/clipr.c", "file_type": "c"}
{"text": "/* Copyright (c) 1998 Lucent Technologies - All rights reserved. */\n#include <string.h>\n#include <u.h>\n#include <libg.h>\n#include <frame.h>\n#include \"flayer.h\"\n#include \"samterm.h\"\n\nextern char *exname;\nextern Flayer *flast;\n\n#define HSIZE   3   /* Type + int16_t count */\nHeader  h;\nuint8_t   indata[DATASIZE+1]; /* room for NUL */\nuint8_t   outdata[DATASIZE];\nint16_t   outcount;\nint hversion;\n\nvoid    inmesg(Hmesg, int);\nint inshort(int);\nint64_t    inlong(int);\nvoid    hsetdot(int, int64_t, int64_t);\nvoid    hmoveto(int, int64_t, Flayer *);\nvoid    hsetsnarf(int);\nvoid    clrlock(void);\nint snarfswap(char*, int, char**);\n\nvoid\nrcv(void)\n{\n    int c;\n    static int state = 0;\n    static int count = 0;\n    static int i = 0;\n    static int errs = 0;\n\n    while((c=rcvchar()) != -1)\n        switch(state){\n        case 0:\n            h.type = c;\n            state++;\n            break;\n\n        case 1:\n            h.count0 = c;\n            state++;\n            break;\n\n        case 2:\n            h.count1 = c;\n            count = h.count0|(h.count1<<8);\n            i = 0;\n            if(count > DATASIZE){\n                if(++errs < 5){\n                    dumperrmsg(count, h.type, h.count0, c);\n                    state = 0;\n                    continue;\n                }\n                fprintf(stderr, \"type %d count %d\\n\", h.type, count);\n                panic(\"count>DATASIZE\");\n            }\n            if(count == 0)\n                goto zerocount;\n            state++;\n            break;\n\n        case 3:\n            indata[i++] = c;\n            if(i == count){\n        zerocount:\n                indata[i] = 0;\n                inmesg(h.type, count);\n                state = count = 0;\n                continue;\n            }\n            break;\n        }\n}\n\nText *\nwhichtext(int tg)\n{\n    int i;\n\n    for(i=0; i<nname; i++)\n        if(tag[i] == tg)\n            return text[i];\n    panic(\"whichtext\");\n    return 0;\n}\n\nvoid\ninmesg(Hmesg type, int count)\n{\n    Text *t;\n    int i, m;\n    int64_t l, l2;\n    Flayer *lp;\n\n    m = inshort(0);\n    l = inlong(2);\n    switch(type){\n    case Terror:\n        panic(\"rcv error\");\n    default:\n        fprintf(stderr, \"type %d\\n\", type);\n        panic(\"rcv unknown\");\n\n    case Hversion:\n        hversion = m;\n        if (hversion != VERSION)\n            panic(\"host-terminal version mismatch\");\n        break;\n\n    case Hbindname:\n        l = inlong(2);     /* for 64-bit pointers */\n        if((i=whichmenu(m)) < 0)\n            break;\n        /* in case of a race, a bindname may already have occurred */\n        if((t=whichtext(m)) == 0)\n            t=(Text *)l;\n        else    /* let the old one win; clean up the new one */\n            while(((Text *)l)->nwin>0)\n                closeup(&((Text *)l)->l[((Text *)l)->front]);\n        text[i] = t;\n        text[i]->tag = m;\n        break;\n\n    case Hcurrent:\n        if(whichmenu(m)<0)\n            break;\n        t = whichtext(m);\n        i = which && ((Text *)which->user1)==&cmd && m!=cmd.tag;\n        if(t==0 && (t = sweeptext(0, m))==0)\n            break;\n        if(t->l[t->front].textfn==0)\n            panic(\"Hcurrent\");\n        lp = &t->l[t->front];\n        if(i){\n            flupfront(lp);\n            flborder(lp, 0);\n            work = lp;\n            flast = lp;\n        }else\n            current(lp);\n        break;\n\n    case Hmovname:\n        if((m=whichmenu(m)) < 0)\n            break;\n        t = text[m];\n        l = tag[m];\n        i = name[m][0];\n        text[m] = 0;    /* suppress panic in menudel */\n        menudel(m);\n        if(t == &cmd)\n            m = 0;\n        else{\n            if (nname>0 && text[0]==&cmd)\n                m = 1;\n            else m = 0;\n            for(; m<nname; m++)\n                if(strcmp((char*)indata+2, (char*)name[m]+1)<0)\n                    break;\n        }\n        menuins(m, indata+2, t, i, (int)l);\n        break;\n\n    case Hgrow:\n        if(whichmenu(m) >= 0)\n            hgrow(m, l, inlong(10), true);\n        break;\n\n    case Hnewname:\n        menuins(0, (uint8_t *)\"\", (Text *)0, ' ', m);\n        break;\n\n    case Hcheck0:\n        i = whichmenu(m);\n        if(i>=0) {\n            t = text[i];\n            if (t)\n                t->lock++;\n            outTs(Tcheck, m);\n        }\n        break;\n\n    case Hcheck:\n        i = whichmenu(m);\n        if(i>=0) {\n            t = text[i];\n            if (t && t->lock)\n                t->lock--;\n            hcheck(m);\n        }\n        break;\n\n    case Hunlock:\n        clrlock();\n        break;\n\n    case Hdata:\n        if(whichmenu(m) >= 0)\n            l += hdata(m, l, indata+10, count-10);\n    Checkscroll:\n        if(m == cmd.tag){\n            for(i=0; i<NL; i++){\n                lp = &cmd.l[i];\n                if(lp->textfn)\n                    center(lp, l>=0? l : lp->p1);\n            }\n        }\n        break;\n\n    case Horigin:\n        if(whichmenu(m) >= 0){\n            Text *t = whichtext(m);\n            l2 = inlong(10);\n            horigin(m, l, &t->l[l2]);\n        }\n        break;\n\n    case Hunlockfile:\n        if(whichmenu(m)>=0 && (t = whichtext(m))->lock){\n            --t->lock;\n            l = -1;\n            goto Checkscroll;\n        }\n        break;\n\n    case Hsetdot:\n        if(whichmenu(m) >= 0)\n            hsetdot(m, l, inlong(10));\n        break;\n\n    case Hgrowdata:\n        if(whichmenu(m)<0)\n            break;\n        hgrow(m, l, inlong(10), false);\n        whichtext(m)->lock++;   /* fake the request */\n        l += hdata(m, l, indata+18, count-18);\n        goto Checkscroll;\n\n    case Hmoveto:\n        if(whichmenu(m)>=0)\n            hmoveto(m, l, NULL);\n        break;\n\n    case Hclean:\n        if((m = whichmenu(m)) >= 0)\n            name[m][0] = ' ';\n        break;\n\n    case Hdirty:\n        if((m = whichmenu(m))>=0)\n            name[m][0] = '\\'';\n        break;\n\n    case Hdelname:\n        if((m=whichmenu(m)) >= 0)\n            menudel(m);\n        break;\n\n    case Hcut:\n        if(whichmenu(m) >= 0)\n            hcut(m, l, inlong(10));\n        break;\n\n    case Hclose:\n        if(whichmenu(m)<0 || (t = whichtext(m))==0)\n            break;\n        l = t->nwin;\n        for(i = 0,lp = t->l; l>0 && i<NL; i++,lp++)\n            if(lp->textfn){\n                closeup(lp);\n                --l;\n            }\n        break;\n\n    case Hsetpat:\n        setpat((char *)indata);\n        break;\n\n    case Hsetsnarf:\n        hsetsnarf(m);\n        break;\n\n    case Hsnarflen:\n        snarflen = inlong(0);\n        break;\n\n    case Hack:\n        outT0(Tack);\n        break;\n\n    case Hexit:\n        outT0(Texit);\n        mouseexit();\n        break;\n    }\n}\n\nvoid\nsetlock(void)\n{\n    lock++;\n    cursorswitch(cursor = LockCursor);\n}\n\nvoid\nclrlock(void)\n{\n    hasunlocked = true;\n    if(lock > 0)\n        lock--;\n    if(lock == 0)\n        cursorswitch(cursor=DefaultCursor);\n}\n\nvoid\nstartfile(Text *t)\n{\n    outTsl(Tstartfile, t->tag, (int64_t)t);      /* for 64-bit pointers */\n    setlock();\n}\n\nvoid\nstartnewfile(int type, Text *t)\n{\n    t->tag = Untagged;\n    outTl(type, (int64_t)t);             /* for 64-bit pointers */\n}\n\nint\ninshort(int n)\n{\n    return indata[n]|(indata[n+1]<<8);\n}\n\nint64_t\ninlong(int n)\n{\n    int64_t l;\n\n    l = (indata[n+7]<<24) | (indata[n+6]<<16) | (indata[n+5]<<8) | indata[n+4];\n    l = (l<<16) | (indata[n+3]<<8) | indata[n+2];\n    l = (l<<16) | (indata[n+1]<<8) | indata[n];\n    return l;\n}\n\nvoid\noutT0(Tmesg type)\n{\n    outstart(type);\n    outsend();\n}\n\nvoid\noutTl(Tmesg type, int64_t l)\n{\n    outstart(type);\n    outlong(l);\n    outsend();\n}\n\nvoid\noutTs(Tmesg type, int s)\n{\n    outstart(type);\n    outshort(s);\n    outsend();\n}\n\nvoid\noutTss(Tmesg type, int s1, int s2)\n{\n    outstart(type);\n    outshort(s1);\n    outshort(s2);\n    outsend();\n}\n\nvoid\noutTslll(Tmesg type, int s1, int64_t l1, int64_t l2, int64_t l3)\n{\n    outstart(type);\n    outshort(s1);\n    outlong(l1);\n    outlong(l2);\n    outlong(l3);\n    outsend();\n}\n\nvoid\noutTsll(Tmesg type, int s1, int64_t l1, int64_t l2)\n{\n    outstart(type);\n    outshort(s1);\n    outlong(l1);\n    outlong(l2);\n    outsend();\n}\n\nvoid\noutTsl(Tmesg type, int s1, int64_t l1)\n{\n    outstart(type);\n    outshort(s1);\n    outlong(l1);\n    outsend();\n}\n\nvoid\noutTslS(Tmesg type, int s1, int64_t l1, wchar_t *s)\n{\n    char buf[DATASIZE*3+1];\n    char *c;\n\n    outstart(type);\n    outshort(s1);\n    outlong(l1);\n    c = buf;\n    while(*s)\n        c += runetochar(c, *s++);\n    *c++ = 0;\n    outcopy(c-buf, (uint8_t *)buf);\n    outsend();\n}\n\nvoid\noutTsls(Tmesg type, int s1, int64_t l1, int s2)\n{\n    outstart(type);\n    outshort(s1);\n    outlong(l1);\n    outshort(s2);\n    outsend();\n}\n\nvoid\noutstart(Tmesg type)\n{\n    outdata[0] = type;\n    outcount = 0;\n}\n\nvoid\noutcopy(int count, uint8_t *data)\n{\n    while(count--)\n        outdata[HSIZE+outcount++] = *data++;    \n}\n\nvoid\noutshort(int s)\n{\n    uint8_t buf[2];\n\n    buf[0]=s;\n    buf[1]=s>>8;\n    outcopy(2, buf);\n}\n\nvoid\noutlong(int64_t l)\n{\n    int i;\n    uint8_t buf[8];\n\n    for(i = 0; i < sizeof(buf); i++, l >>= 8)\n        buf[i] = l;\n\n    outcopy(8, buf);\n}\n\nvoid\noutsend(void)\n{\n    if(outcount>DATASIZE-HSIZE)\n        panic(\"outcount>sizeof outdata\");\n    outdata[1]=outcount;\n    outdata[2]=outcount>>8;\n    if(write(1, (char *)outdata, outcount+HSIZE)!=outcount+HSIZE)\n        exit(EXIT_FAILURE);\n}\n\n\nvoid\nhsetdot(int m, int64_t p0, int64_t p1)\n{\n    Text *t = whichtext(m);\n    Flayer *l = &t->l[t->front];\n\n    flushtyping(true);\n    flsetselect(l, p0, p1);\n}\n\nvoid\nhorigin(int m, int64_t p0, Flayer *l)\n{\n    Text *t = whichtext(m);\n    l = l ? l : &t->l[t->front];\n    int64_t a;\n    uint64_t n;\n    wchar_t *r;\n\n    if (getlayer(l, t) < 0)\n        return; /* the user managed to close the layer during the round trip with the host */\n\n    if(!flprepare(l)){\n        l->origin = p0;\n        return;\n    }\n    a = p0-l->origin;\n    if(a>=0 && a<l->f.nchars)\n        frdelete(&l->f, 0, a);\n    else if(a<0 && -a<l->f.nchars){\n        r = rload(&t->rasp, p0, l->origin, &n);\n        frinsert(&l->f, r, r+n, 0);\n    }else\n        frdelete(&l->f, 0, l->f.nchars);\n    l->origin = p0;\n    scrdraw(l, t->rasp.nrunes);\n    if(l->visible==Some)\n        flrefresh(l, l->entire, 0);\n    hcheck(m);\n}\n\nvoid\nhmoveto(int m, int64_t p0, Flayer *l)\n{\n    Text *t = whichtext(m);\n    l = l ? l : &t->l[t->front];\n\n    if (p0 < l->origin || p0 - l->origin > l->f.nchars * 9/10)\n        outTslll(Torigin, m, p0, 2L, getlayer(l, t));\n}\n\nvoid\nhcheck(int m)\n{\n    Flayer *l;\n    Text *t;\n    int reqd = 0, i;\n    int64_t n, nl, a;\n    wchar_t *r;\n\n    if(m == Untagged)\n        return;\n    t = whichtext(m);\n    if(t == 0)      /* possible in a half-built window */\n        return;\n    for(l = &t->l[0], i = 0; i<NL; i++, l++){\n        if(l->textfn==0 || !flprepare(l))   /* BUG: don't\n                               need this if BUG below\n                               is fixed */\n            continue;\n        a = t->l[i].origin;\n        n = rcontig(&t->rasp, a, a+l->f.nchars, true);\n        if(n<l->f.nchars)   /* text missing in middle of screen */\n            a+=n;\n        else{           /* text missing at end of screen? */\n        Again:\n            if(l->f.lastlinefull)\n                goto Checksel;  /* all's well */\n            a = t->l[i].origin+l->f.nchars;\n            n = t->rasp.nrunes-a;\n            if(n==0)\n                goto Checksel;\n            if(n>TBLOCKSIZE)\n                n = TBLOCKSIZE;\n            n = rcontig(&t->rasp, a, a+n, true);\n            if(n>0){\n                rload(&t->rasp, a, a+n, 0);\n                nl = l->f.nchars;\n                r = scratch;\n                flinsert(l, r, r+n, l->origin+nl);\n                if(nl == l->f.nchars)   /* made no progress */\n                    goto Checksel;\n                goto Again;\n            }\n        }\n        if(!reqd){\n            n = rcontig(&t->rasp, a, a+TBLOCKSIZE, false);\n            if(n <= 0)\n                panic(\"hcheck request==0\");\n            outTsls(Trequest, m, a, (int)n);\n            outTs(Tcheck, m);\n            t->lock++;  /* for the Trequest */\n            t->lock++;  /* for the Tcheck */\n            reqd++;\n        }\n        Checksel:\n        flsetselect(l, l->p0, l->p1);\n    }\n}\n\nvoid\nflnewlyvisible(Flayer *l)\n{\n    hcheck(((Text *)l->user1)->tag);\n}\n\nvoid\nhsetsnarf(int nc)\n{\n    char *s2;\n    char *s1;\n    int i;\n    int n;\n\n    cursorswitch(DeadCursor);\n    s2 = alloc(nc+1);\n    for(i=0; i<nc; i++)\n        s2[i] = getch();\n    s2[nc] = 0;\n    n = snarfswap(s2, nc, &s1);\n    if(n >= 0){\n        if(!s1)\n            n = 0;\n        if(n > SNARFSIZE-1)\n            n = SNARFSIZE-1;\n        s1 = realloc(s1, n+1);\n        if (!s1)\n            exit(EXIT_FAILURE);\n        s1[n] = 0;\n        snarflen = n;\n        outTs(Tsetsnarf, n);\n        if(n>0 && write(1, s1, n)!=n)\n            exit(EXIT_FAILURE);\n        free(s1);\n    }else\n        outTs(Tsetsnarf, 0);\n    free(s2);\n    cursorswitch(cursor);\n}\n\nvoid\nhgrow(int m, int64_t a, int64_t new, bool req)\n{\n    int i;\n    Flayer *l;\n    Text *t = whichtext(m);\n    int64_t o, b;\n\n    if(new <= 0)\n        panic(\"hgrow\");\n    rresize(&t->rasp, a, 0L, new);\n    for(l = &t->l[0], i = 0; i<NL; i++, l++){\n        if(l->textfn == 0)\n            continue;\n        o = l->origin;\n        b = a-o-rmissing(&t->rasp, o, a);\n        if(a < o)\n            l->origin+=new;\n        if(a < l->p0)\n            l->p0+=new;\n        if(a < l->p1)\n            l->p1+=new;\n        /* must prevent b temporarily becoming unsigned */\n        if(!req || a<o || (b>0 && b>l->f.nchars) ||\n            (l->f.nchars==0 && a-o>0))\n            continue;\n        if(new>TBLOCKSIZE)\n            new = TBLOCKSIZE;\n        outTsls(Trequest, m, a, (int)new);\n        t->lock++;\n        req = false;\n    }\n}\n\nint\nhdata1(Text *t, int64_t a, wchar_t *r, int len)\n{\n    int i;\n    Flayer *l;\n    int64_t o, b;\n\n    for(l = &t->l[0], i=0; i<NL; i++, l++){\n        if(l->textfn==0)\n            continue;\n        o = l->origin;\n        b = a-o-rmissing(&t->rasp, o, a);\n        /* must prevent b temporarily becoming unsigned */\n        if(a<o || (b>0 && b>l->f.nchars))\n            continue;\n        flinsert(l, r, r+len, o+b);\n    }\n    rdata(&t->rasp, a, a+len, r);\n    rclean(&t->rasp);\n    return len;\n}\n\nint\nhdata(int m, int64_t a, uint8_t *s, int len)\n{\n    int i, w;\n    Text *t = whichtext(m);\n    wchar_t buf[DATASIZE], *r;\n\n    if(t->lock)\n        --t->lock;\n    if(len == 0)\n        return 0;\n    r = buf;\n    for(i=0; i<len; i+=w,s+=w)\n        w = chartorune(r++, (char*)s);\n    return hdata1(t, a, buf, r-buf);\n}\n\nint\nhdatarune(int m, int64_t a, wchar_t *r, int len)\n{\n    Text *t = whichtext(m);\n\n    if(t->lock)\n        --t->lock;\n    if(len == 0)\n        return 0;\n    return hdata1(t, a, r, len);\n}\n\nvoid\nhcut(int m, int64_t a, int64_t old)\n{\n    Flayer *l;\n    Text *t = whichtext(m);\n    int i;\n    int64_t o, b;\n\n    if(t->lock)\n        --t->lock;\n    for(l = &t->l[0], i = 0; i<NL; i++, l++){\n        if(l->textfn == 0)\n            continue;\n        o = l->origin;\n        b = a-o-rmissing(&t->rasp, o, a);\n        /* must prevent b temporarily becoming unsigned */\n        if((b<0 || b<l->f.nchars) && a+old>=o){\n            fldelete(l, b<0? o : o+b,\n                a+old-rmissing(&t->rasp, o, a+old));\n        }\n        if(a+old<o)\n            l->origin-=old;\n        else if(a<=o)\n            l->origin = a;\n        if(a+old<l->p0)\n            l->p0-=old;\n        else if(a<=l->p0)\n            l->p0 = a;\n        if(a+old<l->p1)\n            l->p1-=old;\n        else if(a<=l->p1)\n            l->p1 = a;\n    }\n    rresize(&t->rasp, a, old, 0L);\n    rclean(&t->rasp);\n}\n", "source": "sam/samterm/mesg.c", "file_type": "c"}
{"text": "/* Copyright (c) 1998 Lucent Technologies - All rights reserved. */\n#include <u.h>\n#include <libg.h>\n#include <frame.h>\n#include \"flayer.h\"\n#include \"samterm.h\"\n\nextern Bitmap *darkgrey;\nextern Mouse mouse;\n\nRectangle\nscrpos(Rectangle r, int64_t p0, int64_t p1, int64_t tot)\n{\n    int64_t h;\n    Rectangle q;\n\n    q = inset(r, 1);\n    h = q.max.y-q.min.y;\n    if(tot == 0)\n        return q;\n    if(tot > 1024L*1024L)\n        tot>>=10, p0>>=10, p1>>=10;\n    if(p0 > 0)\n        q.min.y += h*p0/tot;\n    if(p1 < tot)\n        q.max.y -= h*(tot-p1)/tot;\n    if(q.max.y < q.min.y+2){\n        if(q.min.y+2 <= r.max.y)\n            q.max.y = q.min.y+2;\n        else\n            q.min.y = q.max.y-2;\n    }\n    return q;\n}\n\nvoid\nscrflip(Flayer *l, Rectangle r)\n{\n    if(rectclip(&r, l->scroll))\n        bitblt2(l->f.b, r.min, l->f.b, r, F&~D, 0, l->bg);\n}\n\nvoid\nscrdraw(Flayer *l, int64_t tot)\n{\n    Rectangle r, r1, r2;\n    Bitmap *b;\n    static Bitmap *x;\n    int h;\n\n    if(l->f.b == 0)\n        panic(\"scrdraw\");\n    r = l->scroll;\n    r.min.x += 1;   /* border between margin and bar */\n    r1 = r;\n    if(l->visible == All){\n        if(x == 0){\n            if (screensize(0, &h) == 0)\n                h = 2048;\n            x = balloc(Rect(0, 0, 32, h), l->f.b->ldepth);\n            if(x == 0)\n                panic(\"scrdraw balloc\");\n        }\n        b = x;\n        r1.min.x = 0;\n        r1.max.x = Dx(r);\n    }else\n        b = l->f.b;\n    bitblt2(b, r1.min, b, r1, F, 0, l->bg);\n    texture(b, inset(r1, 1), darkgrey, S);\n    r2 = scrpos(r1, l->origin, l->origin+l->f.nchars, tot);\n    bitblt2(b, r2.min, b, r2, 0, 0, l->bg);\n    if(b!=l->f.b)\n        bitblt2(l->f.b, r.min, b, r1, S, 0, l->bg);\n}\n\nvoid\nscroll(Flayer *l, int pbut, int but)\n{\n    int in = 0, oin;\n    int64_t tot = scrtotal(l);\n    Rectangle scr, r, s, rt;\n    int x, y, my, oy, h;\n    int64_t p0;\n\n    s = inset(l->scroll, 1);\n    x = s.min.x+FLSCROLLWID/2;\n    scr = scrpos(l->scroll, l->origin, l->origin+l->f.nchars, tot);\n    r = scr;\n    y = scr.min.y;\n    my = mouse.xy.y;\n    do{\n        oin = in;\n        in = abs(x-mouse.xy.x)<=FLSCROLLWID/2;\n        if(oin != in)\n            scrflip(l, r);\n        if(in){\n            oy = y;\n            my = mouse.xy.y;\n            if(my < s.min.y)\n                my = s.min.y;\n            if(my >= s.max.y)\n                my = s.max.y;\n            if(!eqpt(mouse.xy, Pt(x, my)))\n                cursorset(Pt(x, my));\n            if(but == 1){\n                p0 = l->origin-frcharofpt(&l->f, Pt(s.max.x, my));\n                rt = scrpos(l->scroll, p0, p0+l->f.nchars, tot);\n                y = rt.min.y;\n            }else if(but == 2){\n                y = my;\n                if(y > s.max.y-2)\n                    y = s.max.y-2;\n            }else if(but == 3){\n                p0 = l->origin+frcharofpt(&l->f, Pt(s.max.x, my));\n                rt = scrpos(l->scroll, p0, p0+l->f.nchars, tot);\n                y = rt.min.y;\n            }\n            if(y != oy){\n                scrflip(l, r);\n                r = raddp(scr, Pt(0, y-scr.min.y));\n                scrflip(l, r);\n            }\n        }\n    }while(button(pbut));\n    if(in){\n        h = s.max.y-s.min.y;\n        scrflip(l, r);\n        p0 = 0;\n        if(but == 1)\n            p0 = (int64_t)(my-s.min.y)/l->f.fheight+1;\n        else if(but == 2){\n            if(tot > 1024L*1024L)\n                p0 = ((tot>>10)*(y-s.min.y)/h)<<10;\n            else\n                p0 = tot*(y-s.min.y)/h;\n        }else if(but == 3){\n            p0 = l->origin+frcharofpt(&l->f, Pt(s.max.x, my));\n            if(p0 > tot)\n                p0 = tot;\n        }\n        scrorigin(l, but, p0);\n    }\n}\n", "source": "sam/samterm/scroll.c", "file_type": "c"}
{"text": "/* Copyright (c) 1998 Lucent Technologies - All rights reserved. */\n#include <u.h>\n#include <libg.h>\n#include <frame.h>\n#include \"flayer.h\"\n#include \"samterm.h\"\n\nuint8_t   *name[MAXFILES];    /* first byte is ' ' or '\\'': modified state */\nText    *text[MAXFILES];    /* pointer to Text associated with file */\nuint16_t  tag[MAXFILES];      /* text[i].tag, even if text[i] not defined */\nint nname;\nint mw;\n\nchar    *genmenu3(int);\nchar    *genmenu2(int);\nchar    *genmenu2c(int);\n\nextern uint64_t _bgpixel;\n\nenum Menu2\n{\n    Cut,\n    Paste,\n    Snarf,\n    Look,\n    Exch,\n    Search,\n    NMENU2 = Search,\n    Send = Search,\n    NMENU2C\n};\n\nenum Menu3\n{\n    New,\n    Zerox,\n    Reshape,\n    Close,\n    Write,\n    NMENU3\n};\n\nchar    *menu2str[] = {\n    \"cut\",\n    \"paste\",\n    \"snarf\",\n    \"look\",\n    \"<exch>\",\n    0,      /* storage for last pattern */\n};\n\nchar    *menu3str[] = {\n    \"new\",\n    \"zerox\",\n    \"reshape\",\n    \"close\",\n    \"write\",\n};\n\nMenu    menu2 = {0, genmenu2};\nMenu    menu2c ={0, genmenu2c};\nMenu    menu3 = {0, genmenu3};\n\nvoid\nmenu2hit(void)\n{\n    Text *t=(Text *)which->user1;\n    int w = which-t->l;\n    int m;\n\n    m = menuhit(2, &mouse, t==&cmd? &menu2c : &menu2);\n    if(lock || t->lock)\n        return;\n\n    switch(m){\n    case Cut:\n        cut(t, w, true, true);\n        break;\n\n    case Paste:\n        paste(t, w);\n        break;\n\n    case Snarf:\n        snarf(t, w);\n        break;\n\n    case Exch:\n        snarf(t, w);\n        outT0(Tstartsnarf);\n        setlock();\n        break;\n\n    case Look:\n        outTsll(Tlook, t->tag, which->p0, which->p1);\n        setlock();\n        break;\n\n    case Search:\n        outcmd();\n        if(t==&cmd)\n            outTsll(Tsend, 0 /*ignored*/, which->p0, which->p1);\n        else\n            outT0(Tsearch);\n        setlock();\n        break;\n    }\n}\n\nvoid\nmenu3hit(void)\n{\n    Rectangle r;\n    Flayer *l;\n    int m, i;\n    Text *t;\n\n    mw = -1;\n    switch(m = menuhit(3, &mouse, &menu3)){\n    case -1:\n        break;\n\n    case New:\n        if(!lock)\n            sweeptext(1, 0);\n        break;\n\n    case Zerox:\n    case Reshape:\n        if(!lock){\n            cursorswitch(BullseyeCursor);\n            buttons(Down);\n            if((mouse.buttons&4) && (l = flwhich(mouse.xy)) && getr(&r))\n                duplicate(l, r, l->f.font, m==Reshape);\n            else\n                cursorswitch(cursor);\n            buttons(Up);\n        }\n        break;\n\n    case Close:\n        if(!lock){\n            cursorswitch(BullseyeCursor);\n            buttons(Down);\n            if((mouse.buttons&4) && (l = flwhich(mouse.xy)) && !lock){\n                t=(Text *)l->user1;\n                if (t->nwin>1)\n                    closeup(l);\n                else if(t!=&cmd) {\n                    outTs(Tclose, t->tag);\n                    setlock();\n                }\n            }\n            cursorswitch(cursor);\n            buttons(Up);\n        }\n        break;\n\n    case Write:\n        if(!lock){\n            cursorswitch(BullseyeCursor);\n            buttons(Down);\n            if((mouse.buttons&4) && (l = flwhich(mouse.xy))){\n                outTs(Twrite, ((Text *)l->user1)->tag);\n                setlock();\n            }else\n                cursorswitch(cursor);\n            buttons(Up);\n        }\n        break;\n\n    default:\n        if((t = text[m-NMENU3])){\n            i = t->front;\n            if(t->nwin==0 || t->l[i].textfn==0)\n                return; /* not ready yet; try again later */\n            if(t->nwin>1 && which==&t->l[i])\n                do\n                    if(++i==NL)\n                        i = 0;\n                while(i!=t->front && t->l[i].textfn==0);\n            current(&t->l[i]);\n            if (followfocus)\n                flupfront(&t->l[i]);\n        }else if(!lock)\n            sweeptext(0, tag[m-NMENU3]);\n        break;\n    }\n}\n\n\nText *\nsweeptext(int new, int tag)\n{\n    Rectangle r;\n    Text *t;\n\n    if(getr(&r) && (t = malloc(sizeof(Text)))){\n        memset((void*)t, 0, sizeof(Text));\n        current((Flayer *)0);\n        flnew(&t->l[0], stgettext, 0, (char *)t);\n        flinit(&t->l[0], r, font, getbg()); /*bnl*/\n        t->nwin = 1;\n        rinit(&t->rasp);\n        if(new)\n            startnewfile(Tstartnewfile, t);\n        else{\n            rinit(&t->rasp);\n            t->tag = tag;\n            startfile(t);\n        }\n        return t;\n    }\n    return 0;\n}\n\nint\nwhichmenu(int tg)\n{\n    int i;\n\n    for(i=0; i<nname; i++)\n        if(tag[i] == tg)\n            return i;\n    return -1;\n}\n\nvoid\nmenuins(int n, uint8_t *s, Text *t, int m, int tg)\n{\n    int i;\n\n    if(nname == MAXFILES)\n        panic(\"menuins\");\n    for(i=nname; i>n; --i)\n        name[i]=name[i-1], text[i]=text[i-1], tag[i]=tag[i-1];\n    text[n] = t;\n    tag[n] = tg;\n    name[n] = alloc(strlen((char*)s)+2);\n    name[n][0] = m;\n    strcpy((char*)name[n]+1, (char*)s);\n    nname++;\n    menu3.lasthit = n+NMENU3;\n}\n\nvoid\nmenudel(int n)\n{\n    int i;\n\n    if(nname==0 || n>=nname || text[n])\n        panic(\"menudel\");\n    free(name[n]);\n    --nname;\n    for(i = n; i<nname; i++)\n        name[i]=name[i+1], text[i]=text[i+1], tag[i]=tag[i+1];\n}\n\nvoid\nsetpat(char *s)\n{\n    static char pat[17];\n\n    pat[0] = '/';\n    strncpy(pat+1, s, 15);\n    menu2str[Search] = pat;\n}\n\nbool\nhaspat(void)\n{\n    return (bool)(menu2str[Search]);\n}\n\n#define NBUF    64\nstatic uint8_t buf[NBUF * MB_LEN_MAX] = {' ', ' ', ' ', ' '};\n\nchar *\nparen(char *s)\n{\n    uint8_t *t = buf;\n\n    *t++ = '(';\n    do; while((*t++ = *s++));\n    t[-1] = ')';\n    *t = 0;\n    return (char *)buf;\n}\nchar*\ngenmenu2(int n)\n{\n    Text *t=(Text *)which->user1;\n    char *p;\n    if(n>=NMENU2+(menu2str[Search]!=0))\n        return 0;\n    p = menu2str[n];\n    if((!lock && !t->lock) || n==Search || n==Look)\n        return p;\n    return paren(p);\n}\nchar*\ngenmenu2c(int n)\n{\n    Text *t=(Text *)which->user1;\n    char *p;\n    if(n >= NMENU2C)\n        return 0;\n    if(n == Send)\n        p=\"send\";\n    else\n        p = menu2str[n];\n    if(!lock && !t->lock)\n        return p;\n    return paren(p);\n}\nchar *\ngenmenu3(int n)\n{\n    Text *t;\n    int c, i, k, l, w;\n    wchar_t r;\n    char *p;\n\n    if(n >= NMENU3+nname)\n        return 0;\n    if(n < NMENU3){\n        p = menu3str[n];\n        if(lock)\n            p = paren(p);\n        return p;\n    }\n    n -= NMENU3;\n    if(n == 0)  /* unless we've been fooled, this is cmd */\n        return (char *)&name[n][1];\n    if(mw == -1){\n        mw = 7; /* strlen(\"~~sam~~\"); */\n        for(i=1; i<nname; i++){\n            w = utflen((char*)name[i]+1)+4; /* include \"'+. \" */\n            if(w > mw)\n                mw = w;\n        }\n    }\n    if(mw > NBUF)\n        mw = NBUF;\n    t = text[n];\n    buf[0] = name[n][0];\n    buf[1] = '-';\n    buf[2] = ' ';\n    buf[3] = ' ';\n    if(t){\n        if(t->nwin == 1)\n            buf[1] = '+';\n        else if(t->nwin > 1)\n            buf[1] = '*';\n        if(work && t==(Text *)work->user1) {\n            buf[2]= '.';\n            if(modified)\n                buf[0] = '\\'';\n        }\n    }\n    l = utflen((char*)name[n]+1);\n    if(l > NBUF-4-2){\n        i = 4;\n        k = 1;\n        while(i < NBUF/2){\n            k += chartorune(&r, (char*)name[n]+k);\n            i++;\n        }\n        c = name[n][k];\n        name[n][k] = 0;\n        strcpy((char*)buf+4, (char*)name[n]+1);\n        name[n][k] = c;\n        strcat((char*)buf, \"...\");\n        while((l-i) >= NBUF/2-4){\n            k += chartorune(&r, (char*)name[n]+k);\n            i++;\n        }\n        strcat((char*)buf, (char*)name[n]+k);\n    }else\n        strcpy((char*)buf+4, (char*)name[n]+1);\n    i = utflen((char*)buf);\n    k = strlen((char*)buf);\n    while(i<mw && k<sizeof buf-1){\n        buf[k++] = ' ';\n        i++;\n    }\n    buf[k] = 0;\n    return (char *)buf;\n}\n", "source": "sam/samterm/menu.c", "file_type": "c"}
{"text": "/* Copyright (c) 1998 Lucent Technologies - All rights reserved. */\n#include <u.h>\n#include <libg.h>\n#include <frame.h>\n#include \"flayer.h\"\n#include \"samterm.h\"\n\nvoid\nrinit(Rasp *r)\n{\n    r->nrunes=0;\n    r->sect=0;\n}\n\nvoid\nrclear(Rasp *r)\n{\n    Section *s, *ns;\n\n    for(s=r->sect; s; s=ns){\n        ns = s->next;\n        free(s->text);\n        free(s);\n    }\n    r->sect = 0;\n}\n\nSection*\nrsinsert(Rasp *r, Section *s)   /* insert before s */\n{\n    Section *t;\n    Section *u;\n\n    t = alloc(sizeof(Section));\n    if(r->sect == s){   /* includes empty list case: r->sect==s==0 */\n        r->sect = t;\n        t->next = s;\n    }else{\n        u = r->sect;\n        if(u == 0)\n            panic(\"rsinsert 1\");\n        do{\n            if(u->next == s){\n                t->next = s;\n                u->next = t;\n                goto Return;\n            }\n            u=u->next;\n        }while(u);\n        panic(\"rsinsert 2\");\n    }\n    Return:\n    return t;\n}\n\nvoid\nrsdelete(Rasp *r, Section *s)\n{\n    Section *t;\n\n    if(s == 0)\n        panic(\"rsdelete\");\n    if(r->sect == s){\n        r->sect = s->next;\n        goto Free;\n    }\n    for(t=r->sect; t; t=t->next)\n        if(t->next == s){\n            t->next = s->next;\n    Free:\n            if(s->text)\n                free(s->text);\n            free(s);\n            return;\n        }\n    panic(\"rsdelete 2\");\n}\n\nvoid\nsplitsect(Rasp *r, Section *s, int64_t n0)\n{\n    if(s == 0)\n        panic(\"splitsect\");\n    rsinsert(r, s->next);\n    if(s->text == 0)\n        s->next->text = 0;\n    else{\n        s->next->text = alloc(RUNESIZE*(TBLOCKSIZE+1));\n        Strcpy(s->next->text, s->text+n0);\n        s->text[n0] = 0;\n    }\n    s->next->nrunes = s->nrunes-n0;\n    s->nrunes = n0;\n}\n\nSection *\nfindsect(Rasp *r, Section *s, int64_t p, int64_t q)   /* find sect containing q and put q on a sect boundary */\n{\n    if(s==0 && p!=q)\n        panic(\"findsect\");\n    for(; s && p+s->nrunes<=q; s=s->next)\n        p += s->nrunes;\n    if(p != q){\n        splitsect(r, s, q-p);\n        s = s->next;\n    }\n    return s;\n}\n\nvoid\nrresize(Rasp *r, int64_t a, int64_t old, int64_t new)\n{\n    Section *s, *t, *ns;\n\n    s = findsect(r, r->sect, 0L, a);\n    t = findsect(r, s, a, a+old);\n    for(; s!=t; s=ns){\n        ns=s->next;\n        rsdelete(r, s);\n    }\n    /* now insert the new piece before t */\n    if(new > 0){\n        ns=rsinsert(r, t);\n        ns->nrunes=new;\n        ns->text=0;\n    }\n    r->nrunes += new-old;\n}\n\nvoid\nrdata(Rasp *r, int64_t p0, int64_t p1, wchar_t *cp)\n{\n    Section *s, *t, *ns;\n\n    s = findsect(r, r->sect, 0L, p0);\n    t = findsect(r, s, p0, p1);\n    for(; s!=t; s=ns){\n        ns=s->next;\n        if(s->text)\n            panic(\"rdata\");\n        rsdelete(r, s);\n    }\n    p1 -= p0;\n    s = rsinsert(r, t);\n    s->text = alloc(RUNESIZE*(TBLOCKSIZE+1));\n    memmove(s->text, cp, RUNESIZE*p1);\n    s->text[p1] = 0;\n    s->nrunes = p1;\n}\n\nvoid\nrclean(Rasp *r)\n{\n    Section *s;\n\n    for(s=r->sect; s; s=s->next)\n        while(s->next && (s->text!=0)==(s->next->text!=0)){\n            if(s->text){\n                if(s->nrunes+s->next->nrunes>TBLOCKSIZE)\n                    break;\n                Strcpy(s->text+s->nrunes, s->next->text);\n            }\n            s->nrunes += s->next->nrunes;\n            rsdelete(r, s->next);\n        }\n}\n\nvoid\nStrcpy(wchar_t *to, wchar_t *from)\n{\n    do; while((*to++ = *from++));\n}\n\nwchar_t*\nrload(Rasp *r, uint64_t p0, uint64_t p1, uint64_t *nrp)\n{\n    Section *s;\n    int64_t p;\n    int n, nb;\n\n    nb = 0;\n    Strgrow(&scratch, &nscralloc, p1-p0+1);\n    scratch[0] = 0;\n    for(p=0,s=r->sect; s && p+s->nrunes<=p0; s=s->next)\n        p += s->nrunes;\n    while(p<p1 && s){\n        /*\n         * Subtle and important.  If we are preparing to handle an 'rdata'\n         * call, it's because we have an 'rresize' hole here, so the\n         * screen doesn't have data for that space anyway (it got cut\n         * first).  So pretend it isn't there.\n         */\n        if(s->text){\n            n = s->nrunes-(p0-p);\n            if(n>p1-p0) /* all in this section */\n                n = p1-p0;\n            memmove(scratch+nb, s->text+(p0-p), n*RUNESIZE);\n            nb += n;\n            scratch[nb] = 0;\n        }\n        p += s->nrunes;\n        p0 = p;\n        s = s->next;\n    }\n    if(nrp)\n        *nrp = nb;\n    return scratch;\n}\n\nint\nrmissing(Rasp *r, uint64_t p0, uint64_t p1)\n{\n    Section *s;\n    int64_t p;\n    int n, nm=0;\n\n    for(p=0,s=r->sect; s && p+s->nrunes<=p0; s=s->next)\n        p += s->nrunes;\n    while(p<p1 && s){\n        if(s->text == 0){\n            n = s->nrunes-(p0-p);\n            if(n > p1-p0)   /* all in this section */\n                n = p1-p0;\n            nm += n;\n        }\n        p += s->nrunes;\n        p0 = p;\n        s = s->next;\n    }\n    return nm;\n}\n\nint\nrcontig(Rasp *r, uint64_t p0, uint64_t p1, bool text)\n{\n    Section *s;\n    int64_t p, n;\n    int np=0;\n\n    for(p=0,s=r->sect; s && p+s->nrunes<=p0; s=s->next)\n        p += s->nrunes;\n    while(p<p1 && s && (text ? (s->text!=0) : (s->text==0))){\n        n = s->nrunes-(p0-p);\n        if(n > p1-p0)   /* all in this section */\n            n = p1-p0;\n        np += n;\n        p += s->nrunes;\n        p0 = p;\n        s = s->next;\n    }\n    return np;\n}\n\nvoid\nStrgrow(wchar_t **s, int64_t *n, int want)    /* can always toss the old data when called */\n{\n    if(*n >= want)\n        return;\n    free(*s);\n    *s = alloc(RUNESIZE*want);\n    *n = want;\n}\n", "source": "sam/samterm/rasp.c", "file_type": "c"}
{"text": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <strings.h>\n#include <X11/Xlib.h>\n#include <X11/keysym.h>\n\n#include <u.h>\n#include <libg.h>\n#include <frame.h>\n#include \"flayer.h\"\n#include \"samterm.h\"\n\nextern bool expandtabs;\nextern int tabwidth;\nextern bool autoindent;\n\ntypedef struct Namemapping Namemapping;\nstruct Namemapping{\n    const char *name;\n    int value;\n};\n\nstatic Namemapping commandmapping[] ={\n    {\"none\",            Cnone},\n    {\"default\",         Cdefault},\n    {\"escape\",          Cescape},\n    {\"scrolldown\",      Cscrolldown},\n    {\"scrollup\",        Cscrollup},\n    {\"scrolldownline\",  Cscrolldownline},\n    {\"scrollupline\",    Cscrollupline},\n    {\"jump\",            Cjump},\n    {\"charright\",       Ccharright},\n    {\"charleft\",        Ccharleft},\n    {\"linedown\",        Clinedown},\n    {\"lineup\",          Clineup},\n    {\"delword\",         Cdelword},\n    {\"delbol\",          Cdelbol},\n    {\"delbs\",           Cdelbs},\n    {\"del\",             Cdel},\n    {\"snarf\",           Csnarf},\n    {\"cut\",             Ccut},\n    {\"paste\",           Cpaste},\n    {\"exchange\",        Cexchange},\n    {\"eol\",             Ceol},\n    {\"bol\",             Cbol},\n    {\"tab\",             Ctab},\n    {\"send\",            Csend},\n    {\"look\",            Clook},\n    {\"search\",          Csearch},\n    {\"write\",           Cwrite},\n    {NULL, 0}\n};\n\nstatic Namemapping targetmapping[] ={\n    {\"current\",     Tcurrent},\n    {\"mouse\",       Tmouse},\n    {NULL, 0}\n};\n\nstatic Namemapping buttonmapping[] ={\n    {\"0\",  0}, \n    {\"n\",  0}, \n#define B1 1\n    {\"1\",  1}, \n#define B2 2\n    {\"2\",  2}, \n#define B3 4\n    {\"3\",  4}, \n#define B4 8\n    {\"4\",  8}, \n#define B5 16\n    {\"5\", 16}, \n    {NULL, 0}\n};\n\nstatic Namemapping modmapping[] ={\n    {\"*\", 0},\n    {\"c\", ControlMask}, \n    {\"a\", Mod1Mask},\n    {\"s\", ShiftMask},\n    {NULL, 0}\n};\n\nstatic int\nlookupmapping(const char *n, Namemapping *m)\n{\n    for (Namemapping *k = m; k->name != NULL; k++){\n        if (strcasecmp(k->name, n) == 0)\n            return k->value;\n    }\n\n    return -1;\n}\n\n#define nametocommand(n) lookupmapping(n, commandmapping)\n#define nametotarget(n) lookupmapping(n, targetmapping)\n\ntypedef struct Defaultbinding Defaultbinding;\nstruct Defaultbinding{\n    int modifiers;\n    KeySym keysym;\n    int kind;\n    int command;\n    const char *arg;\n};\n\nstatic Defaultbinding defaultbindings[] ={    \n    /* Suppress control key combinations unless explicitly bound. */\n    {ControlMask, XK_VoidSymbol,    Kcommand, Cnone,        NULL},\n\n    /* Motion commands following the WordStar diamond. */\n    {ControlMask, XK_e,             Kcommand,  Clineup,     NULL},\n    {ControlMask, XK_x,             Kcommand,  Clinedown,   NULL},\n    {ControlMask, XK_d,             Kcommand,  Ccharright,  NULL},\n    {ControlMask, XK_s,             Kcommand,  Ccharleft,   NULL},\n    {ControlMask, XK_u,             Kcommand,  Cdelbol,     NULL},\n    {ControlMask, XK_w,             Kcommand,  Cdelword,    NULL},\n    {ControlMask, XK_k,             Kcommand,  Cjump,       NULL},\n    {ControlMask, XK_BackSpace,     Kcommand,  Cdelword,    NULL},\n    {ControlMask, XK_y,             Kcommand,  Ccut,        NULL},\n    {ControlMask, XK_c,             Kcommand,  Csnarf,      NULL},\n    {ControlMask, XK_v,             Kcommand,  Cpaste,      NULL},\n    {ControlMask, XK_q,             Kcommand,  Cexchange,   NULL},\n\n    /* Handle arrow keys, page up/down, and escape. */\n    {0,           XK_Up,            Kcommand, Cscrollup,    NULL},\n    {0,           XK_Prior,         Kcommand, Cscrollup,    NULL},\n    {0,           XK_Left,          Kcommand, Cscrollup,    NULL},\n    {0,           XK_Down,          Kcommand, Cscrolldown,  NULL},\n    {0,           XK_Next,          Kcommand, Cscrolldown,  NULL},\n    {0,           XK_Right,         Kcommand, Cscrolldown,  NULL},\n    {0,           XK_Escape,        Kcommand, Cescape,      NULL},\n    \n    /* More fundamental stuff: backspace, delete, etc. */\n    {0,           XK_BackSpace,     Kcommand, Cdelbs,   NULL},\n    {0,           XK_Delete,        Kcommand, Cdel,     NULL},\n    {0,           XK_Tab,           Kcommand, Ctab,     NULL},\n    {0,           XK_Return,        Kraw,     '\\n',     NULL},\n    {0,           XK_KP_Enter,      Kraw,     '\\n',     NULL},\n    {0,           XK_Linefeed,      Kraw,     '\\r',     NULL},\n    {0,           XK_KP_0,          Kraw,     '0',      NULL},\n    {0,           XK_KP_1,          Kraw,     '1',      NULL},\n    {0,           XK_KP_2,          Kraw,     '2',      NULL},\n    {0,           XK_KP_3,          Kraw,     '3',      NULL},\n    {0,           XK_KP_4,          Kraw,     '4',      NULL},\n    {0,           XK_KP_5,          Kraw,     '5',      NULL},\n    {0,           XK_KP_6,          Kraw,     '6',      NULL},\n    {0,           XK_KP_7,          Kraw,     '7',      NULL},\n    {0,           XK_KP_8,          Kraw,     '8',      NULL},\n    {0,           XK_KP_9,          Kraw,     '9',      NULL},\n    {0,           XK_KP_Divide,     Kraw,     '/',      NULL},\n    {0,           XK_KP_Multiply,   Kraw,     '*',      NULL},\n    {0,           XK_KP_Subtract,   Kraw,     '-',      NULL},\n    {0,           XK_KP_Add,        Kraw,     '+',      NULL},\n    {0,           XK_KP_Decimal,    Kraw,     '.',      NULL},\n    {0,           XK_hyphen,        Kraw,     '-',      NULL},\n\n    /* Support traditional control sequences. */\n    {ControlMask, XK_bracketleft,   Kcommand, Cescape,  NULL},\n    {ControlMask, XK_h,             Kcommand, Cdelbs,   NULL},\n    {ControlMask, XK_Delete,        Kcommand, Cdel,     NULL},\n    {ControlMask, XK_i,             Kcommand, Ctab,     NULL},\n    {ControlMask, XK_j,             Kraw,     '\\n',     NULL},\n    {ControlMask, XK_m,             Kraw,     '\\r',     NULL},\n\n    /* Use Control-Tab to insert a literal tab when tab expansion is enabled. */\n    {ControlMask, XK_Tab,           Kraw,     '\\t',     NULL},\n\n    {0,           0,                Kend,     0,        NULL}\n};\n\nvoid\ninstalldefaultbindings(void)\n{\n    for (Defaultbinding *b = defaultbindings; b->kind != Kend; b++)\n        installbinding(b->modifiers, b->keysym, b->kind, b->command, b->arg);\n}\n\ntypedef struct Defaultchord Defaultchord;\nstruct Defaultchord{\n    int state1;\n    int state2;\n    int command;\n    int target;\n    const char *arg;\n};\n\nstatic Defaultchord defaultchords[] ={\n    {B1, B1|B2,  Ccut,   Tcurrent, NULL},\n    {B1, B1|B3,  Cpaste, Tcurrent, NULL},\n    {B1|B2, B1,  Cnone,  Tcurrent, NULL},\n    {B1|B3, B1,  Cnone,  Tcurrent, NULL},\n\n    {B4, 0,  Cscrollupline,   Tmouse, NULL},\n    {B5, 0,  Cscrolldownline, Tmouse, NULL},\n\n    {0, 0, Kend, 0, NULL}\n};\n\nvoid\ninstalldefaultchords(void)\n{\n    for (Defaultchord *c = defaultchords; c->state1 != 0; c++)\n        installchord(c->state1, c->state2, c->command, c->target, c->arg);\n}\n\nstatic int\nstatetomask(const char *n, Namemapping *m)\n{\n    int r = 0;\n    for (int i = 0; n[i] != 0; i++){\n        char s[2] = {n[i], 0};\n        int v = lookupmapping(s, m);\n        if (v < 0)\n            return -1;\n        r |= v;\n    }\n\n    return r;\n}\n\n#define buttontomask(n) statetomask(n, buttonmapping)\n#define modtomask(n) statetomask(n, modmapping)\n\nstatic KeySym\nnametokeysym(const char *n)\n{\n    KeySym k, l, u;\n\n    k = XStringToKeysym(n);\n    XConvertCase(k, &l, &u);\n    return l;\n}\n\nstatic int\ndirfollowfocus(const char *s1, const char *s2, const char *s3, const char *s4, const char *s5)\n{\n    if (strcasecmp(s1, \"true\") != 0 && strcasecmp(s1, \"false\") != 0)\n        return -1;\n\n    followfocus = (strcasecmp(s1, \"true\") == 0);\n    return 0;\n}\n\nstatic int\ndirsnarfselection(const char *s1, const char *s2, const char *s3, const char *s4, const char *s5)\n{\n    extern const char *clipatom;\n\n    if (strcasecmp(s1, \"primary\") == 0)\n        clipatom = \"PRIMARY\";\n    else if (strcasecmp(s1, \"secondary\") == 0)\n        clipatom = \"SECONDARY\";\n    else if (strcasecmp(s1, \"clipboard\") == 0)\n        clipatom = \"CLIPBOARD\";\n    else\n        return -1;\n\n    return 0;\n}\n\nstatic int\ndirchord(const char *s1, const char *s2, const char *s3, const char *s4, const char *s5)\n{\n    return installchord(buttontomask(s1), buttontomask(s2), nametocommand(s3), nametotarget(s4), s5);\n}\n\nstatic int\ndirraw(const char *s1, const char *s2, const char *s3, const char *s4, const char *s5)\n{\n    return installbinding(modtomask(s1), nametokeysym(s2), Kraw, strtol(s3, NULL, 16), NULL);\n}\n\nstatic int\ndirrawliteral(const char *s1, const char *s2, const char *s3, const char *s4, const char *s5)\n{\n    if (strlen(s3) != 1)\n        return -1;\n    return installbinding(modtomask(s1), nametokeysym(s2), Kraw, s3[0], NULL);\n}\n\nstatic int\ndirbind(const char *s1, const char *s2, const char *s3, const char *s4, const char *s5)\n{\n    return installbinding(modtomask(s1), nametokeysym(s2), Kcommand, nametocommand(s3), s4);\n}\n\nstatic int\ndirunbind(const char *s1, const char *s2, const char *s3, const char *s4, const char *s5)\n{\n    return removebinding(modtomask(s1), nametokeysym(s2));\n}\n\nstatic int\ndirunchord(const char *s1, const char *s2, const char *s3, const char *s4, const char *s5)\n{\n    return removechord(buttontomask(s1), buttontomask(s2));\n}\n\nstatic int\ndirforeground(const char *s1, const char *s2, const char *s3, const char *s4, const char *s5)\n{\n    if (strlen(s1) == 0)\n        return -1;\n\n    strncpy(foregroundspec, s1, sizeof(foregroundspec) - 1);\n    return 0;\n}\n\nstatic int\ndirbackground(const char *s1, const char *s2, const char *s3, const char *s4, const char *s5)\n{\n    if (strlen(s1) == 0)\n        return -1;\n\n    strncpy(backgroundspec, s1, sizeof(backgroundspec) - 1);\n    return 0;\n}\n\nstatic int\ndirborder(const char *s1, const char *s2, const char *s3, const char *s4, const char *s5)\n{\n    if (strlen(s1) == 0)\n        return -1;\n\n    strncpy(borderspec, s1, sizeof(borderspec) - 1);\n    return 0;\n}\n\nstatic int\ndirfont(const char *s1, const char *s2, const char *s3, const char *s4, const char *s5)\n{\n    if (strlen(s1) == 0)\n        return -1;\n\n    strncpy(fontspec, s1, sizeof(fontspec) - 1);\n    return 0;\n}\n\nstatic int\ndirtabs(const char *s1, const char *s2, const char *s3, const char *s4, const char *s5)\n{\n    int i = atoi(s1);\n    if (i <= 0 || i > 12)\n        return -1;\n\n    tabwidth = i;\n    return 0;\n}\n\nstatic int\ndirexpandtabs(const char *s1, const char *s2, const char *s3, const char *s4, const char *s5)\n{\n    if (strcasecmp(s1, \"true\") != 0 && strcasecmp(s1, \"false\") != 0)\n        return -1;\n\n    expandtabs = (strcasecmp(s1, \"true\") == 0);\n    return 0;\n}\n\nstatic int\ndirautoindent(const char *s1, const char *s2, const char *s3, const char *s4, const char *s5)\n{\n    if (strcasecmp(s1, \"true\") != 0 && strcasecmp(s1, \"false\") != 0)\n        return -1;\n\n    autoindent = (strcasecmp(s1, \"true\") == 0);\n    return 0;\n}\n\nstatic int\ndircomment(const char *s1, const char *s2, const char *s3, const char *s4, const char *s5)\n{\n    return 0;\n}\n\ntypedef struct Directive Directive;\nstruct Directive{\n    const char *format;\n    int result;\n    int (*action)(const char *, const char *, const char *, const char *, const char *);\n};\n\nDirective directives[] ={\n    {\" chord %5[Nn12345] %5[Nn12345] %99s %99s %1023[^\\n]\",       5,   dirchord},\n    {\" chord %5[Nn12345] %5[Nn12345] %99s %99s\",                  4,   dirchord},\n    {\" unchord %5[Nn12345] %5[Nn12345]\",                          2,   dirunchord},\n    {\" bind %5[*camshNCAMSH12345] %99s raw 0x%4[0-9a-fA-F]\",      3,   dirraw},\n    {\" bind %5[*camshNCAMSH12345] %99s raw %1s\",                  3,   dirrawliteral},\n    {\" bind %5[*camshNCAMSH12345] %99s command %99s %1023[^\\n]\",  4,   dirbind},\n    {\" bind %5[*camshNCAMSH12345] %99s command %99s\",             3,   dirbind},\n    {\" unbind %5[*camshNCAMSH12345] %99s\",                        2,   dirunbind},\n    {\" foreground %1023s\",                                        1,   dirforeground},\n    {\" background %1023s\",                                        1,   dirbackground},\n    {\" border %1023s\",                                            1,   dirborder},\n    {\" font %1023[^\\n]\",                                          1,   dirfont},\n    {\" tabs %2[0-9]\",                                             1,   dirtabs},\n    {\" expandtabs %99s\",                                          1,   direxpandtabs},\n    {\" autoindent %99s\",                                          1,   dirautoindent},\n    {\" snarfselection %99s\",                                      1,   dirsnarfselection},\n    {\" followfocus %99s\",                                         1,   dirfollowfocus},\n    {\" %1[#]\",                                                    1,   dircomment},\n    {\" %1[^ ]\",                                                   EOF, dircomment},\n    {NULL, 0, NULL}\n};\n\nvoid\nloadrcfile(FILE *f)\n{\n    char *l = NULL;\n    size_t n = 0;\n    ssize_t r = 0;\n    size_t ln = 0;\n\n    while ((r = getline(&l, &n, f)) >= 0){\n        char s1[1024] = {0};\n        char s2[1024] = {0};\n        char s3[1024] = {0};\n        char s4[1024] = {0};\n        char s5[1024] = {0};\n        int rc = 0;\n        bool found = false;\n\n        ln++;\n        if (r == 0)\n            continue;\n\n        for (Directive *d = directives; d->format && !found; d++){\n            if (sscanf(l, d->format, s1, s2, s3, s4, s5) == d->result){\n                rc = d->action(s1, s2, s3, s4, s5);\n                found = true;\n            }\n        }\n\n        if (!found)\n            fprintf(stderr, \"invalid rc line %zd\\n\", ln);\n\n        if (rc != 0)\n            fprintf(stderr, \"invalid chord/binding on rc line %zd\\n\", ln);\n    }\n\n    free(l);\n}\n", "source": "sam/samterm/samrc.c", "file_type": "c"}
{"text": "/* Copyright (c) 1998 Lucent Technologies - All rights reserved. */\n#include <u.h>\n#include <libg.h>\n#include <frame.h>\n#include \"flayer.h\"\n#include \"samterm.h\"\n\n#define DELTA   10\n\nstatic Flayer   **llist;    /* front to back */\nstatic int  nllist;\nstatic int  nlalloc;\nstatic Rectangle lDrect;\n\nextern Bitmap   screen;\nextern Mouse    mouse;\n\nextern uint64_t _bgpixel;\n\nVis     visibility(Flayer *);\nvoid        newvisibilities(int);\nvoid        llinsert(Flayer*);\nvoid        lldelete(Flayer*);\n\nvoid\nflstart(Rectangle r)\n{\n    lDrect = r;\n}\n\nvoid\nflnew(Flayer *l, wchar_t *(*fn)(Flayer*, int64_t, uint64_t*), int u0, void *u1)\n{\n    if(nllist == nlalloc){\n        nlalloc += DELTA;\n        llist = realloc(llist, nlalloc*sizeof(Flayer**));\n        if(llist == 0)\n            panic(\"flnew\");\n    }\n    l->textfn = fn;\n    l->user0 = u0;\n    l->user1 = u1;\n    l->bg = _bgpixel;\n    llinsert(l);\n}\n\nRectangle\nflrect(Flayer *l, Rectangle r)\n{\n    rectclip(&r, lDrect);\n    l->entire = r;\n    l->scroll = inset(r, FLMARGIN);\n    r.min.x =\n     l->scroll.max.x = r.min.x+FLMARGIN+FLSCROLLWID+(FLGAP-FLMARGIN);\n    return r;\n}\n\nvoid\nflinit(Flayer *l, Rectangle r, XftFont *ft, uint64_t bg)\n{\n    lldelete(l);\n    llinsert(l);\n    l->visible = All;\n    l->origin = l->p0 = l->p1 = 0;\n    frinit(&l->f, inset(flrect(l, r), FLMARGIN), ft, &screen, bg);\n    l->bg = bg;\n    newvisibilities(1);\n    bitblt2(&screen, l->entire.min, &screen, l->entire, 0, 0, l->bg);\n    scrdraw(l, 0L);\n    flborder(l, 0);\n}\n\nvoid\nflclose(Flayer *l)\n{\n    if(l->visible == All)\n        bitblt2(&screen, l->entire.min, &screen, l->entire, 0, _bgpixel, _bgpixel);\n    else if(l->visible == Some){\n        if(l->f.b == 0)\n            l->f.b = balloc(l->entire, screen.ldepth);\n        if(l->f.b){\n            bitblt2(l->f.b, l->entire.min, l->f.b, l->entire, 0, _bgpixel, _bgpixel);\n            flrefresh(l, l->entire, 0);\n        }\n    }\n    frclear(&l->f);\n    lldelete(l);\n    if(l->f.b && l->visible!=All)\n        bfree(l->f.b);\n    l->textfn = 0;\n    newvisibilities(1);\n}\n\nvoid\nflborder(Flayer *l, bool wide)\n{\n    if(flprepare(l)){\n        border(l->f.b, l->entire, FLMARGIN, 0, l->bg);\n        border(l->f.b, l->entire, wide? FLMARGIN : 1, F&~D, l->bg);\n        if(l->visible==Some)\n            flrefresh(l, l->entire, 0);\n    }\n}\n\nFlayer *\nflwhich(Point p)\n{\n    int i;\n\n    if(p.x==0 && p.y==0)\n        return nllist? llist[0] : 0;\n    for(i=0; i<nllist; i++)\n        if(ptinrect(p, llist[i]->entire))\n            return llist[i];\n    return 0;\n}\n\nvoid\nflupfront(Flayer *l)\n{\n    int v = l->visible;\n\n    lldelete(l);\n    llinsert(l);\n    if(v!=All)\n        newvisibilities(0);\n}\n\nvoid\nnewvisibilities(int redraw)\n    /* if redraw false, we know it's a flupfront, and needn't\n     * redraw anyone becoming partially covered */\n{\n    int i;\n    Vis ov;\n    Flayer *l;\n\n    for(i = 0; i<nllist; i++){\n        l = llist[i];\n        ov = l->visible;\n        l->visible = visibility(l);\n#define V(a, b) (((a)<<2)|((b)))\n        switch(V(ov, l->visible)){\n        case V(Some, None):\n            if(l->f.b)\n                bfree(l->f.b);\n        case V(All, None):\n        case V(All, Some):\n            l->f.b = 0;\n            frclear(&l->f);\n            break;\n\n        case V(Some, Some):\n            if(l->f.b==0 && redraw)\n        case V(None, Some):\n                flprepare(l);\n            if(l->f.b && redraw){\n                flrefresh(l, l->entire, 0);\n                bfree(l->f.b);\n                l->f.b = 0;\n                frclear(&l->f);\n            }\n        case V(None, None):\n        case V(All, All):\n            break;\n\n        case V(Some, All):\n            if(l->f.b){\n                bitblt2(&screen, l->entire.min, l->f.b, l->entire, S, 0, l->bg);\n                bfree(l->f.b);\n                l->f.b = &screen;\n                break;\n            }\n        case V(None, All):\n            flprepare(l);\n            break;\n        }\n        if(ov==None && l->visible!=None)\n            flnewlyvisible(l);\n    }\n}\n\nvoid\nllinsert(Flayer *l)\n{\n    int i;\n    for(i=nllist; i>0; --i)\n        llist[i]=llist[i-1];\n    llist[0]=l;\n    nllist++;\n}\n\nvoid\nlldelete(Flayer *l)\n{\n    int i;\n\n    for(i=0; i<nllist; i++)\n        if(llist[i]==l){\n            --nllist;\n            for(; i<nllist; i++)\n                llist[i] = llist[i+1];\n            return;\n        }\n    panic(\"lldelete\");\n}\n\nvoid\nflinsert(Flayer *l, wchar_t *sp, wchar_t *ep, int64_t p0)\n{\n    if(flprepare(l)){\n        frinsert(&l->f, sp, ep, p0-l->origin);\n        scrdraw(l, scrtotal(l));\n        if(l->visible==Some)\n            flrefresh(l, l->entire, 0);\n    }\n}\n\nvoid\nfldelete(Flayer *l, int64_t p0, int64_t p1)\n{\n    if(flprepare(l)){\n        p0 -= l->origin;\n        if(p0 < 0)\n            p0 = 0;\n        p1 -= l->origin;\n        if(p1<0)\n            p1 = 0;\n        frdelete(&l->f, p0, p1);\n        scrdraw(l, scrtotal(l));\n        if(l->visible==Some)\n            flrefresh(l, l->entire, 0);\n    }\n}\n\nbool\nflselect(Flayer *l)\n{\n    if(l->visible!=All)\n        flupfront(l);\n    if(mouse.msec-l->click<Clicktime && (l->f.p0 == l->f.p1 && l->f.p0 == frcharofpt(&l->f, mouse.xy))) {\n        l->click = 0;\n        return true;\n    }\n    frselect(&l->f, &mouse);\n    if(l->f.p0==l->f.p1)\n        l->click = mouse.msec;\n    else\n        l->click = 0;\n    l->p0 = l->f.p0+l->origin, l->p1 = l->f.p1+l->origin;\n    return false;\n}\n\nvoid\nflsetselect(Flayer *l, int64_t p0, int64_t p1)\n{\n    uint64_t fp0, fp1;\n\n    l->click = 0;\n    if(l->visible==None || !flprepare(l)){\n        l->p0 = p0, l->p1 = p1;\n        return;\n    }\n    l->p0 = p0, l->p1 = p1;\n    flfp0p1(l, &fp0, &fp1);\n    if(fp0==l->f.p0 && fp1==l->f.p1)\n        return;\n    frselectp(&l->f, F&~D);\n    l->f.p0 = fp0, l->f.p1 = fp1;\n    frselectp(&l->f, F&~D);\n    if(l->visible==Some)\n        flrefresh(l, l->entire, 0);\n}\n\nvoid\nflfp0p1(Flayer *l, uint64_t *pp0, uint64_t *pp1)\n{\n    int64_t p0 = l->p0-l->origin, p1 = l->p1-l->origin;\n\n    if(p0 < 0)\n        p0 = 0;\n    if(p1 < 0)\n        p1 = 0;\n    if(p0 > l->f.nchars)\n        p0 = l->f.nchars;\n    if(p1 > l->f.nchars)\n        p1 = l->f.nchars;\n    *pp0 = p0;\n    *pp1 = p1;\n}\n\nRectangle\nrscale(Rectangle r, Point old, Point new)\n{\n    r.min.x = r.min.x*new.x/old.x;\n    r.min.y = r.min.y*new.y/old.y;\n    r.max.x = r.max.x*new.x/old.x;\n    r.max.y = r.max.y*new.y/old.y;\n    return r;\n}\n\nvoid\nflreshape(Rectangle dr)\n{\n    int i;\n    Flayer *l;\n    Frame *f;\n    Rectangle r, olDrect;\n    int move;\n\n    olDrect = lDrect;\n    lDrect = dr;\n    move = 0;\n    bitblt2(&screen, lDrect.min, &screen, lDrect, 0, 0, _bgpixel);\n\n    for(i=0; i<nllist; i++){\n        l = llist[i];\n        f = &l->f;\n        if(move)\n            r = raddp(rsubp(l->entire, olDrect.min), dr.min);\n        else{\n            r = raddp(rscale(rsubp(l->entire, olDrect.min),\n                sub(olDrect.max, olDrect.min),\n                sub(dr.max, dr.min)), dr.min);\n            if(l->visible==Some && f->b){\n                bfree(f->b);\n                frclear(f);\n            }\n            f->b = 0;\n            if(l->visible!=None)\n                frclear(f);\n        }\n        if(!rectclip(&r, dr))\n            panic(\"flreshape\");\n        if(r.max.x-r.min.x<100)\n            r.min.x = dr.min.x;\n        if(r.max.x-r.min.x<100)\n            r.max.x = dr.max.x;\n        if(r.max.y-r.min.y<2*FLMARGIN+f->fheight)\n            r.min.y = dr.min.y;\n        if(r.max.y-r.min.y<2*FLMARGIN+f->fheight)\n            r.max.y = dr.max.y;\n        if(!move)\n            l->visible = None;\n        frsetrects(f, inset(flrect(l, r), FLMARGIN), f->b);\n        if(!move && f->b)\n            scrdraw(l, scrtotal(l));\n    }\n    newvisibilities(1);\n}\n\nint\nflprepare(Flayer *l)\n{\n    Frame *f;\n    uint64_t n;\n    wchar_t *r;\n\n    if(l->visible == None)\n        return 0;\n    f = &l->f;\n    if(f->b == 0){\n        if(l->visible == All)\n            f->b = &screen;\n        else if((f->b = balloc(l->entire, screen.ldepth))==0)\n            return 0;\n        bitblt2(f->b, l->entire.min, f->b, l->entire, 0, 0, l->bg);\n        border(f->b, l->entire, l==llist[0]? FLMARGIN : 1, F&~D, l->bg);\n        n = f->nchars;\n        frinit(f, f->entire, f->font, f->b, l->bg);\n        r = (*l->textfn)(l, n, &n);\n        frinsert(f, r, r+n, (uint64_t)0);\n        frselectp(f, F&~D);\n        flfp0p1(l, &l->f.p0, &l->f.p1);\n        frselectp(f, F&~D);\n        scrdraw(l, scrtotal(l));\n    }\n    return 1;\n}\n\nstatic  bool somevis, someinvis, justvis;\n\nVis\nvisibility(Flayer *l)\n{\n    somevis = someinvis = false;\n    justvis = true;\n    flrefresh(l, l->entire, 0);\n    justvis = false;\n    if(!somevis)\n        return None;\n    if(!someinvis)\n        return All;\n    return Some;\n}\n\nvoid\nflrefresh(Flayer *l, Rectangle r, int i)\n{\n    Flayer *t;\n    Rectangle s;\n\n    Top:\n    if((t=llist[i++]) == l){\n        if(!justvis)\n            bitblt2(&screen, r.min, l->f.b, r, S, 0, l->bg);\n        somevis = true;\n    }else{\n        if(!rectXrect(t->entire, r))\n            goto Top;   /* avoid stacking unnecessarily */\n        if(t->entire.min.x>r.min.x){\n            s = r;\n            s.max.x = t->entire.min.x;\n            flrefresh(l, s, i);\n            r.min.x = t->entire.min.x;\n        }\n        if(t->entire.min.y>r.min.y){\n            s = r;\n            s.max.y = t->entire.min.y;\n            flrefresh(l, s, i);\n            r.min.y = t->entire.min.y;\n        }\n        if(t->entire.max.x<r.max.x){\n            s = r;\n            s.min.x = t->entire.max.x;\n            flrefresh(l, s, i);\n            r.max.x = t->entire.max.x;\n        }\n        if(t->entire.max.y<r.max.y){\n            s = r;\n            s.min.y = t->entire.max.y;\n            flrefresh(l, s, i);\n            r.max.y = t->entire.max.y;\n        }\n        /* remaining piece of r is blocked by t; forget about it */\n        someinvis = true;\n    }\n}\n", "source": "sam/samterm/flayer.c", "file_type": "c"}
{"text": "/* Copyright (c) 1998 Lucent Technologies - All rights reserved. */\n#include <u.h>\n#include <libg.h>\n#include <frame.h>\n#include \"flayer.h\"\n#include \"samterm.h\"\n\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/un.h>\n#include <errno.h>\n#include <signal.h>\n\nstatic char *fallbacks[] = {\n    \"*scrollForwardR: true\",\n    \"*geometry: 740x780\",\n    NULL\n};\n\nvoid\ngetscreen(int argc, char **argv)\n{\n    Rectangle r;\n\n    signal(SIGINT, SIG_IGN);\n    xtbinit(0, \"Sam\", &argc, argv, fallbacks);\n    r = inset(screen.r, 4);\n    bitblt(&screen, r.min, &screen, r, 0);\n}\n\nint\nscreensize(int *w, int *h)\n{\n    return scrpix(w,h);\n}\n\nvoid\ndumperrmsg(int count, int type, int count0, int c)\n{\n    uint8_t *cp;\n    int i;\n\n    cp = (uint8_t *) rcvstring();\n    fprintf(stderr, \"samterm: host mesg: count %d %ux %ux %ux %s...ignored\\n\",\n        count, type, count0, c, cp);\n    i = 0;\n    while (*cp) {\n        fprintf(stderr, \"%x \", *cp);\n        if (i++ >= 20) {\n            fprintf(stderr, \"\\n\");\n            i = 0;\n        }\n        cp++;\n    }\n}\n", "source": "sam/samterm/unix.c", "file_type": "c"}
{"text": "\n/* Copyright (c) 1998 Lucent Technologies - All rights reserved. */\n#include <u.h>\n#include <libg.h>\n#include <frame.h>\n#include <unistd.h>\n#include \"flayer.h\"\n#include \"samterm.h\"\n\nextern uint64_t _bgpixel;\nextern void hmoveto(int, int64_t, Flayer *);\n\nText    cmd;\nwchar_t    *scratch;\nint64_t    nscralloc;\nextern Bitmap   screen;\nunsigned int cursor;\nMouse   mouse;\nFlayer  *which = NULL;\nFlayer  *flast = NULL;\nFlayer  *work = NULL;\nint64_t    snarflen;\nint64_t    typestart = -1;\nint64_t    typeend = -1;\nint64_t    typeesc = -1;\nbool    modified = false;       /* strange lookahead for menus */\nchar    lock = 1;\nbool    hasunlocked = false;\nbool expandtabs = false;\nbool autoindent = false;\nchar *machine = \"localhost\";\nint exfd = -1;\nconst char *exname;\nbool followfocus = false;\n\nvoid\nremoveext(void)\n{\n    if (exname)\n        unlink(exname);\n}\n\nint\nmain(int argc, char *argv[])\n{\n    int i, got, scr, opt;\n    Text *t;\n    Rectangle r;\n    Flayer *nwhich;\n    char rcpath[PATH_MAX + 1] = {0};\n    FILE *rc = NULL;\n\n    setlocale(LC_ALL, \"\");\n    installdefaultbindings();\n    installdefaultchords();\n\n    if (getenv(\"SAMRC\"))\n        strncpy(rcpath, getenv(\"SAMRC\"), PATH_MAX);\n    else\n        snprintf(rcpath, PATH_MAX, \"%s/.samrc\", getenv(\"HOME\") ? getenv(\"HOME\") : \".\");\n\n    while ((opt = getopt(argc, argv, \"ef:n:r:\")) != -1){\n        switch (opt){\n            case 'r':\n                machine = optarg;\n                break;\n\n            case 'f':\n                exfd = atoi(optarg);\n                break;\n\n            case 'n':\n                exname = optarg;\n                atexit(removeext);\n                break;\n        }\n    }\n\n    rc = fopen(rcpath, \"r\");\n    if (rc){\n        loadrcfile(rc);\n        fclose(rc);\n    }\n\n    getscreen(argc, argv);\n    initio();\n    scratch = alloc(100*RUNESIZE);\n    nscralloc = 100;\n    r = screen.r;\n    r.max.y = r.min.y+Dy(r)/5;\n    flstart(screen.clipr);\n    rinit(&cmd.rasp);\n    flnew(&cmd.l[0], stgettext, 1, &cmd);\n    cmd.l[0].bg = getbg();\n    flinit(&cmd.l[0], r, font, cmd.l[0].bg);\n    cmd.nwin = 1;\n    which = &cmd.l[0];\n    cmd.tag = Untagged;\n    outTs(Tversion, VERSION);\n    startnewfile(Tstartcmdfile, &cmd);\n\n    got = 0;\n    for(;;got = waitforio()){\n        if(hasunlocked && RESHAPED())\n            reshape();\n        if(got&RHost)\n            rcv();\n        if(got&RExtern){\n            for(i=0; cmd.l[i].textfn==0; i++)\n                ;\n            current(&cmd.l[i]);\n            flsetselect(which, cmd.rasp.nrunes, cmd.rasp.nrunes);\n            type(which);\n        }\n        if(got&RKeyboard){\n            if(which)\n                type(which);\n            else\n                kbdblock();\n        }\n        if(got&RMouse){\n            if(lock==2 || !ptinrect(mouse.xy, screen.r)){\n                mouseunblock();\n                continue;\n            }\n            nwhich = flwhich(mouse.xy);\n            scr = which && ptinrect(mouse.xy, which->scroll);\n            if(mouse.buttons)\n                flushtyping(true);\n            if(mouse.buttons&1){\n                if(nwhich){\n                    if(nwhich!=which)\n                        current(nwhich);\n                    else if(scr)\n                        scroll(which, 1, 1);\n                    else{\n                        t=(Text *)which->user1;\n                        if(flselect(which)){\n                            outTsl(Tdclick, t->tag, which->p0);\n                            t->lock++;\n                        }else if(t!=&cmd)\n                            outcmd();\n                    }\n                }\n            }else if((mouse.buttons&2) && which){\n                if(scr)\n                    scroll(which, 2, 2);\n                else\n                    menu2hit();\n            }else if((mouse.buttons&4)){\n                if(scr)\n                    scroll(which, 3, 3);\n                else\n                    menu3hit();\n            }else if(followfocus && nwhich && nwhich!=which){\n                current(nwhich);\n            }\n            mouseunblock();\n        }\n    }\n\n    return EXIT_SUCCESS;\n}\n\n\nvoid\nreshape(void)\n{\n    int i;\n\n    flreshape(screen.clipr);\n    for(i = 0; i<nname; i++)\n        if(text[i])\n            hcheck(text[i]->tag);\n}\n\nvoid\ncurrent(Flayer *nw)\n{\n    Text *t;\n\n    if(which)\n        flborder(which, false);\n    if(nw){\n        flushtyping(true);\n        if (!followfocus)\n            flupfront(nw);\n        flborder(nw, true);\n        buttons(Up);\n        t = (Text *)nw->user1;\n        t->front = nw-&t->l[0];\n        if(t != &cmd)\n            work = nw;\n    }\n    which = nw;\n}\n\nvoid\ncloseup(Flayer *l)\n{\n    Text *t=(Text *)l->user1;\n    int m;\n\n    m = whichmenu(t->tag);\n    if(m < 0)\n        return;\n    flclose(l);\n    if(l == which){\n        which = 0;\n        current(flwhich(Pt(0, 0)));\n    }\n    if(l == flast)\n        flast = 0;\n    if(l == work)\n        work = 0;\n    if(--t->nwin == 0){\n        rclear(&t->rasp);\n        free(t);\n        text[m] = 0;\n    }else if(l == &t->l[t->front]){\n        for(m=0; m<NL; m++) /* find one; any one will do */\n            if(t->l[m].textfn){\n                t->front = m;\n                return;\n            }\n        panic(\"close\");\n    }\n}\n\nFlayer *\nfindl(Text *t)\n{\n    int i;\n    for(i = 0; i<NL; i++)\n        if(t->l[i].textfn==0)\n            return &t->l[i];\n    return 0;\n}\n\nvoid\nduplicate(Flayer *l, Rectangle r, XftFont *f, int close)\n{\n    Text *t=(Text *)l->user1;\n    Flayer *nl = findl(t);\n    wchar_t *rp;\n    uint64_t n;\n\n    if(nl){\n        flnew(nl, stgettext, l->user0, (char *)t);\n        flinit(nl, r, f, l->bg);\n        nl->origin = l->origin;\n        rp = (*l->textfn)(l, l->f.nchars, &n);\n        flinsert(nl, rp, rp+n, l->origin);\n        flsetselect(nl, l->p0, l->p1);\n        if(close){\n            flclose(l);\n            if(l==which)\n                which = 0;\n        }else\n            t->nwin++;\n        current(nl);\n        hcheck(t->tag);\n    }\n    cursorswitch(cursor);\n}\n\nvoid\nbuttons(int updown)\n{\n    while(((mouse.buttons&7)!=0) != updown)\n        frgetmouse();\n}\n\nint\ngetr(Rectangle *rp)\n{\n    Point p;\n    Rectangle r;\n\n    *rp = getrect(3, &mouse);\n    if(rp->max.x && rp->max.x-rp->min.x<=5 && rp->max.y-rp->min.y<=5){\n        p = rp->min;\n        r = cmd.l[cmd.front].entire;\n        *rp = screen.r;\n        if(cmd.nwin==1){\n            if (p.y <= r.min.y)\n                rp->max.y = r.min.y;\n            else if (p.y >= r.max.y)\n                rp->min.y = r.max.y;\n            if (p.x <= r.min.x)\n                rp->max.x = r.min.x;\n            else if (p.x >= r.max.x)\n                rp->min.x = r.max.x;\n        }\n    }\n    return rectclip(rp, screen.r) &&\n       rp->max.x-rp->min.x>100 && rp->max.y-rp->min.y>40;\n}\n\nvoid\nsnarf(Text *t, int w)\n{\n    Flayer *l = &t->l[w];\n\n    if(l->p1>l->p0){\n        snarflen = l->p1-l->p0;\n        outTsll(Tsnarf, t->tag, l->p0, l->p1);\n    }\n}\n\nvoid\ncut(Text *t, int w, bool save, bool check)\n{\n    int64_t p0, p1;\n    Flayer *l;\n\n    l = &t->l[w];\n    p0 = l->p0;\n    p1 = l->p1;\n    if(p0 == p1)\n        return;\n    if(p0 < 0)\n        panic(\"cut\");\n    if(save)\n        snarf(t, w);\n    outTsll(Tcut, t->tag, p0, p1);\n    flsetselect(l, p0, p0);\n    t->lock++;\n    hcut(t->tag, p0, p1-p0);\n    if(check)\n        hcheck(t->tag);\n}\n\nvoid\npaste(Text *t, int w)\n{\n    if(snarflen){\n        cut(t, w, false, false);\n        t->lock++;\n        outTsl(Tpaste, t->tag, t->l[w].p0);\n    }\n}\n\nvoid\nscrorigin(Flayer *l, int but, int64_t p0)\n{\n    Text *t=(Text *)l->user1;\n\n    switch(but){\n    case 1:\n        outTslll(Torigin, t->tag, l->origin, p0, getlayer(l, t));\n        break;\n    case 2:\n        outTslll(Torigin, t->tag, p0, 1L, getlayer(l, t));\n        break;\n    case 3:\n        horigin(t->tag, p0, NULL);\n    }\n}\n\nint\nraspc(Rasp *r, int64_t p)\n{\n    uint64_t n;\n    rload(r, p, p+1, &n);\n    if(n)\n        return scratch[0];\n    return 0;\n}\n\nint64_t\nctlw(Rasp *r, int64_t o, int64_t p)\n{\n    int c;\n\n    if(--p < o)\n        return o;\n    if(raspc(r, p)=='\\n')\n        return p;\n    for(; p>=o && !iswalnum(c=raspc(r, p)); --p)\n        if(c=='\\n')\n            return p+1;\n    for(; p>o && iswalnum(raspc(r, p-1)); --p)\n        ;\n    return p>=o? p : o;\n}\n\nint64_t\nctlu(Rasp *r, int64_t o, int64_t p)\n{\n    for(; p-1>=o && raspc(r, p-1)!='\\n'; --p)\n        ;\n    return p>=o? p : o;\n}\n\nint64_t\nindent(Flayer *l, long p)\n{\n\tText *t = (Text *)l->user1;\n\tstatic wchar_t sbuf[7] = {' ',' ',' ',' ',' ',' ',' '};\n\tstatic wchar_t tbuf[7] = {'\\t','\\t','\\t','\\t','\\t','\\t','\\t'};\n\tint i, is, it, q, c, space;\n\n\tq = p - 1; is = 0; it = 0; space = true;\n\twhile(--q >= l->origin) {\n\t\tc = raspc(&t->rasp, q);\n\t\tif(c == '\\n') {\n            break;\n\t\t} else if(c == '\\t') {\n\t\t\t++it;\n\t\t} else if(c == ' ') {\n\t\t\t++is;\n\t\t} else {\n\t\t\tit = is = 0; \n\t\t\tspace = false;\n\t\t}\n\t}\n    if(space) \n        it = is = 0;\n\n\twhile(it != 0) {\n\t\ti = it>7?7:it;\n\t\thgrow(t->tag, p, i, 0);\n\t\tt->lock++;\n\t\thdatarune(t->tag, p, tbuf, i);\n\t\tit -= i; p += i;\n\t}\n\twhile(is != 0) {\n\t\ti = is > 7? 7 : is;\n\t\thgrow(t->tag, p, i, 0);\n\t\tt->lock++;\n\t\thdatarune(t->tag, p, sbuf, i);\n\t\tis -= i; p += i;\n\t}\n\n\treturn typeend = l->p0 = l->p1 = p;\n}\n\nint\ncenter(Flayer *l, int64_t a)\n{\n    Text *t = l->user1;\n\n    if (!t->lock && (a < l->origin || l->origin + l->f.nchars < a)){\n        a = (a > t->rasp.nrunes) ? t->rasp.nrunes : a;\n        outTslll(Torigin, t->tag, a, 2L, getlayer(l, t));\n        return 1;\n    }\n\n    return 0;\n}\n\nint\nonethird(Flayer *l, int64_t a)\n{\n    Text *t;\n    Rectangle s;\n    int64_t lines;\n\n    t = l->user1;\n    if(!t->lock && (a<l->origin || l->origin+l->f.nchars<a)){\n        if(a > t->rasp.nrunes)\n            a = t->rasp.nrunes;\n        s = inset(l->scroll, 1);\n        lines = ((s.max.y-s.min.y)/l->f.fheight+1)/3;\n        if (lines < 2)\n            lines = 2;\n        outTslll(Torigin, t->tag, a, lines, getlayer(l, t));\n        return 1;\n    }\n    return 0;\n}\n\n\nint\nXDisplay(Display *);\n\nextern Display * _dpy;\n\nvoid\nflushtyping(bool clearesc)\n{\n    Text *t;\n    uint64_t n;\n\n    if (clearesc)\n        typeesc = -1;   \n    if (typestart == typeend){\n        modified = false;\n        return;\n    }\n    t = which->user1;\n    if(t != &cmd)\n        modified = true;\n    rload(&t->rasp, typestart, typeend, &n);\n    scratch[n] = 0;\n    if(t==&cmd && typeend==t->rasp.nrunes && scratch[typeend-typestart-1]=='\\n'){\n        setlock();\n        outcmd();\n    }\n    outTslS(Ttype, t->tag, typestart, scratch);\n    typestart = -1;\n    typeend = -1;\n    XFlush(_dpy);\n}\n\nstatic int64_t\ncmdscrolldown(Flayer *l, int64_t a, Text *t, const char *arg)\n{\n    flushtyping(false);\n    center(l, l->origin + l->f.nchars + 1);\n    return a;\n}\n\nstatic int64_t\ncmdscrollup(Flayer *l, int64_t a, Text *t, const char *arg)\n{\n    flushtyping(false);\n    outTslll(Torigin, t->tag, l->origin, l->f.maxlines + 1, getlayer(l, t));\n    return a;\n}\n\nstatic int64_t\ncmdcharleft(Flayer *l, int64_t a, Text *t, const char *arg)\n{\n    flsetselect(l, a, a);\n    flushtyping(false);\n    if (a > 0)\n        a--;\n    flsetselect(l, a, a);\n    center(l, a);\n\n    return a;\n}\n\nstatic int64_t\ncmdcharright(Flayer *l, int64_t a, Text *t, const char *arg)\n{\n    flsetselect(l, a, a);\n    flushtyping(false);\n    if (a < t->rasp.nrunes)\n        a++;\n    flsetselect(l, a, a);\n    center(l, a);\n\n    return a;\n}\n\nstatic int64_t\ncmdeol(Flayer *l, int64_t a, Text *t, const char *arg)\n{\n    flsetselect(l, a, a);\n    flushtyping(true);\n    while(a < t->rasp.nrunes)\n         if(raspc(&t->rasp, a++) == '\\n') {\n             a--;\n             break;\n         }\n\n    flsetselect(l, a, a);\n    center(l, a);\n\n    return a;\n}\n\nstatic int64_t\ncmdbol(Flayer *l, int64_t a, Text *t, const char *arg)\n{\n    flsetselect(l, a, a);\n    flushtyping(true);\n    while (a > 0){\n        if (raspc(&t->rasp, --a) == '\\n'){\n            a++;\n            break;\n        }\n    }\n\n    flsetselect(l, a, a);\n    center(l, a);\n\n    return a;\n}\n\nstatic int64_t\ncmdscrollupline(Flayer *l, int64_t a, Text *t, const char *arg)\n{\n    if (l->origin > 0)\n        hmoveto(t->tag, l->origin - 1, l);\n    return a;\n}\n\nstatic int64_t\ncmdscrolldownline(Flayer *l, int64_t a, Text *t, const char *arg)\n{\n    int64_t e = t->rasp.nrunes;\n\n    horigin(t->tag,\n            l->origin + frcharofpt(&l->f,Pt(l->f.r.min.x, l->f.r.min.y + l->f.fheight)),\n            l);\n\n    return a;\n}\n\nstatic int64_t\ncmdlineup(Flayer *l, int64_t a, Text *t, const char *arg)\n{\n    flsetselect(l, a, a);\n    flushtyping(true);\n    if (a > 0){\n        int64_t n0, n1, count = 0;\n        while (a > 0 && raspc(&t->rasp, a - 1) != '\\n'){\n            a--;\n            count++;\n        }\n        if (a > 0){\n            n1 = a;\n            a--;\n            while (a > 0 && raspc(&t->rasp, a - 1) != '\\n')\n                a--;\n    \n            n0 = a;\n            a = (n0 + count >= n1) ? n1 - 1 : n0 + count;\n            flsetselect(l, a, a);\n            center(l, a);\n        }\n    }\n\n    return a;\n}\n\nstatic int64_t\ncmdlinedown(Flayer *l, int64_t a, Text *t, const char *arg)\n{\n    flsetselect(l, a, a);\n    flushtyping(true);\n    if (a < t->rasp.nrunes){\n        int64_t p0, count = 0;\n\n        p0 = a;\n        while (a > 0 && raspc(&t->rasp, a - 1) != '\\n'){\n            a--;\n            count++;\n        }\n\n        a = p0;\n        while (a < t->rasp.nrunes && raspc(&t->rasp, a) != '\\n')\n            a++;\n\n        if (a < t->rasp.nrunes){\n            a++;\n            while (a < t->rasp.nrunes && count > 0 && raspc(&t->rasp, a) != '\\n'){\n                a++;\n                count--;\n            }\n            if (a != p0){\n                flsetselect(l, a, a);\n                center(l, a);\n            }\n        }\n    }\n\n    return a;\n}\n\nstatic int64_t\ncmdjump(Flayer *l, int64_t a, Text *u, const char *arg)\n{\n    Text *t = NULL;\n\n    if (which == &cmd.l[cmd.front] && flast)\n        current(flast);\n    else{\n        l = &cmd.l[cmd.front];\n        t = (Text *)l->user1;\n        flast = which;\n        current(l);\n        flushtyping(false);\n        flsetselect(l, t->rasp.nrunes, t->rasp.nrunes);\n        center(l, t->rasp.nrunes);\n    }\n\n    return a;\n}\n\nstatic int64_t\ncmdlook(Flayer *l, int64_t a, Text *t, const char *arg)\n{\n    outTsll(Tlook, t->tag, which->p0, which->p1);\n    setlock();\n    return a;\n}\n\nstatic int64_t\ncmdsearch(Flayer *l, int64_t a, Text *t, const char *arg)\n{\n    if (t != &cmd && haspat()){\n        outcmd();\n        outT0(Tsearch);\n        setlock();\n    }\n    return a;\n}\n\nstatic int64_t\ncmdwrite(Flayer *l, int64_t a, Text *t, const char *arg)\n{\n    cursorswitch(BullseyeCursor);\n    if (t != &cmd){\n        outTs(Twrite, t->tag);\n        setlock();\n    }\n    cursorswitch(cursor);\n    return a;\n}\n\nstatic int64_t\ncmdescape(Flayer *l, int64_t a, Text *t, const char *arg)\n{\n    if (typeesc >= 0){\n        l->p0 = typeesc;\n        l->p1 = a;\n        flushtyping(true);\n    }\n\n    for (l = t->l; l < &t->l[NL]; l++)\n        if (l->textfn)\n            flsetselect(l, l->p0, l->p1);\n\n    return a;\n}\n\nstatic int64_t\ncmddelword(Flayer *l, int64_t a, Text *t, const char *arg)\n{\n    if (l->f.p0 > 0 && a > 0)\n        l->p0 = ctlw(&t->rasp, l->origin, a);\n\n    l->p1 = a;\n    if (l->p1 != l->p0){\n        if(typestart<=l->p0 && l->p1<=typeend){\n            t->lock++;  /* to call hcut */\n            hcut(t->tag, l->p0, l->p1-l->p0);\n            /* hcheck is local because we know rasp is contiguous */\n            hcheck(t->tag);\n        }else{\n            flushtyping(false);\n            cut(t, t->front, false, true);\n        }\n    }\n\n    return a;\n}\n\nstatic int64_t\ncmddelbol(Flayer *l, int64_t a, Text *t, const char *arg)\n{\n    if (l->f.p0 > 0 && a > 0)\n        l->p0 = ctlu(&t->rasp, l->origin, a);\n\n    l->p1 = a;\n    if (l->p1 != l->p0){\n        if(typestart<=l->p0 && l->p1<=typeend){\n            t->lock++;  /* to call hcut */\n            hcut(t->tag, l->p0, l->p1-l->p0);\n            /* hcheck is local because we know rasp is contiguous */\n            hcheck(t->tag);\n        }else{\n            flushtyping(false);\n            cut(t, t->front, false, true);\n        }\n    }\n\n    return a;\n}\n\nstatic int64_t\ncmddelbs(Flayer *l, int64_t a, Text *t, const char *arg)\n{\n    if (l->f.p0 > 0 && a > 0)\n        l->p0 = a - 1;\n\n    l->p1 = a;\n    if (l->p1 != l->p0){\n        if(typestart <= l->p0 && l->p1 <= typeend){\n            t->lock++;  /* to call hcut */\n            hcut(t->tag, l->p0, l->p1 - l->p0);\n            /* hcheck is local because we know rasp is contiguous */\n            hcheck(t->tag);\n        }else{\n            flushtyping(false);\n            cut(t, t->front, false, true);\n        }\n    }\n\n    return a;\n}\n\nstatic int64_t\ncmddel(Flayer *l, int64_t a, Text *t, const char *arg)\n{\n    l->p0 = a;\n    if (a < t->rasp.nrunes)\n        l->p1 = a + 1;\n    if (l->p1 != l->p0){\n        if(typestart <= l->p0 && l->p1 <= typeend){\n            t->lock++;  /* to call hcut */\n            hcut(t->tag, l->p0, l->p1 - l->p0);\n            /* hcheck is local because we know rasp is contiguous */\n            hcheck(t->tag);\n        }else{\n            flushtyping(false);\n            cut(t, t->front, false, true);\n        }\n    }\n\n    return a;\n}\n\nint\ngetlayer(const Flayer *l, const Text *t)\n{\n    int i;\n    for (i = 0; i < NL; i++){\n        if (&t->l[i] == l)\n            return i;\n    }\n\n    return -1;\n}\n\nstatic int64_t\ncmdexchange(Flayer *l, int64_t a, Text *t, const char *arg)\n{\n    int w = getlayer(l, t);\n    if (w >= 0){\n        snarf(t, w);\n        outT0(Tstartsnarf);\n        setlock();\n    }\n\n    return a;\n}\n\nstatic int64_t\ncmdsnarf(Flayer *l, int64_t a, Text *t, const char *arg)\n{\n    flushtyping(false);\n\n    int w = getlayer(l, t);\n    if (w >= 0)\n        snarf(t, w);\n\n    return a;\n}\n\nstatic int64_t\ncmdcut(Flayer *l, int64_t a, Text *t, const char *arg)\n{\n    flushtyping(false);\n\n    int w = getlayer(l, t);\n    if (w >= 0)\n        cut(t, w, true, true);\n\n    return a;\n}\n\nstatic int64_t\ncmdpaste(Flayer *l, int64_t a, Text *t, const char *arg)\n{\n    flushtyping(false);\n\n    int w = getlayer(l, t);\n    if (w >= 0)\n        paste(t, w);\n\n    return a;\n}\n\nstatic int64_t\ncmdtab(Flayer *l, int64_t a, Text *t, const char *arg)\n{\n    flushtyping(false);\n\n    if (!expandtabs)\n        pushkbd('\\t');\n    else{\n        int col = 0, nspaces = 8, off = a;\n        int i;\n        while (off > 0 && raspc(&t->rasp, off - 1) != '\\n')\n            off--, col++;\n\n        nspaces = tabwidth - col % tabwidth;\n        for (i = 0; i < nspaces; i++)\n            pushkbd(' ');\n    }\n\n    return a;\n}\n\nstatic int64_t\ncmdsend(Flayer *l, int64_t a, Text *t, const char *arg)\n{\n    bool dojump = (t != &cmd);\n\n    flushtyping(false);\n    if (dojump)\n        cmdjump(l, a, t, NULL);\n\n    for (const char *c = arg; *c; c++){\n        pushkbd(*c);\n        type(&cmd.l[cmd.front]);\n        flushtyping(false);\n    }\n    pushkbd('\\n');\n    type(&cmd.l[cmd.front]);\n    flushtyping(false);\n\n    if (dojump)\n        cmdjump(l, a, t, NULL);\n\n    return a;\n}\n\nstatic int64_t\ncmdnone(Flayer *l, int64_t a, Text *t, const char *arg)\n{\n    return a;\n}\n\ntypedef int64_t (*Commandfunc)(Flayer *, int64_t, Text *, const char *);\ntypedef struct CommandEntry CommandEntry;\nstruct CommandEntry{\n    Commandfunc f;\n    bool unlocked;\n    bool docut;\n};\n\nCommandEntry commands[Cmax] ={\n    [Cnone]           = {cmdnone,           false, false},\n    [Cscrolldown]     = {cmdscrolldown,     false, false},\n    [Cscrollup]       = {cmdscrollup,       false, false},\n    [Cscrolldownline] = {cmdscrolldownline, false, false},\n    [Cscrollupline]   = {cmdscrollupline,   false, false},\n    [Ccharleft]       = {cmdcharleft,       false, false},\n    [Ccharright]      = {cmdcharright,      false, false},\n    [Clineup]         = {cmdlineup,         false, false},\n    [Clinedown]       = {cmdlinedown,       false, false},\n    [Cjump]           = {cmdjump,           false, false},\n    [Cescape]         = {cmdescape,         false, false},\n    [Csnarf]          = {cmdsnarf,          false, false},\n    [Ccut]            = {cmdcut,            false, false},\n    [Cpaste]          = {cmdpaste,          false, false},\n    [Cexchange]       = {cmdexchange,       false, false},\n    [Cdelword]        = {cmddelword,        true,  false},\n    [Cdelbol]         = {cmddelbol,         true,  false},\n    [Cdelbs]          = {cmddelbs,          true,  true},\n    [Cdel]            = {cmddel,            true,  true},\n    [Ceol]            = {cmdeol,            false, false},\n    [Cbol]            = {cmdbol,            false, false},\n    [Ctab]            = {cmdtab,            false, false},\n    [Csend]           = {cmdsend,           false, false},\n    [Clook]           = {cmdlook,           false, false},\n    [Csearch]         = {cmdsearch,         false, false},\n    [Cwrite]          = {cmdwrite,          false, false}\n};\n\n\nvoid\ntype(Flayer *l)    /* what a bloody mess this is -- but it's getting better! */\n{\n    Text *t = (Text *)l->user1;\n    wchar_t buf[100];\n    Keystroke k = {0};\n    wchar_t *p = buf;\n    int64_t a;\n\n    if(lock || t->lock){\n        kbdblock();\n        return;\n    }\n\n    k = qpeekc();\n    a = l->p0;\n    if (a != l->p1 && (k.k != Kcommand || commands[k.c].docut)){\n        flushtyping(true);\n        cut(t, t->front, true, true);\n        return; /* it may now be locked */\n    }\n\n    while (((k = kbdchar()), k.c) > 0) {\n        if (k.k == Kcommand)\n            break;\n\n        *p++ = k.c;\n        if (k.c == '\\n' || p >= buf + sizeof(buf) / sizeof(buf[0]))\n            break;\n    }\n\n    if (k.k == Kcommand){\n        flushtyping(false);\n        if (k.c < 0 || k.c >= Cmax || commands[k.c].f == NULL)\n            panic(\"command table miss\");\n\n        CommandEntry *e = &commands[k.c];\n        if (!e->unlocked || !lock){\n            if (k.t == Tcurrent)\n                a = e->f(l, a, t, k.a);\n            else{\n                Flayer *lt = flwhich(k.p);\n                if (lt)\n                    lt->p0 = e->f(lt, lt->p0, (Text *)lt->user1, k.a);\n            }\n        }\n    }\n\n    if (p > buf){\n        if (typestart < 0)\n            typestart = a;\n\n        if (typeesc < 0)\n            typeesc = a;\n\n        hgrow(t->tag, a, p-buf, 0);\n        t->lock++;  /* pretend we Trequest'ed for hdatarune*/\n        hdatarune(t->tag, a, buf, p-buf);\n        a += p-buf;\n        l->p0 = a;\n        l->p1 = a;\n        typeend = a;\n        if (autoindent && k.c == '\\n' && t!=&cmd)\n            a = indent(l, a);\n        if (k.c == '\\n' || typeend - typestart > 100)\n            flushtyping(false);\n        onethird(l, a);\n    }\n\n    if (typeesc >= l->p0)\n        typeesc = l->p0;\n\n    if (typestart >= 0){\n        if(typestart >= l->p0)\n            typestart = l->p0;\n        typeend = l->p0;\n        if (typestart == typeend){\n            typestart = -1;\n            typeend = -1;\n            modified = false;\n        }\n    }\n}\n\nvoid\noutcmd(void)\n{\n    if(work)\n        outTsll(Tworkfile, ((Text *)work->user1)->tag, work->p0, work->p1);\n}\n\nvoid\npanic(char *s)\n{\n    fprintf(stderr, \"samterm:panic: \");\n    perror(s);\n    abort();\n}\n\nwchar_t*\nstgettext(Flayer *l, int64_t n, uint64_t *np)\n{\n    Text *t;\n\n    t = l->user1;\n    rload(&t->rasp, l->origin, l->origin+n, np);\n    return scratch;\n}\n\nint64_t\nscrtotal(Flayer *l)\n{\n    return ((Text *)l->user1)->rasp.nrunes;\n}\n\nvoid*\nalloc(uint64_t n)\n{\n    void *p;\n\n    p = malloc(n);\n    if(p == 0)\n        panic(\"alloc\");\n    memset(p, 0, n);\n    return p;\n}\n", "source": "sam/samterm/main.c", "file_type": "c"}
{"text": "/* Copyright (c) 1998 Lucent Technologies - All rights reserved. */\n#include <u.h>\n#include <libg.h>\n#include <frame.h>\n#include \"flayer.h\"\n#include \"samterm.h\"\n\nint cursorfd;\nint input;\nint got;\nint block;\nKeystroke   keystroke;\nint reshaped;\nuint8_t   *hostp;\nuint8_t   *hoststop;\nuint8_t   *externbase;\nuint8_t   *externp;\nuint8_t   *externstop;\nvoid    panic(char*);\n\nvoid\ninitio(void){\n    extern int exfd;\n\n    einit(Emouse|Ekeyboard);\n    estart(Ehost, 0, 0, false);\n    if (exfd >= 0)\n        estart(Eextern, exfd, 8192, true);\n}\n\nvoid\nfrgetmouse(void)\n{\n    mouse = emouse();\n}\n\nvoid\nmouseunblock(void)\n{\n    got &= ~Emouse;\n}\n\nvoid\nkbdblock(void)\n{       /* ca suffit */\n    block = Ekeyboard|Eextern;\n}\n\nint\nbutton(int but)\n{\n    frgetmouse();\n    return mouse.buttons&(1<<(but-1));\n}\n\nvoid\nexternload(Event *e)\n{\n    externbase = malloc(e->n);\n    if(externbase == 0)\n        return;\n    memmove(externbase, e->data, e->n);\n    externp = externbase;\n    externstop = externbase + e->n;\n    got |= Eextern;\n}\n\nint\nwaitforio(void)\n{\n    uint64_t type;\n    static Event e;\n\n    if(got & ~block)\n        return got & ~block;\n    type = eread(~(got|block), &e);\n    switch(type){\n    case Ehost:\n        hostp = e.data;\n        hoststop = hostp + e.n;\n        block = 0;\n        break;\n    case Eextern:\n        externload(&e);\n        break;\n    case Ekeyboard:\n        keystroke = e.keystroke;\n        break;\n    case Emouse:\n        mouse = e.mouse;\n        break;\n    }\n    got |= type;\n    return got; \n}\n\nint\nrcvchar(void)\n{\n    int c;\n\n    if(!(got & Ehost))\n        return -1;\n    c = *hostp++;\n    if(hostp == hoststop)\n        got &= ~Ehost;\n    return c;\n}\n\nchar*\nrcvstring(void)\n{\n    *hoststop = 0;\n    got &= ~Ehost;\n    return (char*)hostp;\n}\n\nint\ngetch(void)\n{\n    int c;\n\n    while((c = rcvchar()) == -1){\n        block = ~Ehost;\n        waitforio();\n        block = 0;\n    }\n    return c;\n}\n\nint\nexternchar(void)\n{\n    wchar_t r;\n\n    loop:\n    if(got & (Eextern & ~block)){\n        externp += chartorune(&r, (char*)externp);\n        if(externp >= externstop){\n            got &= ~Eextern;\n            free(externbase);\n        }\n        if(r == 0)\n            goto loop;\n        return r;\n    }\n    return -1;\n}\n\nKeystroke\nqpeekc(void)\n{\n    return keystroke;\n}\n\nKeystroke\nkbdchar(void)\n{\n    Keystroke k = {0};\n    static Event e;\n\n    k.c = externchar();\n    if(k.c > 0)\n        return k;\n    if(got & Ekeyboard){\n        k = keystroke;\n        memset(&keystroke, 0, sizeof(keystroke));\n        got &= ~Ekeyboard;\n        return k;\n    }\n    while(ecanread(Eextern)){\n        eread(Eextern, &e);\n        externload(&e);\n        k.c = externchar();\n        if(k.c > 0)\n            return k;\n    }\n    if(!ecankbd()){\n        k.c = -1;\n        return k;\n    }\n    return ekbd();\n}\n\nvoid\nereshaped(Rectangle r)\n{\n    reshaped = 1;\n}\n\nint\nRESHAPED(void)\n{\n    if(reshaped){\n        screen.r = bscreenrect(&screen.clipr);\n        reshaped = 0;\n        return 1;\n    }\n    return 0;\n}\n\nvoid\nmouseexit(void)\n{\n    exit(EXIT_SUCCESS);\n}\n", "source": "sam/samterm/io.c", "file_type": "c"}
{"text": "/* Copyright (c) 1998 Lucent Technologies - All rights reserved. */\n#include <u.h>\n#include <libg.h>\n#include <frame.h>\n\nvoid\n_frredraw(Frame *f, Point pt)\n{\n    Frbox *b;\n    int nb;\n    for(nb=0,b=f->box; nb<f->nbox; nb++, b++){\n        _frcklinewrap(f, &pt, b);\n        if(b->nrune >= 0)\n            string(f->b, pt, f->font, (char *)b->a.ptr, S^D);\n        pt.x += b->wid;\n    }\n}\n\nPoint\n_frdraw(Frame *f, Point pt)\n{\n    Frbox *b;\n    int nb, n;\n    for(b=f->box,nb=0; nb<f->nbox; nb++, b++){\n        _frcklinewrap0(f, &pt, b);\n        if(pt.y == f->r.max.y){\n            f->nchars -= _frstrlen(f, nb);\n            _frdelbox(f, nb, f->nbox-1);\n            break;\n        }\n        if(b->nrune > 0){\n            n = _frcanfit(f, pt, b);\n            if(n == 0)\n                berror(\"draw: _frcanfit==0\");\n            if(n != b->nrune){\n                _frsplitbox(f, nb, n);\n                b = &f->box[nb];\n            }\n            pt.x += b->wid;\n        }else{\n            if(b->a.b.bc == '\\n')\n                pt.x = f->left, pt.y+=f->fheight;\n            else\n                pt.x += _frnewwid(f, pt, b);\n        }\n    }\n    return pt;\n}\n\nint\n_frstrlen(Frame *f, int nb)\n{\n    int n;\n\n    for(n=0; nb<f->nbox; nb++)\n        n += NRUNE(&f->box[nb]);\n    return n;\n}\n", "source": "sam/libframe/frdraw.c", "file_type": "c"}
{"text": "/* Copyright (c) 1998 Lucent Technologies - All rights reserved. */\n#include <u.h>\n#include <libg.h>\n#include <frame.h>\n\n#define DELTA   25\n#define TMPSIZE 256\nstatic Frame        frame;\n\nstatic\nPoint\nbxscan(Frame *f, wchar_t *sp, wchar_t *ep, Point *ppt)\n{\n    int w, c, nb, delta, nl, nr, rw;\n    Frbox *b;\n    char *s, tmp[TMPSIZE+3];    /* +3 for rune overflow */\n    uint8_t *p;\n\n    frame.r = f->r;\n    frame.b = f->b;\n    frame.font = f->font;\n    frame.fheight = f->font->ascent + f->font->descent;\n    frame.maxtab = f->maxtab;\n    frame.left = f->left;\n    frame.nbox = 0;\n    frame.nchars = 0;\n    delta = DELTA;\n    nl = 0;\n    for(nb=0; sp<ep && nl<=f->maxlines; nb++,frame.nbox++){\n        if(nb == frame.nalloc){\n            _frgrowbox(&frame, delta);\n            if(delta < 10000)\n                delta *= 2;\n        }\n        b = &frame.box[nb];\n        c = *sp;\n        if(c=='\\t' || c=='\\n'){\n            b->a.b.bc = c;\n            b->wid = 5000;\n            b->a.b.minwid = (c=='\\n')? 0 : charwidth(frame.font, ' ');\n            b->nrune = -1;\n            if(c=='\\n')\n                nl++;\n            frame.nchars++;\n            sp++;\n        }else{\n            s = tmp;\n            nr = 0;\n            w = 0;\n            while(sp < ep){\n                c = *sp;\n                if(c=='\\t' || c=='\\n')\n                    break;\n                rw = runetochar(s, *sp);\n                if(s+rw >= tmp+TMPSIZE)\n                    break;\n                w += charwidth(frame.font, c);\n                sp++;\n                s += rw;\n                nr++;\n            }\n            *s++ = 0;\n            p = _frallocstr(s-tmp);\n            b = &frame.box[nb];\n            b->a.ptr = p;\n            memmove(p, tmp, s-tmp);\n            b->wid = w;\n            b->nrune = nr;\n            frame.nchars += nr;\n        }\n    }\n    _frcklinewrap0(f, ppt, &frame.box[0]);\n    return _frdraw(&frame, *ppt);\n}\n\nstatic\nvoid\nchopframe(Frame *f, Point pt, uint64_t p, int bn)\n{\n    Frbox *b;\n\n    for(b = &f->box[bn]; ; b++){\n        if(b >= &f->box[f->nbox])\n            berror(\"endofframe\");\n        _frcklinewrap(f, &pt, b);\n        if(pt.y >= f->r.max.y)\n            break;\n        p += NRUNE(b);\n        _fradvance(f, &pt, b);\n    }\n    f->nchars = p;\n    f->nlines = f->maxlines;\n    if(b<&f->box[f->nbox])              /* BUG */\n        _frdelbox(f, (int)(b-f->box), f->nbox-1);\n}\n\nvoid\nfrinsert(Frame *f, wchar_t *sp, wchar_t *ep, uint64_t p0)\n{\n    Point pt0, pt1, ppt0, ppt1, pt;\n    Frbox *b;\n    int n, n0, nn0, y;\n    Rectangle r;\n    static struct{\n        Point pt0, pt1;\n    }*pts;\n    static int nalloc=0;\n    int npts;\n\n    if(p0>f->nchars || sp==ep || f->b==0)\n        return;\n    n0 = _frfindbox(f, 0, 0, p0);\n    nn0 = n0;\n    pt0 = _frptofcharnb(f, p0, n0);\n    ppt0 = pt0;\n    pt1 = bxscan(f, sp, ep, &ppt0);\n    ppt1 = pt1;\n    if(n0 < f->nbox){\n        _frcklinewrap(f, &pt0, b = &f->box[n0]);    /* for frselectf() */\n        _frcklinewrap0(f, &ppt1, b);\n    }\n    f->modified = true;\n    /*\n     * ppt0 and ppt1 are start and end of insertion as they will appear when\n     * insertion is complete. pt0 is current location of insertion position\n     * (p0); pt1 is terminal point (without line wrap) of insertion.\n     */\n    if(p0==f->p0 && p0==f->p1)      /* quite likely */\n        frselectf(f, pt0, pt0, F&~D);\n    else\n        frselectp(f, F&~D);\n    /*\n     * Find point where old and new x's line up\n     * Invariants:\n     *  pt0 is where the next box (b, n0) is now\n     *  pt1 is where it will be after then insertion\n     * If pt1 goes off the rectangle, we can toss everything from there on\n     */\n    for(b = &f->box[n0],npts=0;\n         pt1.x!=pt0.x && pt1.y!=f->r.max.y && n0<f->nbox; b++,n0++,npts++){\n        _frcklinewrap(f, &pt0, b);\n        _frcklinewrap0(f, &pt1, b);\n        if(b->nrune > 0){\n            n = _frcanfit(f, pt1, b);\n            if(n == 0)\n                berror(\"_frcanfit==0\");\n            if(n != b->nrune){\n                _frsplitbox(f, n0, n);\n                b = &f->box[n0];\n            }\n        }\n        if(npts == nalloc){\n            pts = realloc(pts, (npts+DELTA)*sizeof(pts[0]));\n            nalloc += DELTA;\n            b = &f->box[n0];\n        }\n        pts[npts].pt0 = pt0;\n        pts[npts].pt1 = pt1;\n        /* has a text box overflowed off the frame? */\n        if(pt1.y == f->r.max.y)\n            break;\n        _fradvance(f, &pt0, b);\n        pt1.x += _frnewwid(f, pt1, b);\n    }\n    if(pt1.y > f->r.max.y)\n        berror(\"frinsert pt1 too far\");\n    if(pt1.y==f->r.max.y && n0<f->nbox){\n        f->nchars -= _frstrlen(f, n0);\n        _frdelbox(f, n0, f->nbox-1);\n    }\n    if(n0 == f->nbox)\n        f->nlines = (pt1.y-f->r.min.y)/f->fheight+(pt1.x>f->left);\n    else if(pt1.y!=pt0.y){\n        int q0, q1;\n\n        y = f->r.max.y;\n        q0 = pt0.y+f->fheight;\n        q1 = pt1.y+f->fheight;\n        f->nlines += (q1-q0)/f->fheight;\n        if(f->nlines > f->maxlines)\n            chopframe(f, ppt1, p0, nn0);\n        if(pt1.y < y){\n            r = f->r;\n            r.min.y = q0;\n            r.max.y = y-(q1-q0);\n            if(q1 < y)\n                bitblt2(f->b, Pt(f->r.min.x, q1), f->b, r, S, 0, f->bg);\n            r.min = pt0;\n            r.max.y = q0;\n            bitblt2(f->b, pt1, f->b, r, S, 0, f->bg);\n        }\n    }\n    /*\n     * Move the old stuff down to make room.  The loop will move the stuff\n     * between the insertion and the point where the x's lined up.\n     * The bitblt2 above moved everything down after the point they lined up.\n     */\n    for((y=pt1.y==f->r.max.y?pt1.y:0),b = &f->box[n0-1]; --npts>=0; --b){\n        pt = pts[npts].pt1;\n        if(b->nrune > 0){\n            r.min = pts[npts].pt0;\n            r.max = r.min;\n            r.max.x += b->wid;\n            r.max.y += f->fheight;\n            bitblt2(f->b, pt, f->b, r, S, 0, f->bg);\n            if(pt.y < y){   /* clear bit hanging off right */\n                r.min = pt;\n                r.max = pt;\n                r.min.x += b->wid;\n                r.max.x = f->r.max.x;\n                r.max.y += f->fheight;\n                bitblt2(f->b, r.min, f->b, r, 0, 0, f->bg);\n            }\n            y = pt.y;\n        }else{\n            r.min = pt;\n            r.max = pt;\n            r.max.x += b->wid;\n            r.max.y += f->fheight;\n            if(r.max.x >= f->r.max.x)\n                r.max.x = f->r.max.x;\n            bitblt2(f->b, r.min, f->b, r, 0, 0, f->bg);\n            y = (pt.x == f->left)? pt.y : 0;\n        }\n    }\n    frselectf(f, ppt0, ppt1, 0);\n    _frredraw(&frame, ppt0);\n    _fraddbox(f, nn0, frame.nbox);\n    for(n=0; n<frame.nbox; n++)\n        f->box[nn0+n] = frame.box[n];\n    if(nn0>0 && f->box[nn0-1].nrune>=0 && ppt0.x-f->box[nn0-1].wid>=(int)f->left){\n        --nn0;\n        ppt0.x -= f->box[nn0].wid;\n    }\n    n0 += frame.nbox;\n    _frclean(f, ppt0, nn0, n0<f->nbox-1? n0+1 : n0);\n    f->nchars += frame.nchars;\n    if(f->p0 >= p0)\n        f->p0 += frame.nchars;\n    if(f->p0 > f->nchars)\n        f->p0 = f->nchars;\n    if(f->p1 >= p0)\n        f->p1 += frame.nchars;\n    if(f->p1 > f->nchars)\n        f->p1 = f->nchars;\n    frselectp(f, F&~D);\n}\n", "source": "sam/libframe/frinsert.c", "file_type": "c"}
{"text": "/* Copyright (c) 1998 Lucent Technologies - All rights reserved. */\n#include <u.h>\n#include <libg.h>\n#include <frame.h>\n\nint tabwidth = 8;\nextern bool expandtabs;\n\nvoid\nfrinit(Frame *f, Rectangle r, XftFont *ft, Bitmap *b, uint64_t bg)\n{\n    int tabs = atoi(getenv(\"TABS\") ? getenv(\"TABS\") : \"\");\n    if (tabs < 0){\n        tabs = -tabs;\n        expandtabs = true;\n    }\n\n    if (tabs > 0 && tabs <= 12)\n        tabwidth = tabs;\n\n    f->font = ft;\n    /* ft->height is NOT CORRECT; we must use ascent + descent to\n       clear the lowest edge of characters. - cks */\n    f->fheight = ft->ascent + ft->descent;\n    f->maxtab = tabwidth*charwidth(ft, '0');\n    f->nbox = 0;\n    f->nalloc = 0;\n    f->nchars = 0;\n    f->nlines = 0;\n    f->p0 = 0;\n    f->p1 = 0;\n    f->box = 0;\n    f->lastlinefull = 0;\n    f->bg = bg;\n    frsetrects(f, r, b);\n}\n\nvoid\nfrsetrects(Frame *f, Rectangle r, Bitmap *b)\n{\n    f->b = b;\n    f->entire = r;\n    f->r = r;\n    f->r.max.y -= (r.max.y-r.min.y)%f->fheight;\n    f->left = r.min.x+1;\n    f->maxlines = (r.max.y-r.min.y)/f->fheight;\n}\n\nvoid\nfrclear(Frame *f)\n{\n    if(f->nbox)\n        _frdelbox(f, 0, f->nbox-1);\n    if(f->box)\n        free(f->box);\n    f->box = 0;\n}\n", "source": "sam/libframe/frinit.c", "file_type": "c"}
{"text": "/* Copyright (c) 1998 Lucent Technologies - All rights reserved. */\n#include <u.h>\n#include <libg.h>\n#include <frame.h>\n\n#define SLOP    25\n\nvoid\n_fraddbox(Frame *f, int bn, int n)  /* add n boxes after bn, shift the rest up,\n                 * box[bn+n]==box[bn] */\n{\n    int i;\n\n    if(bn > f->nbox)\n        berror(\"_fraddbox\");\n    if(f->nbox+n > f->nalloc)\n        _frgrowbox(f, n+SLOP);\n    for(i=f->nbox; --i>=bn; )\n        f->box[i+n] = f->box[i];\n    f->nbox+=n;\n}\n\nvoid\n_frclosebox(Frame *f, int n0, int n1)   /* inclusive */\n{\n    int i;\n\n    if(n0>=f->nbox || n1>=f->nbox || n1<n0)\n        berror(\"_frclosebox\");\n    n1++;\n    for(i=n1; i<f->nbox; i++)\n        f->box[i-(n1-n0)] = f->box[i];\n    f->nbox -= n1-n0;\n}\n\nvoid\n_frdelbox(Frame *f, int n0, int n1) /* inclusive */\n{\n    if(n0>=f->nbox || n1>=f->nbox || n1<n0)\n        berror(\"_frdelbox\");\n    _frfreebox(f, n0, n1);\n    _frclosebox(f, n0, n1);\n}\n\nvoid\n_frfreebox(Frame *f, int n0, int n1)    /* inclusive */\n{\n    int i;\n\n    if(n1<n0)\n        return;\n    if(n0>=f->nbox || n1>=f->nbox)\n        berror(\"_frfreebox\");\n    n1++;\n    for(i=n0; i<n1; i++)\n        if(f->box[i].nrune >= 0)\n            free(f->box[i].a.ptr);\n}\n\nvoid\n_frgrowbox(Frame *f, int delta)\n{\n    f->nalloc += delta;\n    f->box = realloc(f->box, f->nalloc*sizeof(Frbox));\n    if(f->box == 0)\n        berror(\"_frgrowbox\");\n}\n\nstatic\nvoid\ndupbox(Frame *f, int bn)\n{\n    uint8_t *p;\n\n    if(f->box[bn].nrune < 0)\n        berror(\"dupbox\");\n    _fraddbox(f, bn, 1);\n    if(f->box[bn].nrune >= 0){\n        p = _frallocstr(NBYTE(&f->box[bn])+1);\n        strcpy((char*)p, (char*)f->box[bn].a.ptr);\n        f->box[bn+1].a.ptr = p;\n    }\n}\n\nstatic\nuint8_t*\nruneindex(uint8_t *p, int n)\n{\n    int i, w;\n    wchar_t rune;\n\n    for(i=0; i<n; i++,p+=w)\n        w = chartorune(&rune, (char*)p);\n    return p;\n}\n\nstatic\nvoid\ntruncatebox(Frame *f, Frbox *b, int n)  /* drop last n chars; no allocation done */\n{\n    if(b->nrune<0 || b->nrune<n)\n        berror(\"truncatebox\");\n    b->nrune -= n;\n    runeindex(b->a.ptr, b->nrune)[0] = 0;\n    b->wid = strwidth(f->font, (char *)b->a.ptr);\n}\n\nstatic\nvoid\nchopbox(Frame *f, Frbox *b, int n)  /* drop first n chars; no allocation done */\n{\n    if(b->nrune<0 || b->nrune<n)\n        berror(\"chopbox\");\n\n    uint8_t *ri = runeindex(b->a.ptr, n);\n    memmove(b->a.ptr, ri, strlen((char *)ri) + 1);\n    b->nrune -= n;\n    b->wid = strwidth(f->font, (char *)b->a.ptr);\n}\n\nvoid\n_frsplitbox(Frame *f, int bn, int n)\n{\n    dupbox(f, bn);\n    truncatebox(f, &f->box[bn], f->box[bn].nrune-n);\n    chopbox(f, &f->box[bn+1], n);\n}\n\nvoid\n_frmergebox(Frame *f, int bn)       /* merge bn and bn+1 */\n{\n    Frbox *b;\n\n    b = &f->box[bn];\n    _frinsure(f, bn, NBYTE(&b[0])+NBYTE(&b[1])+1);\n    strcpy((char*)runeindex(b[0].a.ptr, b[0].nrune), (char*)b[1].a.ptr);\n    b[0].wid += b[1].wid;\n    b[0].nrune += b[1].nrune;\n    _frdelbox(f, bn+1, bn+1);\n}\n\nint\n_frfindbox(Frame *f, int bn, uint64_t p, uint64_t q)  /* find box containing q and put q on a box boundary */\n{\n    Frbox *b;\n\n    for(b = &f->box[bn]; bn<f->nbox && p+NRUNE(b)<=q; bn++, b++)\n        p += NRUNE(b);\n    if(p != q)\n        _frsplitbox(f, bn++, (int)(q-p));\n    return bn;\n}\n", "source": "sam/libframe/frbox.c", "file_type": "c"}
{"text": "/* Copyright (c) 1998 Lucent Technologies - All rights reserved. */\n#include <u.h>\n#include <libg.h>\n#include <frame.h>\n\n/*\n * The code here and elsewhere requires that strings not be gcalloc()ed\n */\n\n#define CHUNK   16\n#define ROUNDUP(n)  ((n+CHUNK)&~(CHUNK-1))\n\nuint8_t *\n_frallocstr(unsigned n)\n{\n    uint8_t *p;\n\n    p = malloc(ROUNDUP(n));\n    if(p == 0)\n        berror(\"out of memory\");\n    return p;\n}\n\nvoid\n_frinsure(Frame *f, int bn, unsigned n)\n{\n    Frbox *b;\n    uint8_t *p;\n\n    b = &f->box[bn];\n    if(b->nrune < 0)\n        berror(\"_frinsure\");\n    if(ROUNDUP(b->nrune) > n)   /* > guarantees room for terminal NUL */\n        return;\n    p = _frallocstr(n);\n    b = &f->box[bn];\n    memmove(p, b->a.ptr, NBYTE(b)+1);\n    free(b->a.ptr);\n    b->a.ptr = p;\n}\n", "source": "sam/libframe/frstr.c", "file_type": "c"}
{"text": "/* Copyright (c) 1998 Lucent Technologies - All rights reserved. */\n#include <u.h>\n#include <libg.h>\n#include <frame.h>\n\nPoint\n_frptofcharptb(Frame *f, uint64_t p, Point pt, int bn)\n{\n    uint8_t *s;\n    Frbox *b;\n    int w, l;\n    wchar_t r;\n\n    for(b = &f->box[bn]; bn<f->nbox; bn++,b++){\n        _frcklinewrap(f, &pt, b);\n        if(p < (l=NRUNE(b))){\n            if(b->nrune > 0)\n                for(s=b->a.ptr; p>0; s+=w, p--){\n                    w = chartorune(&r, (char*)s);\n                    pt.x += charwidth(f->font, r);\n                    if(r==0 || pt.x>f->r.max.x)\n                        berror(\"frptofchar\");\n                }\n            break;\n        }\n        p -= l;\n        _fradvance(f, &pt, b);\n    }\n    return pt;\n}\n\nPoint\nfrptofchar(Frame *f, uint64_t p)\n{\n    return _frptofcharptb(f, p, Pt(f->left, f->r.min.y), 0);\n}\n\nPoint\n_frptofcharnb(Frame *f, uint64_t p, int nb)    /* doesn't do final _fradvance to next line */\n{\n    Point pt;\n    int nbox;\n\n    nbox = f->nbox;\n    f->nbox = nb;\n    pt = _frptofcharptb(f, p, Pt(f->left, f->r.min.y), 0);\n    f->nbox = nbox;\n    return pt;\n}\n\nstatic\nPoint\n_frgrid(Frame *f, Point p)\n{\n    p.y -= f->r.min.y;\n    p.y -= p.y%f->fheight;\n    p.y += f->r.min.y;\n    if(p.x > f->r.max.x)\n        p.x = f->r.max.x;\n    return p;\n}\n\nuint64_t\nfrcharofpt(Frame *f, Point pt)\n{\n    Point qt;\n    int w, bn, cstart;\n    uint8_t *s;\n    Frbox *b;\n    uint64_t p;\n    wchar_t r;\n\n    pt = _frgrid(f, pt);\n    qt.x = f->left;\n    qt.y = f->r.min.y;\n    for(b=f->box,bn=0,p=0; bn<f->nbox && qt.y<pt.y; bn++,b++){\n        _frcklinewrap(f, &qt, b);\n        if(qt.y >= pt.y)\n            break;\n        _fradvance(f, &qt, b);\n        p += NRUNE(b);\n    }\n    for(; bn<f->nbox && qt.x<=pt.x; bn++,b++){\n        _frcklinewrap(f, &qt, b);\n        if(qt.y > pt.y)\n            break;\n        if(qt.x+b->wid > pt.x){\n            if(b->nrune < 0)\n                _fradvance(f, &qt, b);\n            else{\n                s = b->a.ptr;\n                for(;;){\n                    w = chartorune(&r, (char*)s);\n                    if(r == 0)\n                        berror(\"end of string in frcharofpt\");\n                    s += w;\n                    cstart = qt.x;\n                    qt.x += charwidth(f->font, r);\n                    if(qt.x > pt.x){\n                        if(qt.x - pt.x < pt.x - cstart)\n                            p++;\n                        break;\n                    }\n                    p++;\n                }\n            }\n        }else{\n            p += NRUNE(b);\n            _fradvance(f, &qt, b);\n        }\n    }\n    return p;\n}\n", "source": "sam/libframe/frptofchar.c", "file_type": "c"}
{"text": "/* Copyright (c) 1998 Lucent Technologies - All rights reserved. */\n#include <u.h>\n#include <libg.h>\n#include <frame.h>\n\nvoid\nfrselect(Frame *f, Mouse *m)    /* when called, button 1 is down */\n{\n    uint64_t p0, p1, q;\n    Point mp, pt0, pt1, qt;\n\n    mp = m->xy;\n\n    Again:\n    f->modified = 0;\n    frselectp(f, F&~D);\n    p0 = p1 = frcharofpt(f, mp);\n    pt0 = frptofchar(f, p0);\n    pt1 = frptofchar(f, p1);\n    frselectf(f, pt0, pt1, F&~D);\n    do{\n        if(f->modified) /* special hack so 8\u00bd can frselect in parallel */\n            goto Again;\n        q = frcharofpt(f, m->xy);\n        if(p1 != q){\n            if(p0 == p1)\n                frselectf(f, pt0, pt1, F&~D);\n            qt = frptofchar(f, q);\n            if(p1 < q)\n                frselectf(f, pt1, qt, F&~D);\n            else\n                frselectf(f, qt, pt1, F&~D);\n            p1 = q;\n            pt1 = qt;\n            if(p0 == p1)\n                frselectf(f, pt0, pt1, F&~D);\n        }\n        f->modified = 0;\n        if(p0 < p1)\n            f->p0 = p0, f->p1 = p1;\n        else\n            f->p0 = p1, f->p1 = p0;\n        frgetmouse();\n    }while((m->buttons & 7) == 1);\n}\n/* it is assumed p0<=p1 and both were generated by frptofchar() */\nvoid\nfrselectf(Frame *f, Point p0, Point p1, Fcode c)\n{\n    int n;\n    Point q0, q1;\n\n    if(p0.x == f->left)\n        p0.x = f->r.min.x;\n    if(p1.x == f->left)\n        p1.x = f->r.min.x;\n    q0 = p0;\n    q1 = p1;\n    q0.y += f->fheight;\n    q1.y += f->fheight;\n    n = (p1.y-p0.y)/f->fheight;\n    if(f->b == 0)\n        berror(\"frselectf b==0\");\n    if(p0.y == f->r.max.y)\n        return;\n    if(n == 0){\n        if(p0.x == p1.x){\n            if(p0.x == f->r.min.x)\n                q1.x++;\n            else\n                p0.x--;\n        }\n        bitblt2(f->b, p0, f->b, Rpt(p0, q1), c, 0, f->bg);\n    }else{\n        if(p0.x >= f->r.max.x)\n            p0.x = f->r.max.x-1;\n        bitblt2(f->b, p0, f->b, Rect(p0.x, p0.y, f->r.max.x, q0.y), c, 0, f->bg);\n        if(n > 1)\n            bitblt2(f->b, Pt(f->r.min.x, q0.y),\n                f->b, Rect(f->r.min.x, q0.y, f->r.max.x, p1.y), c, 0, f->bg);\n        bitblt2(f->b, Pt(f->r.min.x, p1.y),\n                f->b, Rect(f->r.min.x, p1.y, q1.x, q1.y), c, 0, f->bg);\n    }\n}\n\nvoid\nfrselectp(Frame *f, Fcode c)\n{\n    Point pt0, pt1;\n\n    pt0 = frptofchar(f, f->p0);\n    pt1 = (f->p0==f->p1)? pt0 : frptofchar(f, f->p1);\n    frselectf(f, pt0, pt1, c);\n}\n", "source": "sam/libframe/frselect.c", "file_type": "c"}
{"text": "/* Copyright (c) 1998 Lucent Technologies - All rights reserved. */\n#include <u.h>\n#include <libg.h>\n#include <frame.h>\n\nint\nfrdelete(Frame *f, uint64_t p0, uint64_t p1)\n{\n    Point pt0, pt1, ppt0;\n    Frbox *b;\n    int n0, n1, n;\n    Rectangle r;\n    int nn0;\n\n    if(p0>=f->nchars || p0==p1 || f->b==0)\n        return 0;\n    if(p1 > f->nchars)\n        p1 = f->nchars;\n    n0 = _frfindbox(f, 0, (uint64_t)0, p0);\n    n1 = _frfindbox(f, n0, p0, p1);\n    pt0 = _frptofcharnb(f, p0, n0);\n    pt1 = frptofchar(f, p1);\n    if(f->p0!=p0 || f->p1!=p1)  /* likely they ARE equal */\n        frselectp(f, F&~D); /* can do better some day */\n    frselectf(f, pt0, pt1, 0);\n    if(n0 == f->nbox)\n        berror(\"off end in frdelete\");\n    nn0 = n0;\n    ppt0 = pt0;\n    _frfreebox(f, n0, n1-1);\n    f->modified = true;\n\n    /*\n     * Invariants:\n     *  pt0 points to beginning, pt1 points to end\n     *  n0 is box containing beginning of stuff being deleted\n     *  n1, b are box containing beginning of stuff to be kept after deletion\n     *  region between pt0 and pt1 is clear\n     */\n    b = &f->box[n1];\n    while(pt1.x!=pt0.x && n1<f->nbox){\n        _frcklinewrap0(f, &pt0, b);\n        _frcklinewrap(f, &pt1, b);\n        if(b->nrune > 0){\n            n = _frcanfit(f, pt0, b);\n            if(n==0)\n                berror(\"_frcanfit==0\");\n            if(n != b->nrune){\n                _frsplitbox(f, n1, n);\n                b = &f->box[n1];\n            }\n            r.min = pt1;\n            r.max = pt1;\n            r.max.x += b->wid;\n            r.max.y += f->fheight;\n            bitblt2(f->b, pt0, f->b, r, S, 0, f->bg);\n            if(pt0.y == pt1.y)\n                r.min.x = r.max.x-(pt1.x-pt0.x);\n            bitblt2(f->b, r.min, f->b, r, 0, 0, f->bg);\n        }\n        _fradvance(f, &pt1, b);\n        pt0.x += _frnewwid(f, pt0, b);\n        f->box[n0++] = f->box[n1++];\n        b++;\n    }\n    if(pt1.y != pt0.y){\n        Point pt2;\n\n        pt2 = _frptofcharptb(f, 32767, pt1, n1);\n        if(pt2.y > f->r.max.y)\n            berror(\"frptofchar in frdelete\");\n        if(n1 < f->nbox){\n            int q0, q1, q2;\n\n            q0 = pt0.y+f->fheight;\n            q1 = pt1.y+f->fheight;\n            q2 = pt2.y+f->fheight;\n            bitblt2(f->b, pt0, f->b, Rect(pt1.x, pt1.y, f->r.max.x, q1), S, 0, f->bg);\n            bitblt2(f->b, Pt(f->r.min.x, q0), f->b, Rect(f->r.min.x, q1, f->r.max.x, q2), S, 0, f->bg);\n            frselectf(f, Pt(pt2.x, pt2.y-(pt1.y-pt0.y)), pt2, 0);\n        }else\n            frselectf(f, pt0, pt2, 0);\n    }\n    _frclosebox(f, n0, n1-1);\n    if(nn0>0 && f->box[nn0-1].nrune>=0 && ppt0.x-f->box[nn0-1].wid>=(int)f->left){\n        --nn0;\n        ppt0.x -= f->box[nn0].wid;\n    }\n    _frclean(f, ppt0, nn0, n0<f->nbox-1? n0+1 : n0);\n    if(f->p1 > p1)\n        f->p1 -= p1-p0;\n    else if(f->p1 > p0)\n        f->p1 = p0;\n    if(f->p0 > p1)\n        f->p0 -= p1-p0;\n    else if(f->p0 > p0)\n        f->p0 = p0;\n    frselectp(f, F&~D);\n    f->nchars -= p1-p0;\n    pt0 = frptofchar(f, f->nchars);\n    n = f->nlines;\n    f->nlines = (pt0.y-f->r.min.y)/f->fheight+(pt0.x>f->left);\n    return n - f->nlines;\n}\n", "source": "sam/libframe/frdelete.c", "file_type": "c"}
{"text": "/* Copyright (c) 1998 Lucent Technologies - All rights reserved. */\n#include <u.h>\n#include <libg.h>\n#include <frame.h>\n\nint\n_frcanfit(Frame *f, Point pt, Frbox *b)\n{\n    int left, w, nr;\n    uint8_t *p;\n    wchar_t r;\n\n    left = f->r.max.x-pt.x;\n    if(b->nrune < 0)\n        return b->a.b.minwid <= left;\n    if(left >= b->wid)\n        return b->nrune;\n    for(nr=0,p=b->a.ptr; *p; p+=w,nr++){\n        r = *p;\n        w = chartorune(&r, (char*)p);\n        left -= charwidth(f->font, r);\n        if(left < 0)\n            return nr;\n    }\n    berror(\"_frcanfit can't\");\n    return 0;\n}\n\nvoid\n_frcklinewrap(Frame *f, Point *p, Frbox *b)\n{\n    if((b->nrune<0? b->a.b.minwid : b->wid) > f->r.max.x-p->x){\n        p->x = f->left;\n        p->y += f->fheight;\n    }\n}\n\nvoid\n_frcklinewrap0(Frame *f, Point *p, Frbox *b)\n{\n    if(_frcanfit(f, *p, b) == 0){\n        p->x = f->left;\n        p->y += f->fheight;\n    }\n}\n\nvoid\n_fradvance(Frame *f, Point *p, Frbox *b)\n{\n    if(b->nrune<0 && b->a.b.bc=='\\n'){\n        p->x = f->left;\n        p->y += f->fheight;\n    }else\n        p->x += b->wid;\n}\n\nint\n_frnewwid(Frame *f, Point pt, Frbox *b)\n{\n    int c, x;\n\n    c = f->r.max.x;\n    x = pt.x;\n    if(b->nrune >= 0)\n        return b->wid;\n    if(b->a.b.bc == '\\t'){\n        if(x+b->a.b.minwid > c)\n            x = pt.x = f->left;\n        x += f->maxtab;\n        x -= (x-f->left)%f->maxtab;\n        if(x-pt.x<b->a.b.minwid || x>c)\n            x = pt.x+b->a.b.minwid;\n        b->wid = x-pt.x;\n    }\n    return b->wid;\n}\n\nvoid\n_frclean(Frame *f, Point pt, int n0, int n1)    /* look for mergeable boxes */\n{\n    Frbox *b;\n    int nb, c;\n\n    c = f->r.max.x;\n    for(nb=n0; nb<n1-1; nb++){\n        b = &f->box[nb];\n        _frcklinewrap(f, &pt, b);\n        while(b[0].nrune>=0 && nb<n1-1 && b[1].nrune>=0 && pt.x+b[0].wid+b[1].wid<c){\n            _frmergebox(f, nb);\n            n1--;\n            b = &f->box[nb];\n        }\n        _fradvance(f, &pt, &f->box[nb]);\n    }\n    for(; nb<f->nbox; nb++){\n        b = &f->box[nb];\n        _frcklinewrap(f, &pt, b);\n        _fradvance(f, &pt, &f->box[nb]);\n    }\n    f->lastlinefull = false;\n    if(pt.y >= f->r.max.y)\n        f->lastlinefull = true;\n}\n", "source": "sam/libframe/frutil.c", "file_type": "c"}
{"text": "#include <u.h>\n#include <libc.h>\n#include \"git.h\"\n\ntypedef struct Pfilt Pfilt;\nstruct Pfilt {\n\tchar\t*elt;\n\tint\tshow;\n\tPfilt\t*sub;\n\tint\tnsub;\n};\n\nBiobuf\t*out;\nchar\t*queryexpr;\nchar\t*commitid;\nint\tshortlog;\nint\tmsgcount = -1;\n\nObjset\tdone;\nObjq\tobjq;\nPfilt\t*pathfilt;\n\nvoid\nfilteradd(Pfilt *pf, char *path)\n{\n\tchar *p, *e;\n\tint i;\n\n\tif((e = strchr(path, '/')) != nil)\n\t\tp = smprint(\"%.*s\", (int)(e - path), path);\n\telse\n\t\tp = strdup(path);\n\n\twhile(e != nil && *e == '/')\n\t\te++;\n\tfor(i = 0; i < pf->nsub; i++){\n\t\tif(strcmp(pf->sub[i].elt, p) == 0){\n\t\t\tpf->sub[i].show = pf->sub[i].show || (e == nil);\n\t\t\tif(e != nil)\n\t\t\t\tfilteradd(&pf->sub[i], e);\n\t\t\tfree(p);\n\t\t\treturn;\n\t\t}\n\t}\n\tpf->sub = earealloc(pf->sub, pf->nsub+1, sizeof(Pfilt));\n\tpf->sub[pf->nsub].elt = p;\n\tpf->sub[pf->nsub].show = (e == nil);\n\tpf->sub[pf->nsub].nsub = 0;\n\tpf->sub[pf->nsub].sub = nil;\n\tif(e != nil)\n\t\tfilteradd(&pf->sub[pf->nsub], e);\n\tpf->nsub++;\n}\n\nHash\nlookup(Pfilt *pf, Object *o)\n{\n\tint i;\n\n\tfor(i = 0; i < o->tree->nent; i++)\n\t\tif(strcmp(o->tree->ent[i].name, pf->elt) == 0)\n\t\t\treturn o->tree->ent[i].h;\n\treturn Zhash;\n}\n\nint\nmatchesfilter1(Pfilt *pf, Object *t, Object *pt)\n{\n\tObject *a, *b;\n\tHash ha, hb;\n\tint i, r;\n\n\tif(pf->show)\n\t\treturn 1;\n\tif(t->type != pt->type)\n\t\treturn 1;\n\tif(t->type != GTree)\n\t\treturn 0;\n\n\tfor(i = 0; i < pf->nsub; i++){\n\t\tha = lookup(&pf->sub[i], t);\n\t\thb = lookup(&pf->sub[i], pt);\n\t\tif(hasheq(&ha, &hb))\n\t\t\tcontinue;\n\t\tif(hasheq(&ha, &Zhash) || hasheq(&hb, &Zhash))\n\t\t\treturn 1;\n\t\tif((a = readobject(ha)) == nil)\n\t\t\tsysfatal(\"read %H: %r\", ha);\n\t\tif((b = readobject(hb)) == nil)\n\t\t\tsysfatal(\"read %H: %r\", hb);\n\t\tr = matchesfilter1(&pf->sub[i], a, b);\n\t\tunref(a);\n\t\tunref(b);\n\t\tif(r)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nint\nmatchesfilter(Object *o)\n{\n\tObject *t, *p, *pt;\n\tint i, r;\n\n\tassert(o->type == GCommit);\n\tif(pathfilt == nil)\n\t\treturn 1;\n\tif((t = readobject(o->commit->tree)) == nil)\n\t\tsysfatal(\"read %H: %r\", o->commit->tree);\n\tfor(i = 0; i < o->commit->nparent; i++){\n\t\tif((p = readobject(o->commit->parent[i])) == nil)\n\t\t\tsysfatal(\"read %H: %r\", o->commit->parent[i]);\n\t\tif((pt = readobject(p->commit->tree)) == nil)\n\t\t\tsysfatal(\"read %H: %r\", o->commit->tree);\n\t\tr = matchesfilter1(pathfilt, t, pt);\n\t\tunref(p);\n\t\tunref(pt);\n\t\tif(r)\n\t\t\treturn 1;\n\t}\n\treturn o->commit->nparent == 0;\n}\n\n\nstatic char*\nnextline(char *p, char *e)\n{\n\tfor(; p != e; p++)\n\t\tif(*p == '\\n')\n\t\t\tbreak;\n\treturn p;\n}\n\nstatic int\nshow(Object *o)\n{\n\tTm tm;\n\tchar *p, *q, *e;\n\n\tassert(o->type == GCommit);\n\tif(shortlog){\n\t\tp = o->commit->msg;\n\t\te = p + o->commit->nmsg;\n\t\tq = nextline(p, e);\n\t\tBprint(out, \"%H \", o->hash);\n\t\tBwrite(out, p, q - p);\n\t\tBputc(out, '\\n');\n\t}else{\n\t\ttmtime(&tm, o->commit->mtime, tzload(\"local\"));\n\t\tBprint(out, \"Hash:\\t%H\\n\", o->hash);\n\t\tBprint(out, \"Author:\\t%s\\n\", o->commit->author);\n\t\tif(o->commit->committer != nil\n\t\t&& strcmp(o->commit->author, o->commit->committer) != 0)\n\t\t\tBprint(out, \"Committer:\\t%s\\n\", o->commit->committer);\n\t\tBprint(out, \"Date:\\t%\u03c4\\n\", tmfmt(&tm, \"WW MMM D hh:mm:ss z YYYY\"));\n\t\tBprint(out, \"\\n\");\n\t\tp = o->commit->msg;\n\t\te = p + o->commit->nmsg;\n\t\tfor(; p != e; p = q){\n\t\t\tq = nextline(p, e);\n\t\t\tBputc(out, '\\t');\n\t\t\tBwrite(out, p, q - p);\n\t\t\tBputc(out, '\\n');\n\t\t\tif(q != e)\n\t\t\t\tq++;\n\t\t}\n\t\tBprint(out, \"\\n\");\n\t}\n\tBflush(out);\n\treturn 1;\n}\n\nstatic void\nshowquery(char *q)\n{\n\tObject *o;\n\tHash *h;\n\tint n, i;\n\n\tif((n = resolverefs(&h, q)) == -1)\n\t\tsysfatal(\"resolve: %r\");\n\tfor(i = 0; i < n && (msgcount == -1 || msgcount > 0); i++){\n\t\tif((o = readobject(h[i])) == nil)\n\t\t\tsysfatal(\"read %H: %r\", h[i]);\n\t\tif(matchesfilter(o)){\n\t\t\tshow(o);\n\t\t\tif(msgcount != -1)\n\t\t\t\tmsgcount--;\n\t\t}\n\t\tunref(o);\n\t}\n\texits(nil);\n}\n\nstatic void\nshowcommits(char *c)\n{\n\tObject *o, *p;\n\tQelt e;\n\tint i;\n\tHash h;\n\n\tif(c == nil)\n\t\tc = \"HEAD\";\n\tif(resolveref(&h, c) == -1)\n\t\tsysfatal(\"resolve %s: %r\", c);\n\tif((o = readobject(h)) == nil)\n\t\tsysfatal(\"load %H: %r\", h);\n\tif(o->type != GCommit)\n\t\tsysfatal(\"%s: not a commit\", c);\n\tqinit(&objq);\n\tosinit(&done);\n\tqput(&objq, o, 0);\n\twhile(qpop(&objq, &e) && (msgcount == -1 || msgcount > 0)){\n\t\tif(matchesfilter(e.o)){\n\t\t\tshow(e.o);\n\t\t\tif(msgcount != -1)\n\t\t\t\tmsgcount--;\n\t\t}\n\t\tfor(i = 0; i < e.o->commit->nparent; i++){\n\t\t\tif(oshas(&done, e.o->commit->parent[i]))\n\t\t\t\tcontinue;\n\t\t\tif((p = readobject(e.o->commit->parent[i])) == nil)\n\t\t\t\tsysfatal(\"load %H: %r\", o->commit->parent[i]);\n\t\t\tosadd(&done, p);\n\t\t\tqput(&objq, p, 0);\n\t\t}\n\t\tunref(e.o);\n\t}\n}\n\nstatic void\nusage(void)\n{\n\tfprint(2, \"usage: %s [-s] [-e expr | -c commit] files..\\n\", argv0);\n\texits(\"usage\");\n}\n\t\nvoid\nmain(int argc, char **argv)\n{\n\tchar path[1024], repo[1024], *p, *r;\n\tint i, nrel, nrepo;\n\n\tARGBEGIN{\n\tcase 'e':\n\t\tqueryexpr = EARGF(usage());\n\t\tbreak;\n\tcase 'c':\n\t\tcommitid = EARGF(usage());\n\t\tbreak;\n\tcase 's':\n\t\tshortlog++;\n\t\tbreak;\n\tcase 'n':\n\t\tmsgcount = atoi(EARGF(usage()));\n\t\tbreak;\n\tdefault:\n\t\tusage();\n\t\tbreak;\n\t}ARGEND;\n\n\tif(findrepo(repo, sizeof(repo), &nrel) == -1)\n\t\tsysfatal(\"find root: %r\");\n\tnrepo = strlen(repo);\n\tif(argc != 0){\n\t\tif(getwd(path, sizeof(path)) == nil)\n\t\t\tsysfatal(\"getwd: %r\");\n\t\tif(strncmp(path, repo, nrepo) != 0)\n\t\t\tsysfatal(\"path shifted??\");\n\t\tp = path + nrepo;\n\t\tpathfilt = emalloc(sizeof(Pfilt));\n\t\tfor(i = 0; i < argc; i++){\n\t\t\tif(*argv[i] == '/'){\n\t\t\t\tif(strncmp(argv[i], repo, nrepo) != 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tr = smprint(\"./%s\", argv[i]+nrepo);\n\t\t\t}else\n\t\t\t\tr = smprint(\"./%s/%s\", p, argv[i]);\n\t\t\tcleanname(r);\n\t\t\tfilteradd(pathfilt, r);\n\t\t\tfree(r);\n\t\t}\n\t}\n\tif(chdir(repo) == -1)\n\t\tsysfatal(\"chdir: %r\");\n\n\tgitinit();\n\ttmfmtinstall();\n\tout = Bfdopen(1, OWRITE);\n\tif(queryexpr != nil)\n\t\tshowquery(queryexpr);\n\telse\n\t\tshowcommits(commitid);\n\tBterm(out);\n\texits(nil);\n}\n", "source": "git9/log.c", "file_type": "c"}
{"text": "#!/bin/rc -e\nrfork en\n. /sys/lib/git/common.rc\n\ngitup\n\nflagfmt='e:expr expression, c:branch commit, s:short'; args='file ...'\neval `''{aux/getflags $*} || exec aux/usage\n\nbase=/mnt/git/object/\nif(~ $#branch 0)\n\tbranch=`{git/branch}\nif(~ $#expr 0)\n\tcommits=`{git/query $branch}\nif not\n\tcommits=`{git/query $expr}\n\nfiles=()\nif(! ~ $#* 0)\n\tfiles=`\"{walk -f $gitrel/^$* | subst '^\\./' | sort}\n\nwhile(! ~ $#commits 0){\n\tids=$nids\n\tshow=()\n\tc=$commits(1)\n\tif(! ~ $#files 0){\n\t\tncomm=`{comm -12 /env/files <{git/query -c $c~ $c | subst '^..' | sort} | wc -l}\n\t\tif(! ~ $ncomm 0)\n\t\t\tshow=true\n\t}\n\tcommits=$commits(2-)\n\tif(~ $#expr 0)\n\t\tcommits=($commits `{cat $base/$c/parent >[2]/dev/null})\n\tif(! ~ $#commits 0)\n\t\tcommits=`$nl{walk -emp -n0 $base^$commits | sort -rn | uniq | awk -F/ '{print $NF}'}\n\n\tif(~ $#files 0 || ~ $show true){\n\t\tif(~ $short 1)\n\t\t\techo $c `{cat $base/$c/msg | sed 1q}\n\t\tif not{\n\t\t\techo -n 'Hash:\t'`''{cat $base/$c/hash}\n\t\t\techo -n 'Author:\t'`''{cat $base/$c/author}\n\t\t\techo -n 'Date:\t'`''{date `{mtime $base/$c/msg | awk '{print $1}'}}\n\t\t\tsubst -g '^' '\t' <$base/$c/msg \n\t\t\techo\n\t\t}\n\t}\n}\nexit ''\n", "source": "git9/log", "file_type": "rc"}
{"text": "#!/bin/rc\nrfork en\n. /sys/lib/git/common.rc\n\nflagfmt='d:debug, b:branch branch'; args='remote [local]'\neval `''{aux/getflags $*} || exec aux/usage\nif(~ $debug 1)\n\tdebug=(-d)\n\nremote=`{echo $1 | sed  's@/*$@@'}\nlocal=$2\n\nif(~ $#remote 0)\n\texec aux/usage\nif(~ $#local 0)\n\tlocal=`{basename $remote .git}\nif(~ $#branch 1)\n\tbranchflag=(-b $branch)\n\nif(test -e $local && ~ `{ls $local | sed 1q | wc -l} 1)\n\tdie 'destination already exists:' $local\n\nfn clone{\n\tflag +e\n\tmkdir -p $local/.git\n\tmkdir -p $local/.git/fs\n\tmkdir -p $local/.git/objects/pack/\n\tmkdir -p $local/.git/refs/heads/\n\t\n\tcd $local\n\t\n\t>>.git/config {\n\t\techo '[remote \"origin\"]'\n\t\techo '\turl='$remote\n\t}\n\t{git/get  $debug $branchflag $remote >[2=3] | awk '\n\t\tBEGIN{\n\t\t\theadref=\"\"\n\t\t\tif(ENVIRON[\"branch\"] != \"\")\n\t\t\t\theadref=\"refs/remotes/origin/\"ENVIRON[\"branch\"]\n\t\t\theadhash=\"\"\n\t\t}\n\t\t/^symref / && headref == \"\" {\n\t\t\tif($2 == \"HEAD\"){\n\t\t\t\tgsub(\"^refs/heads\", \"refs/remotes/origin\", $3)\n\t\t\t\tgsub(\"^refs/tags\", \"refs/remotes/origin/tags\", $3)\n\t\t\t}\n\t\t}\n\t\t/^remote /{\n\t\t\tif($2==\"HEAD\"){\n\t\t\t\theadhash=$3\n\t\t\t}else if(match($2, \"^refs/(heads|tags)/\")){\n\t\t\t\tgsub(\"^refs/heads\", \"refs/remotes/origin\", $2)\n\t\t\t\tif($2 == headref || (headref == \"\" && $3 == headhash))\n\t\t\t\t\theadref=$2\n\t\t\t\toutfile = \".git/\" $2\n\t\t\t\toutdir = outfile\n\t\t\t\tgsub(\"/?[^/]*/?$\", \"\", outdir)\n\t\t\t\tsystem(\"mkdir -p \"outdir)\n\t\t\t\tprint $3 > outfile\n\t\t\t\tclose(outfile)\n\t\t\t}\n\t\t}\n\t\tEND{\n\t\t\tif(headref != \"\"){\n\t\t\t\tremote = headref;\n\t\t\t\trefdir = headref;\n\t\t\t\tgsub(\"/?[^/]*/?$\", \"\", refdir)\n\t\t\t\tgsub(\"^refs/remotes/origin\", \"refs/heads\", headref)\n\t\t\t\tsystem(\"mkdir -p `{basename -d .git/\"headref\"}\");\n\t\t\t\tsystem(\"cp .git/\" remote \" .git/\" headref)\n\t\t\t\tprint \"ref: \" headref > \".git/HEAD\"\n\t\t\t}else if(headhash != \"\"){\n\t\t\t\tprint \"warning: detached head \"headhash > \"/fd/2\"\n\t\t\t\tprint headhash > \".git/HEAD\"\n\t\t\t}\n\t\t}\n\t'} |[3] tr '\\x0d' '\\x0a' || die 'could not clone repository'\n\n\ttree=.git/fs/HEAD/tree\n\tlbranch=`{git/branch}\n\trbranch=`{echo $lbranch | subst 'heads' 'remotes/origin'}\n\techo checking out repository...\n\tif(test -f .git/refs/$rbranch){\n\t\tmkdir -p `{basename -d .git/refs/$lbranch}\n\t\tcp .git/refs/$rbranch .git/refs/$lbranch\n\t\tgit/fs\n\t\t@ {builtin cd $tree && tar cif /fd/1 .} | @ {tar xf /fd/0} \\\n\t\t\t|| die 'checkout failed:' $status\n\t\t{for(f in `$nl{cd $tree && walk -f})\n\t\t\techo 'T NOQID 0 '$f} > .git/INDEX9\n\t}\n\tif not{\n\t\techo no default branch >[1=2]\n\t\techo check out your code with git/branch >[1=2]\n\t}\n}\n\nfn sigint {\n\techo cancelled clone $remote: cleaning $local >[1=2]\n\tunmount $local/.git/fs >[2]/dev/null\n\trm -rf $local\n\texit interrupted\n}\n\n@{clone}\nst=$status\nif(! ~ $st ''){\n\techo failed to clone $remote: cleaning $local >[1=2]\n\tunmount $local/.git/fs >[2]/dev/null\n\trm -rf $local\n\texit $st\n}\nexit ''\n", "source": "git9/clone", "file_type": "rc"}
{"text": "#!/bin/rc\n\n. /sys/lib/git/common.rc\ngitup\n\nflagfmt='a:abort, r:resume, i:interactive'; args='onto'\neval `''{aux/getflags $*} || exec aux/usage\n\ntmp=_rebase.working\nif(~ $#abort 1){\n\tif(! test -f .git/rebase.todo)\n\t\tdie no rebase to abort\n\tsrc=`{cat .git/rebase.src}\n\trm -f .git/rebase.^(src todo)\n\tgit/branch $src\n\tgit/branch -d $tmp\n\texit\n}\nif(test -f .git/rebase.todo){\n\tif(~ $#resume 0)\n\t\tdie rebase in progress\n\tif(! ~ $#* 0)\n\t\texec aux/usage\n\tsrc=`{cat .git/rebase.src}\n}\nif not{\n\tif(! ~ $#* 1)\n\t\texec aux/usage\n\tsrc=`{git/branch}\n\tdst=`{git/query $1}\n\techo $src > .git/rebase.src\n\tgit/log -se $dst'..'$src | sed 's/^/pick /' >.git/rebase.todo\n\tif(! ~ $#interactive 0){\n\t\tgiteditor=`{git/conf core.editor}\n\t\tif(~ $#editor 0)\n\t\t\teditor=$giteditor\n\t\tif(~ $#editor 0)\n\t\t\teditor=hold\n\t\t$editor .git/rebase.todo\n\t}\n\tgit/branch -nb $dst $tmp\n}\ntodo=`$nl{cat .git/rebase.todo}\n\nfn sigexit {\n\ts=$status\n\tif(!)\n\t\techo 'fix and git/rebase -r'\n\t>.git/rebase.todo for(i in $todo)\n\t\techo $i\n\tstatus=$s\n}\n\nflag e +\n\nwhile(! ~ $#todo 0){\n\titem=`{echo $todo(1)}\n\ttodo=$todo(2-)\n\techo $item\n\tc=$item(2)\n\tswitch($item(1)){\n\tcase p pick\n\t\tgit/export $c | git/import\n\tcase r reword\n\t\tgit/export $c | git/import\n\t\tgit/commit -re\n\tcase e edit\n\t\tgit/export $c | git/import\n\t\techo 'stopped for edit, resume with git/rebase -r'\n\t\texit\n\tcase s squash\n\t\tgit/export $c | git/import -n\n\t\tmsg=`''{cat $gitfs/HEAD/msg; echo; cat $gitfs/object/$c/msg}\n\t\tgit/commit -rem $msg .\n\tcase f fixup\n\t\tgit/export $c | git/import -n\n\t\tgit/commit -r .\n\tcase b break\n\t\techo 'stopped, resume with git/rebase -r'\n\t\texit\n\tcase '#'* ''\n\tcase *\n\t\tdie 'unknown command '''^$item(1)^''''\n\t}\n}\n\nfn sigexit\ngit/branch -nb $tmp $src\ngit/branch -d $tmp\nrm .git/rebase.todo .git/rebase.src\n", "source": "git9/rebase", "file_type": "rc"}
{"text": "#!/bin/rc\nrfork ne\n. /sys/lib/git/common.rc\n\ngitup\n\nflagfmt='c:commit branch, s:summarize, u:uncommitted'; args='[file ...]'\neval `''{aux/getflags $*} || exec aux/usage\n\nif(~ $#commit 0){\n\tcommit=HEAD\n\tcparam=()\n}\n\nfiles=()\nfilt=MAR\nif(~ $#uncommitted 1)\n\tfilt=MARU\nif(! ~ $#* 0)\n\tfiles=`{cleanname -d $gitrel $*}\n\nbranch=`{git/query -p $commit}\nif(~ $summarize 1 || ~ $uncommitted 1){\n\tgit/walk -f$filt $cparam $files\n\texit\n}\n\nshowed=()\nmntgen /mnt/scratch\nbind $branch/tree/ /mnt/scratch/a\nbind . /mnt/scratch/b\nfor(f in `$nl{git/walk -c -f$filt $cparam $files}){\n\tif(~ $#showed 0){\n\t\techo diff `{git/query $commit} uncommitted\n\t\tshowed=1\n\t}\n\tcd /mnt/scratch\n\ta=a/$f\n\tb=b/$f\n\tif(! test -f a/$f)\n\t\ta=/dev/null\n\tif(! test -f b/$f)\n\t\tb=/dev/null\n\tdiff -u $a $b\n}\nexit ''\n", "source": "git9/diff", "file_type": "rc"}
{"text": "#include <u.h>\n#include <libc.h>\n#include <ctype.h>\n\n#include \"git.h\"\n\ntypedef struct Buf\tBuf;\ntypedef struct Metavec\tMetavec;\ntypedef struct Meta\tMeta;\ntypedef struct Compout\tCompout;\ntypedef struct Packf\tPackf;\n\n#define max(x, y) ((x) > (y) ? (x) : (y))\n\nstruct Metavec {\n\tMeta\t**meta;\n\tint\tnmeta;\n\tint\tmetasz;\n};\n\nstruct Meta {\n\tObject\t*obj;\n\tvlong\tpath;\n\tvlong\tmtime;\n\n\t/* The best delta we picked */\n\tMeta\t*head;\n\tMeta\t*prev;\n\tDelta\t*delta;\n\tint\tndelta;\n\tint\tnchain;\n\n\t/* Only used for delta window */\n\tDtab \tdtab;\n\n\t/* Only used for writing offset deltas */\n\tvlong\toff;\n};\n\nstruct Compout {\n\tBiobuf *bfd;\n\tDigestState *st;\n};\n\nstruct Buf {\n\tint len;\n\tint sz;\n\tint off;\n\tchar *data;\n};\n\nstruct Packf {\n\tchar\tpath[128];\n\tchar\t*idx;\n\tvlong\tnidx;\n\n\tint\trefs;\n\tBiobuf\t*pack;\n\tvlong\topentm;\n};\n\nstatic int\treadpacked(Biobuf *, Object *, int);\nstatic Object\t*readidxobject(Biobuf *, Hash, int);\n\nObjset objcache;\nObject *lruhead;\nObject *lrutail;\nvlong\tncache;\nvlong\tcachemax = 128*MiB;\nPackf\t*packf;\nint\tnpackf;\nint\topenpacks;\nint\tgitdirmode = -1;\n\nstatic void\nclear(Object *o)\n{\n\tif(!o)\n\t\treturn;\n\n\tassert(o->refs == 0);\n\tassert((o->flag & Ccache) == 0);\n\tassert(o->flag & Cloaded);\n\tswitch(o->type){\n\tcase GCommit:\n\t\tif(!o->commit)\n\t\t\tbreak;\n\t\tfree(o->commit->parent);\n\t\tfree(o->commit->author);\n\t\tfree(o->commit->committer);\n\t\tfree(o->commit);\n\t\to->commit = nil;\n\t\tbreak;\n\tcase GTree:\n\t\tif(!o->tree)\n\t\t\tbreak;\n\t\tfree(o->tree->ent);\n\t\tfree(o->tree);\n\t\to->tree = nil;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tfree(o->all);\n\to->all = nil;\n\to->data = nil;\n\to->flag &= ~(Cloaded|Cparsed);\n}\n\nvoid\nunref(Object *o)\n{\n\tif(!o)\n\t\treturn;\n\to->refs--;\n\tif(o->refs == 0)\n\t\tclear(o);\n}\n\nObject*\nref(Object *o)\n{\n\to->refs++;\n\treturn o;\n}\n\nvoid\ncache(Object *o)\n{\n\tObject *p;\n\n\tif(o == lruhead)\n\t\treturn;\n\tif(o == lrutail)\n\t\tlrutail = lrutail->prev;\n\tif(!(o->flag & Cexist)){\n\t\tosadd(&objcache, o);\n\t\to->id = objcache.nobj;\n\t\to->flag |= Cexist;\n\t}\n\tif(o->prev != nil)\n\t\to->prev->next = o->next;\n\tif(o->next != nil)\n\t\to->next->prev = o->prev;\n\tif(lrutail == o){\n\t\tlrutail = o->prev;\n\t\tif(lrutail != nil)\n\t\t\tlrutail->next = nil;\n\t}else if(lrutail == nil)\n\t\tlrutail = o;\n\tif(lruhead)\n\t\tlruhead->prev = o;\n\to->next = lruhead;\n\to->prev = nil;\n\tlruhead = o;\n\n\tif(!(o->flag & Ccache)){\n\t\to->flag |= Ccache;\n\t\tref(o);\n\t\tncache += o->size;\n\t}\n\twhile(ncache > cachemax && lrutail != lruhead){\n\t\tp = lrutail;\n\t\tlrutail = p->prev;\n\t\tif(lrutail != nil)\n\t\t\tlrutail->next = nil;\n\t\tp->flag &= ~Ccache;\n\t\tp->prev = nil;\n\t\tp->next = nil;\n\t\tncache -= p->size;\n\t\tunref(p);\n\t}\t\t\n}\n\nstatic int\nloadpack(Packf *pf, char *name)\n{\n\tchar buf[128];\n\tint i, ifd;\n\tDir *d;\n\n\tmemset(pf, 0, sizeof(Packf));\n\tsnprint(buf, sizeof(buf), \".git/objects/pack/%s.idx\", name);\n\tsnprint(pf->path, sizeof(pf->path), \".git/objects/pack/%s.pack\", name);\n\t/*\n\t * if we already have the pack open, just\n\t * steal the loaded info\n\t */\n\tfor(i = 0; i < npackf; i++){\n\t\tif(strcmp(pf->path, packf[i].path) == 0){\n\t\t\tpf->pack = packf[i].pack;\n\t\t\tpf->idx = packf[i].idx;\n\t\t\tpf->nidx = packf[i].nidx;\n\t\t\tpackf[i].idx = nil;\n\t\t\tpackf[i].pack = nil;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif((ifd = open(buf, OREAD)) == -1)\n\t\treturn -1;\n\tif((d = dirfstat(ifd)) == nil){\n\t\tclose(ifd);\n\t\treturn -1;\n\t}\n\tpf->nidx = d->length;\n\tpf->idx = emalloc(pf->nidx);\n\tif(readn(ifd, pf->idx, pf->nidx) != pf->nidx){\n\t\tclose(ifd);\n\t\tfree(pf->idx);\n\t\tfree(d);\n\t\treturn -1;\n\t}\n\tclose(ifd);\n\tfree(d);\n\treturn 0;\n}\n\nstatic void\nrefreshpacks(void)\n{\n\tPackf *pf, *new;\n\tint i, n, l, nnew;\n\tDir *d;\n\n\tif((n = slurpdir(\".git/objects/pack\", &d)) == -1)\n\t\treturn;\n\tnnew = 0;\n\tnew = eamalloc(n, sizeof(Packf));\n\tfor(i = 0; i < n; i++){\n\t\tl = strlen(d[i].name);\n\t\tif(l > 4 && strcmp(d[i].name + l - 4, \".idx\") != 0)\n\t\t\tcontinue;\n\t\td[i].name[l - 4] = 0;\n\t\tif(loadpack(&new[nnew], d[i].name) != -1)\n\t\t\tnnew++;\n\t}\n\tfor(i = 0; i < npackf; i++){\n\t\tpf = &packf[i];\n\t\tfree(pf->idx);\n\t\tif(pf->pack != nil)\n\t\t\tBterm(pf->pack);\n\t}\n\tfree(packf);\n\tpackf = new;\n\tnpackf = nnew;\n\tfree(d);\n}\n\nstatic Biobuf*\nopenpack(Packf *pf)\n{\n\tvlong t;\n\tint i, best;\n\n\tif(pf->pack != nil){\n\t\tpf->refs++;\n\t\treturn pf->pack;\n\t}\n\t/*\n\t * If we've got more packs open\n\t * than we want cached, try to\n\t * free up the oldest ones.\n\t *\n\t * If we can't find a slot, this\n\t * isn't fatal; we can just use\n\t * another fd.\n\t */\n\twhile(openpacks >= Npackcache){\n\t\tt = (1ull<<62)-1;\n\t\tbest = -1;\n\t\tfor(i = 0; i < npackf; i++){\n\t\t\tif(&packf[i] != pf\n\t\t\t&& packf[i].pack != nil\n\t\t\t&& packf[i].opentm < t\n\t\t\t&& packf[i].refs == 0){\n\t\t\t\tt = packf[i].opentm;\n\t\t\t\tbest = i;\n\t\t\t}\n\t\t}\n\t\tif(best == -1){\n\t\t\tfprint(2, \"no available pack slots\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tBterm(packf[best].pack);\n\t\tpackf[best].pack = nil;\n\t\topenpacks--;\n\t}\n\topenpacks++;\n\tpf->opentm = nsec();\n\tpf->refs++;\n\tif((pf->pack = Bopen(pf->path, OREAD)) == nil)\n\t\treturn nil;\n\treturn pf->pack;\n}\n\nstatic void\nclosepack(Packf *pf)\n{\n\tpf->refs--;\n}\n\nstatic u32int\ncrc32(u32int crc, char *b, int nb)\n{\n\tstatic u32int crctab[256] = {\n\t\t0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f, 0xe963a535, \n\t\t0x9e6495a3, 0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988, 0x09b64c2b, 0x7eb17cbd, \n\t\t0xe7b82d07, 0x90bf1d91, 0x1db71064, 0x6ab020f2, 0xf3b97148, 0x84be41de, 0x1adad47d, \n\t\t0x6ddde4eb, 0xf4d4b551, 0x83d385c7, 0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, \n\t\t0x14015c4f, 0x63066cd9, 0xfa0f3d63, 0x8d080df5, 0x3b6e20c8, 0x4c69105e, 0xd56041e4, \n\t\t0xa2677172, 0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b, 0x35b5a8fa, 0x42b2986c, \n\t\t0xdbbbc9d6, 0xacbcf940, 0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59, 0x26d930ac, \n\t\t0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423, 0xcfba9599, 0xb8bda50f, \n\t\t0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924, 0x2f6f7c87, 0x58684c11, 0xc1611dab, \n\t\t0xb6662d3d, 0x76dc4190, 0x01db7106, 0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f, \n\t\t0x9fbfe4a5, 0xe8b8d433, 0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb, \n\t\t0x086d3d2d, 0x91646c97, 0xe6635c01, 0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e, \n\t\t0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457, 0x65b0d9c6, 0x12b7e950, 0x8bbeb8ea, \n\t\t0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65, 0x4db26158, 0x3ab551ce, \n\t\t0xa3bc0074, 0xd4bb30e2, 0x4adfa541, 0x3dd895d7, 0xa4d1c46d, 0xd3d6f4fb, 0x4369e96a, \n\t\t0x346ed9fc, 0xad678846, 0xda60b8d0, 0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9, \n\t\t0x5005713c, 0x270241aa, 0xbe0b1010, 0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, \n\t\t0xce61e49f, 0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81, \n\t\t0xb7bd5c3b, 0xc0ba6cad, 0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a, 0xead54739, \n\t\t0x9dd277af, 0x04db2615, 0x73dc1683, 0xe3630b12, 0x94643b84, 0x0d6d6a3e, 0x7a6a5aa8, \n\t\t0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1, 0xf00f9344, 0x8708a3d2, 0x1e01f268, \n\t\t0x6906c2fe, 0xf762575d, 0x806567cb, 0x196c3671, 0x6e6b06e7, 0xfed41b76, 0x89d32be0, \n\t\t0x10da7a5a, 0x67dd4acc, 0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5, 0xd6d6a3e8, \n\t\t0xa1d1937e, 0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b, \n\t\t0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55, 0x316e8eef, \n\t\t0x4669be79, 0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236, 0xcc0c7795, 0xbb0b4703, \n\t\t0x220216b9, 0x5505262f, 0xc5ba3bbe, 0xb2bd0b28, 0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, \n\t\t0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d, 0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, \n\t\t0x9c0906a9, 0xeb0e363f, 0x72076785, 0x05005713, 0x95bf4a82, 0xe2b87a14, 0x7bb12bae, \n\t\t0x0cb61b38, 0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21, 0x86d3d2d4, 0xf1d4e242, \n\t\t0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777, 0x88085ae6, \n\t\t0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69, 0x616bffd3, 0x166ccf45, \n\t\t0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2, 0xa7672661, 0xd06016f7, 0x4969474d, \n\t\t0x3e6e77db, 0xaed16a4a, 0xd9d65adc, 0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, \n\t\t0x47b2cf7f, 0x30b5ffe9, 0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605, \n\t\t0xcdd70693, 0x54de5729, 0x23d967bf, 0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94, \n\t\t0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d\n\t};\n\tint i;\n\n\tcrc ^=  0xFFFFFFFF;\n\tfor(i = 0; i < nb; i++)\n\t\tcrc = (crc >> 8) ^ crctab[(crc ^ b[i]) & 0xFF];\n\treturn crc ^ 0xFFFFFFFF;\n}\n\nint\nbappend(void *p, void *src, int len)\n{\n\tBuf *b = p;\n\tchar *n;\n\n\twhile(b->len + len >= b->sz){\n\t\tb->sz = b->sz*2 + 64;\n\t\tn = realloc(b->data, b->sz);\n\t\tif(n == nil)\n\t\t\treturn -1;\n\t\tb->data = n;\n\t}\n\tmemmove(b->data + b->len, src, len);\n\tb->len += len;\n\treturn len;\n}\n\nint\nbreadc(void *p)\n{\n\treturn Bgetc(p);\n}\n\nint\nbdecompress(Buf *d, Biobuf *b, vlong *csz)\n{\n\tvlong o;\n\n\to = Boffset(b);\n\tif(inflatezlib(d, bappend, b, breadc) == -1 || d->data == nil){\n\t\tfree(d->data);\n\t\treturn -1;\n\t}\n\tif (csz)\n\t\t*csz = Boffset(b) - o;\n\treturn d->len;\n}\n\nint\ndecompress(void **p, Biobuf *b, vlong *csz)\n{\n\tBuf d = {.len=0, .data=nil, .sz=0};\n\n\tif(bdecompress(&d, b, csz) == -1){\n\t\tfree(d.data);\n\t\treturn -1;\n\t}\n\t*p = d.data;\n\treturn d.len;\n}\n\nstatic vlong\nreadvint(char *p, char **pp)\n{\n\tint s, c;\n\tvlong n;\n\t\n\ts = 0;\n\tn = 0;\n\tdo {\n\t\tc = *p++;\n\t\tn |= (c & 0x7f) << s;\n\t\ts += 7;\n\t} while (c & 0x80 && s < 63);\n\t*pp = p;\n\n\treturn n;\n}\n\nstatic int\napplydelta(Object *dst, Object *base, char *d, int nd)\n{\n\tchar *r, *b, *ed, *er;\n\tint n, nr, c;\n\tvlong o, l;\n\n\ted = d + nd;\n\tb = base->data;\n\tn = readvint(d, &d);\n\tif(n != base->size){\n\t\twerrstr(\"mismatched source size\");\n\t\treturn -1;\n\t}\n\n\tnr = readvint(d, &d);\n\tr = emalloc(nr + 64);\n\tn = snprint(r, 64, \"%T %d\", base->type, nr) + 1;\n\tdst->all = r;\n\tdst->type = base->type;\n\tdst->data = r + n;\n\tdst->size = nr;\n\ter = dst->data + nr;\n\tr = dst->data;\n\n\twhile(d != ed){\n\t\tc = *d++;\n\t\t/* copy from base */\n\t\tif(c & 0x80){\n\t\t\to = 0;\n\t\t\tl = 0;\n\t\t\t/* Offset in base */\n\t\t\tif(d != ed && (c & 0x01)) o |= (*d++ <<  0) & 0x000000ff;\n\t\t\tif(d != ed && (c & 0x02)) o |= (*d++ <<  8) & 0x0000ff00;\n\t\t\tif(d != ed && (c & 0x04)) o |= (*d++ << 16) & 0x00ff0000;\n\t\t\tif(d != ed && (c & 0x08)) o |= (*d++ << 24) & 0xff000000;\n\n\t\t\t/* Length to copy */\n\t\t\tif(d != ed && (c & 0x10)) l |= (*d++ <<  0) & 0x0000ff;\n\t\t\tif(d != ed && (c & 0x20)) l |= (*d++ <<  8) & 0x00ff00;\n\t\t\tif(d != ed && (c & 0x40)) l |= (*d++ << 16) & 0xff0000;\n\t\t\tif(l == 0) l = 0x10000;\n\n\t\t\tif(o + l > base->size){\n\t\t\t\twerrstr(\"garbled delta: out of bounds copy\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tmemmove(r, b + o, l);\n\t\t\tr += l;\n\t\t/* inline data */\n\t\t}else{\n\t\t\tif(c > ed - d){\n\t\t\t\twerrstr(\"garbled delta: write past object\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tmemmove(r, d, c);\n\t\t\td += c;\n\t\t\tr += c;\n\t\t}\n\t}\n\tif(r != er){\n\t\twerrstr(\"truncated delta\");\n\t\treturn -1;\n\t}\n\n\treturn nr;\n}\n\nstatic int\nreadrdelta(Biobuf *f, Object *o, int nd, int flag)\n{\n\tObject *b;\n\tHash h;\n\tchar *d;\n\tint n;\n\n\td = nil;\n\tif(Bread(f, h.h, sizeof(h.h)) != sizeof(h.h))\n\t\tgoto error;\n\tif(hasheq(&o->hash, &h))\n\t\tgoto error;\n\tif((n = decompress(&d, f, nil)) == -1)\n\t\tgoto error;\n\to->len = Boffset(f) - o->off;\n\tif(d == nil || n != nd)\n\t\tgoto error;\n\tif((b = readidxobject(f, h, flag|Cthin)) == nil)\n\t\tgoto error;\n\tif(applydelta(o, b, d, n) == -1)\n\t\tgoto error;\n\tfree(d);\n\treturn 0;\nerror:\n\tfree(d);\n\treturn -1;\n}\n\nstatic int\nreadodelta(Biobuf *f, Object *o, vlong nd, vlong p, int flag)\n{\n\tObject b;\n\tchar *d;\n\tvlong r;\n\tint c, n;\n\n\td = nil;\n\tif((c = Bgetc(f)) == -1)\n\t\treturn -1;\n\tr = c & 0x7f;\n\twhile(c & 0x80 && r < (1ULL<<56)){\n\t\tif((c = Bgetc(f)) == -1)\n\t\t\treturn -1;\n\t\tr = ((r + 1)<<7) | (c & 0x7f);\n\t}\n\n\tif(r > p || r >= (1ULL<<56)){\n\t\twerrstr(\"junk offset -%lld (from %lld)\", r, p);\n\t\tgoto error;\n\t}\n\tif((n = decompress(&d, f, nil)) == -1)\n\t\tgoto error;\n\to->len = Boffset(f) - o->off;\n\tif(d == nil || n != nd)\n\t\tgoto error;\n\tif(Bseek(f, p - r, 0) == -1)\n\t\tgoto error;\n\tmemset(&b, 0, sizeof(Object));\n\tif(readpacked(f, &b, flag) == -1)\n\t\tgoto error;\n\tif(applydelta(o, &b, d, nd) == -1)\n\t\tgoto error;\n\tclear(&b);\n\tfree(d);\n\treturn 0;\nerror:\n\tfree(d);\n\treturn -1;\n}\n\nstatic int\nreadpacked(Biobuf *f, Object *o, int flag)\n{\n\tint c, s, n;\n\tvlong l, p;\n\tint t;\n\tBuf b;\n\n\tp = Boffset(f);\n\tc = Bgetc(f);\n\tif(c == -1)\n\t\treturn -1;\n\tl = c & 0xf;\n\ts = 4;\n\tt = (c >> 4) & 0x7;\n\tif(!t){\n\t\twerrstr(\"unknown type for byte %x at %lld\", c, p);\n\t\treturn -1;\n\t}\n\twhile(c & 0x80){\n\t\tif((c = Bgetc(f)) == -1)\n\t\t\treturn -1;\n\t\tl |= (c & 0x7f) << s;\n\t\ts += 7;\n\t}\n\tif(l >= (1ULL << 32)){\n\t\twerrstr(\"object too big\");\n\t\treturn -1;\n\t}\n\tswitch(t){\n\tdefault:\n\t\twerrstr(\"invalid object at %lld\", Boffset(f));\n\t\treturn -1;\n\tcase GCommit:\n\tcase GTree:\n\tcase GTag:\n\tcase GBlob:\n\t\tb.sz = 64 + l;\n\t\tb.data = emalloc(b.sz);\n\t\tn = snprint(b.data, 64, \"%T %lld\", t, l) + 1;\n\t\tb.len = n;\n\t\tif(bdecompress(&b, f, nil) == -1){\n\t\t\tfree(b.data);\n\t\t\treturn -1;\n\t\t}\n\t\to->len = Boffset(f) - o->off;\n\t\to->type = t;\n\t\to->all = b.data;\n\t\to->data = b.data + n;\n\t\to->size = b.len - n;\n\t\tbreak;\n\tcase GOdelta:\n\t\tif(readodelta(f, o, l, p, flag) == -1)\n\t\t\treturn -1;\n\t\tbreak;\n\tcase GRdelta:\n\t\tif(readrdelta(f, o, l, flag) == -1)\n\t\t\treturn -1;\n\t\tbreak;\n\t}\n\to->flag |= Cloaded|flag;\n\treturn 0;\n}\n\nstatic int\nreadloose(Biobuf *f, Object *o, int flag)\n{\n\tstruct { char *tag; int type; } *p, types[] = {\n\t\t{\"blob\", GBlob},\n\t\t{\"tree\", GTree},\n\t\t{\"commit\", GCommit},\n\t\t{\"tag\", GTag},\n\t\t{nil},\n\t};\n\tchar *d, *s, *e;\n\tvlong sz, n;\n\tint l;\n\n\tn = decompress(&d, f, nil);\n\tif(n == -1)\n\t\treturn -1;\n\n\ts = d;\n\to->type = GNone;\n\tfor(p = types; p->tag; p++){\n\t\tl = strlen(p->tag);\n\t\tif(strncmp(s, p->tag, l) == 0){\n\t\t\ts += l;\n\t\t\to->type = p->type;\n\t\t\twhile(!isspace(*s))\n\t\t\t\ts++;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(o->type == GNone){\n\t\tfree(o->data);\n\t\treturn -1;\n\t}\n\tsz = strtol(s, &e, 0);\n\tif(e == s || *e++ != 0){\n\t\twerrstr(\"malformed object header\");\n\t\tgoto error;\n\t}\n\tif(sz != n - (e - d)){\n\t\twerrstr(\"mismatched sizes\");\n\t\tgoto error;\n\t}\n\to->size = sz;\n\to->data = e;\n\to->all = d;\n\to->flag |= Cloaded|flag;\n\treturn 0;\n\nerror:\n\tfree(d);\n\treturn -1;\n}\n\nvlong\nsearchindex(char *idx, int nidx, Hash h)\n{\n\tint lo, hi, hidx, i, r, nent;\n\tvlong o, oo;\n\tvoid *s;\n\n\to = 8;\n\tif(nidx < 8 + 256*4)\n\t\treturn -1;\n\t/*\n\t * Read the fanout table. The fanout table\n\t * contains 256 entries, corresponsding to\n\t * the first byte of the hash. Each entry\n\t * is a 4 byte big endian integer, containing\n\t * the total number of entries with a leading\n\t * byte <= the table index, allowing us to\n\t * rapidly do a binary search on them.\n\t */\n\tif (h.h[0] == 0){\n\t\tlo = 0;\n\t\thi = GETBE32(idx + o);\n\t} else {\n\t\to += h.h[0]*4 - 4;\n\t\tlo = GETBE32(idx + o);\n\t\thi = GETBE32(idx + o + 4);\n\t}\n\tif(hi == lo)\n\t\tgoto notfound;\n\tnent=GETBE32(idx + 8 + 255*4);\n\n\t/*\n\t * Now that we know the range of hashes that the\n\t * entry may exist in, search them\n\t */\n\tr = -1;\n\thidx = -1;\n\to = 8 + 256*4;\n\twhile(lo < hi){\n\t\thidx = (hi + lo)/2;\n\t\ts = idx + o + hidx*sizeof(h.h);\n\t\tr = memcmp(h.h, s, sizeof(h.h));\n\t\tif(r < 0)\n\t\t\thi = hidx;\n\t\telse if(r > 0)\n\t\t\tlo = hidx + 1;\n\t\telse\n\t\t\tbreak;\n\t}\n\tif(r != 0)\n\t\tgoto notfound;\n\n\t/*\n\t * We found the entry. If it's 32 bits, then we\n\t * can just return the oset, otherwise the 32\n\t * bit entry contains the oset to the 64 bit\n\t * entry.\n\t */\n\too = 8;\t\t\t/* Header */\n\too += 256*4;\t\t/* Fanout table */\n\too += Hashsz*nent;\t/* Hashes */\n\too += 4*nent;\t\t/* Checksums */\n\too += 4*hidx;\t\t/* Offset offset */\n\tif(oo < 0 || oo + 4 > nidx)\n\t\tgoto err;\n\ti = GETBE32(idx + oo);\n\to = i & 0xffffffffULL;\n\t/*\n\t * Large offsets (i.e. 64-bit) are encoded as an index\n\t * into the next table with the MSB bit set.\n\t */\n\tif(o & (1ull << 31)){\n\t\to &= 0x7fffffffULL;\n\t\too = 8;\t\t\t\t/* Header */\n\t\too += 256*4;\t\t\t/* Fanout table */\n\t\too += Hashsz*nent;\t\t/* Hashes */\n\t\too += 4*nent;\t\t\t/* Checksums */\n\t\too += 4*nent;\t\t\t/* 32-bit Offsets */\n\t\too += 8*o;\t\t\t/* 64-bit Offset offset */\n\t\tif(oo < 0 || oo + 8 >= nidx)\n\t\t\tgoto err;\n\t\to = GETBE64(idx + oo);\n\t}\n\treturn o;\n\nerr:\n\twerrstr(\"out of bounds read\");\n\treturn -1;\nnotfound:\n\twerrstr(\"not present\");\n\treturn -1;\t\t\n}\n\n/*\n * Scans for non-empty word, copying it into buf.\n * Strips off word, leading, and trailing space\n * from input.\n * \n * Returns -1 on empty string or error, leaving\n * input unmodified.\n */\nstatic int\nscanword(char **str, int *nstr, char *buf, int nbuf)\n{\n\tchar *p;\n\tint n, r;\n\n\tr = -1;\n\tp = *str;\n\tn = *nstr;\n\twhile(n && isblank(*p)){\n\t\tn--;\n\t\tp++;\n\t}\n\n\tfor(; n && *p && !isspace(*p); p++, n--){\n\t\tr = 0;\n\t\t*buf++ = *p;\n\t\tnbuf--;\n\t\tif(nbuf == 0)\n\t\t\treturn -1;\n\t}\n\twhile(n && isblank(*p)){\n\t\tn--;\n\t\tp++;\n\t}\n\t*buf = 0;\n\t*str = p;\n\t*nstr = n;\n\treturn r;\n}\n\nstatic void\nnextline(char **str, int *nstr)\n{\n\tchar *s;\n\n\tif((s = strchr(*str, '\\n')) != nil){\n\t\t*nstr -= s - *str + 1;\n\t\t*str = s + 1;\n\t}\n}\n\nstatic int\nparseauthor(char **str, int *nstr, char **name, vlong *time)\n{\n\tchar buf[128];\n\tResub m[4];\n\tvlong tz;\n\tchar *p;\n\tint n, nm;\n\n\tif((p = strchr(*str, '\\n')) == nil)\n\t\tsysfatal(\"malformed author line\");\n\tn = p - *str;\n\tif(n >= sizeof(buf))\n\t\tsysfatal(\"overlong author line\");\n\tmemset(m, 0, sizeof(m));\n\tsnprint(buf, n + 1, *str);\n\t*str = p;\n\t*nstr -= n;\n\t\n\tif(!regexec(authorpat, buf, m, nelem(m)))\n\t\tsysfatal(\"invalid author line %s\", buf);\n\tnm = m[1].ep - m[1].sp;\n\t*name = emalloc(nm + 1);\n\tmemcpy(*name, m[1].sp, nm);\n\tbuf[nm] = 0;\n\t\n\tnm = m[3].ep - m[3].sp;\n\tmemcpy(buf, m[3].sp, nm);\n\tbuf[nm] = 0;\n\ttz = atoll(buf);\n\n\tnm = m[2].ep - m[2].sp;\n\tmemcpy(buf, m[2].sp, nm);\n\tbuf[nm] = 0;\n\t*time = atoll(buf) + 3600*(tz/100) + 60*(tz%100);\n\n\treturn 0;\n}\n\nstatic void\nparsecommit(Object *o)\n{\n\tchar *p, *t, buf[128];\n\tint np;\n\n\tp = o->data;\n\tnp = o->size;\n\to->commit = emalloc(sizeof(Cinfo));\n\twhile(1){\n\t\tif(scanword(&p, &np, buf, sizeof(buf)) == -1)\n\t\t\tbreak;\n\t\tif(strcmp(buf, \"tree\") == 0){\n\t\t\tif(scanword(&p, &np, buf, sizeof(buf)) == -1)\n\t\t\t\tsysfatal(\"invalid commit: tree missing\");\n\t\t\tif(hparse(&o->commit->tree, buf) == -1)\n\t\t\t\tsysfatal(\"invalid commit: garbled tree\");\n\t\t}else if(strcmp(buf, \"parent\") == 0){\n\t\t\tif(scanword(&p, &np, buf, sizeof(buf)) == -1)\n\t\t\t\tsysfatal(\"invalid commit: missing parent\");\n\t\t\to->commit->parent = realloc(o->commit->parent, ++o->commit->nparent * sizeof(Hash));\n\t\t\tif(!o->commit->parent)\n\t\t\t\tsysfatal(\"unable to malloc: %r\");\n\t\t\tif(hparse(&o->commit->parent[o->commit->nparent - 1], buf) == -1)\n\t\t\t\tsysfatal(\"invalid commit: garbled parent\");\n\t\t}else if(strcmp(buf, \"author\") == 0){\n\t\t\tparseauthor(&p, &np, &o->commit->author, &o->commit->mtime);\n\t\t}else if(strcmp(buf, \"committer\") == 0){\n\t\t\tparseauthor(&p, &np, &o->commit->committer, &o->commit->ctime);\n\t\t}else if(strcmp(buf, \"gpgsig\") == 0){\n\t\t\t/* just drop it */\n\t\t\tif((t = strstr(p, \"-----END PGP SIGNATURE-----\")) == nil)\n\t\t\tif((t = strstr(p, \"-----END SSH SIGNATURE-----\")) == nil)\n\t\t\tif((t = strstr(p, \"-----END SIGNED MESSAGE-----\")) == nil)\n\t\t\t\tsysfatal(\"malformed gpg signature\");\n\t\t\tnp -= t - p;\n\t\t\tp = t;\n\t\t}\n\t\tnextline(&p, &np);\n\t}\n\twhile (np && isspace(*p)) {\n\t\tp++;\n\t\tnp--;\n\t}\n\to->commit->msg = p;\n\to->commit->nmsg = np;\n}\n\nstatic void\nparsetree(Object *o)\n{\n\tint m, a, entsz, nent;\n\tDirent *t, *ent;\n\tchar *p, *ep;\n\n\tp = o->data;\n\tep = p + o->size;\n\n\tnent = 0;\n\tentsz = 16;\n\tent = eamalloc(entsz, sizeof(Dirent));\t\n\to->tree = emalloc(sizeof(Tinfo));\n\twhile(p != ep){\n\t\tif(nent == entsz){\n\t\t\tentsz *= 2;\n\t\t\tent = earealloc(ent, entsz, sizeof(Dirent));\t\n\t\t}\n\t\tt = &ent[nent++];\n\t\tm = strtol(p, &p, 8);\n\t\tif(*p != ' ')\n\t\t\tsysfatal(\"malformed tree %H: *p=(%d) %c\\n\", o->hash, *p, *p);\n\t\tp++;\n\t\t/*\n\t\t * only the stored permissions for the user\n\t\t * are relevant; git fills group and world\n\t\t * bits with whatever -- so to serve with\n\t\t * useful permissions, replicate the mode\n\t\t * of the git repo dir.\n\t\t */\n\t\ta = (m & 0777)>>6;\n\t\tt->mode = ((a<<6)|(a<<3)|a) & gitdirmode;\n\t\tt->ismod = 0;\n\t\tt->islink = 0;\n\t\tif(m == 0160000){\n\t\t\tt->mode |= DMDIR;\n\t\t\tt->ismod = 1;\n\t\t}else if(m == 0120000){\n\t\t\tt->mode = 0;\n\t\t\tt->islink = 1;\n\t\t}\n\t\tif(m & 0040000)\n\t\t\tt->mode |= DMDIR;\n\t\tt->name = p;\n\t\tp = memchr(p, 0, ep - p);\n\t\tif(*p++ != 0 ||  ep - p < sizeof(t->h.h))\n\t\t\tsysfatal(\"malformed tree %H, remaining %d (%s)\", o->hash, (int)(ep - p), p);\n\t\tmemcpy(t->h.h, p, sizeof(t->h.h));\n\t\tp += sizeof(t->h.h);\n\t}\n\to->tree->ent = ent;\n\to->tree->nent = nent;\n}\n\nstatic void\nparsetag(Object *)\n{\n}\n\nvoid\nparseobject(Object *o)\n{\n\tif(o->flag & Cparsed)\n\t\treturn;\n\tswitch(o->type){\n\tcase GTree:\tparsetree(o);\tbreak;\n\tcase GCommit:\tparsecommit(o);\tbreak;\n\tcase GTag:\tparsetag(o);\tbreak;\n\tdefault:\tbreak;\n\t}\n\to->flag |= Cparsed;\n}\n\nstatic Object*\nreadidxobject(Biobuf *idx, Hash h, int flag)\n{\n\tchar path[Pathmax], hbuf[41];\n\tObject *obj, *new;\n\tint i, r, retried;\n\tBiobuf *f;\n\tvlong o;\n\n\tif((obj = osfind(&objcache, h)) != nil){\n\t\tif(flag & Cidx){\n\t\t\t/*\n\t\t\t * If we're indexing, we need to be careful\n\t\t\t * to only return objects within this pack,\n\t\t\t * so if the objects exist outside the pack,\n\t\t\t * we don't index the wrong copy.\n\t\t\t */\n\t\t\tif(!(obj->flag & Cidx))\n\t\t\t\treturn nil;\n\t\t\tif(obj->flag & Cloaded)\n\t\t\t\treturn obj;\n\t\t\to = Boffset(idx);\n\t\t\tif(Bseek(idx, obj->off, 0) == -1)\n\t\t\t\treturn nil;\n\t\t\tif(readpacked(idx, obj, flag) == -1)\n\t\t\t\treturn nil;\n\t\t\tif(Bseek(idx, o, 0) == -1)\n\t\t\t\tsysfatal(\"could not restore offset\");\n\t\t\tcache(obj);\n\t\t\treturn obj;\n\t\t}\n\t\tif(obj->flag & Cloaded)\n\t\t\treturn obj;\n\t}\n\tif(flag & Cthin)\n\t\tflag &= ~Cidx;\n\tif(flag & Cidx)\n\t\treturn nil;\n\tnew = nil;\n\tif(obj == nil){\n\t\tnew = emalloc(sizeof(Object));\n\t\tnew->id = objcache.nobj + 1;\n\t\tnew->hash = h;\n\t\tobj = new;\n\t}\n\n\to = -1;\n\tretried = 0;\nretry:\n\tfor(i = 0; i < npackf; i++){\n\t\to = searchindex(packf[i].idx, packf[i].nidx, h);\n\t\tif(o != -1){\n\t\t\tif((f = openpack(&packf[i])) == nil)\n\t\t\t\tgoto error;\n\t\t\tif((r = Bseek(f, o, 0)) != -1)\n\t\t\t\tr = readpacked(f, obj, flag);\n\t\t\tclosepack(&packf[i]);\n\t\t\tif(r == -1)\n\t\t\t\tgoto error;\n\t\t\tparseobject(obj);\n\t\t\tcache(obj);\n\t\t\treturn obj;\n\t\t}\n\t}\n\n\tsnprint(hbuf, sizeof(hbuf), \"%H\", h);\n\tsnprint(path, sizeof(path), \".git/objects/%c%c/%s\", hbuf[0], hbuf[1], hbuf + 2);\n\tif((f = Bopen(path, OREAD)) != nil){\n\t\tif(readloose(f, obj, flag) == -1)\n\t\t\tgoto errorf;\n\t\tBterm(f);\n\t\tparseobject(obj);\n\t\tcache(obj);\n\t\treturn obj;\n\t}\n\n\tif(o == -1){\n\t\tif(retried)\n\t\t\tgoto error;\n\t\tretried = 1;\n\t\trefreshpacks();\n\t\tgoto retry;\n\t}\nerrorf:\n\tBterm(f);\nerror:\n\tfree(new);\n\treturn nil;\n}\n\n/*\n * Loads and returns a cached object.\n */\nObject*\nreadobject(Hash h)\n{\n\tObject *o;\n\tDir *d;\n\n\tif(gitdirmode == -1){\n\t\tif((d = dirstat(\".git\")) == nil)\n\t\t\tsysfatal(\"stat .git: %r\");\n\t\tgitdirmode = d->mode & 0777;\n\t\tfree(d);\n\t}\n\tif((o = readidxobject(nil, h, 0)) == nil)\n\t\treturn nil;\n\tparseobject(o);\n\tref(o);\n\treturn o;\n}\n\n/*\n * Creates and returns a cached, cleared object\n * that will get loaded some other time. Useful\n * for performance if need to mark that a blob\n * exists, but we don't care about its contents.\n *\n * The refcount of the returned object is 0, so\n * it doesn't need to be unrefed.\n */\nObject*\nclearedobject(Hash h, int type)\n{\n\tObject *o;\n\n\tif((o = osfind(&objcache, h)) != nil)\n\t\treturn o;\n\n\to = emalloc(sizeof(Object));\n\to->hash = h;\n\to->type = type;\n\tosadd(&objcache, o);\n\to->id = objcache.nobj;\n\to->flag |= Cexist;\n\treturn o;\n}\n\nint\nobjcmp(void *pa, void *pb)\n{\n\tObject *a, *b;\n\n\ta = *(Object**)pa;\n\tb = *(Object**)pb;\n\treturn memcmp(a->hash.h, b->hash.h, sizeof(a->hash.h));\n}\n\nstatic int\nhwrite(Biobuf *b, void *buf, int len, DigestState **st)\n{\n\t*st = sha1(buf, len, nil, *st);\n\treturn Bwrite(b, buf, len);\n}\n\nstatic u32int\nobjectcrc(Biobuf *f, Object *o)\n{\n\tchar buf[8096];\n\tint n, r;\n\n\to->crc = 0;\n\tBseek(f, o->off, 0);\n\tfor(n = o->len; n > 0; n -= r){\n\t\tr = Bread(f, buf, n > sizeof(buf) ? sizeof(buf) : n);\n\t\tif(r == -1)\n\t\t\treturn -1;\n\t\tif(r == 0)\n\t\t\treturn 0;\n\t\to->crc = crc32(o->crc, buf, r);\n\t}\n\treturn 0;\n}\n\nint\nindexpack(char *pack, char *idx, Hash ph)\n{\n\tchar hdr[4*3], buf[8];\n\tint nobj, npct, nvalid, nbig;\n\tint i, n, pct;\n\tObject *o, **obj;\n\tDigestState *st;\n\tchar *valid;\n\tBiobuf *f;\n\tHash h;\n\tint c;\n\n\tif((f = Bopen(pack, OREAD)) == nil)\n\t\treturn -1;\n\tif(Bread(f, hdr, sizeof(hdr)) != sizeof(hdr)){\n\t\twerrstr(\"short read on header\");\n\t\treturn -1;\n\t}\n\tif(memcmp(hdr, \"PACK\\0\\0\\0\\2\", 8) != 0){\n\t\twerrstr(\"invalid header\");\n\t\treturn -1;\n\t}\n\n\tpct = 0;\n\tnpct = 0;\n\tnvalid = 0;\n\tnobj = GETBE32(hdr + 8);\n\tobj = eamalloc(nobj, sizeof(Object*));\n\tvalid = eamalloc(nobj, sizeof(char));\n\tif(interactive)\n\t\tfprint(2, \"indexing %d objects:   0%%\", nobj);\n\twhile(nvalid != nobj){\n\t\tn = 0;\n\t\tfor(i = 0; i < nobj; i++){\n\t\t\tif(valid[i]){\n\t\t\t\tn++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tpct = showprogress((npct*100)/nobj, pct);\n\t\t\tif(obj[i] == nil){\n\t\t\t\to = emalloc(sizeof(Object));\n\t\t\t\to->off = Boffset(f);\n\t\t\t\tobj[i] = o;\n\t\t\t}\n\t\t\to = obj[i];\n\t\t\t/*\n\t\t\t * We can seek around when packing delta chains.\n\t\t\t * Be extra careful while we don't know where all\n\t\t\t * the objects start.\n\t\t\t */\n\t\t\tBseek(f, o->off, 0);\n\t\t\tif(readpacked(f, o, Cidx) == -1)\n\t\t\t\tcontinue;\n\t\t\tsha1((uchar*)o->all, o->size + strlen(o->all) + 1, o->hash.h, nil);\n\t\t\tvalid[i] = 1;\n\t\t\tcache(o);\n\t\t\tnpct++;\n\t\t\tn++;\n\t\t\tif(objectcrc(f, o) == -1)\n\t\t\t\treturn -1;\n\t\t}\n\t\tif(n == nvalid)\n\t\t\tsysfatal(\"fix point reached too early: %d/%d: %r\", nvalid, nobj);\n\t\tnvalid = n;\n\t}\n\tif(interactive)\n\t\tfprint(2, \"\\b\\b\\b\\b100%%\\n\");\n\tBterm(f);\n\n\tst = nil;\n\tqsort(obj, nobj, sizeof(Object*), objcmp);\n\tif((f = Bopen(idx, OWRITE)) == nil)\n\t\treturn -1;\n\tif(hwrite(f, \"\\xfftOc\\x00\\x00\\x00\\x02\", 8, &st) != 8)\n\t\tgoto error;\n\t/* fanout table */\n\tc = 0;\n\tfor(i = 0; i < 256; i++){\n\t\twhile(c < nobj && (obj[c]->hash.h[0] & 0xff) <= i)\n\t\t\tc++;\n\t\tPUTBE32(buf, c);\n\t\tif(hwrite(f, buf, 4, &st) == -1)\n\t\t\tgoto error;\n\t}\n\tfor(i = 0; i < nobj; i++){\n\t\to = obj[i];\n\t\tif(hwrite(f, o->hash.h, sizeof(o->hash.h), &st) == -1)\n\t\t\tgoto error;\n\t}\n\n\tfor(i = 0; i < nobj; i++){\n\t\tPUTBE32(buf, obj[i]->crc);\n\t\tif(hwrite(f, buf, 4, &st) == -1)\n\t\t\tgoto error;\n\t}\n\n\tnbig = 0;\n\tfor(i = 0; i < nobj; i++){\n\t\tif(obj[i]->off < (1ull<<31))\n\t\t\tPUTBE32(buf, obj[i]->off);\n\t\telse{\n\t\t\tPUTBE32(buf, (1ull << 31) | nbig);\n\t\t\tnbig++;\n\t\t}\n\t\tif(hwrite(f, buf, 4, &st) == -1)\n\t\t\tgoto error;\n\t}\n\tfor(i = 0; i < nobj; i++){\n\t\tif(obj[i]->off >= (1ull<<31)){\n\t\t\tPUTBE64(buf, obj[i]->off);\n\t\t\tif(hwrite(f, buf, 8, &st) == -1)\n\t\t\t\tgoto error;\n\t\t}\n\t}\n\tif(hwrite(f, ph.h, sizeof(ph.h), &st) == -1)\n\t\tgoto error;\n\tsha1(nil, 0, h.h, st);\n\tBwrite(f, h.h, sizeof(h.h));\n\n\tfree(obj);\n\tfree(valid);\n\tBterm(f);\n\treturn 0;\n\nerror:\n\tfree(obj);\n\tfree(valid);\n\tBterm(f);\n\treturn -1;\n}\n\nstatic int\ndeltaordercmp(void *pa, void *pb)\n{\n\tMeta *a, *b;\n\tvlong cmp;\n\n\ta = *(Meta**)pa;\n\tb = *(Meta**)pb;\n\tif(a->obj->type != b->obj->type)\n\t\treturn a->obj->type - b->obj->type;\n\tcmp = (b->path - a->path);\n\tif(cmp != 0)\n\t\treturn (cmp < 0) ? -1 : 1;\n\tcmp = a->mtime - b->mtime;\n\tif(cmp != 0)\n\t\treturn (cmp < 0) ? -1 : 1;\n\treturn memcmp(a->obj->hash.h, b->obj->hash.h, sizeof(a->obj->hash.h));\n}\n\nstatic int\nwriteordercmp(void *pa, void *pb)\n{\n\tMeta *a, *b, *ahd, *bhd;\n\n\ta = *(Meta**)pa;\n\tb = *(Meta**)pb;\n\tahd = (a->head == nil) ? a : a->head;\n\tbhd = (b->head == nil) ? b : b->head;\n\tif(ahd->mtime != bhd->mtime)\n\t\treturn bhd->mtime - ahd->mtime;\n\tif(ahd != bhd)\n\t\treturn (uintptr)bhd - (uintptr)ahd;\n\tif(a->nchain != b->nchain)\n\t\treturn a->nchain - b->nchain;\n\treturn a->mtime - b->mtime;\n}\n\nstatic void\naddmeta(Metavec *v, Objset *has, Object *o, vlong pathid, vlong mtime)\n{\n\tMeta *m;\n\n\tif(oshas(has, o->hash))\n\t\treturn;\n\tosadd(has, o);\n\tif(v == nil)\n\t\treturn;\n\tm = emalloc(sizeof(Meta));\n\tm->obj = o;\n\tm->path = pathid;\n\tm->mtime = mtime;\n\n\tif(v->nmeta == v->metasz){\n\t\tv->metasz = 2*v->metasz;\n\t\tv->meta = earealloc(v->meta, v->metasz, sizeof(Meta*));\n\t}\n\tv->meta[v->nmeta++] = m;\n}\n\nstatic void\nfreemeta(Meta *m)\n{\n\tfree(m->delta);\n\tfree(m);\n}\n\nstatic int\nloadtree(Metavec *v, Objset *has, Hash tree, char *dpath, vlong mtime)\n{\n\tObject *t, *o;\n\tDirent *e;\n\tvlong dh, eh;\n\tint i, k, r;\n\tchar *p;\n\n\tif(oshas(has, tree))\n\t\treturn 0;\n\tif((t = readobject(tree)) == nil)\n\t\treturn -1;\n\tif(t->type != GTree){\n\t\tfprint(2, \"load: %H: not tree\\n\", t->hash);\n\t\tunref(t);\n\t\treturn 0;\n\t}\n\tdh = murmurhash2(dpath, strlen(dpath));\n\taddmeta(v, has, t, dh, mtime);\n\tfor(i = 0; i < t->tree->nent; i++){\n\t\te = &t->tree->ent[i];\n\t\tif(oshas(has, e->h))\n\t\t\tcontinue;\n\t\tif(e->ismod)\n\t\t\tcontinue;\n\t\tk = (e->mode & DMDIR) ? GTree : GBlob;\n\t\to = clearedobject(e->h, k);\n\t\tif(k == GTree){\n\t\t\tp = smprint(\"%s/%s\", dpath, e->name);\n\t\t\tr = loadtree(v, has, e->h, p, mtime);\n\t\t\tfree(p);\n\t\t\tif(r == -1)\n\t\t\t\treturn -1;\n\t\t}else{\n\t\t\teh = murmurhash2(e->name, strlen(e->name));\n\t\t\taddmeta(v, has, o, dh^eh, mtime);\n\t\t}\n\t}\n\tunref(t);\n\treturn 0;\n}\n\nstatic int\nloadcommit(Metavec *v, Objset *has, Hash h)\n{\n\tObject *c;\n\tint r;\n\n\tif(osfind(has, h))\n\t\treturn 0;\n\tif((c = readobject(h)) == nil)\n\t\treturn -1;\n\tif(c->type != GCommit){\n\t\tfprint(2, \"load: %H: not commit\\n\", c->hash);\n\t\tunref(c);\n\t\treturn 0;\n\t}\n\taddmeta(v, has, c, 0, c->commit->ctime);\n\tr = loadtree(v, has, c->commit->tree, \"\", c->commit->ctime);\n\tunref(c);\n\treturn r;\n}\n\nstatic int\nreadmeta(Hash *theirs, int ntheirs, Hash *ours, int nours, Meta ***m)\n{\n\tObject **obj;\n\tObjset has;\n\tint i, nobj;\n\tMetavec v;\n\n\t*m = nil;\n\tosinit(&has);\n\tv.nmeta = 0;\n\tv.metasz = 64;\n\tv.meta = eamalloc(v.metasz, sizeof(Meta*));\n\tif(findtwixt(theirs, ntheirs, ours, nours, &obj, &nobj) == -1)\n\t\tsysfatal(\"load twixt: %r\");\n\n\tif(nobj == 0)\n\t\treturn 0;\n\tfor(i = 0; i < nours; i++)\n\t\tif(!hasheq(&ours[i], &Zhash))\n\t\t\tif(loadcommit(nil, &has, ours[i]) == -1)\n\t\t\t\tgoto out;\n\tfor(i = 0; i < nobj; i++)\n\t\tif(loadcommit(&v, &has, obj[i]->hash) == -1)\n\t\t\tgoto out;\n\tosclear(&has);\n\t*m = v.meta;\n\treturn v.nmeta;\nout:\n\tosclear(&has);\n\tfree(v.meta);\n\treturn -1;\n}\n\nstatic int\ndeltasz(Delta *d, int nd)\n{\n\tint i, sz;\n\tsz = 32;\n\tfor(i = 0; i < nd; i++)\n\t\tsz += d[i].cpy ? 7 : d[i].len + 1;\n\treturn sz;\n}\n\nstatic void\npickdeltas(Meta **meta, int nmeta)\n{\n\tMeta *m, *p;\n\tObject *o;\n\tDelta *d;\n\tint i, j, nd, sz, pct, best;\n\n\tpct = 0;\n\tdprint(1, \"picking deltas\\n\");\n\tif(interactive)\n\t\tfprint(2, \"deltifying %d objects:   0%%\", nmeta);\n\tqsort(meta, nmeta, sizeof(Meta*), deltaordercmp);\n\tfor(i = 0; i < nmeta; i++){\n\t\tm = meta[i];\n\t\tpct = showprogress((i*100) / nmeta, pct);\n\t\tm->delta = nil;\n\t\tm->ndelta = 0;\n\t\tif(m->obj->type == GCommit || m->obj->type == GTag)\n\t\t\tcontinue;\n\t\tif((o = readobject(m->obj->hash)) == nil)\n\t\t\tsysfatal(\"readobject %H: %r\", m->obj->hash);\n\t\tdtinit(&m->dtab, o);\n\t\tif(i >= 11)\n\t\t\tdtclear(&meta[i-11]->dtab);\n\t\tbest = o->size;\n\t\tfor(j = max(0, i - 10); j < i; j++){\n\t\t\tp = meta[j];\n\t\t\t/* long chains make unpacking slow */\n\t\t\tif(p->nchain >= 128 || p->obj->type != o->type)\n\t\t\t\tcontinue;\n\t\t\td = deltify(o, &p->dtab, &nd);\n\t\t\tsz = deltasz(d, nd);\n\t\t\tif(sz + 32 < best){\n\t\t\t\t/*\n\t\t\t\t * if we already picked a best delta,\n\t\t\t\t * replace it.\n\t\t\t\t */\n\t\t\t\tfree(m->delta);\n\t\t\t\tbest = sz;\n\t\t\t\tm->delta = d;\n\t\t\t\tm->ndelta = nd;\n\t\t\t\tm->nchain = p->nchain + 1;\n\t\t\t\tm->prev = p;\n\t\t\t\tm->head = p->head;\n\t\t\t\tif(m->head == nil)\n\t\t\t\t\tm->head = p;\n\t\t\t}else\n\t\t\t\tfree(d);\n\t\t}\n\t\tunref(o);\n\t}\n\tfor(i = max(0, nmeta - 10); i < nmeta; i++)\n\t\tdtclear(&meta[i]->dtab);\n\tif(interactive)\n\t\tfprint(2, \"\\b\\b\\b\\b100%%\\n\");\n}\n\nstatic int\ncompread(void *p, void *dst, int n)\n{\n\tBuf *b;\n\n\tb = p;\n\tif(n > b->sz - b->off)\n\t\tn = b->sz - b->off;\n\tmemcpy(dst, b->data + b->off, n);\n\tb->off += n;\n\treturn n;\n}\n\nstatic int\ncompwrite(void *p, void *buf, int n)\n{\n\treturn hwrite(((Compout *)p)->bfd, buf, n, &((Compout*)p)->st);\n}\n\nstatic int\nhcompress(Biobuf *bfd, void *buf, int sz, DigestState **st)\n{\n\tint r;\n\tBuf b ={\n\t\t.off=0,\n\t\t.data=buf,\n\t\t.sz=sz,\n\t};\n\tCompout o = {\n\t\t.bfd = bfd,\n\t\t.st = *st,\n\t};\n\n\tr = deflatezlib(&o, compwrite, &b, compread, 6, 0);\n\t*st = o.st;\n\treturn r;\n}\n\nstatic void\nappend(char **p, int *len, int *sz, void *seg, int nseg)\n{\n\tif(*len + nseg >= *sz){\n\t\twhile(*len + nseg >= *sz)\n\t\t\t*sz += *sz/2;\n\t\t*p = erealloc(*p, *sz);\n\t}\n\tmemcpy(*p + *len, seg, nseg);\n\t*len += nseg;\n}\n\nstatic int\nencodedelta(Meta *m, Object *o, Object *b, void **pp)\n{\n\tchar *p, *bp, buf[16];\n\tint len, sz, n, i, j;\n\tDelta *d;\n\n\tsz = 128;\n\tlen = 0;\n\tp = emalloc(sz);\n\n\t/* base object size */\n\tbuf[0] = b->size & 0x7f;\n\tn = b->size >> 7;\n\tfor(i = 1; n > 0; i++){\n\t\tbuf[i - 1] |= 0x80;\n\t\tbuf[i] = n & 0x7f;\n\t\tn >>= 7;\n\t}\n\tappend(&p, &len, &sz, buf, i);\n\n\t/* target object size */\n\tbuf[0] = o->size & 0x7f;\n\tn = o->size >> 7;\n\tfor(i = 1; n > 0; i++){\n\t\tbuf[i - 1] |= 0x80;\n\t\tbuf[i] = n & 0x7f;\n\t\tn >>= 7;\n\t}\n\tappend(&p, &len, &sz, buf, i);\n\tfor(j = 0; j < m->ndelta; j++){\n\t\td = &m->delta[j];\n\t\tif(d->cpy){\n\t\t\tn = d->off;\n\t\t\tbp = buf + 1;\n\t\t\tbuf[0] = 0x81;\n\t\t\tbuf[1] = 0x00;\n\t\t\tfor(i = 0; i < sizeof(buf); i++) {\n\t\t\t\tbuf[0] |= 1<<i;\n\t\t\t\t*bp++ = n & 0xff;\n\t\t\t\tn >>= 8;\n\t\t\t\tif(n == 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tn = d->len;\n\t\t\tif(n != 0x10000) {\n\t\t\t\tbuf[0] |= 0x1<<4;\n\t\t\t\tfor(i = 0; i < sizeof(buf)-4 && n > 0; i++){\n\t\t\t\t\tbuf[0] |= 1<<(i + 4);\n\t\t\t\t\t*bp++ = n & 0xff;\n\t\t\t\t\tn >>= 8;\n\t\t\t\t}\n\t\t\t}\n\t\t\tappend(&p, &len, &sz, buf, bp - buf);\n\t\t}else{\n\t\t\tn = 0;\n\t\t\twhile(n != d->len){\n\t\t\t\tbuf[0] = (d->len - n < 127) ? d->len - n : 127;\n\t\t\t\tappend(&p, &len, &sz, buf, 1);\n\t\t\t\tappend(&p, &len, &sz, o->data + d->off + n, buf[0]);\n\t\t\t\tn += buf[0];\n\t\t\t}\n\t\t}\n\t}\n\t*pp = p;\n\treturn len;\n}\n\nstatic int\npackhdr(char *hdr, int ty, int len)\n{\n\tint i;\n\n\thdr[0] = ty << 4;\n\thdr[0] |= len & 0xf;\n\tlen >>= 4;\n\tfor(i = 1; len != 0; i++){\n\t\thdr[i-1] |= 0x80;\n\t\thdr[i] = len & 0x7f;\n\t\tlen >>= 7;\n\t}\n\treturn i;\n}\n\nstatic int\npackoff(char *hdr, vlong off)\n{\n\tint i, j;\n\tchar rbuf[8];\n\n\trbuf[0] = off & 0x7f;\n\tfor(i = 1; (off >>= 7) != 0; i++)\n\t\trbuf[i] = (--off & 0x7f)|0x80;\n\n\tj = 0;\n\twhile(i > 0)\n\t\thdr[j++] = rbuf[--i];\n\treturn j;\n}\n\nstatic int\ngenpack(int fd, Meta **meta, int nmeta, Hash *h, int odelta)\n{\n\tint i, nh, nd, res, pct, ret;\n\tDigestState *st;\n\tBiobuf *bfd;\n\tMeta *m;\n\tObject *o, *po, *b;\n\tchar *p, buf[32];\n\n\tst = nil;\n\tret = -1;\n\tpct = 0;\n\tdprint(1, \"generating pack\\n\");\n\tif((fd = dup(fd, -1)) == -1)\n\t\treturn -1;\n\tif((bfd = Bfdopen(fd, OWRITE)) == nil)\n\t\treturn -1;\n\tif(hwrite(bfd, \"PACK\", 4, &st) == -1)\n\t\treturn -1;\n\tPUTBE32(buf, 2);\n\tif(hwrite(bfd, buf, 4, &st) == -1)\n\t\treturn -1;\n\tPUTBE32(buf, nmeta);\n\tif(hwrite(bfd, buf, 4, &st) == -1)\n\t\treturn -1;\n\tqsort(meta, nmeta, sizeof(Meta*), writeordercmp);\n\tif(interactive)\n\t\tfprint(2, \"writing %d objects:   0%%\", nmeta);\n\tfor(i = 0; i < nmeta; i++){\n\t\tpct = showprogress((i*100)/nmeta, pct);\n\t\tm = meta[i];\n\t\tm->off = Boffset(bfd);\n\t\tif(m->off == -1)\n\t\t\tgoto error;\n\t\tif((o = readobject(m->obj->hash)) == nil)\n\t\t\treturn -1;\n\t\tif(m->delta == nil){\n\t\t\tnh = packhdr(buf, o->type, o->size);\n\t\t\tif(hwrite(bfd, buf, nh, &st) == -1)\n\t\t\t\tgoto error;\n\t\t\tif(hcompress(bfd, o->data, o->size, &st) == -1)\n\t\t\t\tgoto error;\n\t\t}else{\n\t\t\tif((b = readobject(m->prev->obj->hash)) == nil)\n\t\t\t\tgoto error;\n\t\t\tnd = encodedelta(m, o, b, &p);\n\t\t\tunref(b);\n\t\t\tif(odelta && m->prev->off != 0){\n\t\t\t\tnh = 0;\n\t\t\t\tnh += packhdr(buf, GOdelta, nd);\n\t\t\t\tnh += packoff(buf+nh, m->off - m->prev->off);\n\t\t\t\tif(hwrite(bfd, buf, nh, &st) == -1)\n\t\t\t\t\tgoto error;\n\t\t\t}else{\n\t\t\t\tnh = packhdr(buf, GRdelta, nd);\n\t\t\t\tpo = m->prev->obj;\n\t\t\t\tif(hwrite(bfd, buf, nh, &st) == -1)\n\t\t\t\t\tgoto error;\n\t\t\t\tif(hwrite(bfd, po->hash.h, sizeof(po->hash.h), &st) == -1)\n\t\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tres = hcompress(bfd, p, nd, &st);\n\t\t\tfree(p);\n\t\t\tif(res == -1)\n\t\t\t\tgoto error;\n\t\t}\n\t\tunref(o);\n\t}\n\tif(interactive)\n\t\tfprint(2, \"\\b\\b\\b\\b100%%\\n\");\n\tsha1(nil, 0, h->h, st);\n\tif(Bwrite(bfd, h->h, sizeof(h->h)) == -1)\n\t\tgoto error;\n\tret = 0;\nerror:\n\tif(Bterm(bfd) == -1)\n\t\treturn -1;\n\treturn ret;\n}\n\nint\nwritepack(int fd, Hash *theirs, int ntheirs, Hash *ours, int nours, Hash *h)\n{\n\tMeta **meta;\n\tint i, r, nmeta;\n\n\tif((nmeta = readmeta(theirs, ntheirs, ours, nours, &meta)) == -1)\n\t\treturn -1;\n\tpickdeltas(meta, nmeta);\n\tr = genpack(fd, meta, nmeta, h, 0);\n\tfor(i = 0; i < nmeta; i++)\n\t\tfreemeta(meta[i]);\n\tfree(meta);\n\treturn r;\n}\n", "source": "git9/pack.c", "file_type": "c"}
{"text": "#include <u.h>\n#include <libc.h>\n#include <ctype.h>\n\n#include \"git.h\"\n\nReprog *authorpat;\nHash Zhash;\n\nint chattygit;\nint interactive = 1;\n\nenum {\n\tSeed\t\t= 2928213749ULL\n};\n\nObject*\nemptydir(void)\n{\n\tstatic Object *e;\n\n\tif(e != nil)\n\t\treturn ref(e);\n\te = emalloc(sizeof(Object));\n\te->hash = Zhash;\n\te->type = GTree;\n\te->tree = emalloc(sizeof(Tinfo));\n\te->tree->ent = nil;\n\te->tree->nent = 0;\n\te->flag |= Cloaded|Cparsed;\n\te->off = -1;\n\tref(e);\n\tcache(e);\n\treturn e;\n}\n\nint\nhasheq(Hash *a, Hash *b)\n{\n\treturn memcmp(a->h, b->h, sizeof(a->h)) == 0;\n}\n\nstatic int\ncharval(int c, int *err)\n{\n\tif(c >= '0' && c <= '9')\n\t\treturn c - '0';\n\tif(c >= 'a' && c <= 'f')\n\t\treturn c - 'a' + 10;\n\tif(c >= 'A' && c <= 'F')\n\t\treturn c - 'A' + 10;\n\t*err = 1;\n\treturn -1;\n}\n\nvoid *\nemalloc(ulong n)\n{\n\tvoid *v;\n\t\n\tv = mallocz(n, 1);\n\tif(v == nil)\n\t\tsysfatal(\"malloc: %r\");\n\tsetmalloctag(v, getcallerpc(&n));\n\treturn v;\n}\n\nvoid *\neamalloc(ulong n, ulong sz)\n{\n\tuvlong na;\n\tvoid *v;\n\n\tna = (uvlong)n*(uvlong)sz;\n\tif(na >= (1ULL<<30))\n\t\tsysfatal(\"alloc: overflow\");\n\tv = mallocz(na, 1);\n\tif(v == nil)\n\t\tsysfatal(\"malloc: %r\");\n\tsetmalloctag(v, getcallerpc(&n));\n\treturn v;\n}\n\nvoid *\nerealloc(void *p, ulong n)\n{\n\tvoid *v;\n\t\n\tv = realloc(p, n);\n\tif(v == nil)\n\t\tsysfatal(\"realloc: %r\");\n\tsetmalloctag(v, getcallerpc(&p));\n\treturn v;\n}\n\nvoid *\nearealloc(void *p, ulong n, ulong sz)\n{\n\tuvlong na;\n\tvoid *v;\n\n\tna = (uvlong)n*(uvlong)sz;\n\tif(na >= (1ULL<<30))\n\t\tsysfatal(\"alloc: overflow\");\n\tv = realloc(p, na);\n\tif(v == nil)\n\t\tsysfatal(\"realloc: %r\");\n\tsetmalloctag(v, getcallerpc(&p));\n\treturn v;\n}\n\nchar*\nestrdup(char *s)\n{\n\ts = strdup(s);\n\tif(s == nil)\n\t\tsysfatal(\"strdup: %r\");\n\tsetmalloctag(s, getcallerpc(&s));\n\treturn s;\n}\n\nint\nHfmt(Fmt *fmt)\n{\n\tHash h;\n\tint i, n, l;\n\tchar c0, c1;\n\n\tl = 0;\n\th = va_arg(fmt->args, Hash);\n\tfor(i = 0; i < sizeof h.h; i++){\n\t\tn = (h.h[i] >> 4) & 0xf;\n\t\tc0 = (n >= 10) ? n-10 + 'a' : n + '0';\n\t\tn = h.h[i] & 0xf;\n\t\tc1 = (n >= 10) ? n-10 + 'a' : n + '0';\n\t\tl += fmtprint(fmt, \"%c%c\", c0, c1);\n\t}\n\treturn l;\n}\n\nint\nTfmt(Fmt *fmt)\n{\n\tint t;\n\tint l;\n\n\tt = va_arg(fmt->args, int);\n\tswitch(t){\n\tcase GNone:\tl = fmtprint(fmt, \"none\");\tbreak;\n\tcase GCommit:\tl = fmtprint(fmt, \"commit\");\tbreak;\n\tcase GTree:\tl = fmtprint(fmt, \"tree\");\tbreak;\n\tcase GBlob:\tl = fmtprint(fmt, \"blob\");\tbreak;\n\tcase GTag:\tl = fmtprint(fmt, \"tag\");\tbreak;\n\tcase GOdelta:\tl = fmtprint(fmt, \"odelta\");\tbreak;\n\tcase GRdelta:\tl = fmtprint(fmt, \"gdelta\");\tbreak;\n\tdefault:\tl = fmtprint(fmt, \"?%d?\", t);\tbreak;\n\t}\n\treturn l;\n}\n\nint\nOfmt(Fmt *fmt)\n{\n\tObject *o;\n\tint l;\n\n\to = va_arg(fmt->args, Object *);\n\tprint(\"== %H (%T) ==\\n\", o->hash, o->type);\n\tswitch(o->type){\n\tcase GTree:\n\t\tl = fmtprint(fmt, \"tree\\n\");\n\t\tbreak;\n\tcase GBlob:\n\t\tl = fmtprint(fmt, \"blob %s\\n\", o->data);\n\t\tbreak;\n\tcase GCommit:\n\t\tl = fmtprint(fmt, \"commit\\n\");\n\t\tbreak;\n\tcase GTag:\n\t\tl = fmtprint(fmt, \"tag\\n\");\n\t\tbreak;\n\tdefault:\n\t\tl = fmtprint(fmt, \"invalid: %d\\n\", o->type);\n\t\tbreak;\n\t}\n\treturn l;\n}\n\nint\nQfmt(Fmt *fmt)\n{\n\tQid q;\n\n\tq = va_arg(fmt->args, Qid);\n\tif(q.path == ~0ULL && q.vers == ~0UL && q.type == 0xff)\n\t\treturn fmtprint(fmt, \"NOQID\");\n\telse\n\t\treturn fmtprint(fmt, \"%llux.%lud.%hhx\", q.path, q.vers, q.type);\n}\n\nvoid\ngitinit(void)\n{\n\tfmtinstall('H', Hfmt);\n\tfmtinstall('T', Tfmt);\n\tfmtinstall('O', Ofmt);\n\tfmtinstall('Q', Qfmt);\n\tinflateinit();\n\tdeflateinit();\n\tauthorpat = regcomp(\"[\\t ]*(.*)[\\t ]+([0-9]+)[\\t ]*([\\\\-+]?[0-9]+)?\");\n\tosinit(&objcache);\n}\n\nint\nhparse(Hash *h, char *b)\n{\n\tint i, err;\n\n\terr = 0;\n\tfor(i = 0; i < sizeof(h->h); i++){\n\t\terr = 0;\n\t\th->h[i] = 0;\n\t\th->h[i] |= ((charval(b[2*i], &err) & 0xf) << 4);\n\t\th->h[i] |= ((charval(b[2*i+1], &err)& 0xf) << 0);\n\t\tif(err){\n\t\t\twerrstr(\"invalid hash\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint\nslurpdir(char *p, Dir **d)\n{\n\tint r, f;\n\n\tif((f = open(p, OREAD)) == -1)\n\t\treturn -1;\n\tr = dirreadall(f, d);\n\tclose(f);\n\treturn r;\n}\t\n\nint\nhassuffix(char *base, char *suf)\n{\n\tint nb, ns;\n\n\tnb = strlen(base);\n\tns = strlen(suf);\n\tif(ns <= nb && strcmp(base + (nb - ns), suf) == 0)\n\t\treturn 1;\n\treturn 0;\n}\n\nint\nswapsuffix(char *dst, int dstsz, char *base, char *oldsuf, char *suf)\n{\n\tint bl, ol, sl, l;\n\n\tbl = strlen(base);\n\tol = strlen(oldsuf);\n\tsl = strlen(suf);\n\tl = bl + sl - ol;\n\tif(l + 1 > dstsz || ol > bl)\n\t\treturn -1;\n\tmemmove(dst, base, bl - ol);\n\tmemmove(dst + bl - ol, suf, sl);\n\tdst[l] = 0;\n\treturn l;\n}\n\nchar *\nstrip(char *s)\n{\n\tchar *e;\n\n\twhile(isspace(*s))\n\t\ts++;\n\te = s + strlen(s);\n\twhile(e > s && isspace(*--e))\n\t\t*e = 0;\n\treturn s;\n}\n\nvoid\n_dprint(char *fmt, ...)\n{\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tvfprint(2, fmt, ap);\n\tva_end(ap);\n}\n\n/* Finds the directory containing the git repo. */\nint\nfindrepo(char *buf, int nbuf, int *nrel)\n{\n\tchar *p, *suff;\n\n\tsuff = \"/.git/HEAD\";\n\tif(getwd(buf, nbuf - strlen(suff) - 1) == nil)\n\t\treturn -1;\n\n\t*nrel = 0;\n\tfor(p = buf + strlen(buf); p != nil; p = strrchr(buf, '/')){\n\t\tstrcpy(p, suff);\n\t\tif(access(buf, AEXIST) == 0){\n\t\t\tp[p == buf] = '\\0';\n\t\t\treturn 0;\n\t\t}\n\t\t*nrel += 1;\n\t\t*p = '\\0';\n\t}\n\twerrstr(\"not a git repository\");\n\treturn -1;\n}\n\nint\nshowprogress(int x, int pct)\n{\n\tif(!interactive)\n\t\treturn 0;\n\tif(x > pct){\n\t\tpct = x;\n\t\tfprint(2, \"\\b\\b\\b\\b%3d%%\", pct);\n\t}\n\treturn pct;\n}\n\nvoid\nqinit(Objq *q)\n{\n\tmemset(q, 0, sizeof(Objq));\n\tq->nheap = 0;\n\tq->heapsz = 8;\n\tq->heap = eamalloc(q->heapsz, sizeof(Qelt));\n}\n\nvoid\nqclear(Objq *q)\n{\n\tfree(q->heap);\n}\n\nvoid\nqput(Objq *q, Object *o, int color)\n{\n\tQelt t;\n\tint i;\n\n\tassert(o->type == GCommit);\n\tif(q->nheap == q->heapsz){\n\t\tq->heapsz *= 2;\n\t\tq->heap = earealloc(q->heap, q->heapsz, sizeof(Qelt));\n\t}\n\tq->heap[q->nheap].o = o;\n\tq->heap[q->nheap].color = color;\n\tq->heap[q->nheap].ctime = o->commit->ctime;\n\tfor(i = q->nheap; i > 0; i = (i-1)/2){\n\t\tif(q->heap[i].ctime < q->heap[(i-1)/2].ctime)\n\t\t\tbreak;\n\t\tt = q->heap[i];\n\t\tq->heap[i] = q->heap[(i-1)/2];\n\t\tq->heap[(i-1)/2] = t;\n\t}\n\tq->nheap++;\n}\n\nint\nqpop(Objq *q, Qelt *e)\n{\n\tint i, l, r, m;\n\tQelt t;\n\n\tif(q->nheap == 0)\n\t\treturn 0;\n\t*e = q->heap[0];\n\tif(--q->nheap == 0)\n\t\treturn 1;\n\n\ti = 0;\n\tq->heap[0] = q->heap[q->nheap];\n\twhile(1){\n\t\tm = i;\n\t\tl = 2*i+1;\n\t\tr = 2*i+2;\n\t\tif(l < q->nheap && q->heap[m].ctime < q->heap[l].ctime)\n\t\t\tm = l;\n\t\tif(r < q->nheap && q->heap[m].ctime < q->heap[r].ctime)\n\t\t\tm = r;\n\t\tif(m == i)\n\t\t\tbreak;\n\t\tt = q->heap[m];\n\t\tq->heap[m] = q->heap[i];\n\t\tq->heap[i] = t;\n\t\ti = m;\n\t}\n\treturn 1;\n}\n\nu64int\nmurmurhash2(void *pp, usize n)\n{\n\tu32int m = 0x5bd1e995;\n\tu32int r = 24;\n\tu32int h, k;\n\tu32int *w, *e;\n\tuchar *p;\n\t\n\th = Seed ^ n;\n\te = pp;\n\te += (n / 4);\n\tfor (w = pp; w != e; w++) {\n\t\t/*\n\t\t * NB: this is endian dependent.\n\t\t * This is fine for use in git, since the\n\t\t * hashes computed here are only ever used\n\t\t * for in memory data structures.\n\t\t *\n\t\t * Pack files will differ when packed on\n\t\t * machines with different endianness,\n\t\t * but the results will still be correct.\n\t\t */\n\t\tk = *w;\n\t\tk *= m;\n\t\tk ^= k >> r;\n\t\tk *= m;\n\n\t\th *= m;\n\t\th ^= k;\n\t}\n\n\tp = (uchar*)w;\n\tswitch (n & 0x3) {\n\tcase 3:\th ^= p[2] << 16;\n\tcase 2:\th ^= p[1] << 8;\n\tcase 1:\th ^= p[0] << 0;\n\t\th *= m;\n\t}\n\n\th ^= h >> 13;\n\th *= m;\n\th ^= h >> 15;\n\n\treturn h;\n}\n\nQid\nparseqid(char *s)\n{\n\tchar *e;\n\tQid q;\n\n\tif(strcmp(s, \"NOQID\") == 0)\n\t\treturn (Qid){-1, -1, -1};\t\t\n\te = s;\n\tq.path = strtoull(e, &e, 16);\n\tif(*e != '.')\n\t\tsysfatal(\"corrupt qid: %s (%s)\\n\", s, e);\n\tq.vers = strtoul(e+1, &e, 10);\n\tif(*e != '.')\n\t\tsysfatal(\"corrupt qid: %s (%s)\\n\", s, e);\n\tq.type = strtoul(e+1, &e, 16);\n\tif(*e != '\\0')\n\t\tsysfatal(\"corrupt qid: %s (%x)\\n\", s, *e);\n\treturn q;\n}\n", "source": "git9/util.c", "file_type": "c"}
{"text": "#!/bin/rc -e\nrfork ne\n. /sys/lib/git/common.rc\n\ngitup\n\nflagfmt='r:remove'; args='file ...'\neval `''{aux/getflags $*} || exec aux/usage\n\ns=A\nif(~ $remove 1)\n\ts=R\nif(~ $#* 0)\n\texec aux/usage\n\npaths=`$nl{cleanname -d $gitrel $* | drop $gitroot}\nwalk -f ./$paths | grep -v '^(./)?.git/' | \\\n\tsed 's/^/'$s' NOQID 0 /' >> .git/INDEX9\nexit ''\n", "source": "git9/add", "file_type": "rc"}
{"text": "#!/bin/rc\n\nrfork e\n\nopts=()\nargs=()\nnl='\n'\n\nfn cmd_init{\n\twhile(! ~ $#* 0){\n\t\tswitch($1){\n\t\tcase --bare\n\t\t\t# ignore\n\t\tcase -- \n\t\t\t# go likes to use these\n\t\tcase -*\n\t\t\tdie unknown command init $*\n\t\tcase *\n\t\t\targs=($args $1)\n\t\t}\n\t\tshift\n\t}\n\tgit/init $opts $args\n}\n\nfn cmd_clone{\n\tbranch=()\n\twhile( ! ~ $#* 0){\n\t\tswitch($1){\n\t\tcase -b\n\t\t\tbranch=$2\n\t\t\tshift\n\t\tcase --\n\t\t\t# go likes to use these\n\t\tcase -*\n\t\t\tdie unknown command clone $*\n\t\tcase *\n\t\t\targs=($args $1)\n\t\t}\n\t\tshift\n\t}\n\tgit/clone $opts $args\n\tif(~ $#branch 1)\n\t\tgit/branch -n -b $1 origin/$1\n}\n\nfn cmd_pull{\n\tif(~ $1 -*)\n\t\tdie unknown options for pull $*\n\tgit/pull\n}\n\nfn cmd_fetch{\n\twhile(~ $#* 0){\n\t\tswitch($1){\n\t\tcase --all\n\t\t\topts=($opts -a)\n\t\tcase -f\n\t\t\topts=($opts -u $2)\n\t\t\tshift\n\t\tcase --\n \t\t\t# go likes to use these\n\t\tcase -*\n\t\t\tdie unknown command clone $*\n\t\tcase *\n\t\t\targs=($args $1)\n\t\t}\n\t\tshift\n\t}\t\n\tgit/pull -f $opts\n}\n\n\nfn cmd_checkout{\n\tif(~ $1 -*)\n\t\tdie unknown command pull $*\n\tif(~ $#* 0)\n\t\tdie git checkout branch\n\tgit/branch $b\n}\n\nfn cmd_submodule {\n\tif(test -f .gitmodules)\n\t\tdie 'submodules unsupported'\n}\n\nfn cmd_rev-parse{\n\twhile(~ $1 -*){\n\t\tswitch($1){\n\t\tcase --git-dir\n\t\t\techo $gitroot/.git\n\t\t\tshift\n\t\tcase --abbrev-ref\n\t\t\techo `{dcmd git9/branch | sed s@^heads/@@g}\n\t\t\tshift\n\t\tcase *\n\t\t\tdie unknown option $opt\n\t\t}\n\t\tshift\n\t}\n}\n\nfn cmd_show-ref{\n\tif(~ $1 -*)\n\t\tdie unknown command pull $*\n\tfilter=cat\n\tif(~ $#* 0)\n\t\tfilter=cat\n\tif not\n\t\tfilter='-e(^|/)'^$*^'$'\n\tfor(b in `$nl{cd $gitroot/.git/refs/ && walk -f})\n\t\techo `{cat $gitroot/.git/refs/$b} refs/$b \n}\n\nfn cmd_rev-parse{\n\tswitch($1){\n\tcase --git-dir\n\t\techo `{git/conf -r}^/.git\n\tcase *\n\t\tdie 'unknown rev-parse '$*\n\t}\n}\n\nfn cmd_remote{\n\tif({! ~ $#* 3 && ! ~ $#* 4} || ! ~ $1 add)\n\t\tdie unimplemented remote cmd $*\n\tname=$2\n\turl=$3\n\tif(~ $3 '--')\n\t\turl=$4\n\t>>$gitroot/.git/config{\n\t\techo '[remote \"'$name'\"]'\n\t\techo '\turl='$url\n\t}\n}\n\nfn cmd_log{\n\tcount=()\n\tformat=''\n\twhile(~ $1 -*){\n\t\tswitch($1){\n\t\tcase --format\n\t\t\tformat=$2\n\t\t\tshift\n\t\tcase '--format='*\n\t\t\tformat=`{echo $1 | sed 's/--format=//g'}\n\t\tcase -n\n\t\t\tcount=-n$2\n\t\t\tshift\n\t\tcase -n*\n\t\t\tcount=$1\n\t\tcase *\n\t\t\tdprint option $opt\n\t\t}\n\t\tshift\n\t}\n\t@{cd $gitroot && git/fs}\n\tswitch($format){\n\tcase ''\n\t\tgit/log $count\n\tcase '%H:%ct'\n\t\tfor(c in `{git/log -s $count| awk '{print $1}'})\n\t\t\techo $c:`{mtime $gitroot/.git/fs/object/$c/msg}\n\tcase '%h %cd'\n\t\tfor(c in `{git/log -s $count| awk '{print $1}'})\n\t\t\techo $c `{date `{mtime $gitroot/.git/fs/object/$c/msg}}\n\t}\n\n}\n\nfn cmd_show{\n\tcmd_log -n1 $*\n}\n\nfn cmd_ls-remote{\n\tif(~ $1 -q)\n\t\tshift\n\tremote=`$nl{git/conf 'remote \"'$1'\".url'}\n\tif(~ $#remote 0)\n\t\tremote=$1\n\tgit/get -l $remote | awk '/^remote/{print $3\"\\t\"$2}'\n}\n\nfn cmd_version{\n\techo git version 2.2.0\n}\n\nfn cmd_status{\n\techo\n}\n\nfn usage{\n\techo 'git <command> <args>' >[1=2]\n\texit usage\n}\n\nfn die {\n\t>[1=2] echo git $_cmdname: $*\n\texit $_cmdname: $*\n}\n\n_cmdname=$1\nif(~ $0 *compat){\n\tramfs -m /n/gitcompat\n\ttouch /n/gitcompat/git\n\tbind $0 /n/gitcompat/git\n\tpath=( /n/gitcompat $path )\n\texec rc\n}\n\nif(~ $#gitcompatdebug 1)\n\techo running  $* >>/tmp/gitlog\n\nif(~ $1 -c)\n\tshift 2\nif(~ $1 -c*)\n\tshift 1\nif(! test -f '/env/fn#cmd_'$1)\n\tdie git $1: commmand not implemented\nif(! ~ $1 init && ! ~ $1 clone)\n\tgitroot=`{git/conf -r} || die repo\n\nif(~ $#gitcompatdebug 1)\n\tcmd_$1 $*(2-) | tee >>/tmp/gitlog\nif not\n\tcmd_$1 $*(2-)\nexit ''\n", "source": "git9/compat", "file_type": "rc"}
{"text": "#!/bin/rc -e\nrfork en\n. /sys/lib/git/common.rc\n\nfn update{\n\tupstream=$1\n\turl=$2\n\tdir=$3\n\tdflag=()\n\tif(! ~ $#debug 0)\n\t\tdflag='-d'\n\t{git/get $dflag -u $upstream $url >[2=3] || die $status} | awk '\n\t/^remote/{\n\t\tif($2==\"HEAD\")\n\t\t\tnext\n\t\tref=$2\n\t\thash=$3\n\t\tgsub(\"^refs/heads\", \"refs/remotes/'$upstream'\", ref)\n\t\toutfile = \".git/\"ref\n\t\tsystem(\"mkdir -p `{basename -d \"outfile\"}\");\n\t\tprint hash > outfile;\n\t\tclose(outfile);\n\t}\n\t' |[3] tr '\\x0d' '\\x0a'\n}\n\ngitup\n\nflagfmt='d:debug, q:quiet, f:fetchonly,\n\tu:upstream upstream'\nargs=''\neval `''{aux/getflags $*} || exec aux/usage\n\nif(~ $#upstream 0)\n\tupstream=origin\nremote=`$nl{git/conf 'remote \"'$upstream'\".url'}\nif(~ $#remote 0){\n\tremote=$upstream\n\tupstream=THEM\n}\n\nupdate $upstream $remote\nif (~ $fetchonly 1)\n\texit\n\nlocal=`{git/branch}\nremote=`{git/branch | subst '^(refs/)?heads' 'remotes/'$upstream}\n\n# we have local commits, but the remote hasn't changed.\n# in this case, we want to keep the local commits untouched.\nif(~ `{git/query HEAD $remote @} `{git/query $remote}){\n\techo 'up to date' >[1=2]\n\texit\n}\n# The remote repository and our HEAD have diverged: we\n# need to merge.\nif(! ~ `{git/query HEAD $remote @} `{git/query HEAD}){\n\t>[1=2]{\n\t\techo ours:\t`{git/query HEAD}\n\t\techo theirs:\t`{git/query $remote}\n\t\techo common:\t`{git/query HEAD $remote @}\n\t\techo git/merge $remote\n\t}\n\texit diverged\n}\n# The remote is directly ahead of the local, and we have\n# no local commits that need merging.\nif(~ $#quiet 0)\n\tgit/log -s -e $local'..'$remote\necho $remote':' `{git/query $local} '=>' `{git/query $remote}\ngit/branch -mnb $remote $local\nexit ''\n", "source": "git9/pull", "file_type": "rc"}
{"text": "#include <u.h>\n#include <libc.h>\n\n#include \"git.h\"\n\nchar *fetchbranch;\nchar *upstream = \"origin\";\nint listonly;\n\nint\nresolveremote(Hash *h, char *ref)\n{\n\tchar buf[128], *s;\n\tint r, f;\n\n\tref = strip(ref);\n\tif((r = hparse(h, ref)) != -1)\n\t\treturn r;\n\t/* Slightly special handling: translate remote refs to local ones. */\n\tif(strcmp(ref, \"HEAD\") == 0){\n\t\tsnprint(buf, sizeof(buf), \".git/HEAD\");\n\t}else if(strstr(ref, \"refs/heads\") == ref){\n\t\tref += strlen(\"refs/heads\");\n\t\tsnprint(buf, sizeof(buf), \".git/refs/remotes/%s/%s\", upstream, ref);\n\t}else if(strstr(ref, \"refs/tags\") == ref){\n\t\tref += strlen(\"refs/tags\");\n\t\tsnprint(buf, sizeof(buf), \".git/refs/tags/%s/%s\", upstream, ref);\n\t}else{\n\t\treturn -1;\n\t}\n\n\tr = -1;\n\ts = strip(buf);\n\tif((f = open(s, OREAD)) == -1)\n\t\treturn -1;\n\tif(readn(f, buf, sizeof(buf)) >= 40)\n\t\tr = hparse(h, buf);\n\tclose(f);\n\n\tif(r == -1 && strstr(buf, \"ref:\") == buf)\n\t\treturn resolveremote(h, buf + strlen(\"ref:\"));\n\treturn r;\n}\n\nint\nrename(char *pack, char *idx, Hash h)\n{\n\tchar name[128];\n\tDir st;\n\n\tnulldir(&st);\n\tst.name = name;\n\tsnprint(name, sizeof(name), \"%H.pack\", h);\n\tif(access(name, AEXIST) == 0)\n\t\tfprint(2, \"warning, pack %s already fetched\\n\", name);\n\telse if(dirwstat(pack, &st) == -1)\n\t\treturn -1;\n\tsnprint(name, sizeof(name), \"%H.idx\", h);\n\tif(access(name, AEXIST) == 0)\n\t\tfprint(2, \"warning, pack %s already indexed\\n\", name);\n\telse if(dirwstat(idx, &st) == -1)\n\t\treturn -1;\n\treturn 0;\n}\n\nint\ncheckhash(int fd, vlong sz, Hash *hcomp)\n{\n\tDigestState *st;\n\tHash hexpect;\n\tchar buf[Pktmax];\n\tvlong n, r;\n\tint nr;\n\t\n\tif(sz < 28){\n\t\twerrstr(\"undersize packfile\");\n\t\treturn -1;\n\t}\n\n\tst = nil;\n\tn = 0;\n\twhile(n != sz - 20){\n\t\tnr = sizeof(buf);\n\t\tif(sz - n - 20 < sizeof(buf))\n\t\t\tnr = sz - n - 20;\n\t\tr = readn(fd, buf, nr);\n\t\tif(r != nr)\n\t\t\treturn -1;\n\t\tst = sha1((uchar*)buf, nr, nil, st);\n\t\tn += r;\n\t}\n\tsha1(nil, 0, hcomp->h, st);\n\tif(readn(fd, hexpect.h, sizeof(hexpect.h)) != sizeof(hexpect.h))\n\t\tsysfatal(\"truncated packfile\");\n\tif(!hasheq(hcomp, &hexpect)){\n\t\twerrstr(\"bad hash: %H != %H\", *hcomp, hexpect);\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nint\nmkoutpath(char *path)\n{\n\tchar s[128];\n\tchar *p;\n\tint fd;\n\n\tsnprint(s, sizeof(s), \"%s\", path);\n\tfor(p=strchr(s+1, '/'); p; p=strchr(p+1, '/')){\n\t\t*p = 0;\n\t\tif(access(s, AEXIST) != 0){\n\t\t\tfd = create(s, OREAD, DMDIR | 0775);\n\t\t\tif(fd == -1)\n\t\t\t\treturn -1;\n\t\t\tclose(fd);\n\t\t}\t\t\n\t\t*p = '/';\n\t}\n\treturn 0;\n}\n\nint\nbranchmatch(char *br, char *pat)\n{\n\tchar name[128];\n\n\tif(strstr(pat, \"refs/heads\") == pat)\n\t\tsnprint(name, sizeof(name), \"%s\", pat);\n\telse if(strstr(pat, \"heads\"))\n\t\tsnprint(name, sizeof(name), \"refs/%s\", pat);\n\telse\n\t\tsnprint(name, sizeof(name), \"refs/heads/%s\", pat);\n\treturn strcmp(br, name) == 0;\n}\n\nchar *\nmatchcap(char *s, char *cap, int full)\n{\n\tif(strncmp(s, cap, strlen(cap)) == 0)\n\t\tif(!full || strlen(s) == strlen(cap))\n\t\t\treturn s + strlen(cap);\n\treturn nil;\n}\n\nvoid\nhandlecaps(char *caps)\n{\n\tchar *p, *n, *c, *r;\n\n\tfor(p = caps; p != nil; p = n){\n\t\tn = strchr(p, ' ');\n\t\tif(n != nil)\n\t\t\t*n++ = 0;\n\t\tif((c = matchcap(p, \"symref=\", 0)) != nil){\n\t\t\tif((r = strchr(c, ':')) != nil){\n\t\t\t\t*r++ = '\\0';\n\t\t\t\tprint(\"symref %s %s\\n\", c, r);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid\nfail(char *pack, char *idx, char *msg, ...)\n{\n\tchar buf[ERRMAX];\n\tva_list ap;\n\n\tva_start(ap, msg);\n\tsnprint(buf, sizeof(buf), msg, ap);\n\tva_end(ap);\n\n\tremove(pack);\n\tremove(idx);\n\tfprint(2, \"%s\", buf);\n\texits(buf);\n}\n\nvoid\nenqueueparent(Objq *q, Object *o)\n{\n\tObject *p;\n\tint i;\n\n\tif(o->type != GCommit)\n\t\treturn;\n\tfor(i = 0; i < o->commit->nparent; i++){\n\t\tif((p = readobject(o->commit->parent[i])) == nil)\n\t\t\tcontinue;\n\t\tqput(q, p, 0);\n\t\tunref(p);\n\t}\n}\n\nint\nfetchpack(Conn *c)\n{\n\tchar buf[Pktmax], *sp[3], *ep;\n\tchar *packtmp, *idxtmp, **ref, *caps;\n\tHash h, *have, *want;\n\tint nref, refsz, first, nsent;\n\tint i, l, n, req, pfd;\n\tvlong packsz;\n\tObjset hadobj;\n\tObject *o;\n\tObjq haveq;\n\tQelt e;\n\n\tnref = 0;\n\trefsz = 16;\n\tfirst = 1;\n\thave = eamalloc(refsz, sizeof(have[0]));\n\twant = eamalloc(refsz, sizeof(want[0]));\n\tref = eamalloc(refsz, sizeof(ref[0]));\n\twhile(1){\n\t\tn = readpkt(c, buf, sizeof(buf));\n\t\tif(n == -1)\n\t\t\treturn -1;\n\t\tif(n == 0)\n\t\t\tbreak;\n\n\t\tif(first && n > strlen(buf))\n\t\t\thandlecaps(buf + strlen(buf) + 1);\n\t\tfirst = 0;\n\n\t\tgetfields(buf, sp, nelem(sp), 1, \" \\t\\n\\r\");\n\t\tif(strstr(sp[1], \"^{}\"))\n\t\t\tcontinue;\n\t\tif(fetchbranch && !branchmatch(sp[1], fetchbranch))\n\t\t\tcontinue;\n\t\tif(refsz == nref + 1){\n\t\t\trefsz *= 2;\n\t\t\thave = earealloc(have, refsz, sizeof(have[0]));\n\t\t\twant = earealloc(want, refsz, sizeof(want[0]));\n\t\t\tref = earealloc(ref, refsz, sizeof(ref[0]));\n\t\t}\n\t\tif(hparse(&want[nref], sp[0]) == -1)\n\t\t\tsysfatal(\"invalid hash %s\", sp[0]);\n\t\tif (resolveremote(&have[nref], sp[1]) == -1)\n\t\t\tmemset(&have[nref], 0, sizeof(have[nref]));\n\t\tref[nref] = estrdup(sp[1]);\n\t\tnref++;\n\t}\n\tif(listonly){\n\t\tflushpkt(c);\n\t\tgoto showrefs;\n\t}\n\n\tif(writephase(c) == -1)\n\t\tsysfatal(\"write: %r\");\n\treq = 0;\n\tcaps = \" multi_ack\";\n\tfor(i = 0; i < nref; i++){\n\t\tif(hasheq(&have[i], &want[i]))\n\t\t\tcontinue;\n\t\tif((o = readobject(want[i])) != nil){\n\t\t\tunref(o);\n\t\t\tcontinue;\n\t\t}\n\t\tif(fmtpkt(c, \"want %H%s\\n\", want[i], caps) == -1)\n\t\t\tsysfatal(\"could not send want for %H\", want[i]);\n\t\tcaps = \"\";\n\t\treq = 1;\n\t}\n\tflushpkt(c);\n\n\tnsent = 0;\n\tqinit(&haveq);\n\tosinit(&hadobj);\n\t/*\n\t * We know we have these objects, and we want to make sure that\n\t * they end up at the front of the queue. Send the 'have lines'\n\t * first, and then enqueue their parents for a second round of\n\t * sends.\n\t */\n\tfor(i = 0; i < nref; i++){\n\t\tif(hasheq(&have[i], &Zhash) || oshas(&hadobj, have[i]))\n\t\t\tcontinue;\n\t\tif((o = readobject(have[i])) == nil)\n\t\t\tsysfatal(\"missing exected object: %H\", have[i]);\n\t\tif(fmtpkt(c, \"have %H\", o->hash) == -1)\n\t\t\tsysfatal(\"write: %r\");\n\t\tenqueueparent(&haveq, o);\n\t\tosadd(&hadobj, o);\n\t\tunref(o);\n\t}\n\t/*\n\t * While we could short circuit this and check if upstream has\n\t * acked our objects, for the first 256 haves, this is simple\n\t * enough.\n\t *\n\t * Also, doing multiple rounds of reference discovery breaks\n\t * when using smart http.\n\t */\n\twhile(req && qpop(&haveq, &e) && nsent < 256){\n\t\tif(oshas(&hadobj, e.o->hash))\n\t\t\tcontinue;\n\t\tif((o = readobject(e.o->hash)) == nil)\n\t\t\tsysfatal(\"missing object we should have: %H\", have[i]);\n\t\tif(fmtpkt(c, \"have %H\", o->hash) == -1)\n\t\t\tsysfatal(\"write: %r\");\n\t\tenqueueparent(&haveq, o);\n\t\tosadd(&hadobj, o);\n\t\tunref(o);\n\t\tnsent++;\n\t}\n\tosclear(&hadobj);\n\tqclear(&haveq);\n\tif(!req)\n\t\tflushpkt(c);\n\tif(fmtpkt(c, \"done\\n\") == -1)\n\t\tsysfatal(\"write: %r\");\n\tif(!req)\n\t\tgoto showrefs;\n\tif(readphase(c) == -1)\n\t\tsysfatal(\"read: %r\");\n\tif((n = readpkt(c, buf, sizeof(buf))) == -1)\n\t\tsysfatal(\"read: %r\");\n\tbuf[n] = 0;\n\n\tif((packtmp = smprint(\".git/objects/pack/fetch.%d.pack\", getpid())) == nil)\n\t\tsysfatal(\"smprint: %r\");\n\tif((idxtmp = smprint(\".git/objects/pack/fetch.%d.idx\", getpid())) == nil)\n\t\tsysfatal(\"smprint: %r\");\n\tif(mkoutpath(packtmp) == -1)\n\t\tsysfatal(\"could not create %s: %r\", packtmp);\n\tif((pfd = create(packtmp, ORDWR, 0664)) == -1)\n\t\tsysfatal(\"could not create %s: %r\", packtmp);\n\n\tfprint(2, \"fetching...\\n\");\n\t/*\n\t * Work around torvalds git bug: we get duplicate have lines\n\t * somtimes, even though the protocol is supposed to start the\n\t * pack file immediately.\n\t *\n\t * Skip ahead until we read 'PACK' off the wire\n\t */\n\twhile(1){\n\t\tif(readn(c->rfd, buf, 4) != 4)\n\t\t\tsysfatal(\"fetch packfile: short read\");\n\t\tbuf[4] = 0;\n\t\tif(strncmp(buf, \"PACK\", 4) == 0)\n\t\t\tbreak;\n\t\tl = strtol(buf, &ep, 16);\n\t\tif(ep != buf + 4)\n\t\t\tsysfatal(\"fetch packfile: junk pktline\");\n\t\tif(readn(c->rfd, buf, l-4) != l-4)\n\t\t\tsysfatal(\"fetch packfile: short read\");\n\t}\n\tif(write(pfd, \"PACK\", 4) != 4)\n\t\tsysfatal(\"write pack header: %r\");\n\tpacksz = 4;\n\twhile(1){\n\t\tn = read(c->rfd, buf, sizeof buf);\n\t\tif(n == 0)\n\t\t\tbreak;\n\t\tif(n == -1 || write(pfd, buf, n) != n)\n\t\t\tsysfatal(\"fetch packfile: %r\");\n\t\tpacksz += n;\n\t}\n\n\tcloseconn(c);\n\tif(seek(pfd, 0, 0) == -1)\n\t\tfail(packtmp, idxtmp, \"packfile seek: %r\");\n\tif(checkhash(pfd, packsz, &h) == -1)\n\t\tfail(packtmp, idxtmp, \"corrupt packfile: %r\");\n\tclose(pfd);\n\tif(indexpack(packtmp, idxtmp, h) == -1)\n\t\tfail(packtmp, idxtmp, \"could not index fetched pack: %r\");\n\tif(rename(packtmp, idxtmp, h) == -1)\n\t\tfail(packtmp, idxtmp, \"could not rename indexed pack: %r\");\n\nshowrefs:\n\tfor(i = 0; i < nref; i++){\n\t\tprint(\"remote %s %H local %H\\n\", ref[i], want[i], have[i]);\n\t\tfree(ref[i]);\n\t}\n\tfree(ref);\n\tfree(want);\n\tfree(have);\n\treturn 0;\n}\n\nvoid\nusage(void)\n{\n\tfprint(2, \"usage: %s [-dl] [-b br] [-u upstream] remote\\n\", argv0);\n\tfprint(2, \"\\t-b br:\tonly fetch matching branch 'br'\\n\");\n\tfprint(2, \"remote:\tfetch from this repository\\n\");\n\texits(\"usage\");\n}\n\nvoid\nmain(int argc, char **argv)\n{\n\tConn c;\n\n\tARGBEGIN{\n\tcase 'b':\tfetchbranch=EARGF(usage());\tbreak;\n\tcase 'u':\tupstream=EARGF(usage());\tbreak;\n\tcase 'd':\tchattygit++;\t\t\tbreak;\n\tcase 'l':\tlistonly++;\t\t\tbreak;\n\tdefault:\tusage();\t\t\tbreak;\n\t}ARGEND;\n\n\tgitinit();\n\tif(argc != 1)\n\t\tusage();\n\n\tif(gitconnect(&c, argv[0], \"upload\") == -1)\n\t\tsysfatal(\"could not dial %s: %r\", argv[0]);\n\tif(fetchpack(&c) == -1)\n\t\tsysfatal(\"fetch failed: %r\");\n\tcloseconn(&c);\n\texits(nil);\n}\n", "source": "git9/get.c", "file_type": "c"}
{"text": "#!/bin/rc -e\n\nexec git/add -r $*\n", "source": "git9/rm", "file_type": "rc"}
{"text": "#include <u.h>\n#include <libc.h>\n#include <ctype.h>\n\n#include \"git.h\"\n\nint\tfindroot;\nint\tshowall;\nint\tnfile;\nchar\t*file[32];\n\nstatic int\nshowconf(char *cfg, char *sect, char *key)\n{\n\tchar *ln, *p;\n\tBiobuf *f;\n\tint foundsect, nsect, nkey, found;\n\n\tif((f = Bopen(cfg, OREAD)) == nil)\n\t\treturn 0;\n\n\tfound = 0;\n\tnsect = sect ? strlen(sect) : 0;\n\tnkey = strlen(key);\n\tfoundsect = (sect == nil);\n\twhile((ln = Brdstr(f, '\\n', 1)) != nil){\n\t\tp = strip(ln);\n\t\tif(*p == '[' && sect){\n\t\t\tfoundsect = strncmp(sect, ln, nsect) == 0;\n\t\t}else if(foundsect && strncmp(p, key, nkey) == 0){\n\t\t\tp = strip(p + nkey);\n\t\t\tif(*p != '=')\n\t\t\t\tcontinue;\n\t\t\tp = strip(p + 1);\n\t\t\tprint(\"%s\\n\", p);\n\t\t\tfound = 1;\n\t\t\tif(!showall){\n\t\t\t\tfree(ln);\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t\tfree(ln);\n\t}\ndone:\n\treturn found;\n}\n\n\nvoid\nusage(void)\n{\n\tfprint(2, \"usage: %s [-f file] [-r] keys..\\n\", argv0);\n\tfprint(2, \"\\t-f:\tuse file 'file' (default: .git/config)\\n\");\n\tfprint(2, \"\\t r:\tprint repository root\\n\");\n\texits(\"usage\");\n}\n\nvoid\nmain(int argc, char **argv)\n{\n\tchar repo[512], *p, *s;\n\tint i, j, nrel;\n\n\tARGBEGIN{\n\tcase 'f':\tfile[nfile++]=EARGF(usage());\tbreak;\n\tcase 'r':\tfindroot++;\t\t\tbreak;\n\tcase 'a':\tshowall++;\t\t\tbreak;\n\tdefault:\tusage();\t\t\tbreak;\n\t}ARGEND;\n\n\tif(findroot){\n\t\tif(findrepo(repo, sizeof(repo), &nrel) == -1)\n\t\t\tsysfatal(\"%r\");\n\t\tprint(\"%s\\n\", repo);\n\t\texits(nil);\n\t}\n\tif(nfile == 0){\n\t\tfile[nfile++] = \".git/config\";\n\t\tif((p = getenv(\"home\")) != nil)\n\t\t\tfile[nfile++] = smprint(\"%s/lib/git/config\", p);\n\t\tfile[nfile++] = \"/sys/lib/git/config\";\n\t}\n\n\tfor(i = 0; i < argc; i++){\n\t\tif((p = strchr(argv[i], '.')) == nil){\n\t\t\ts = nil;\n\t\t\tp = argv[i];\n\t\t}else{\n\t\t\t*p = 0;\n\t\t\tp++;\n\t\t\ts = smprint(\"[%s]\", argv[i]);\n\t\t}\n\t\tfor(j = 0; j < nfile; j++)\n\t\t\tif(showconf(file[j], s, p))\n\t\t\t\tbreak;\n\t}\n\texits(nil);\n}\n", "source": "git9/conf.c", "file_type": "c"}
{"text": "#include <u.h>\n#include <libc.h>\n#include <ctype.h>\n#include <fcall.h>\n#include <thread.h>\n#include <9p.h>\n\n#include \"git.h\"\n\nenum {\n\tQroot,\n\tQhead,\n\tQbranch,\n\tQcommit,\n\t\tQmsg,\n\t\tQparent,\n\t\tQtree,\n\t\tQcdata,\n\t\tQhash,\n\t\tQauthor,\n\t\tQcommitter,\n\tQobject,\n\tQctl,\n\tQmax,\n\tInternal=1<<7,\n};\n\ntypedef struct Gitaux Gitaux;\ntypedef struct Crumb Crumb;\ntypedef struct Cache Cache;\ntypedef struct Uqid Uqid;\nstruct Crumb {\n\tchar\t*name;\n\tObject\t*obj;\n\tQid\tqid;\n\tint\tmode;\n\tvlong\tmtime;\n};\n\nstruct Gitaux {\n\tint\tncrumb;\n\tCrumb\t*crumb;\n\tchar\t*refpath;\n\tint\tqdir;\n\n\t/* For listing object dir */\n\tObjlist\t*ols;\n\tObject\t*olslast;\n};\n\nstruct Uqid {\n\tvlong\tuqid;\n\n\tvlong\tppath;\n\tvlong\toid;\n\tint\tt;\n\tint\tidx;\n};\n\nstruct Cache {\n\tUqid *cache;\n\tint n;\n\tint max;\n};\n\nchar *qroot[] = {\n\t\"HEAD\",\n\t\"branch\",\n\t\"object\",\n\t\"ctl\",\n};\n\n#define Eperm\t\"permission denied\"\n#define Eexist\t\"file does not exist\"\n#define E2long\t\"path too long\"\n#define Enodir\t\"not a directory\"\n#define Erepo\t\"unable to read repo\"\n#define Egreg\t\"wat\"\n#define Ebadobj\t\"invalid object\"\n\nchar\tgitdir[512];\nchar\t*username;\nchar\t*groupname;\nchar\t*mntpt = \".git/fs\";\nchar\t**branches = nil;\nCache\tuqidcache[512];\nvlong\tnextqid = Qmax;\n\nstatic Object*\twalklink(Gitaux *, char *, int, int, int*);\n\nvlong\nqpath(Crumb *p, int idx, vlong id, vlong t)\n{\n\tint h, i;\n\tvlong pp;\n\tCache *c;\n\tUqid *u;\n\n\tpp = p ? p->qid.path : 0;\n\th = (pp*333 + id*7 + t) & (nelem(uqidcache) - 1);\n\tc = &uqidcache[h];\n\tu = c->cache;\n\tfor(i=0; i <c->n ; i++){\n\t\tif(u->ppath == pp && u->oid == id && u->t == t && u->idx == idx)\n\t\t\treturn (u->uqid << 8) | t;\n\t\tu++;\n\t}\n\tif(c->n == c->max){\n\t\tc->max += c->max/2 + 1;\n\t\tc->cache = erealloc(c->cache, c->max*sizeof(Uqid));\n\t}\n\tnextqid++;\n\tc->cache[c->n] = (Uqid){nextqid, pp, id, t, idx};\n\tc->n++;\n\treturn (nextqid << 8) | t;\n}\n\nstatic Crumb*\ncrumb(Gitaux *aux, int n)\n{\n\tif(n < aux->ncrumb)\n\t\treturn &aux->crumb[aux->ncrumb - n - 1];\n\treturn nil;\n}\n\nstatic void\npopcrumb(Gitaux *aux)\n{\n\tCrumb *c;\n\n\tif(aux->ncrumb > 1){\n\t\tc = crumb(aux, 0);\n\t\tfree(c->name);\n\t\tunref(c->obj);\n\t\taux->ncrumb--;\n\t}\n}\n\nstatic vlong\nbranchid(Gitaux *aux, char *path)\n{\n\tint i;\n\n\tfor(i = 0; branches[i]; i++)\n\t\tif(strcmp(path, branches[i]) == 0)\n\t\t\tgoto found;\n\tbranches = realloc(branches, sizeof(char *)*(i + 2));\n\tbranches[i] = estrdup(path);\n\tbranches[i + 1] = nil;\n\nfound:\n\tif(aux){\n\t\tif(aux->refpath)\n\t\t\tfree(aux->refpath);\n\t\taux->refpath = estrdup(branches[i]);\n\t}\n\treturn i;\n}\n\nstatic void\nobj2dir(Dir *d, Crumb *c, Object *o, char *name)\n{\n\td->qid = c->qid;\n\td->atime = c->mtime;\n\td->mtime = c->mtime;\n\td->mode = c->mode;\n\td->name = estrdup9p(name);\n\td->uid = estrdup9p(username);\n\td->gid = estrdup9p(groupname);\n\td->muid = estrdup9p(username);\n\tif(o->type == GBlob || o->type == GTag){\n\t\td->qid.type = 0;\n\t\td->mode &= 0777;\n\t\td->length = o->size;\n\t}\n\n}\n\nstatic int\nrootgen(int i, Dir *d, void *p)\n{\n\tCrumb *c;\n\n\tc = crumb(p, 0);\n\tif (i >= nelem(qroot))\n\t\treturn -1;\n\td->mode = 0555 | DMDIR;\n\td->name = estrdup9p(qroot[i]);\n\td->qid.vers = 0;\n\td->qid.type = strcmp(qroot[i], \"ctl\") == 0 ? 0 : QTDIR;\n\td->qid.path = qpath(nil, i, i, Qroot);\n\td->uid = estrdup9p(username);\n\td->gid = estrdup9p(groupname);\n\td->muid = estrdup9p(username);\n\td->mtime = c->mtime;\n\treturn 0;\n}\n\nstatic int\nbranchgen(int i, Dir *d, void *p)\n{\n\tGitaux *aux;\n\tDir *refs;\n\tCrumb *c;\n\tint n;\n\n\taux = p;\n\tc = crumb(aux, 0);\n\trefs = nil;\n\td->qid.vers = 0;\n\td->qid.type = QTDIR;\n\td->qid.path = qpath(c, i, branchid(aux, aux->refpath), Qbranch | Internal);\n\td->mode = 0555 | DMDIR;\n\td->uid = estrdup9p(username);\n\td->gid = estrdup9p(groupname);\n\td->muid = estrdup9p(username);\n\td->mtime = c->mtime;\n\td->atime = c->mtime;\n\tif((n = slurpdir(aux->refpath, &refs)) < 0)\n\t\treturn -1;\n\tif(i < n){\n\t\td->name = estrdup9p(refs[i].name);\n\t\tfree(refs);\n\t\treturn 0;\n\t}else{\n\t\tfree(refs);\n\t\treturn -1;\n\t}\n}\n\nstatic int\ngtreegen(int i, Dir *d, void *p)\n{\n\tObject *o, *l, *e;\n\tGitaux *aux;\n\tCrumb *c;\n\tint m;\n\n\taux = p;\n\tc = crumb(aux, 0);\n\te = c->obj;\n\tif(i >= e->tree->nent)\n\t\treturn -1;\n\tm = e->tree->ent[i].mode;\n\tif(e->tree->ent[i].ismod)\n\t\to = emptydir();\n\telse if((o = readobject(e->tree->ent[i].h)) == nil)\n\t\tsysfatal(\"could not read object %H: %r\", e->tree->ent[i].h);\n\tif(e->tree->ent[i].islink)\n\t\tif((l = walklink(aux, o->data, o->size, 0, &m)) != nil)\n\t\t\to = l;\n\td->qid.vers = 0;\n\td->qid.type = o->type == GTree ? QTDIR : 0;\n\td->qid.path = qpath(c, i, o->id, aux->qdir);\n\td->mode = m;\n\td->atime = c->mtime;\n\td->mtime = c->mtime;\n\td->uid = estrdup9p(username);\n\td->gid = estrdup9p(groupname);\n\td->muid = estrdup9p(username);\n\td->name = estrdup9p(e->tree->ent[i].name);\n\td->length = o->size;\n\treturn 0;\n}\n\nstatic int\ngcommitgen(int i, Dir *d, void *p)\n{\n\tObject *o;\n\tCrumb *c;\n\n\tc = crumb(p, 0);\n\to = c->obj;\n\td->uid = estrdup9p(username);\n\td->gid = estrdup9p(groupname);\n\td->muid = estrdup9p(username);\n\td->mode = 0444;\n\td->atime = o->commit->ctime;\n\td->mtime = o->commit->ctime;\n\td->qid.type = 0;\n\td->qid.vers = 0;\n\n\tswitch(i){\n\tcase 0:\n\t\td->mode = 0755 | DMDIR;\n\t\td->name = estrdup9p(\"tree\");\n\t\td->qid.type = QTDIR;\n\t\td->qid.path = qpath(c, i, o->id, Qtree);\n\t\tbreak;\n\tcase 1:\n\t\td->name = estrdup9p(\"parent\");\n\t\td->qid.path = qpath(c, i, o->id, Qparent);\n\t\tbreak;\n\tcase 2:\n\t\td->name = estrdup9p(\"msg\");\n\t\td->qid.path = qpath(c, i, o->id, Qmsg);\n\t\tbreak;\n\tcase 3:\n\t\td->name = estrdup9p(\"hash\");\n\t\td->qid.path = qpath(c, i, o->id, Qhash);\n\t\tbreak;\n\tcase 4:\n\t\td->name = estrdup9p(\"author\");\n\t\td->qid.path = qpath(c, i, o->id, Qauthor);\n\t\tbreak;\n\tdefault:\n\t\tfree(d->uid);\n\t\tfree(d->gid);\n\t\tfree(d->muid);\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\n\nstatic int\nobjgen(int i, Dir *d, void *p)\n{\n\tGitaux *aux;\n\tObject *o;\n\tCrumb *c;\n\tchar name[64];\n\tObjlist *ols;\n\tHash h;\n\n\taux = p;\n\tc = crumb(aux, 0);\n\tif(!aux->ols)\n\t\taux->ols = mkols();\n\tols = aux->ols;\n\to = nil;\n\t/* We tried to sent it, but it didn't fit */\n\tif(aux->olslast && ols->idx == i + 1){\n\t\tsnprint(name, sizeof(name), \"%H\", aux->olslast->hash);\n\t\tobj2dir(d, c, aux->olslast, name);\n\t\treturn 0;\n\t}\n\twhile(ols->idx <= i){\n\t\tif(olsnext(ols, &h) == -1)\n\t\t\treturn -1;\n\t\tif((o = readobject(h)) == nil){\n\t\t\tfprint(2, \"corrupt object %H\\n\", h);\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif(o != nil){\n\t\tsnprint(name, sizeof(name), \"%H\", o->hash);\n\t\tobj2dir(d, c, o, name);\n\t\tunref(aux->olslast);\n\t\taux->olslast = ref(o);\n\t\treturn 0;\n\t}\n\treturn -1;\n}\n\nstatic void\nobjread(Req *r, Gitaux *aux)\n{\n\tObject *o;\n\n\to = crumb(aux, 0)->obj;\n\tswitch(o->type){\n\tcase GBlob:\n\t\treadbuf(r, o->data, o->size);\n\t\tbreak;\n\tcase GTag:\n\t\treadbuf(r, o->data, o->size);\n\t\tbreak;\n\tcase GTree:\n\t\tdirread9p(r, gtreegen, aux);\n\t\tbreak;\n\tcase GCommit:\n\t\tdirread9p(r, gcommitgen, aux);\n\t\tbreak;\n\tdefault:\n\t\tsysfatal(\"invalid object type %d\", o->type);\n\t}\n}\n\nstatic void\nreadcommitparent(Req *r, Object *o)\n{\n\tchar *buf, *p, *e;\n\tint i, n;\n\n\t/* 40 bytes per hash, 1 per nl, 1 for terminator */\n\tn = o->commit->nparent * (40 + 1) + 1;\n\tbuf = emalloc(n);\n\tp = buf;\n\te = buf + n;\n\tfor (i = 0; i < o->commit->nparent; i++)\n\t\tp = seprint(p, e, \"%H\\n\", o->commit->parent[i]);\n\treadbuf(r, buf, p - buf);\n\tfree(buf);\n}\n\nstatic void\ngitattach(Req *r)\n{\n\tGitaux *aux;\n\tDir *d;\n\n\tif((d = dirstat(\".git\")) == nil)\n\t\tsysfatal(\"git/fs: %r\");\n\tif(getwd(gitdir, sizeof(gitdir)) == nil)\n\t\tsysfatal(\"getwd: %r\");\n\taux = emalloc(sizeof(Gitaux));\n\taux->crumb = emalloc(sizeof(Crumb));\n\taux->crumb[0].qid = (Qid){Qroot, 0, QTDIR};\n\taux->crumb[0].obj = nil;\n\taux->crumb[0].mode = DMDIR | 0555;\n\taux->crumb[0].mtime = d->mtime;\n\taux->crumb[0].name = estrdup(\"/\");\n\taux->ncrumb = 1;\n\tr->ofcall.qid = (Qid){Qroot, 0, QTDIR};\n\tr->fid->qid = r->ofcall.qid;\n\tr->fid->aux = aux;\n\trespond(r, nil);\n}\n\nstatic Object*\nwalklink(Gitaux *aux, char *link, int nlink, int ndotdot, int *mode)\n{\n\tchar *p, *e, *path;\n\tObject *o, *n;\n\tint i;\n\n\tpath = emalloc(nlink + 1);\n\tmemcpy(path, link, nlink);\n\tcleanname(path);\n\n\to = crumb(aux, ndotdot)->obj;\n\tassert(o->type == GTree);\n\tfor(p = path; *p; p = e){\n\t\tn = nil;\n\t\te = p + strcspn(p, \"/\");\n\t\tif(*e == '/')\n\t\t\t*e++ = '\\0';\n\t\t/*\n\t\t * cleanname guarantees these show up at the start of the name,\n\t\t * which allows trimming them from the end of the trail of crumbs\n\t\t * instead of needing to keep track of full parentage.\n\t\t */\n\t\tif(strcmp(p, \"..\") == 0)\n\t\t\tn = crumb(aux, ++ndotdot)->obj;\n\t\telse if(o->type == GTree)\n\t\t\tfor(i = 0; i < o->tree->nent; i++)\n\t\t\t\tif(strcmp(o->tree->ent[i].name, p) == 0){\n\t\t\t\t\t*mode = o->tree->ent[i].mode;\n\t\t\t\t\tn = readobject(o->tree->ent[i].h);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\to = n;\n\t\tif(o == nil)\n\t\t\tbreak;\n\t}\n\tfree(path);\n\tfor(i = 0; o != nil && i < aux->ncrumb; i++)\n\t\tif(crumb(aux, i)->obj == o)\n\t\t\treturn nil;\n\treturn o;\n}\n\nstatic char *\nobjwalk1(Qid *q, Object *o, Crumb *p, Crumb *c, char *name, vlong qdir, Gitaux *aux)\n{\n\tObject *w, *l;\n\tchar *e;\n\tint i, m;\n\n\tw = nil;\n\te = nil;\n\tif(!o)\n\t\treturn Eexist;\n\tif(o->type == GTree){\n\t\tq->type = 0;\n\t\tfor(i = 0; i < o->tree->nent; i++){\n\t\t\tif(strcmp(o->tree->ent[i].name, name) != 0)\n\t\t\t\tcontinue;\n\t\t\tm = o->tree->ent[i].mode;\n\t\t\tw = readobject(o->tree->ent[i].h);\n\t\t\tif(!w && o->tree->ent[i].ismod)\n\t\t\t\tw = emptydir();\n\t\t\tif(w && o->tree->ent[i].islink)\n\t\t\t\tif((l = walklink(aux, w->data, w->size, 1, &m)) != nil)\n\t\t\t\t\tw = l;\n\t\t\tif(!w)\n\t\t\t\treturn Ebadobj;\n\t\t\tq->type = (w->type == GTree) ? QTDIR : 0;\n\t\t\tq->path = qpath(p, i, w->id, qdir);\n\t\t\tc->mode = m;\n\t\t\tc->mode |= (w->type == GTree) ? DMDIR|0755 : 0644;\n\t\t\tc->obj = w;\n\t\t\tbreak;\n\t\t}\n\t\tif(!w)\n\t\t\te = Eexist;\n\t}else if(o->type == GCommit){\n\t\tq->type = 0;\n\t\tc->mtime = o->commit->mtime;\n\t\tc->mode = 0644;\n\t\tassert(qdir == Qcommit || qdir == Qobject || qdir == Qtree || qdir == Qhead || qdir == Qcommitter);\n\t\tif(strcmp(name, \"msg\") == 0)\n\t\t\tq->path = qpath(p, 0, o->id, Qmsg);\n\t\telse if(strcmp(name, \"parent\") == 0)\n\t\t\tq->path = qpath(p, 1, o->id, Qparent);\n\t\telse if(strcmp(name, \"hash\") == 0)\n\t\t\tq->path = qpath(p, 2, o->id, Qhash);\n\t\telse if(strcmp(name, \"author\") == 0)\n\t\t\tq->path = qpath(p, 3, o->id, Qauthor);\n\t\telse if(strcmp(name, \"committer\") == 0)\n\t\t\tq->path = qpath(p, 3, o->id, Qcommitter);\n\t\telse if(strcmp(name, \"tree\") == 0){\n\t\t\tq->type = QTDIR;\n\t\t\tq->path = qpath(p, 4, o->id, Qtree);\n\t\t\tunref(c->obj);\n\t\t\tc->mode = DMDIR | 0755;\n\t\t\tc->obj = readobject(o->commit->tree);\n\t\t\tif(c->obj == nil)\n\t\t\t\tsysfatal(\"could not read object %H: %r\", o->commit->tree);\n\t\t}\n\t\telse\n\t\t\te = Eexist;\n\t}else if(o->type == GTag){\n\t\te = \"tag walk unimplemented\";\n\t}\n\treturn e;\n}\n\nstatic Object *\nreadref(char *pathstr)\n{\n\tchar buf[128], path[128], *p, *e;\n\tHash h;\n\tint n, f;\n\n\tsnprint(path, sizeof(path), \"%s\", pathstr);\n\twhile(1){\n\t\tif((f = open(path, OREAD)) == -1)\n\t\t\treturn nil;\n\t\tif((n = readn(f, buf, sizeof(buf) - 1)) == -1)\n\t\t\treturn nil;\n\t\tclose(f);\n\t\tbuf[n] = 0;\n\t\tif(strncmp(buf, \"ref:\", 4) !=  0)\n\t\t\tbreak;\n\n\t\tp = buf + 4;\n\t\twhile(isspace(*p))\n\t\t\tp++;\n\t\tif((e = strchr(p, '\\n')) != nil)\n\t\t\t*e = 0;\n\t\tsnprint(path, sizeof(path), \".git/%s\", p);\n\t}\n\n\tif(hparse(&h, buf) == -1)\n\t\treturn nil;\n\n\treturn readobject(h);\n}\n\nstatic char*\ngitwalk1(Fid *fid, char *name, Qid *q)\n{\n\tchar path[128];\n\tGitaux *aux;\n\tCrumb *c, *o;\n\tchar *e;\n\tDir *d;\n\tHash h;\n\n\te = nil;\n\taux = fid->aux;\n\t\n\tq->vers = 0;\n\tif(strcmp(name, \"..\") == 0){\n\t\tpopcrumb(aux);\n\t\tc = crumb(aux, 0);\n\t\t*q = c->qid;\n\t\tfid->qid = *q;\n\t\treturn nil;\n\t}\n\t\n\taux->crumb = realloc(aux->crumb, (aux->ncrumb + 1) * sizeof(Crumb));\n\taux->ncrumb++;\n\tc = crumb(aux, 0);\n\to = crumb(aux, 1);\n\tmemset(c, 0, sizeof(Crumb));\n\tc->mode = o->mode;\n\tc->mtime = o->mtime;\n\t\tc->obj = o->obj ? ref(o->obj) : nil;\n\t\n\tswitch(QDIR(&fid->qid)){\n\tcase Qroot:\n\t\tif(strcmp(name, \"HEAD\") == 0){\n\t\t\t*q = (Qid){Qhead, 0, QTDIR};\n\t\t\tc->mode = DMDIR | 0555;\n\t\t\tc->obj = readref(\".git/HEAD\");\n\t\t}else if(strcmp(name, \"object\") == 0){\n\t\t\t*q = (Qid){Qobject, 0, QTDIR};\n\t\t\tc->mode = DMDIR | 0555;\n\t\t}else if(strcmp(name, \"branch\") == 0){\n\t\t\t*q = (Qid){Qbranch, 0, QTDIR};\n\t\t\taux->refpath = estrdup(\".git/refs/\");\n\t\t\tc->mode = DMDIR | 0555;\n\t\t}else if(strcmp(name, \"ctl\") == 0){\n\t\t\t*q = (Qid){Qctl, 0, 0};\n\t\t\tc->mode = 0644;\n\t\t}else{\n\t\t\te = Eexist;\n\t\t}\n\t\tbreak;\n\tcase Qbranch:\n\t\tif(strcmp(aux->refpath, \".git/refs/heads\") == 0 && strcmp(name, \"HEAD\") == 0)\n\t\t\tsnprint(path, sizeof(path), \".git/HEAD\");\n\t\telse\n\t\t\tsnprint(path, sizeof(path), \"%s/%s\", aux->refpath, name);\n\t\tq->type = QTDIR;\n\t\td = dirstat(path);\n\t\tif(d && d->qid.type == QTDIR)\n\t\t\tq->path = qpath(o, Qbranch, branchid(aux, path), Qbranch);\n\t\telse if(d && (c->obj = readref(path)) != nil)\n\t\t\tq->path = qpath(o, Qbranch, c->obj->id, Qcommit);\n\t\telse\n\t\t\te = Eexist;\n\t\tif(d != nil)\n\t\t\tc->mode = d->mode & ~0222;\n\t\tfree(d);\n\t\tbreak;\n\tcase Qobject:\n\t\tif(c->obj){\n\t\t\te = objwalk1(q, o->obj, o, c, name, Qobject, aux);\n\t\t}else{\n\t\t\tif(hparse(&h, name) == -1)\n\t\t\t\treturn Ebadobj;\n\t\t\tif((c->obj = readobject(h)) == nil)\n\t\t\t\treturn Ebadobj;\n\t\t\tif(c->obj->type == GBlob || c->obj->type == GTag){\n\t\t\t\tc->mode = 0644;\n\t\t\t\tq->type = 0;\n\t\t\t}else{\n\t\t\t\tc->mode = DMDIR | 0755;\n\t\t\t\tq->type = QTDIR;\n\t\t\t}\n\t\t\tq->path = qpath(o, Qobject, c->obj->id, Qobject);\n\t\t\tq->vers = 0;\n\t\t}\n\t\tbreak;\n\tcase Qhead:\n\t\te = objwalk1(q, o->obj, o, c, name, Qhead, aux);\n\t\tbreak;\n\tcase Qcommit:\n\t\te = objwalk1(q, o->obj, o, c, name, Qcommit, aux);\n\t\tbreak;\n\tcase Qtree:\n\t\te = objwalk1(q, o->obj, o, c, name, Qtree, aux);\n\t\tbreak;\n\tcase Qparent:\n\tcase Qmsg:\n\tcase Qcdata:\n\tcase Qhash:\n\tcase Qauthor:\n\tcase Qcommitter:\n\tcase Qctl:\n\t\treturn Enodir;\n\tdefault:\n\t\treturn Egreg;\n\t}\n\n\tc->name = estrdup(name);\n\tc->qid = *q;\n\tfid->qid = *q;\n\treturn e;\n}\n\nstatic char*\ngitclone(Fid *o, Fid *n)\n{\n\tGitaux *aux, *oaux;\n\tint i;\n\n\toaux = o->aux;\n\taux = emalloc(sizeof(Gitaux));\n\taux->ncrumb = oaux->ncrumb;\n\taux->crumb = eamalloc(oaux->ncrumb, sizeof(Crumb));\n\tfor(i = 0; i < aux->ncrumb; i++){\n\t\taux->crumb[i] = oaux->crumb[i];\n\t\taux->crumb[i].name = estrdup(oaux->crumb[i].name);\n\t\tif(aux->crumb[i].obj)\n\t\t\taux->crumb[i].obj = ref(oaux->crumb[i].obj);\n\t}\n\tif(oaux->refpath)\n\t\taux->refpath = strdup(oaux->refpath);\n\taux->qdir = oaux->qdir;\n\tn->aux = aux;\n\treturn nil;\n}\n\nstatic void\ngitdestroyfid(Fid *f)\n{\n\tGitaux *aux;\n\tint i;\n\n\tif((aux = f->aux) == nil)\n\t\treturn;\n\tfor(i = 0; i < aux->ncrumb; i++){\n\t\tif(aux->crumb[i].obj)\n\t\t\tunref(aux->crumb[i].obj);\n\t\tfree(aux->crumb[i].name);\n\t}\n\tolsfree(aux->ols);\n\tfree(aux->refpath);\n\tfree(aux->crumb);\n\tfree(aux);\n}\n\nstatic char *\nreadctl(Req *r)\n{\n\tchar data[1024], ref[512], *s, *e;\n\tint fd, n;\n\n\tif((fd = open(\".git/HEAD\", OREAD)) == -1)\n\t\treturn Erepo;\n\t/* empty HEAD is invalid */\n\tif((n = readn(fd, ref, sizeof(ref) - 1)) <= 0)\n\t\treturn Erepo;\n\tclose(fd);\n\n\ts = ref;\n\tref[n] = 0;\n\tif(strncmp(s, \"ref:\", 4) == 0)\n\t\ts += 4;\n\twhile(*s == ' ' || *s == '\\t')\n\t\ts++;\n\tif((e = strchr(s, '\\n')) != nil)\n\t\t*e = 0;\n\tif(strstr(s, \"refs/\") == s)\n\t\ts += strlen(\"refs/\");\n\n\tsnprint(data, sizeof(data), \"branch %s\\nrepo %s\\n\", s, gitdir);\n\treadstr(r, data);\n\treturn nil;\n}\n\nstatic void\ngitread(Req *r)\n{\n\tchar buf[256], *e;\n\tGitaux *aux;\n\tObject *o;\n\tQid *q;\n\n\taux = r->fid->aux;\n\tq = &r->fid->qid;\n\to = crumb(aux, 0)->obj;\n\te = nil;\n\n\tswitch(QDIR(q)){\n\tcase Qroot:\n\t\tdirread9p(r, rootgen, aux);\n\t\tbreak;\n\tcase Qbranch:\n\t\tif(o)\n\t\t\tobjread(r, aux);\n\t\telse\n\t\t\tdirread9p(r, branchgen, aux);\n\t\tbreak;\n\tcase Qobject:\n\t\tif(o)\n\t\t\tobjread(r, aux);\n\t\telse\n\t\t\tdirread9p(r, objgen, aux);\n\t\tbreak;\n\tcase Qmsg:\n\t\treadbuf(r, o->commit->msg, o->commit->nmsg);\n\t\tbreak;\n\tcase Qparent:\n\t\treadcommitparent(r, o);\n\t\tbreak;\n\tcase Qhash:\n\t\tsnprint(buf, sizeof(buf), \"%H\\n\", o->hash);\n\t\treadstr(r, buf);\n\t\tbreak;\n\tcase Qauthor:\n\t\tsnprint(buf, sizeof(buf), \"%s\\n\", o->commit->author);\n\t\treadstr(r, buf);\n\t\tbreak;\n\tcase Qcommitter:\n\t\tsnprint(buf, sizeof(buf), \"%s\\n\", o->commit->committer);\n\t\treadstr(r, buf);\n\t\tbreak;\n\tcase Qctl:\n\t\te = readctl(r);\n\t\tbreak;\n\tcase Qhead:\n\t\t/* Empty repositories have no HEAD */\n\t\tif(o == nil)\n\t\t\tr->ofcall.count = 0;\n\t\telse\n\t\t\tobjread(r, aux);\n\t\tbreak;\n\tcase Qcommit:\n\tcase Qtree:\n\tcase Qcdata:\n\t\tobjread(r, aux);\n\t\tbreak;\n\tdefault:\n\t\te = Egreg;\n\t}\n\trespond(r, e);\n}\n\nstatic void\ngitopen(Req *r)\n{\n\tGitaux *aux;\n\tCrumb *c;\n\n\taux = r->fid->aux;\n\tc = crumb(aux, 0);\n\tswitch(r->ifcall.mode&3){\n\tdefault:\n\t\trespond(r, \"botched mode\");\n\t\tbreak;\n\tcase OWRITE:\n\t\trespond(r, Eperm);\n\t\tbreak;\n\tcase OREAD:\n\tcase ORDWR:\n\t\trespond(r, nil);\n\t\tbreak;\n\tcase OEXEC:\n\t\tif((c->mode & 0111) == 0)\n\t\t\trespond(r, Eperm);\n\t\telse\n\t\t\trespond(r, nil);\n\t\tbreak;\n\t}\n}\n\nstatic void\ngitstat(Req *r)\n{\n\tGitaux *aux;\n\tCrumb *c;\n\n\taux = r->fid->aux;\n\tc = crumb(aux, 0);\n\tr->d.uid = estrdup9p(username);\n\tr->d.gid = estrdup9p(groupname);\n\tr->d.muid = estrdup9p(username);\n\tr->d.qid = r->fid->qid;\n\tr->d.mtime = c->mtime;\n\tr->d.atime = c->mtime;\n\tr->d.mode = c->mode;\n\tif(c->obj)\n\t\tobj2dir(&r->d, c, c->obj, c->name);\n\telse\n\t\tr->d.name = estrdup9p(c->name);\n\trespond(r, nil);\n}\n\nSrv gitsrv = {\n\t.attach=gitattach,\n\t.walk1=gitwalk1,\n\t.clone=gitclone,\n\t.open=gitopen,\n\t.read=gitread,\n\t.stat=gitstat,\n\t.destroyfid=gitdestroyfid,\n};\n\nvoid\nusage(void)\n{\n\tfprint(2, \"usage: %s [-d]\\n\", argv0);\n\tfprint(2, \"\\t-d:\tdebug\\n\");\n\texits(\"usage\");\n}\n\nvoid\nmain(int argc, char **argv)\n{\n\tDir *d;\n\n\tgitinit();\n\tARGBEGIN{\n\tcase 'd':\n\t\tchatty9p++;\n\t\tbreak;\n\tcase 'm':\n\t\tmntpt = EARGF(usage());\n\t\tbreak;\n\tdefault:\n\t\tusage();\n\t\tbreak;\n\t}ARGEND;\n\tif(argc != 0)\n\t\tusage();\n\n\tif((d = dirstat(\".git\")) == nil)\n\t\tsysfatal(\"dirstat .git: %r\");\n\tusername = strdup(d->uid);\n\tgroupname = strdup(d->gid);\n\tfree(d);\n\n\tbranches = emalloc(sizeof(char*));\n\tbranches[0] = nil;\n\tpostmountsrv(&gitsrv, nil, mntpt, MCREATE);\n\texits(nil);\n}\n", "source": "git9/fs.c", "file_type": "c"}
{"text": "#include <u.h>\n#include <libc.h>\n\n#include \"git.h\"\n\n#define TMPPATH(suff) (\".git/objects/pack/repack.\"suff)\n\nint\ncleanup(Hash h)\n{\n\tchar newpfx[42], dpath[256], fpath[256];\n\tint i, j, nd;\n\tDir *d;\n\n\tsnprint(newpfx, sizeof(newpfx), \"%H.\", h);\n\tfor(i = 0; i < 256; i++){\n\t\tsnprint(dpath, sizeof(dpath), \".git/objects/%02x\", i);\n\t\tif((nd = slurpdir(dpath, &d)) == -1)\n\t\t\tcontinue;\n\t\tfor(j = 0; j < nd; j++){\n\t\t\tsnprint(fpath, sizeof(fpath), \".git/objects/%02x/%s\", i, d[j].name);\n\t\t\tremove(fpath);\n\t\t}\n\t\tremove(dpath);\n\t\tfree(d);\n\t}\n\tsnprint(dpath, sizeof(dpath), \".git/objects/pack\");\n\tif((nd = slurpdir(dpath, &d)) == -1)\n\t\treturn -1;\n\tfor(i = 0; i < nd; i++){\n\t\tif(strncmp(d[i].name, newpfx, strlen(newpfx)) == 0)\n\t\t\tcontinue;\n\t\tsnprint(fpath, sizeof(fpath), \".git/objects/pack/%s\", d[i].name);\n\t\tremove(fpath);\n\t}\n\treturn 0;\n}\n\nvoid\nusage(void)\n{\n\tfprint(2, \"usage: %s [-d]\\n\", argv0);\n\texits(\"usage\");\n}\n\nvoid\nmain(int argc, char **argv)\n{\n\tchar path[128], **names;\n\tint fd, nrefs;\n\tHash *refs, h;\n\tDir rn;\n\n\tARGBEGIN{\n\tcase 'd':\n\t\tchattygit++;\n\t\tbreak;\n\tdefault:\n\t\tusage();\n\t}ARGEND;\n\n\tgitinit();\n\trefs = nil;\n\tif((nrefs = listrefs(&refs, &names)) == -1)\n\t\tsysfatal(\"load refs: %r\");\n\tif((fd = create(TMPPATH(\"pack.tmp\"), OWRITE, 0644)) == -1)\n\t\tsysfatal(\"open %s: %r\", TMPPATH(\"pack.tmp\"));\n\tif(writepack(fd, refs, nrefs, nil, 0, &h) == -1)\n\t\tsysfatal(\"writepack: %r\");\n\tif(indexpack(TMPPATH(\"pack.tmp\"), TMPPATH(\"idx.tmp\"), h) == -1)\n\t\tsysfatal(\"indexpack: %r\");\n\tclose(fd);\n\n\tnulldir(&rn);\n\trn.name = path;\n\tsnprint(path, sizeof(path), \"%H.pack\", h);\n\tif(dirwstat(TMPPATH(\"pack.tmp\"), &rn) == -1)\n\t\tsysfatal(\"rename pack: %r\");\n\tsnprint(path, sizeof(path), \"%H.idx\", h);\n\tif(dirwstat(TMPPATH(\"idx.tmp\"), &rn) == -1)\n\t\tsysfatal(\"rename pack: %r\");\n\tif(cleanup(h) == -1)\n\t\tsysfatal(\"cleanup: %r\");\n\texits(nil);\n}\n", "source": "git9/repack.c", "file_type": "c"}
{"text": "#!/bin/rc -e\nrfork ne\n. /sys/lib/git/common.rc\n\nflagfmt='u:upstream upstream,b:branch branch'; args='name'\neval `''{aux/getflags $*} || exec aux/usage\n\ndir=$1\nif(~ $#dir 0)\n\tdir=.\nif(~ $#branch 0)\n\tbranch=front\nif(test -e $dir/.git)\n\tdie $dir/.git already exists\nname=`{basename `{cleanname -d `{pwd} $dir}}\nif(~ $#upstream 0){\n\tupstream=`{git/conf 'defaults \"origin\".baseurl'}\n\tif(! ~ $#upstream 0)\n\t\tupstream=$upstream/$name\n}\n\nmkdir -p $dir/.git/refs/^(heads remotes)\nmkdir -p $dir/.git/^(fs objects)\n>$dir/.git/config {\n\techo '[core]'\n\techo '\trepositoryformatversion = p9.0'\n\tif(! ~ $#upstream 0){\n\t\techo '[remote \"origin\"]'\n\t\techo '\turl = '$upstream\n\t}\n\techo '[branch \"'$branch'\"]'\n\techo '\tremote = origin'\n}\n>$dir/.git/INDEX9\n>$dir/.git/HEAD {\n\techo ref: refs/heads/$branch\n}\n\nexit ''\n", "source": "git9/init", "file_type": "rc"}
{"text": "#!/bin/rc\nrfork en\n. /sys/lib/git/common.rc\n\ngitup\n\nflagfmt='c:query query' args='file ...'\nif (! eval `''{aux/getflags $*} || ~ $#* 0)\n\texec aux/usage\n\nif(~ $#query 0)\n\tquery=HEAD\ncommit=`{git/query -p $query}\n\nfiles=`$nl{cleanname -d $gitrel $* | drop $gitroot}\nfor(f in `$nl{git/walk -c -fRM -b $query $files}){\n\tmkdir -p `{basename -d $f}\n\tcp -x -- $commit/tree/$f $f\n\ttouch $f\n\tgit/add $f\n}\nexit ''\n", "source": "git9/revert", "file_type": "rc"}
{"text": "#!/bin/rc -e\nrfork ne\n. /sys/lib/git/common.rc\n\nfn findbranch{\n\tbranch=`{git/branch}\n\tif(test -e $gitfs/branch/$branch/tree){\n\t\trefpath=.git/refs/$branch\n\t\tinitial=false\n\t}\n\tif not if(test -e $gitfs/object/$branch/tree){\n\t\trefpath=.git/HEAD\n\t\tinitial=false\n\t}\n\tif not if(! test -e $gitfs/HEAD/tree){\n\t\trefpath=.git/refs/$branch\n\t\tinitial=true\n\t}\n\tif not\n\t\tdie 'invalid branch:' $branch\n}\n\n# Remove commentary lines.\n# Remove leading and trailing empty lines.\n# Combine consecutive empty lines between paragraphs.\n# Remove trailing spaces from lines.\n# Ensure there's trailing newline.\nfn cleanmsg{\n\tawk '\n\t/^[ \t]*#/ {next}\n\t/^[ \t]*$/ {empty = 1; next}\n\n\twet && empty {printf \"\\n\"}\n\t{wet = 1; empty = 0}\n\t{sub(/[ \t]+$/, \"\"); print $0}\n\t'\n}\n\nfn editmsg{\n\tif(! test -s $msgfile.tmp){\n\t\t>$msgfile.tmp {\n\t\t\techo '# Author:' $name '<'$email'>'\n\t\t\techo '#'\n\t\t\tfor(p in $parents)\n\t\t\t\techo '# parent:' $p\n\t\t\tgit/walk -fAMR $files | subst '^' '# '\n\t\t\techo '#'\n\t\t\techo '# Commit message:'\n\t\t}\n\t\tedit=1\n\t}\n\tif(! ~ $#edit 0){\n\t\tgiteditor=`{git/conf core.editor}\n\t\tif(~ $#editor 0)\n\t\t\teditor=$giteditor\n\t\tif(~ $#editor 0)\n\t\t\teditor=hold\n\t\t$editor $msgfile.tmp\n\t}\n\tcleanmsg < $msgfile.tmp > $msgfile\n\tif(! test -s $msgfile)\n\t\tdie 'empty commit message'\n}\n\nfn parents{\n\tif(! ~ $#revise 0)\n\t\tparents=`{cat $gitfs/HEAD/parent}\n\tif not if(test -f .git/merge-parents)\n\t\tparents=`{cat .git/merge-parents | sort | uniq}\n\tif not if(~ $initial true)\n\t\tparents=()\n\tif not\n\t\tparents=`{git/query $branch}\n}\n\nfn commit{\n\tmsg=`''{cat $msgfile}\n\tif(! ~ $#parents 0)\n\t\tpflags='-p'^$parents\n\thash=`{git/save -n $\"name -e $\"email -m $\"msg $pflags $files || die $status}\n\trm -f .git/merge-parents\n}\n\nfn update{\n\tmkdir -p `{basename -d $refpath}\n\t# Paranoia: let's not mangle the repo.\n\tif(~ $#hash 0)\n\t\tdie 'botched commit'\n\techo $branch: $hash\n\techo $hash > $refpath\n\tfor(f in $files){\n\t\tif(! test -e $f && ! test -e .git/object/$hash/tree/$f)\n\t\t\techo R NOQID 0 $f >> .git/INDEX9\n\t\tif not\n\t\t\techo T NOQID 0 $f >> .git/INDEX9\n\t}\n}\n\nfn sigexit{\n\tif(! ~ $#msgfile 0)\n\t\trm -f $msgfile $msgfile.tmp\n}\n\ngitup\n\nflagfmt='m:msg message, r:revise, e:edit'; args='[file ...]'\neval `''{aux/getflags $*} || exec aux/usage\n\nmsgfile=/tmp/git-msg.$pid\nif(~ $#msg 1)\n\techo $msg >$msgfile.tmp\nif not if(~ $#revise 1){\n\tmsg=1\n\techo revising commit `{cat $gitfs/HEAD/hash}\n\tcat $gitfs/HEAD/msg >$msgfile.tmp\n}\n\nfiles=()\nif(test -f .git/merge-parents)\n\tfiles=`$nl{git/query -c `{cat .git/merge-parents} | sed 's/^..//'}\nif(! ~ $#* 0)\n\tfiles=($files `$nl{git/walk -c `$nl{cleanname -d $gitrel $*}})\nif(~ $status '' || ~ $#files 0 && ! test -f .git/merge-parents && ~ $#revise 0)\n\tdie 'nothing to commit'\n@{\n\tflag e +\n\twhoami\n\tfindbranch\n\tparents\n\teditmsg\n\tcommit\n\tupdate\n} || die 'could not commit:' $status\nexit ''\n", "source": "git9/commit", "file_type": "rc"}
{"text": "</$objtype/mkfile\n\nBIN=/$objtype/bin/git\nTARG=\\\n\tconf\\\n\tget\\\n\tfs\\\n\tlog\\\n\tquery\\\n\trepack\\\n\tsave\\\n\tsend\\\n\tserve\\\n\twalk\n\nRC=\\\n\tadd\\\n\tbranch\\\n\tclone\\\n\tcommit\\\n\tcompat\\\n\tdiff\\\n\texport\\\n\thist\\\n\timport\\\n\tinit\\\n\tmerge\\\n\tpull\\\n\tpush\\\n\trebase\\\n\trevert\\\n\trm\n\nOFILES=\\\n\tdelta.$O\\\n\tobjset.$O\\\n\tols.$O\\\n\tpack.$O\\\n\tproto.$O\\\n\tutil.$O\\\n\tref.$O\n\nHFILES=git.h\n\n</sys/src/cmd/mkmany\n\n# Override install target to install rc.\ninstall:V:\n\tmkdir -p $BIN\n\tmkdir -p /sys/lib/git\n\tfor (i in $TARG)\n\t\tmk $MKFLAGS $i.install\n\tfor (i in $RC)\n\t\tmk $MKFLAGS $i.rcinstall\n\n%.rcinstall:V:\n\tcp $stem $BIN/$stem\n\tchmod +x $BIN/$stem\n", "source": "git9/mkfile", "file_type": "mkfile"}
{"text": "nl='\n'\n\nfn die{\n\t>[1=2] echo $0: $*\n\texit $\"*\n}\n\nfn usage{\n\t>[1=2] echo -n 'usage:' $usage\n\texit 'usage'\n}\n\nfn subst {\n\tawk '\n\tBEGIN{ARGC=0}\n\t{sub(ARGV[1], ARGV[2]); print}\n\t' $*\n}\n\nfn drop {\n\tawk '\n\tBEGIN{ARGC=0}\n\t{\n\t\tif(index($0, ARGV[1]) == 1)\n\t\t\t$0=substr($0, length(ARGV[1])+1)\n\t\tprint\n\t}\n\t' $*\n}\n\nfn mergeperm {\n\tif(~ $1 /dev/null && cmp $2 $3>/dev/null)\n\t\tstatus=gone\n\tif not if (~ $3 /dev/null && cmp $1 $2>/dev/null)\n\t\tstatus=gone\n\tif not {\n\t\tmergedperms='-x'\n\t\tif(test -x $2){\n\t\t\tif(test -x $1 -a -x $3)\n\t\t\t\tmergedperms='+x'\n\t\t}\n\t\tif not{\n\t\t\tif(test -x $1 -o -x $3)\n\t\t\t\tmergedperms='+x'\n\t\t}\n\t\tstatus=()\n\t}\n}\n\nfn whoami{\n\tname=`$nl{git/conf user.name}\n\temail=`$nl{git/conf user.email}\n\tif(test -f /adm/keys.who){\n\t\tif(~ $name '')\n\t\t\tname=`$nl{awk -F'|' '$1==\"'$user'\" {x=$3} END{print x}' </adm/keys.who}\n\t\tif(~ $email '')\n\t\t\temail=`$nl{awk -F'|' '$1==\"'$user'\" {x=$5} END{print x}' </adm/keys.who}\n\t}\n\tif(~ $name '')\n\t\tname=$user\n\tif(~ $email '')\n\t\temail=$user@$sysname\n\tstatus=''\n}\n\n# merge1 out ours base theirs\nfn merge1 {@{\n\trfork e\n\tn=$pid\n\tout=$1\n\tours=$2\n\tbase=$3\n\ttheirs=$4\n\ttmp=$out.tmp\n\twhile(test -f $tmp){\n\t\ttmp=$tmp.$n\n\t\tn=`{echo $n + 1 | hoc}\n\t}\n\n\tif(! test -f $ours)\n\t\tours=/dev/null\n\tif(! test -f $base)\n\t\tbase=/dev/null\n\tif(! test -f $theirs)\n\t\ttheirs=/dev/null\n\n\tif(mergeperm $ours $base $theirs){\n\t\tmkdir -p `{basename -d $tmp}\n\t\tif(! ape/diff3 -3 -m $ours $base $theirs > $tmp)\n\t\t\techo merge needed: $out >[1=2]\n\t\tmv $tmp $out\n\t\tgit/add $out\n\t\tchmod $mergedperms $out\n\t}\n\tif not {\n\t\trm -f $tmp $out\n\t\tgit/rm $out\n\t}\n}}\n\nfn gitup{\n\tgitroot=`$nl{git/conf -r >[2]/dev/null}\n\tif(~ $#gitroot 0)\n\t\tdie 'not a git repository'\n\tgitwork=`$nl{git/conf work.dir}\n\tif(~ $#gitwork 1)\n\t\tbind -c $gitwork/objects $gitroot/.git/objects\n\tif(~ $#workdir 1)\n\t\tbind $workdir .git/objects\n\tgitfs=$gitroot/.git/fs\n\tgitrel=`{pwd | drop $gitroot | sed 's@^/@@'}\n\tif(~ $#gitrel 0)\n\t\tgitrel='.'\n\tif(! cd $gitroot)\n\t\tdie cd $gitroot: no repo there\n\tstartfs=()\n\tmkdir -p $gitfs\n\tif(! test -e $gitfs/ctl)\n\t\tstartfs=true\n\tif(! grep -s '^repo '$gitroot'$' $gitfs/ctl >[2]/dev/null)\n\t\tstartfs=true\n\tif(~ $#startfs 1)\n\t\tgit/fs\n\tif not\n\t\tstatus=''\n}\n", "source": "git9/common.rc", "file_type": "rc"}
{"text": "#include <u.h>\n#include <libc.h>\n\n#include \"git.h\"\n\ntypedef struct Capset\tCapset;\ntypedef struct Map\tMap;\n\nstruct Capset {\n\tint\tsideband;\n\tint\tsideband64k;\n\tint\treport;\n};\n\nstruct Map {\n\tchar\t*ref;\n\tHash\tours;\n\tHash\ttheirs;\n};\n\nint sendall;\nint force;\nint nbranch;\nchar **branch;\nchar *removed[128];\nint nremoved;\nint npacked;\nint nsent;\n\nint\nfindref(char **r, int nr, char *ref)\n{\n\tint i;\n\tfor(i = 0; i < nr; i++)\n\t\tif(strcmp(r[i], ref) == 0)\n\t\t\treturn i;\n\treturn -1;\n}\n\nint\nfindkey(Map *m, int nm, char *ref)\n{\n\tint i;\n\tfor(i = 0; i < nm; i++)\n\t\tif(strcmp(m[i].ref, ref) == 0)\n\t\t\treturn i;\n\treturn -1;\n}\n\nint\nreadours(Hash **tailp, char ***refp)\n{\n\tint nu, i, idx;\n\tchar *r, *pfx, **ref;\n\tHash *tail;\n\n\tif(sendall)\n\t\treturn listrefs(tailp, refp);\n\tnu = 0;\n\ttail = eamalloc((nremoved + nbranch), sizeof(Hash));\n\tref = eamalloc((nremoved + nbranch), sizeof(char*));\n\tfor(i = 0; i < nbranch; i++){\n\t\tref[nu] = estrdup(branch[i]);\n\t\tif(resolveref(&tail[nu], branch[i]) == -1)\n\t\t\tsysfatal(\"broken branch %s\", branch[i]);\n\t\tnu++;\n\t}\n\tfor(i = 0; i < nremoved; i++){\n\t\tpfx = \"refs/heads/\";\n\t\tif(strstr(removed[i], \"heads/\") == removed[i])\n\t\t\tpfx = \"refs/\";\n\t\tif(strstr(removed[i], \"refs/heads/\") == removed[i])\n\t\t\tpfx = \"\";\n\t\tif((r = smprint(\"%s%s\", pfx, removed[i])) == nil)\n\t\t\tsysfatal(\"smprint: %r\");\n\t\tif((idx = findref(ref, nu, r)) == -1)\n\t\t\tidx = nu++;\n\t\telse\n\t\t\tfree(ref[idx]);\n\t\tassert(idx < nremoved + nbranch);\n\t\tmemcpy(&tail[idx], &Zhash, sizeof(Hash));\n\t\tref[idx] = r;\n\t}\n\tdprint(1, \"nu: %d\\n\", nu);\n\tfor(i = 0; i < nu; i++)\n\t\tdprint(1, \"update: %H %s\\n\", tail[i], ref[i]);\n\t*tailp = tail;\n\t*refp = ref;\n\treturn nu;\t\n}\n\nchar *\nmatchcap(char *s, char *cap, int full)\n{\n\tif(strncmp(s, cap, strlen(cap)) == 0)\n\t\tif(!full || strlen(s) == strlen(cap))\n\t\t\treturn s + strlen(cap);\n\treturn nil;\n}\n\nvoid\nparsecaps(char *caps, Capset *cs)\n{\n\tchar *p, *n;\n\n\tfor(p = caps; p != nil; p = n){\n\t\tn = strchr(p, ' ');\n\t\tif(n != nil)\n\t\t\t*n++ = 0;\n\t\tif(matchcap(p, \"report-status\", 1) != nil)\n\t\t\tcs->report = 1;\n\t\tif(matchcap(p, \"side-band\", 1) != nil)\n\t\t\tcs->sideband = 1;\n\t\tif(matchcap(p, \"side-band-64k\", 1) != nil)\n\t\t\tcs->sideband64k = 1;\n\t}\n}\n\nint\nsendpack(Conn *c)\n{\n\tint i, n, idx, nsp, send, first;\n\tint nours, ntheirs, nmap;\n\tchar buf[Pktmax], *sp[3];\n\tHash h, *theirs, *ours;\n\tObject *a, *b, *p, *o;\n\tchar **refs;\n\tCapset cs;\n\tMap *map, *m;\n\n\tfirst = 1;\n\tmemset(&cs, 0, sizeof(Capset));\n\tnours = readours(&ours, &refs);\n\ttheirs = nil;\n\tntheirs = 0;\n\tnmap = nours;\n\tmap = eamalloc(nmap, sizeof(Map));\n\tfor(i = 0; i < nmap; i++){\n\t\tmap[i].theirs = Zhash;\n\t\tmap[i].ours = ours[i];\n\t\tmap[i].ref = refs[i];\n\t}\n\twhile(1){\n\t\tn = readpkt(c, buf, sizeof(buf));\n\t\tif(n == -1)\n\t\t\treturn -1;\n\t\tif(n == 0)\n\t\t\tbreak;\n\t\tif(first && n > strlen(buf))\n\t\t\tparsecaps(buf + strlen(buf) + 1, &cs);\n\t\tfirst = 0;\n\n\t\tif(getfields(buf, sp, nelem(sp), 1, \" \\t\\r\\n\") != 2)\n\t\t\tsysfatal(\"invalid ref line %.*s\", utfnlen(buf, n), buf);\n\t\ttheirs = earealloc(theirs, ntheirs+1, sizeof(Hash));\n\t\tif(hparse(&theirs[ntheirs], sp[0]) == -1)\n\t\t\tsysfatal(\"invalid hash %s\", sp[0]);\n\t\tif((idx = findkey(map, nmap, sp[1])) != -1)\n\t\t\tmap[idx].theirs = theirs[ntheirs];\n\t\t/*\n\t\t * we only keep their ref if we can read the object to add it\n\t\t * to our reachability; otherwise, discard it; we only care\n\t\t * that we don't have it, so we can tell whether we need to\n\t\t * bail out of pushing.\n\t\t */\n\t\tif((o = readobject(theirs[ntheirs])) != nil){\n\t\t\tntheirs++;\n\t\t\tunref(o);\n\t\t}\n\t}\n\n\tif(writephase(c) == -1)\n\t\treturn -1;\n\tsend = 0;\n\tif(force)\n\t\tsend=1;\n\tfor(i = 0; i < nmap; i++){\n\t\tm = &map[i];\n\t\ta = readobject(m->theirs);\n\t\tif(hasheq(&m->ours, &Zhash))\n\t\t\tb = nil;\n\t\telse\n\t\t\tb = readobject(m->ours);\n\t\tp = nil;\n\t\tif(a != nil && b != nil)\n\t\t\tp = ancestor(a, b);\n\t\tif(!force\n\t\t&& !hasheq(&m->theirs, &Zhash)\n\t\t&& !hasheq(&m->ours, &Zhash)\n\t\t&& (a == nil || p != a)){\n\t\t\tfprint(2, \"remote has diverged\\n\");\n\t\t\twerrstr(\"remote diverged\");\n\t\t\tflushpkt(c);\n\t\t\treturn -1;\n\t\t}\n\t\tunref(a);\n\t\tunref(b);\n\t\tunref(p);\n\t\tif(hasheq(&m->theirs, &m->ours)){\n\t\t\tprint(\"uptodate %s\\n\", m->ref);\n\t\t\tcontinue;\n\t\t}\n\t\tprint(\"update %s %H %H\\n\", m->ref, m->theirs, m->ours);\n\t\tn = snprint(buf, sizeof(buf), \"%H %H %s\", m->theirs, m->ours, m->ref);\n\n\t\t/*\n\t\t * Workaround for github.\n\t\t *\n\t\t * Github will accept the pack but fail to update the references\n\t\t * if we don't have capabilities advertised. Report-status seems\n\t\t * harmless to add, so we add it.\n\t\t *\n\t\t * Github doesn't advertise any capabilities, so we can't check\n\t\t * for compatibility. We just need to add it blindly.\n\t\t */\n\t\tif(i == 0 && cs.report){\n\t\t\tbuf[n++] = '\\0';\n\t\t\tn += snprint(buf + n, sizeof(buf) - n, \" report-status\");\n\t\t}\n\t\tif(writepkt(c, buf, n) == -1)\n\t\t\tsysfatal(\"unable to send update pkt\");\n\t\tsend = 1;\n\t}\n\tflushpkt(c);\n\tif(!send){\n\t\tfprint(2, \"nothing to send\\n\");\n\t\treturn 0;\n\t}\n\n\tif(writepack(c->wfd, ours, nours, theirs, ntheirs, &h) == -1)\n\t\treturn -1;\n\tif(!cs.report)\n\t\treturn 0;\n\n\tif(readphase(c) == -1)\n\t\treturn -1;\n\t/* We asked for a status report, may as well use it. */\n\twhile((n = readpkt(c, buf, sizeof(buf))) > 0){\n \t\tbuf[n] = 0;\n\t\tif(chattygit)\n\t\t\tfprint(2, \"done sending pack, status %s\\n\", buf);\n\t\tnsp = getfields(buf, sp, nelem(sp), 1, \" \\t\\n\\r\");\n\t\tif(nsp < 2) \n\t\t\tcontinue;\n\t\tif(nsp < 3)\n\t\t\tsp[2] = \"\";\n\t\t/*\n\t\t * Only report errors; successes will be reported by\n\t\t * surrounding scripts.\n\t\t */\n\t\tif(strcmp(sp[0], \"unpack\") == 0 && strcmp(sp[1], \"ok\") != 0)\n\t\t\tfprint(2, \"unpack %s\\n\", sp[1]);\n\t\telse if(strcmp(sp[0], \"ng\") == 0)\n\t\t\tfprint(2, \"failed update: %s\\n\", sp[1]);\n\t\telse\n\t\t\tcontinue;\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nvoid\nusage(void)\n{\n\tfprint(2, \"usage: %s remote [reponame]\\n\", argv0);\n\texits(\"usage\");\n}\n\nvoid\nmain(int argc, char **argv)\n{\n\tchar *br;\n\tConn c;\n\n\tARGBEGIN{\n\tdefault:\n\t\tusage();\n\t\tbreak;\n\tcase 'd':\n\t\tchattygit++;\n\t\tbreak;\n\tcase 'f':\n\t\tforce++;\n\t\tbreak;\n\tcase 'r':\n\t\tif(nremoved == nelem(removed))\n\t\t\tsysfatal(\"too many deleted branches\");\n\t\tremoved[nremoved++] = EARGF(usage());\n\t\tbreak;\n\tcase 'a':\n\t\tsendall++;\n\t\tbreak;\n\tcase 'b':\n\t\tbr = EARGF(usage());\n\t\tif(strncmp(br, \"refs/heads/\", strlen(\"refs/heads/\")) == 0)\n\t\t\tbr = smprint(\"%s\", br);\n\t\telse if(strncmp(br, \"heads/\", strlen(\"heads/\")) == 0)\n\t\t\tbr = smprint(\"refs/%s\", br);\n\t\telse\n\t\t\tbr = smprint(\"refs/heads/%s\", br);\n\t\tbranch = erealloc(branch, (nbranch + 1)*sizeof(char*));\n\t\tbranch[nbranch] = br;\n\t\tnbranch++;\n\t\tbreak;\n\t}ARGEND;\n\n\tgitinit();\n\tif(argc != 1)\n\t\tusage();\n\tif(gitconnect(&c, argv[0], \"receive\") == -1)\n\t\tsysfatal(\"git connect: %s: %r\", argv[0]);\n\tif(sendpack(&c) == -1)\n\t\tsysfatal(\"send failed: %r\");\n\tcloseconn(&c);\n\texits(nil);\n}\n", "source": "git9/send.c", "file_type": "c"}
{"text": "#include <u.h>\n#include <libc.h>\n#include \"git.h\"\n\ntypedef struct Seen\tSeen;\ntypedef struct Idxed\tIdxed;\ntypedef struct Idxent\tIdxent;\n\n#define NCACHE 4096\n\nenum {\n\tRflg\t= 1 << 0,\n\tMflg\t= 1 << 1,\n\tAflg\t= 1 << 2,\n\tUflg\t= 1 << 3,\n\t/* everything after this is not an error */\n\tTflg\t= 1 << 4,\n};\n\nstruct Seen {\n\tDir*\tcache;\n\tint\tn;\n\tint\tmax;\n};\n\nstruct Idxed {\n\tchar**\tcache;\n\tint\tn;\n\tint\tmax;\n};\n\nSeen\tseentab[NCACHE];\nIdxed\tidxtab[NCACHE];\nchar\trepopath[1024];\nchar\twdirpath[1024];\nchar\t*rstr\t= \"R \";\nchar\t*mstr\t= \"M \";\nchar\t*astr\t= \"A \";\nchar\t*ustr\t= \"U \";\nchar\t*tstr \t= \"T \";\nchar\t*bdir = \".git/fs/HEAD/tree\";\nint\tuseidx\t= 1;\nint\tnrel;\nint\tquiet;\nint\tdirty;\nint\tprintflg;\n\nIdxent\t*idx;\nint\tidxsz;\nint\tnidx;\nint\tstaleidx;\nIdxent\t*wdir;\nint\twdirsz;\nint\tnwdir;\n\nint\tloadwdir(char*);\n\nint\nseen(Dir *dir)\n{\n\tSeen *c;\n\tDir *dp;\n\tint i;\n\n\tc = &seentab[dir->qid.path&(NCACHE-1)];\n\tdp = c->cache;\n\tfor(i=0; i<c->n; i++, dp++)\n\t\tif(dir->qid.path == dp->qid.path\n\t\t&& dir->qid.type == dp->qid.type\n\t\t&& dir->dev == dp->dev)\n\t\t\treturn 1;\n\tif(c->n == c->max){\n\t\tif (c->max == 0)\n\t\t\tc->max = 8;\n\t\telse\n\t\t\tc->max += c->max/2;\n\t\tc->cache = realloc(c->cache, c->max*sizeof(Dir));\n\t\tif(c->cache == nil)\n\t\t\tsysfatal(\"realloc: %r\");\n\t}\n\tc->cache[c->n++] = *dir;\n\treturn 0;\n}\n\nint\ncheckedin(Idxent *e, int change)\n{\n\tchar *p;\n\tint r;\n\n\tp = smprint(\"%s/%s\", bdir, e->path);\n\tr = access(p, AEXIST);\n\tif(r == 0 && change){\n\t\tif(e->state != 'R')\n\t\t\te->state = 'T';\n\t\tstaleidx = 1;\n\t}\n\tfree(p);\n\treturn r == 0;\n}\n\nint\nindexed(char *path, int isdir)\n{\n\tint lo, hi, mid, n, r;\n\tchar *s;\n\n\tif(!useidx){\n\t\ts = smprint(\"%s/%s\", bdir, path);\n\t\tr = access(s, AEXIST);\n\t\tfree(s);\n\t\treturn r == 0;\n\t}\n\ts = path;\n\tif(isdir)\n\t\ts = smprint(\"%s/\", path);\n\tr = -1;\n\tlo = 0;\n\thi = nidx-1;\n\tn = strlen(s);\n\twhile(lo <= hi){\n\t\tmid = (hi + lo) / 2;\n\t\tif(isdir)\n\t\t\tr = strncmp(s, idx[mid].path, n);\n\t\telse\n\t\t\tr = strcmp(s, idx[mid].path);\n\t\tif(r < 0)\n\t\t\thi = mid-1;\n\t\telse if(r > 0)\n\t\t\tlo = mid+1;\n\t\telse\n\t\t\tbreak;\n\t}\n\tif(isdir)\n\t\tfree(s);\n\treturn r == 0;\n}\n\nint\nidxcmp(void *pa, void *pb)\n{\n\tIdxent *a, *b;\n\tint c;\n\n\ta = (Idxent*)pa;\n\tb = (Idxent*)pb;\n\tif((c = strcmp(a->path, b->path)) != 0)\n\t\treturn c;\n\t/* order is unique */\n\treturn a-> order < b->order ? -1 : 1;\n}\n\n/*\n * compares whether the indexed entry 'a'\n * has the same contents and mode as\n * the entry on disk 'b'; if the indexed\n * entry is nil, does a deep comparison\n * of the checked out file and the file\n * checked in.\n */\nint\nsamedata(Idxent *a, Idxent *b)\n{\n\tchar *gitpath, ba[IOUNIT], bb[IOUNIT];\n\tint fa, fb, na, nb, same;\n\tDir *da, *db;\n\n\tif(a != nil){\n\t\tif(a->qid.path == b->qid.path\n\t\t&& a->qid.vers == b->qid.vers\n\t\t&& a->qid.type == b->qid.type\n\t\t&& a->mode == b->mode\n\t\t&& a->mode != 0)\n\t\t\treturn 1;\n\t}\n\n\tsame = 0;\n\tda = nil;\n\tdb = nil;\n\tif((gitpath = smprint(\"%s/%s\", bdir, b->path)) == nil)\n\t\tsysfatal(\"smprint: %r\");\n\tfa = open(gitpath, OREAD);\n\tfb = open(b->path, OREAD);\n\tif(fa == -1 || fb == -1)\n\t\tgoto mismatch;\n\tda = dirfstat(fa);\n\tdb = dirfstat(fb);\n\tif(da == nil || db == nil)\n\t\tgoto mismatch;\n\tif((da->mode&0100) != (db->mode&0100))\n\t\tgoto mismatch;\n\tif(da->length != db->length)\n\t\tgoto mismatch;\n\twhile(1){\n\t\tif((na = readn(fa, ba, sizeof(ba))) == -1)\n\t\t\tgoto mismatch;\n\t\tif((nb = readn(fb, bb, sizeof(bb))) == -1)\n\t\t\tgoto mismatch;\n\t\tif(na != nb)\n\t\t\tgoto mismatch;\n\t\tif(na == 0)\n\t\t\tbreak;\n\t\tif(memcmp(ba, bb, na) != 0)\n\t\t\tgoto mismatch;\n\t}\n\tif(a != nil){\n\t\ta->qid = db->qid;\n\t\ta->mode = db->mode;\n\t\tstaleidx = 1;\n\t}\n\tsame = 1;\n\nmismatch:\n\tfree(da);\n\tfree(db);\n\tif(fa != -1)\n\t\tclose(fa);\n\tif(fb != -1)\n\t\tclose(fb);\n\treturn same;\n}\n\nint\nloadent(char *dir, Dir *d, int fullpath)\n{\n\tchar *path;\n\tint ret, isdir;\n\tIdxent *e;\n\n\tif(fullpath)\n\t\tpath = strdup(dir);\n\telse\n\t\tpath = smprint(\"%s/%s\", dir, d->name);\n\tif(path == nil)\n\t\tsysfatal(\"smprint: %r\");\n\n\tcleanname(path);\n\tif(strncmp(path, \".git/\", 5) == 0){\n\t\tfree(path);\n\t\treturn 0;\n\t}\n\tret = 0;\n\tisdir = d->qid.type & QTDIR;\n\tif((printflg & Uflg) == 0 && !indexed(path, isdir)){\n\t\tfree(path);\n\t\treturn 0;\n\t}\n\tif(isdir){\n\t\tret = loadwdir(path);\n\t\tfree(path);\n\t}else{\n\t\tif(nwdir == wdirsz){\n\t\t\twdirsz += wdirsz/2;\n\t\t\twdir = erealloc(wdir, wdirsz*sizeof(Idxent));\n\t\t}\n\t\te = wdir + nwdir;\n\t\te->path = path;\n\t\te->qid = d->qid;\n\t\te->mode = d->mode;\n\t\te->order = nwdir;\n\t\te->state = 'T';\n\t\tnwdir++;\n\t}\n\treturn ret;\n}\n\nint\nloadwdir(char *path)\n{\n\tint fd, ret, i, n;\n\tDir *d, *e;\n\n\td = nil;\n\te = nil;\n\tret = -1;\n\tcleanname(path);\n\tif(strncmp(path, \".git/\", 5) == 0)\n\t\treturn 0;\n\tif((fd = open(path, OREAD)) < 0)\n\t\tgoto error;\n\tif((e = dirfstat(fd)) == nil)\n\t\tsysfatal(\"fstat: %r\");\n\tif(e->qid.type & QTDIR)\n\t\twhile((n = dirread(fd, &d)) > 0){\n\t\t\tfor(i = 0; i < n; i++)\n\t\t\t\tif(loadent(path, &d[i], 0) == -1)\n\t\t\t\t\tgoto error;\n\t\t\tfree(d);\n\t\t}\n\telse{\n\t\tif(loadent(path, e, 1) == -1)\n\t\t\tgoto error;\n\t}\n\tret = 0;\nerror:\n\tfree(e);\n\tif(fd != -1)\n\t\tclose(fd);\n\treturn ret;\n}\n\nint\npfxmatch(char *p, char **pfx, int *pfxlen, int npfx)\n{\n\tint i;\n\n\tif(p == nil)\n\t\treturn 0;\n\tif(npfx == 0)\n\t\treturn 1;\n\tfor(i = 0; i < npfx; i++){\n\t\tif(strncmp(p, pfx[i], pfxlen[i]) != 0)\n\t\t\tcontinue;\n\t\tif(p[pfxlen[i]] == '/' || p[pfxlen[i]] == 0)\n\t\t\treturn 1;\n\t\tif(strcmp(pfx[i], \".\") == 0 || *pfx[i] == 0)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n\nchar*\nreporel(char *s)\n{\n\tchar *p;\n\tint n;\n\n\tif(*s == '/')\n\t\ts = strdup(s);\n\telse\n\t\ts = smprint(\"%s/%s\", wdirpath, s);\n\tp = cleanname(s);\n\tn = strlen(repopath);\n\tif(strncmp(s, repopath, n) != 0)\n\t\tsysfatal(\"path outside repo: %s\", s);\n\tp += n;\n\tif(*p == '/')\n\t\tp++;\n\tmemmove(s, p, strlen(p)+1);\n\treturn s;\n}\n\nvoid\nshow(Biobuf *o, int flg, char *str, char *path)\n{\n\tdirty |= flg;\n\tif(!quiet && (printflg & flg))\n\t\tBprint(o, \"%s%s\\n\", str, path);\n}\n\nvoid\nusage(void)\n{\n\tfprint(2, \"usage: %s [-qbc] [-f filt] [-b base] [paths...]\\n\", argv0);\n\texits(\"usage\");\n}\n\nvoid\nmain(int argc, char **argv)\n{\n\tchar *p, *e, *ln, *base, **argrel, *parts[4], xbuf[8];\n\tint i, j, c, line, wfd, *argn;\n\tBiobuf *f, *o, *w;\n\tHash h, hd;\n\tDir rn;\n\n\tgitinit();\n\tif(access(\".git/fs/ctl\", AEXIST) != 0)\n\t\tsysfatal(\"no running git/fs\");\n\tif(getwd(wdirpath, sizeof(wdirpath)) == nil)\n\t\tsysfatal(\"getwd: %r\");\n\tif(findrepo(repopath, sizeof(repopath), &nrel) == -1)\n\t\tsysfatal(\"find root: %r\");\n\tif(chdir(repopath) == -1)\n\t\tsysfatal(\"chdir: %r\");\n\n\tARGBEGIN{\n\tcase 'q':\n\t\tquiet++;\n\t\tbreak;\n\tcase 'c':\n\t\trstr = \"\";\n\t\ttstr = \"\";\n\t\tmstr = \"\";\n\t\tastr = \"\";\n\t\tustr = \"\";\n\t\tbreak;\n\tcase 'f':\n\t\tfor(p = EARGF(usage()); *p; p++)\n\t\t\tswitch(*p){\n\t\t\tcase 'T':\tprintflg |= Tflg;\tbreak;\n\t\t\tcase 'A':\tprintflg |= Aflg;\tbreak;\n\t\t\tcase 'M':\tprintflg |= Mflg;\tbreak;\n\t\t\tcase 'R':\tprintflg |= Rflg;\tbreak;\n\t\t\tcase 'U':\tprintflg |= Uflg;\tbreak;\n\t\t\tdefault:\tusage();\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 'b':\n\t\tuseidx = 0;\n\t\tbase = EARGF(usage());\n\t\tif(resolveref(&h, base) == -1)\n\t\t\tsysfatal(\"no such ref '%s'\", base);\n\t\t/* optimization: we're a lot faster when using the index */\n\t\tif(resolveref(&hd, \"HEAD\") == 0 && hasheq(&h, &hd))\n\t\t\tuseidx = 1;\n\t\tbdir = smprint(\".git/fs/object/%H/tree\", h);\n\t\tbreak;\n\tdefault:\n\t\tusage();\n\t}ARGEND;\n\n\tif(printflg == 0)\n\t\tprintflg = Tflg | Aflg | Mflg | Rflg;\n\n\tnidx = 0;\n\tidxsz = 32;\n\tidx = emalloc(idxsz*sizeof(Idxent));\n\tnwdir = 0;\n\twdirsz = 32;\n\twdir = emalloc(wdirsz*sizeof(Idxent));\n\targrel = emalloc(argc*sizeof(char*));\n\targn = emalloc(argc*sizeof(int));\n\tfor(i = 0; i < argc; i++){\n\t\targrel[i] = reporel(argv[i]);\n\t\targn[i] = strlen(argrel[i]);\n\t}\n\tif((o = Bfdopen(1, OWRITE)) == nil)\n\t\tsysfatal(\"open out: %r\");\n\tif(useidx){\n\t\tif((f = Bopen(\".git/INDEX9\", OREAD)) == nil){\n\t\t\tfprint(2, \"open index: %r\\n\");\n\t\t\tif(access(\".git/index9\", AEXIST) == 0){\n\t\t\t\tfprint(2, \"index format conversion needed:\\n\");\n\t\t\t\tfprint(2, \"\\tcd %s && git/fs\\n\", repopath);\n\t\t\t\tfprint(2, \"\\t@{cd .git/index9/removed >[2]/dev/null && walk -f | sed 's/^/R NOQID 0 /'} >> .git/INDEX9\\n\");\n\t\t\t\tfprint(2, \"\\t@{cd .git/fs/HEAD/tree && walk -f | sed 's/^/T NOQID 0 /'} >> .git/INDEX9\\n\");\n\t\t\t}\n\t\t\texits(\"noindex\");\n\t\t}\n\t\tline = 0;\n\t\twhile((ln = Brdstr(f, '\\n', 1)) != nil){\n\t\t\tline++;\n\t\t\t/* allow blank lines */\n\t\t\tif(ln[0] == 0 || ln[0] == '\\n')\n\t\t\t\tcontinue;\n\t\t\tif(getfields(ln, parts, nelem(parts), 0, \" \\t\") != nelem(parts))\n\t\t\t\tsysfatal(\".git/INDEX9:%d: corrupt index\", line);\n\t\t\tif(nidx == idxsz){\n\t\t\t\tidxsz += idxsz/2;\n\t\t\t\tidx = realloc(idx, idxsz*sizeof(Idxent));\n\t\t\t}\n\t\t\tcleanname(parts[3]);\n\t\t\tif(strncmp(parts[3], \".git/\", 5) == 0){\n\t\t\t\tstaleidx = 1;\n\t\t\t\tfree(ln);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tidx[nidx].state = *parts[0];\n\t\t\tidx[nidx].qid = parseqid(parts[1]);\n\t\t\tidx[nidx].mode = strtol(parts[2], nil, 8);\n\t\t\tidx[nidx].path = strdup(parts[3]);\n\t\t\tidx[nidx].order = nidx;\n\t\t\tnidx++;\n\t\t\tfree(ln);\n\t\t}\n\t\tqsort(idx, nidx, sizeof(Idxent), idxcmp);\n\t}\n\n\tfor(i = 0; i < argc; i++){\n\t\targrel[i] = reporel(argv[i]);\n\t\targn[i] = strlen(argrel[i]);\n\t}\n\tif(argc == 0)\n\t\tloadwdir(\".\");\n\telse for(i = 0; i < argc; i++)\n\t\tloadwdir(argrel[i]);\n\tqsort(wdir, nwdir, sizeof(Idxent), idxcmp);\n\tfor(i = 0; i < argc; i++){\n\t\targrel[i] = reporel(argv[i]);\n\t\targn[i] = strlen(argrel[i]);\n\t}\n\ti = 0;\n\tj = 0;\n\twhile(i < nidx || j < nwdir){\n\t\t/* find the last entry we tracked for a path */\n\t\twhile(i+1 < nidx && strcmp(idx[i].path, idx[i+1].path) == 0){\n\t\t\tstaleidx = 1;\n\t\t\ti++;\n\t\t}\n\t\twhile(j+1 < nwdir && strcmp(wdir[j].path, wdir[j+1].path) == 0)\n\t\t\tj++;\n\t\tif(i < nidx && !pfxmatch(idx[i].path, argrel, argn, argc)){\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tif(i >= nidx)\n\t\t\tc = 1;\n\t\telse if(j >= nwdir)\n\t\t\tc = -1;\n\t\telse\n\t\t\tc = strcmp(idx[i].path, wdir[j].path);\n\t\t/* exists in both index and on disk */\n\t\tif(c == 0){\n\t\t\tif(idx[i].state == 'R'){\n\t\t\t\tif(checkedin(&idx[i], 0))\n\t\t\t\t\tshow(o, Rflg, rstr, idx[i].path);\n\t\t\t\telse{\n\t\t\t\t\tidx[i].state = 'U';\n\t\t\t\t\tstaleidx = 1;\n\t\t\t\t}\n\t\t\t}else if(idx[i].state == 'A' && !checkedin(&idx[i], 1))\n\t\t\t\tshow(o, Aflg, astr, idx[i].path);\n\t\t\telse if(!samedata(&idx[i], &wdir[j]))\n\t\t\t\tshow(o, Mflg, mstr, idx[i].path);\n\t\t\telse\n\t\t\t\tshow(o, Tflg, tstr, idx[i].path);\n\t\t\ti++;\n\t\t\tj++;\n\t\t/* only exists in index */\n\t\t}else if(c < 0){\n\t\t\tif(checkedin(&idx[i], 0))\n\t\t\t\tshow(o, Rflg, rstr, idx[i].path);\n\t\t\ti++;\n\t\t/* only exists on disk */\n\t\t}else{\n\t\t\tif(!useidx && checkedin(&wdir[j], 0)){\n\t\t\t\tif(samedata(nil, &wdir[j]))\n\t\t\t\t\tshow(o, Tflg, tstr, wdir[j].path);\n\t\t\t\telse\n\t\t\t\t\tshow(o, Mflg, mstr, wdir[j].path);\n\t\t\t}else if(printflg & Uflg && pfxmatch(idx[i].path, argrel, argn, argc))\n\t\t\t\tshow(o, Uflg, ustr, wdir[j].path);\n\t\t\tj++;\n\t\t}\n\t}\n\tBterm(o);\n\n\tif(useidx && staleidx)\n\tif((wfd = create(\".git/INDEX9.new\", OWRITE, 0644)) != -1){\n\t\tif((w = Bfdopen(wfd, OWRITE)) == nil){\n\t\t\tclose(wfd);\n\t\t\tgoto Nope;\n\t\t}\n\t\tfor(i = 0; i < nidx; i++){\n\t\t\twhile(i+1 < nidx && strcmp(idx[i].path, idx[i+1].path) == 0)\n\t\t\t\ti++;\n\t\t\tif(idx[i].state == 'U')\n\t\t\t\tcontinue;\n\t\t\tBprint(w, \"%c %Q %o %s\\n\",\n\t\t\t\tidx[i].state,\n\t\t\t\tidx[i].qid, \n\t\t\t\tidx[i].mode,\n\t\t\t\tidx[i].path);\n\t\t}\n\t\tBterm(w);\n\t\tnulldir(&rn);\n\t\trn.name = \"INDEX9\";\n\t\tif(remove(\".git/INDEX9\") == -1)\n\t\t\tgoto Nope;\n\t\tif(dirwstat(\".git/INDEX9.new\", &rn) == -1)\n\t\t\tsysfatal(\"rename: %r\");\n\t}\n\nNope:\n\tif(!dirty)\n\t\texits(nil);\n\n\tp = xbuf;\n\te = p + sizeof(xbuf);\n\tfor(i = 0; (1 << i) != Tflg; i++)\n\t\tif(dirty & (1 << i))\n\t\t\tp = seprint(p, e, \"%c\", \"RMAUT\"[i]);\n\texits(xbuf);\n}\n", "source": "git9/walk.c", "file_type": "c"}
{"text": "#!/bin/rc -e\nrfork en\n. /sys/lib/git/common.rc\n\ngitup\n\nflagfmt='a:pushall, b:branch branch, f:force, d:debug,\n         r:remove remove, u:upstream upstream' args=''\neval `''{aux/getflags $*} || exec aux/usage\nif(! ~ $#* 0)\n\texec aux/usage\n\nif(~ $pushall 1)\n\tbranch=`$nl{cd .git/refs/heads && walk -f}\nif(~ $#branch 0)\n\tbranch=`{git/branch}\nif(~ $#branch 0)\n\tdie 'no branches'\nif(~ $force 1)\n\tforce=-f\nif(~ $debug 1)\n\tdebug='-d'\n\nif(~ $#upstream 0)\n\tupstream=origin\n\nremotes=`$nl{git/conf -a 'remote \"'$upstream'\".url'}\nif(~ $#remotes 0)\n\tremotes=$upstream\nbranch=-b^$branch\nif(! ~ $#remove 0)\n\tremove=-r^$remove\nfor(remote in $remotes){\n\tupdates=`$nl{git/send $debug $force $branch $remove $remote} || die $status\n\tfor(ln in $updates){\n\t\tu=`{echo $ln}\n\t\trefpath=`{echo $u(2) | subst '^refs/heads/' '.git/refs/remotes/'$upstream'/'}\n\t\tswitch($u(1)){\n\t\tcase update;\n\t\t\tmkdir -p `{basename -d $refpath}\n\t\t\techo $u(4) > $refpath\n\t\t\techo $u(2)^':' $u(3) '=>' $u(4)\n\t\tcase delete;\n\t\t\techo $u(2)^': removed'\n\t\t\trm -f $refpath\n\t\tcase uptodate;\n\t\t\techo $u(2)^': up to date'\n\t\t}\n\t}\n}\nexit ''\n", "source": "git9/push", "file_type": "rc"}
{"text": "#!/bin/rc -e\nrfork ne\n. /sys/lib/git/common.rc\n\nfn merge{\n\tourbr=$gitfs/object/$1/tree\n\tbasebr=$gitfs/object/$2/tree\n\ttheirbr=$gitfs/object/$3/tree\n\n\tall=`$nl{{git/query -c $1 $2; git/query -c $2 $3} | sed 's/^..//' | sort | uniq}\n\tfor(f in $all){\n\t\tours=$ourbr/$f\n\t\tbase=$basebr/$f\n\t\ttheirs=$theirbr/$f\n\t\tmerge1 ./$f $ours $base $theirs\n\t}\n}\n\ngitup\n\nflagfmt=''; args='theirs'\neval `''{aux/getflags $*} || exec aux/usage\n\nif(! ~ $#* 1)\n\texec aux/usage\n\ntheirs=`{git/query $1}\nours=`{git/query HEAD}\nbase=`{git/query $theirs ^ ' ' ^ $ours ^ '@'}\n\nif(~ $base $theirs)\n\tdie 'nothing to merge, doofus'\nif(! git/walk -q)\n\tdie 'dirty work tree, refusing to merge'\nif(~ $base $ours){\n\t>[1=2] echo 'fast forwarding...'\n\techo $theirs > .git/refs/`{git/branch}\n\tgit/revert .\n\texit ''\n}\necho $ours >> .git/merge-parents\necho $theirs >> .git/merge-parents\n\nmerge $ours $base $theirs\n>[1=2] echo 'merge complete: remember to commit'\nexit ''\n", "source": "git9/merge", "file_type": "rc"}
{"text": "#!/bin/rc -e\nrfork en\n. /sys/lib/git/common.rc\n\ngitup\n\nflagfmt='a:listall, b:baseref ref, d:delete, n:newbr, s:stay, m:merge, M:nomod'\nargs='[branch]'\neval `''{aux/getflags $*} || exec aux/usage\n\nmodified=()\ndeleted=()\n\nif(~ $#* 0){\n\tif(~ $#listall 0)\n\t\tawk '$1==\"branch\"{print $2}' < $gitfs/ctl\n\tif not\n\t\tcd .git/refs/ && walk -f heads remotes\n\texit\n}\nif(! ~ $#* 1)\n\texec aux/usage\n\nbranch=$1\nif(~ $branch refs/heads/*)\n\tnew=$name\nif not if(~ $branch heads/*)\n\tnew=refs/$branch\nif not\n\tnew=refs/heads/$branch\n\norig=`{git/query HEAD}\nif (~ $#baseref 1)\n\tbase=`{git/query $baseref} || exit 'bad base'\nif not if(~ $#newbr 0)\n\tbase=`{git/query $new}\nif not\n\tbase=`{git/query HEAD}\n\nif(~ $#newbr 0){\n\tif(! ~ $#baseref 0)\n\t\tdie update would clobber $branch with $baseref\n\tbaseref=`$nl{echo -n $new | sed s@refs/heads/@refs/remotes/origin/@}\n\tif(! test -e .git/$new)\n\t\tif(! base=`{git/query $baseref})\n\t\t\tdie could not find branch $branch\n}\nmodified=`$nl{git/query -c HEAD $base | grep '^[^-]' | subst '^..'}\ndeleted=`$nl{git/query -c HEAD $base | grep '^-' | subst '^..'}\n\n# if we delete the current branch without switching, bad things happen\nif(~ $delete 1 && ~ `{git/query HEAD} `{git/query $branch})\n\tdie 'cannot delete current branch'\n# if we're not merging, don't clobber existing changes.\nif(~ $#merge 0 && ~ $#delete 0){\n\tif(! ~ $#modified 0 || ! ~ $#deleted 0){\n\t\tgit/walk -fRMA $modified $deleted || \n\t\t\tdie 'uncommitted changes would be clobbered'\n\t}\n}\nif(~ $delete 1){\n\trm -f .git/$new\n\techo 'deleted branch' $new\n\texit\n}\ncommit=`{git/query $base} || die 'branch does not exist:' $base\nif(~ $new */*)\n\tmkdir -p .git/`{basename -d $new}\nif(! ~ $#stay 0){\n\techo $commit > .git/$new\n\texit\n}\nbasedir=`{git/query -p $base}\ndirtypaths=()\nif(! ~ $#modified 0 || ! ~ $#deleted 0)\n\tdirtypaths=`$nl{git/walk -cfRMA $modified $deleted}\nif(~ $#dirtypaths 0)\n\tcleanpaths=($modified $deleted)\nif not {\n\tcleanpaths=()\n\tfor(p in $modified $deleted)\n\t\tif(! ~ $p $dirtypaths)\n\t\t\tcleanpaths=($cleanpaths $p)\n}\n\necho $commit > .git/$new\nfor(m in $cleanpaths){\n\td=`$nl{basename -d $m}\n\tmkdir -p $d\n\t# Modifications can turn a file into\n\t# a directory, or vice versa, so we\n\t# need to delete and copy the files\n\t# over.\n\ta=dir\n\tb=dir\n\tif(test -f $m)\n\t\ta=file\n\tif(test -f $basedir/tree/$m)\n\t\tb=file\n\tif(! ~ $a $b){\n\t\trm -rf $m\n\t\techo R NOQID 0 $m >> .git/INDEX9\n\t}\n\tif(~ $b file){\n\t\tcp -x -- $basedir/tree/$m $m\n\t\techo T NOQID 0 $m >> .git/INDEX9\n\t\ttouch $m\n\t}\n}\n\nfor(ours in $dirtypaths){\n\tcommon=$gitfs/object/$orig/tree/$ours\n\ttheirs=$gitfs/object/$base/tree/$ours\n\tmerge1 $ours $ours $common $theirs\n}\n\nfor(d in $deleted){\n\tif(! test -d $d){\n\t\trm -f $d\n\t\techo R NOQID 0 $d >> .git/INDEX9\n\t}\n}\n\necho ref: $new > .git/HEAD\necho $new: `{git/query $new}\nexit ''\n", "source": "git9/branch", "file_type": "rc"}
{"text": "#include <u.h>\n#include <libc.h>\n\n#include \"git.h\"\n\n#pragma\tvarargck\ttype\t\"P\"\tvoid\n\nint fullpath;\nint changes;\nint reverse;\nchar *path[128];\nint npath;\n\nint\nPfmt(Fmt *f)\n{\n\tint i, n;\n\n\tn = 0;\n\tfor(i = 0; i < npath; i++)\n\t\tn += fmtprint(f, \"%s/\", path[i]);\n\treturn n;\n}\n\nvoid\nshowdir(Hash dh, char *dname, char m)\n{\n\tDirent *p, *e;\n\tObject *d;\n\n\n\tpath[npath++] = dname;\n\tif((d = readobject(dh)) == nil)\n\t\tsysfatal(\"bad hash %H\", dh);\n\tassert(d->type == GTree);\n\tp = d->tree->ent;\n\te = p + d->tree->nent;\n\tfor(; p != e; p++){\n\t\tif(p->ismod)\n\t\t\tcontinue;\n\t\tif(p->mode & DMDIR)\n\t\t\tshowdir(p->h, p->name, m);\n\t\telse\n\t\t\tprint(\"%c %P%s\\n\", m, p->name);\n\t}\n\tprint(\"%c %P\\n\", m);\n\tunref(d);\n\tnpath--;\n}\n\nvoid\nshow(Dirent *e, char m)\n{\n\tif(e->mode & DMDIR)\n\t\tshowdir(e->h, e->name, m);\n\telse\n\t\tprint(\"%c %P%s\\n\", m, e->name);\n}\n\nvoid\ndifftrees(Object *a, Object *b)\n{\n\tDirent *ap, *bp, *ae, *be;\n\tint c;\n\n\tap = ae = nil;\n\tbp = be = nil;\n\tif(a != nil){\n\t\tif(a->type != GTree)\n\t\t\treturn;\n\t\tap = a->tree->ent;\n\t\tae = ap + a->tree->nent;\n\t}\n\tif(b != nil){\n\t\tif(b->type != GTree)\n\t\t\treturn;\n\t\tbp = b->tree->ent;\n\t\tbe = bp + b->tree->nent;\n\t}\n\twhile(ap != ae && bp != be){\n\t\tc = strcmp(ap->name, bp->name);\n\t\tif(c == 0){\n\t\t\tif(ap->mode == bp->mode && hasheq(&ap->h, &bp->h))\n\t\t\t\tgoto next;\n\t\t\tif(ap->mode != bp->mode)\n\t\t\t\tprint(\"! %P%s\\n\", ap->name);\n\t\t\telse if(!(ap->mode & DMDIR) || !(bp->mode & DMDIR))\n\t\t\t\tprint(\"@ %P%s\\n\", ap->name);\n\t\t\tif((ap->mode & DMDIR) && (bp->mode & DMDIR)){\n\t\t\t\tif(npath >= nelem(path))\n\t\t\t\t\tsysfatal(\"path too deep\");\n\t\t\t\tpath[npath++] = ap->name;\n\t\t\t\tif((a = readobject(ap->h)) == nil)\n\t\t\t\t\tsysfatal(\"bad hash %H\", ap->h);\n\t\t\t\tif((b = readobject(bp->h)) == nil)\n\t\t\t\t\tsysfatal(\"bad hash %H\", bp->h);\n\t\t\t\tdifftrees(a, b);\n\t\t\t\tunref(a);\n\t\t\t\tunref(b);\n\t\t\t\tnpath--;\n\t\t\t}\nnext:\n\t\t\tap++;\n\t\t\tbp++;\n\t\t}else if(c < 0) {\n\t\t\tshow(ap, '-');\n\t\t\tap++;\n\t\t}else if(c > 0){\n\t\t\tshow(bp, '+');\n\t\t\tbp++;\n\t\t}\n\t}\n\tfor(; ap != ae; ap++)\n\t\tshow(ap, '-');\n\tfor(; bp != be; bp++)\n\t\tshow(bp, '+');\n}\n\nvoid\ndiffcommits(Hash ah, Hash bh)\n{\n\tObject *a, *b, *at, *bt;\n\n\tat = nil;\n\tbt = nil;\n\tif(!hasheq(&ah, &Zhash) && (a = readobject(ah)) != nil){\n\t\tif(a->type != GCommit)\n\t\t\tsysfatal(\"not commit: %H\", ah);\n\t\tif((at = readobject(a->commit->tree)) == nil)\n\t\t\tsysfatal(\"bad hash %H\", a->commit->tree);\n\t\tunref(a);\n\t}\n\tif(!hasheq(&bh, &Zhash) && (b = readobject(bh)) != nil){\n\t\tif(b->type != GCommit)\n\t\t\tsysfatal(\"not commit: %H\", ah);\n\t\tif((bt = readobject(b->commit->tree)) == nil)\n\t\t\tsysfatal(\"bad hash %H\", b->commit->tree);\n\t\tunref(b);\n\t}\n\tdifftrees(at, bt);\n\tunref(at);\n\tunref(bt);\n}\n\nvoid\nusage(void)\n{\n\tfprint(2, \"usage: %s [-pcr] query\\n\", argv0);\n\texits(\"usage\");\n}\n\nvoid\nmain(int argc, char **argv)\n{\n\tchar *query, repo[512];\n\tchar *p, *e, *objpfx;\n\tint i, j, n, nrel;\n\tHash *h;\n\n\tARGBEGIN{\n\tcase 'd':\tchattygit++;\tbreak;\n\tcase 'p':\tfullpath++;\tbreak;\n\tcase 'c':\tchanges++;\tbreak;\n\tcase 'r':\treverse ^= 1;\tbreak;\n\tdefault:\tusage();\tbreak;\n\t}ARGEND;\n\n\tgitinit();\n\tfmtinstall('P', Pfmt);\n\n\tif(argc == 0)\n\t\tusage();\n\tif(findrepo(repo, sizeof(repo), &nrel) == -1)\n\t\tsysfatal(\"find root: %r\");\n\tif(chdir(repo) == -1)\n\t\tsysfatal(\"chdir: %r\");\n\tif((objpfx = smprint(\"%s/.git/fs/object/\", repo)) == nil)\n\t\tsysfatal(\"smprint: %r\");\n\tfor(i = 0, n = 0; i < argc; i++)\n\t\tn += strlen(argv[i]) + 1;\n\tquery = emalloc(n+1);\n\tp = query;\n\te = query + n;\n\tfor(i = 0; i < argc; i++)\n\t\tp = seprint(p, e, \"%s \", argv[i]);\n\tn = resolverefs(&h, query);\n\tfree(query);\n\tif(n == -1)\n\t\tsysfatal(\"resolve: %r\");\n\tif(changes){\n\t\tfor(i = 1; i < n; i++)\n\t\t\tdiffcommits(h[0], h[i]);\n\t}else{\n\t\tp = (fullpath ? objpfx : \"\");\n\t\tfor(j = 0; j < n; j++)\n\t\t\tprint(\"%s%H\\n\", p, h[reverse ? n - 1 - j : j]);\n\t}\n\texits(nil);\n}\n\n", "source": "git9/query.c", "file_type": "c"}
{"text": "#include <u.h>\n#include <libc.h>\n\n#include \"git.h\"\n\nvoid\nosinit(Objset *s)\n{\n\ts->sz = 16;\n\ts->nobj = 0;\n\ts->obj = eamalloc(s->sz, sizeof(Hash));\n}\n\nvoid\nosclear(Objset *s)\n{\n\tfree(s->obj);\n}\n\nvoid\nosadd(Objset *s, Object *o)\n{\n\tu32int probe;\n\tObject **obj;\n\tint i, sz;\n\n\tprobe = GETBE32(o->hash.h) % s->sz;\n\twhile(s->obj[probe]){\n\t\tif(hasheq(&s->obj[probe]->hash, &o->hash)){\n\t\t\ts->obj[probe] = o;\n\t\t\treturn;\n\t\t}\n\t\tprobe = (probe + 1) % s->sz;\n\t}\n\tassert(s->obj[probe] == nil);\n\ts->obj[probe] = o;\n\ts->nobj++;\n\tif(s->sz < 2*s->nobj){\n\t\tsz = s->sz;\n\t\tobj = s->obj;\n\n\t\ts->sz *= 2;\n\t\ts->nobj = 0;\n\t\ts->obj = eamalloc(s->sz, sizeof(Hash));\n\t\tfor(i = 0; i < sz; i++)\n\t\t\tif(obj[i])\n\t\t\t\tosadd(s, obj[i]);\n\t\tfree(obj);\n\t}\n}\n\nObject*\nosfind(Objset *s, Hash h)\n{\n\tu32int probe;\n\n\tfor(probe = GETBE32(h.h) % s->sz; s->obj[probe]; probe = (probe + 1) % s->sz)\n\t\tif(hasheq(&s->obj[probe]->hash, &h))\n\t\t\treturn s->obj[probe]; \n\treturn 0;\n}\n\nint\noshas(Objset *s, Hash h)\n{\n\treturn osfind(s, h) != nil;\n}\n", "source": "git9/objset.c", "file_type": "c"}
{"text": "#!/bin/rc\nrfork ne\n. /sys/lib/git/common.rc\n\npatchname=/tmp/git.patchname.$pid\npatchfile=/tmp/git.patchfile.$pid\nfn sigexit{\n\trm -f $patchname $patchfile\n}\n\ngitup\n\nflagfmt='o:patchdir patchdir'; args='[query]'\neval `''{aux/getflags $*} || exec aux/usage\n\nif(~ $#patchdir 1 && ! test -d $patchdir)\n\tmkdir -p $patchdir\n\nq=$*\nif(~ $#q 0)\n\tq=HEAD\ncommits=`{git/query $q || die $status}\nn=1\nm=$#commits\n\n\n# sleazy hack: we want to run\n# under rfork m for the web ui,\n# so don't error if we can't mount\nmntgen /mnt/scratch >[2]/dev/null || status=''\nfor(c in $commits){\n\tcp=`{git/query -p $c}\n\tpp=`{git/query -p $c'~'}\n\tfc=`$nl{git/query -c $c~ $c | sed 's/^..//'}\n\n\t@{\n\t\trfork n\n\t\tcd /mnt/scratch\n\t\tif(test -d $pp/tree)\n\t\t\tbind $pp/tree a\n\t\tif(test -d $cp/tree)\n\t\t\tbind $cp/tree b\n\t\t\n\t\techo From: `{cat $cp/author}\n\t\techo Date: `{date -uf'WW, DD MMM YYYY hh:mm:ss Z' `{walk -em $cp/author}}\n\t\t<$cp/msg awk '\n\t\tNR == 1 {\n\t\t\tn = ENVIRON[\"n\"]\n\t\t\tm = ENVIRON[\"m\"]\n\t\t\tmsg=$0\n\t\t\tif(m > 1)\n\t\t\t\tpatch = sprintf(\"[PATCH %d/%d]\", n, m)\n\t\t\telse\n\t\t\t\tpatch = \"[PATCH]\"\n\t\t\tprintf \"Subject: %s %s\\n\\n\", patch, msg\n\t\t\t\n\t\t\tgsub(\"^[ \t]|[ \t]$\", \"\", msg)\n\t\t\tgsub(\"[^a-zA-Z0-9_]+\", \"-\", msg)\n\t\t\tprintf \"%.4d-%s.patch\", n, msg >ENVIRON[\"patchname\"]\n\t\t\tnext\n\t\t}\n\t\t{\n\t\t\tprint\n\t\t}'\n\t\techo '---'\n\t\techo diff `{basename $pp} `{basename $cp}\n\t\tfor(f in $fc){\n\t\t\ta=a/$f\n\t\t\tif(! test -e $a)\n\t\t\t\ta=/dev/null\n\t\t\tb=b/$f\n\t\t\tif(! test -e $b)\n\t\t\t\tb=/dev/null\n\t\t\tdiff -ur $a $b\n\t\t}\n\t} >$patchfile\n\tif(~ $#patchdir 0){\n\t\tcat $patchfile\n\t\t! ~ $n $m && echo\n\t}\n\tif not{\n\t\tf=$patchdir/`{cat $patchname}\n\t\tmv $patchfile $f\n\t\techo $f\n\t}\n\tn=`{echo $n + 1 | bc}\n}\nexit ''\n", "source": "git9/export", "file_type": "rc"}
{"text": "#include <u.h>\n#include <libc.h>\n#include <ctype.h>\n\n#include \"git.h\"\n\n#define Useragent\t\"useragent git/2.24.1\"\n#define Contenthdr\t\"headers Content-Type: application/x-git-%s-pack-request\"\n#define Accepthdr\t\"headers Accept: application/x-git-%s-pack-result\"\n\nenum {\n\tNproto\t= 16,\n\tNport\t= 16,\n\tNhost\t= 256,\n\tNpath\t= 128,\n\tNrepo\t= 64,\n\tNbranch\t= 32,\n};\n\nvoid\ntracepkt(int v, char *pfx, char *b, int n)\n{\n\tchar *f;\n\tint o, i;\n\n\tif(chattygit < v)\n\t\treturn;\n\to = 0;\n\tf = emalloc(n*4 + 1);\n\tfor(i = 0; i < n; i++){\n\t\tif(isprint(b[i])){\n\t\t\tf[o++] = b[i];\n\t\t\tcontinue;\n\t\t}\n\t\tf[o++] = '\\\\';\n\t\tswitch(b[i]){\n\t\tcase '\\\\':\tf[o++] = '\\\\';\tbreak;\n\t\tcase '\\n':\tf[o++] = 'n';\tbreak;\n\t\tcase '\\r':\tf[o++] = 'r';\tbreak;\n\t\tcase '\\v':\tf[o++] = 'v';\tbreak;\n\t\tcase '\\0':\tf[o++] = '0';\tbreak;\n\t\tdefault:\n\t\t\tf[o++] = 'x';\n\t\t\tf[o++] = \"0123456789abcdef\"[(b[i]>>4)&0xf];\n\t\t\tf[o++] = \"0123456789abcdef\"[(b[i]>>0)&0xf];\n\t\t\tbreak;\n\t\t}\n\t}\n\tf[o] = '\\0';\n\tfprint(2, \"%s %04x:\\t%s\\n\", pfx, n, f);\n\tfree(f);\n}\n\nint\nreadpkt(Conn *c, char *buf, int nbuf)\n{\n\tchar len[5];\n\tchar *e;\n\tint n;\n\n\tif(readn(c->rfd, len, 4) != 4){\n\t\twerrstr(\"pktline: short read from transport\");\n\t\treturn -1;\n\t}\n\tlen[4] = 0;\n\tn = strtol(len, &e, 16);\n\tif(n == 0){\n\t\tdprint(1, \"=r=> 0000\\n\");\n\t\treturn 0;\n\t}\n\tif(e != len + 4 || n <= 4)\n\t\tsysfatal(\"pktline: bad length '%s'\", len);\n\tn  -= 4;\n\tif(n >= nbuf)\n\t\tsysfatal(\"pktline: undersize buffer\");\n\tif(readn(c->rfd, buf, n) != n)\n\t\treturn -1;\n\tif(n > 4 && strncmp(buf, \"ERR \", 4) == 0){\n\t\tif((e = strrchr(buf, '\\n')) != nil)\n\t\t\t*e = '\\0';\n\t\twerrstr(\"%s\", buf + 4);\n\t\treturn -1;\n\t}\n\tbuf[n] = 0;\n\ttracepkt(1, \"=r=>\", buf, n);\n\treturn n;\n}\n\nint\nwritepkt(Conn *c, char *buf, int nbuf)\n{\n\tchar len[5];\n\n\n\tsnprint(len, sizeof(len), \"%04x\", nbuf + 4);\n\tif(write(c->wfd, len, 4) != 4)\n\t\treturn -1;\n\tif(write(c->wfd, buf, nbuf) != nbuf)\n\t\treturn -1;\n\ttracepkt(1, \"<=w=\", buf, nbuf);\n\treturn 0;\n}\n\nint\nfmtpkt(Conn *c, char *fmt, ...)\n{\n\tchar pkt[Pktmax];\n\tva_list ap;\n\tint n;\n\n\tva_start(ap, fmt);\n\tn = vsnprint(pkt, sizeof(pkt), fmt, ap);\n\tn = writepkt(c, pkt, n);\n\tva_end(ap);\n\treturn n;\n}\n\nint\nflushpkt(Conn *c)\n{\n\tdprint(1, \"<=w= 0000\\n\");\n\treturn write(c->wfd, \"0000\", 4);\n}\n\nstatic void\ngrab(char *dst, int n, char *p, char *e)\n{\n\tint l;\n\n\tl = e - p;\n\tif(l >= n)\n\t\tsysfatal(\"overlong component\");\n\tmemcpy(dst, p, l);\n\tdst[l] = 0;\n}\n\nstatic int\nparseuri(char *uri, char *proto, char *host, char *port, char *path, char *repo)\n{\n\tchar *s, *p, *q;\n\tint n, hasport;\n\tprint(\"uri: \\\"%s\\\"\\n\", uri);\n\n\tp = strstr(uri, \"://\");\n\tif(p == nil)\n\t\tsnprint(proto, Nproto, \"ssh\");\n\telse if(strncmp(uri, \"git+\", 4) == 0)\n\t\tgrab(proto, Nproto, uri + 4, p);\n\telse\n\t\tgrab(proto, Nproto, uri, p);\n\t*port = 0;\n\thasport = 1;\n\tif(strcmp(proto, \"git\") == 0)\n\t\tsnprint(port, Nport, \"9418\");\n\telse if(strncmp(proto, \"https\", 5) == 0)\n\t\tsnprint(port, Nport, \"443\");\n\telse if(strncmp(proto, \"http\", 4) == 0)\n\t\tsnprint(port, Nport, \"80\");\n\telse if(strncmp(proto, \"hjgit\", 5) == 0)\n\t\tsnprint(port, Nport, \"17021\");\n\telse if(strncmp(proto, \"gits\", 5) == 0)\n\t\tsnprint(port, Nport, \"9419\");\n\telse\n\t\thasport = 0;\n\ts = (p != nil) ? p + 3 : uri;\n\tp = nil;\n\tif(!hasport){\n\t\tp = strstr(s, \":\");\n\t\tif(p != nil)\n\t\t\tp++;\n\t}\n\tif(p == nil)\n\t\tp = strstr(s, \"/\");\n\tif(p == nil || strlen(p) == 1){\n\t\twerrstr(\"missing path\");\n\t\treturn -1;\n\t}\n\n\tq = memchr(s, ':', p - s);\n\tif(q){\n\t\tgrab(host, Nhost, s, q);\n\t\tgrab(port, Nport, q + 1, p);\n\t}else{\n\t\tgrab(host, Nhost, s, p);\n\t}\n\t\n\tsnprint(path, Npath, \"%s\", p);\n\tif((q = strrchr(p, '/')) != nil)\n\t\tp = q + 1;\n\tif(strlen(p) == 0){\n\t\twerrstr(\"missing repository in uri\");\n\t\treturn -1;\n\t}\n\tn = strlen(p);\n\tif(hassuffix(p, \".git\"))\n\t\tn -= 4;\n\tgrab(repo, Nrepo, p, p + n);\n\treturn 0;\n}\n\nstatic int\nwebclone(Conn *c, char *url)\n{\n\tchar buf[16];\n\tint n, conn;\n\n\tif((c->cfd = open(\"/mnt/web/clone\", ORDWR)) < 0)\n\t\tgoto err;\n\tif((n = read(c->cfd, buf, sizeof(buf)-1)) == -1)\n\t\tgoto err;\n\tbuf[n] = 0;\n\tconn = atoi(buf);\n\n\t/* github will behave differently based on useragent */\n\tif(write(c->cfd, Useragent, sizeof(Useragent)) == -1)\n\t\treturn -1;\n\tdprint(1, \"open url %s\\n\", url);\n\tif(fprint(c->cfd, \"url %s\", url) == -1)\n\t\tgoto err;\n\tfree(c->dir);\n\tc->dir = smprint(\"/mnt/web/%d\", conn);\n\treturn 0;\nerr:\n\tif(c->cfd != -1)\n\t\tclose(c->cfd);\n\treturn -1;\n}\n\nstatic int\nwebopen(Conn *c, char *file, int mode)\n{\n\tchar path[128];\n\tint fd;\n\n\tsnprint(path, sizeof(path), \"%s/%s\", c->dir, file);\n\tif((fd = open(path, mode)) == -1)\n\t\treturn -1;\n\treturn fd;\n}\n\nstatic int\nissmarthttp(Conn *c, char *direction)\n{\n\tchar buf[Pktmax+1], svc[128];\n\tint fd, n;\n\n\tif((fd = webopen(c, \"contenttype\", OREAD)) == -1)\n\t\treturn -1;\n\tn = readn(fd, buf, sizeof(buf) - 1);\n\tclose(fd);\n\tif(n == -1)\n\t\treturn -1;\n\tbuf[n] = '\\0';\n\tsnprint(svc, sizeof(svc), \"application/x-git-%s-pack-advertisement\", direction);\n\tif(strcmp(svc, buf) != 0){\n\t\twerrstr(\"dumb http protocol not supported\");\n\t\treturn -1;\n\t}\n\n\tif((n = readpkt(c, buf, sizeof(buf))) == -1)\n\t\tsysfatal(\"http read: %r\");\n\tbuf[n] = 0;\n\tsnprint(svc, sizeof(svc), \"# service=git-%s-pack\\n\", direction);\n\tif(strncmp(svc, buf, n) != 0){\n\t\twerrstr(\"invalid initial packet line\");\n\t\treturn -1;\n\t}\n\tif(readpkt(c, buf, sizeof(buf)) != 0){\n\t\twerrstr(\"protocol garble: expected flushpkt\");\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int\ndialhttp(Conn *c, char *host, char *port, char *path, char *direction)\n{\n\tchar *geturl, *suff, *hsep, *psep;\n\n\tsuff = \"\";\n\thsep = \"\";\n\tpsep = \"\";\n\tif(port && strlen(port) != 0)\n\t\thsep = \":\";\n\tif(path && path[0] != '/')\n\t\tpsep = \"/\";\n\tmemset(c, 0, sizeof(*c));\n\tgeturl = smprint(\"https://%s%s%s%s%s%s/info/refs?service=git-%s-pack\", host, hsep, port, psep, path, suff, direction);\n\tc->type = ConnHttp;\n\tc->url = smprint(\"https://%s%s%s%s%s%s/git-%s-pack\", host, hsep, port, psep, path, suff, direction);\n\tc->cfd = webclone(c, geturl);\n\tfree(geturl);\n\tif(c->cfd == -1)\n\t\treturn -1;\n\tc->rfd = webopen(c, \"body\", OREAD);\n\tc->wfd = -1;\n\tif(c->rfd == -1)\n\t\treturn -1;\n\tif(issmarthttp(c, direction) == -1)\n\t\treturn -1;\n\tc->direction = estrdup(direction);\n\treturn 0;\n}\n\nstatic int\ndialssh(Conn *c, char *host, char *, char *path, char *direction)\n{\n\tint pid, pfd[2];\n\tchar cmd[64];\n\n\tif(pipe(pfd) == -1)\n\t\tsysfatal(\"unable to open pipe: %r\");\n\tpid = fork();\n\tif(pid == -1)\n\t\tsysfatal(\"unable to fork\");\n\tif(pid == 0){\n\t\tclose(pfd[1]);\n\t\tdup(pfd[0], 0);\n\t\tdup(pfd[0], 1);\n\t\tsnprint(cmd, sizeof(cmd), \"git-%s-pack\", direction);\n\t\tdprint(1, \"exec ssh '%s' '%s' %s\\n\", host, cmd, path);\n\t\texecl(\"/bin/ssh\", \"ssh\", host, cmd, path, nil);\n\t\tsysfatal(\"exec: %r\");\n\t}\n\tclose(pfd[0]);\n\tc->type = ConnSsh;\n\tc->rfd = pfd[1];\n\tc->wfd = dup(pfd[1], -1);\n\treturn 0;\n}\n\nstatic int\ngithandshake(Conn *c, char *host, char *path, char *direction)\n{\n\tchar *p, *e, cmd[512];\n\n\tp = cmd;\n\te = cmd + sizeof(cmd);\n\tp = seprint(p, e - 1, \"git-%s-pack %s\", direction, path);\n\tif(host != nil)\n\t\tp = seprint(p + 1, e, \"host=%s\", host);\n\tif(writepkt(c, cmd, p - cmd + 1) == -1){\n\t\tfprint(2, \"failed to write message\\n\");\n\t\tcloseconn(c);\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int\ndialhjgit(Conn *c, char *host, char *port, char *path, char *direction, int auth)\n{\n\tchar *ds;\n\tint pid, pfd[2];\n\n\tif((ds = netmkaddr(host, \"tcp\", port)) == nil)\n\t\treturn -1;\n\tif(pipe(pfd) == -1)\n\t\tsysfatal(\"unable to open pipe: %r\");\n\tpid = fork();\n\tif(pid == -1)\n\t\tsysfatal(\"unable to fork\");\n\tif(pid == 0){\n\t\tclose(pfd[1]);\n\t\tdup(pfd[0], 0);\n\t\tdup(pfd[0], 1);\n\t\tdprint(1, \"exec tlsclient -a %s\\n\", ds);\n\t\tif(auth)\n\t\t\texecl(\"/bin/tlsclient\", \"tlsclient\", \"-a\", ds, nil);\n\t\telse\n\t\t\texecl(\"/bin/tlsclient\", \"tlsclient\", ds, nil);\n\t\tsysfatal(\"exec: %r\");\n\t}\n\tclose(pfd[0]);\n\tc->type = ConnGit9;\n\tc->rfd = pfd[1];\n\tc->wfd = dup(pfd[1], -1);\n\treturn githandshake(c, host, path, direction);\n}\n\nvoid\ninitconn(Conn *c, int rd, int wr)\n{\n\tc->type = ConnGit;\n\tc->rfd = rd;\n\tc->wfd = wr;\n}\n\nstatic int\ndialgit(Conn *c, char *host, char *port, char *path, char *direction)\n{\n\tchar *ds;\n\tint fd;\n\n\tif((ds = netmkaddr(host, \"tcp\", port)) == nil)\n\t\treturn -1;\n\tdprint(1, \"dial %s git-%s-pack %s\\n\", ds, direction, path);\n\tfd = dial(ds, nil, nil, nil);\n\tif(fd == -1)\n\t\treturn -1;\n\tc->type = ConnGit;\n\tc->rfd = fd;\n\tc->wfd = dup(fd, -1);\n\treturn githandshake(c, host, path, direction);\n}\n\nstatic int\nservelocal(Conn *c, char *path, char *direction)\n{\n\tint pid, pfd[2];\n\n\tif(pipe(pfd) == -1)\n\t\tsysfatal(\"unable to open pipe: %r\");\n\tpid = fork();\n\tif(pid == -1)\n\t\tsysfatal(\"unable to fork\");\n\tif(pid == 0){\n\t\tclose(pfd[1]);\n\t\tdup(pfd[0], 0);\n\t\tdup(pfd[0], 1);\n\t\texecl(\"/bin/git/serve\", \"serve\", \"-w\", nil);\n\t\tsysfatal(\"exec: %r\");\n\t}\n\tclose(pfd[0]);\n\tc->type = ConnGit;\n\tc->rfd = pfd[1];\n\tc->wfd = dup(pfd[1], -1);\n\treturn githandshake(c, nil, path, direction);\n}\n\nstatic int\nlocalrepo(char *uri, char *path, int npath)\n{\n\tint fd;\n\n\tsnprint(path, npath, \"%s/.git/../\", uri);\n\tfd = open(path, OREAD);\n\tif(fd < 0)\n\t\treturn -1;\n\tif(fd2path(fd, path, npath) != 0){\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\tclose(fd);\n\treturn 0;\n}\n\nint\ngitconnect(Conn *c, char *uri, char *direction)\n{\n\tchar proto[Nproto], host[Nhost], port[Nport];\n\tchar repo[Nrepo], path[Npath];\n\n\tmemset(c, 0, sizeof(Conn));\n\tc->rfd = c->wfd = c->cfd = -1;\n\n\tif(localrepo(uri, path, sizeof(path)) == 0)\n\t\treturn servelocal(c, path, direction);\n\n\tif(parseuri(uri, proto, host, port, path, repo) == -1){\n\t\twerrstr(\"bad uri %s\", uri);\n\t\treturn -1;\n\t}\n\tif(strcmp(proto, \"ssh\") == 0)\n\t\treturn dialssh(c, host, port, path, direction);\n\telse if(strcmp(proto, \"git\") == 0)\n\t\treturn dialgit(c, host, port, path, direction);\n\telse if(strcmp(proto, \"hjgit\") == 0)\n\t\treturn dialhjgit(c, host, port, path, direction, 1);\n\telse if(strcmp(proto, \"gits\") == 0)\n\t\treturn dialhjgit(c, host, port, path, direction, 0);\n\telse if(strcmp(proto, \"http\") == 0 || strcmp(proto, \"https\") == 0)\n\t\treturn dialhttp(c, host, port, path, direction);\n\twerrstr(\"unknown protocol %s\", proto);\n\treturn -1;\n}\n\nint\nwritephase(Conn *c)\n{\n\tchar hdr[128];\n\tint n;\n\n\tdprint(1, \"start write phase\\n\");\n\tif(c->type != ConnHttp)\n\t\treturn 0;\n\n\tif(c->wfd != -1)\n\t\tclose(c->wfd);\n\tif(c->cfd != -1)\n\t\tclose(c->cfd);\n\tif((c->cfd = webclone(c, c->url)) == -1)\n\t\treturn -1;\n\tn = snprint(hdr, sizeof(hdr), Contenthdr, c->direction);\n\tif(write(c->cfd, hdr, n) == -1)\n\t\treturn -1;\n\tn = snprint(hdr, sizeof(hdr), Accepthdr, c->direction);\n\tif(write(c->cfd, hdr, n) == -1)\n\t\treturn -1;\n\tif((c->wfd = webopen(c, \"postbody\", OWRITE)) == -1)\n\t\treturn -1;\n\tc->rfd = -1;\n\treturn 0;\n}\n\nint\nreadphase(Conn *c)\n{\n\tdprint(1, \"start read phase\\n\");\n\tif(c->type != ConnHttp)\n\t\treturn 0;\n\tif(close(c->wfd) == -1)\n\t\treturn -1;\n\tif((c->rfd = webopen(c, \"body\", OREAD)) == -1)\n\t\treturn -1;\n\tc->wfd = -1;\n\treturn 0;\n}\n\nvoid\ncloseconn(Conn *c)\n{\n\tclose(c->rfd);\n\tclose(c->wfd);\n\tswitch(c->type){\n\tcase ConnGit:\n\t\tbreak;\n\tcase ConnGit9:\n\tcase ConnSsh:\n\t\tfree(wait());\n\t\tbreak;\n\tcase ConnHttp:\n\t\tclose(c->cfd);\n\t\tbreak;\n\t}\n}\n", "source": "git9/proto.c", "file_type": "c"}
{"text": "#!/bin/rc\nrfork ne\n. /sys/lib/git/common.rc\n\ndiffpath=/tmp/gitimport.$pid.diff\nfn sigexit {\n\trm -f $diffpath\n}\n\n\nfn apply @{\n\tgit/fs\n\tamail=''\n\taname=''\n\tmsg=''\n\twhoami\n\tparents='-p'^`{git/query HEAD}\n\tbranch=`{git/branch}\n\tif(test -e $gitfs/branch/$branch/tree)\n\t\trefpath=.git/refs/$branch\n\tif not if(test -e $gitfs/object/$branch/tree)\n\t\trefpath=.git/HEAD\n\tif not\n\t\tdie 'invalid branch:' $branch\n\tawk '\n\tBEGIN{\n\t\tstate=\"headers\"\n\t}\n\tstate==\"headers\" && /^From:/ {\n\t\tsub(/^From:[ \\t]*/, \"\", $0);\n\t\taname=$0;\n\t\tamail=$0;\n\t\tsub(/[ \\t]*<.*$/, \"\", aname);\n\t\tsub(/^[^<]*</, \"\", amail);\n\t\tsub(/>[^>]*$/, \"\", amail);\n\t}\n\tstate==\"headers\" && /^Date:/{\n\t\tsub(/^Date:[ \\t]*/, \"\", $0)\n\t\tdate=$0\n\t}\n\tstate==\"headers\" && /^Subject:/{\n\t\tsub(/^Subject:[ \\t]*(\\[[^\\]]*\\][ \\t]*)*/, \"\", $0);\n\t\tgotmsg = 1\n\t\tprint > \"/env/msg\"\n\t}\n\tstate==\"headers\" && /^$/ {\n\t\tstate=\"body\"\n\t}\n\t(state==\"headers\" || state==\"body\") && (/^diff / || /^---( |$)/){\n\t\tstate=\"diff\"\n\t}\n\tstate==\"body\" && /^[ \t]*$/ {\n\t\tempty=1\n\t\tnext\n\t}\n\tstate==\"body\" {\n\t\tif(empty)\n\t\t\tprintf \"\\n\" > \"/env/msg\"\n\t\tempty=0\n\t\tsub(/[ \t]+$/, \"\")\n\t\tprint > \"/env/msg\"\n\t}\n\tstate==\"diff\" {\n\t\tprint > ENVIRON[\"diffpath\"]\n\t}\n\tEND{\n\t\tif(state != \"diff\")\n\t\t\texit(\"malformed patch: \" state);\n\t\tif(aname == \"\" || amail == \"\" || date == \"\" || gotmsg == \"\")\n\t\t\texit(\"missing headers\");\n\t\tprintf \"%s\", aname > \"/env/aname\"\n\t\tprintf \"%s\", amail > \"/env/amail\"\n\t\tprintf \"%s\", date > \"/env/date\"\n\t}\n\t' || die 'could not import:' $status\n\n\t# force re-reading env\n\trc -c '\n\t\tdate=`{seconds $date}\n\t\tfiles=`$nl{patch -np1 < $diffpath}\n\t\tif(! git/walk -q $files){\n\t\t\t>[1=2] {\n\t\t\t\techo patch would clobber files:\n\t\t\t\tgit/walk $files\n\t\t\t\texit clobber\n\t\t\t}\n\t\t}\n\t\techo applying $msg | sed 1q\n\t\tif(! files=`$nl{patch -p1 < $diffpath})\n\t\t\tdie ''patch failed''\n\t\tfor(f in $files){\n\t\t\tif(test -e $f)\n\t\t\t\tgit/add $f\n\t\t\tif not\n\t\t\t\tgit/add -r $f\n\t\t}\n\t\tgit/walk -fRMA $files\n\t\tif(~ $#nocommit 0){\n\t\t\tif(hash=`{git/save -n $aname -e $amail -N $name -E $email -m $msg -d $date $parents $files}){\n\t\t\t\techo $hash > $refpath\n\t\t\t\tfor(f in $files)\n\t\t\t\t\techo T NOQID 0 $f >> .git/INDEX9\n\t\t\t}\n\t\t}\n\t\tstatus=''''\n\t'\n}\n\ngitup\n\nflagfmt='n:nocommit'; args='file ...'\neval `''{aux/getflags $*} || exec aux/usage\n\npatches=(/fd/0)\nif(! ~ $#* 0)\n\tpatches=`{cleanname -d $gitrel $*}\nfor(p in $patches){\n\t# upas serves the decoded header and body separately,\n\t# so we cat them together when applying a upas message.\n\t#\n\t# this allows mime-encoded or line-wrapped patches.\n\tif(test -d $p && test -f $p/header && test -f $p/body)\n\t\t{{cat $p/header; echo; cat $p/body} | apply} || die $status\n\tif not\n\t\tapply < $p\n}\nexit ''\n", "source": "git9/import", "file_type": "rc"}
{"text": "#include <u.h>\n#include <libc.h>\n\n#include \"git.h\"\n\nchar *fetchbranch;\nchar *upstream = \"origin\";\nchar *packtmp = \".git/objects/pack/fetch.tmp\";\nint listonly;\n\nint\nresolveremote(Hash *h, char *ref)\n{\n\tchar buf[128], *s;\n\tint r, f;\n\n\tref = strip(ref);\n\tif((r = hparse(h, ref)) != -1)\n\t\treturn r;\n\t/* Slightly special handling: translate remote refs to local ones. */\n\tif(strcmp(ref, \"HEAD\") == 0){\n\t\tsnprint(buf, sizeof(buf), \".git/HEAD\");\n\t}else if(strstr(ref, \"refs/heads\") == ref){\n\t\tref += strlen(\"refs/heads\");\n\t\tsnprint(buf, sizeof(buf), \".git/refs/remotes/%s/%s\", upstream, ref);\n\t}else if(strstr(ref, \"refs/tags\") == ref){\n\t\tref += strlen(\"refs/tags\");\n\t\tsnprint(buf, sizeof(buf), \".git/refs/tags/%s/%s\", upstream, ref);\n\t}else{\n\t\treturn -1;\n\t}\n\n\tr = -1;\n\ts = strip(buf);\n\tif((f = open(s, OREAD)) == -1)\n\t\treturn -1;\n\tif(readn(f, buf, sizeof(buf)) >= 40)\n\t\tr = hparse(h, buf);\n\tclose(f);\n\n\tif(r == -1 && strstr(buf, \"ref:\") == buf)\n\t\treturn resolveremote(h, buf + strlen(\"ref:\"));\n\treturn r;\n}\n\nint\nrename(char *pack, char *idx, Hash h)\n{\n\tchar name[128];\n\tDir st;\n\n\tnulldir(&st);\n\tst.name = name;\n\tsnprint(name, sizeof(name), \"%H.pack\", h);\n\tif(access(name, AEXIST) == 0)\n\t\tfprint(2, \"warning, pack %s already fetched\\n\", name);\n\telse if(dirwstat(pack, &st) == -1)\n\t\treturn -1;\n\tsnprint(name, sizeof(name), \"%H.idx\", h);\n\tif(access(name, AEXIST) == 0)\n\t\tfprint(2, \"warning, pack %s already indexed\\n\", name);\n\telse if(dirwstat(idx, &st) == -1)\n\t\treturn -1;\n\treturn 0;\n}\n\nint\ncheckhash(int fd, vlong sz, Hash *hcomp)\n{\n\tDigestState *st;\n\tHash hexpect;\n\tchar buf[Pktmax];\n\tvlong n, r;\n\tint nr;\n\t\n\tif(sz < 28){\n\t\twerrstr(\"undersize packfile\");\n\t\treturn -1;\n\t}\n\n\tst = nil;\n\tn = 0;\n\twhile(n != sz - 20){\n\t\tnr = sizeof(buf);\n\t\tif(sz - n - 20 < sizeof(buf))\n\t\t\tnr = sz - n - 20;\n\t\tr = readn(fd, buf, nr);\n\t\tif(r != nr)\n\t\t\treturn -1;\n\t\tst = sha1((uchar*)buf, nr, nil, st);\n\t\tn += r;\n\t}\n\tsha1(nil, 0, hcomp->h, st);\n\tif(readn(fd, hexpect.h, sizeof(hexpect.h)) != sizeof(hexpect.h))\n\t\tsysfatal(\"truncated packfile\");\n\tif(!hasheq(hcomp, &hexpect)){\n\t\twerrstr(\"bad hash: %H != %H\", *hcomp, hexpect);\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nint\nmkoutpath(char *path)\n{\n\tchar s[128];\n\tchar *p;\n\tint fd;\n\n\tsnprint(s, sizeof(s), \"%s\", path);\n\tfor(p=strchr(s+1, '/'); p; p=strchr(p+1, '/')){\n\t\t*p = 0;\n\t\tif(access(s, AEXIST) != 0){\n\t\t\tfd = create(s, OREAD, DMDIR | 0755);\n\t\t\tif(fd == -1)\n\t\t\t\treturn -1;\n\t\t\tclose(fd);\n\t\t}\t\t\n\t\t*p = '/';\n\t}\n\treturn 0;\n}\n\nint\nbranchmatch(char *br, char *pat)\n{\n\tchar name[128];\n\n\tif(strstr(pat, \"refs/heads\") == pat)\n\t\tsnprint(name, sizeof(name), \"%s\", pat);\n\telse if(strstr(pat, \"heads\"))\n\t\tsnprint(name, sizeof(name), \"refs/%s\", pat);\n\telse\n\t\tsnprint(name, sizeof(name), \"refs/heads/%s\", pat);\n\treturn strcmp(br, name) == 0;\n}\n\nchar *\nmatchcap(char *s, char *cap, int full)\n{\n\tif(strncmp(s, cap, strlen(cap)) == 0)\n\t\tif(!full || strlen(s) == strlen(cap))\n\t\t\treturn s + strlen(cap);\n\treturn nil;\n}\n\nvoid\nhandlecaps(char *caps)\n{\n\tchar *p, *n, *c, *r;\n\n\tfor(p = caps; p != nil; p = n){\n\t\tn = strchr(p, ' ');\n\t\tif(n != nil)\n\t\t\t*n++ = 0;\n\t\tif((c = matchcap(p, \"symref=\", 0)) != nil){\n\t\t\tif((r = strchr(c, ':')) != nil){\n\t\t\t\t*r++ = '\\0';\n\t\t\t\tprint(\"symref %s %s\\n\", c, r);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint\nfetchpack(Conn *c, int pfd, char *packtmp)\n{\n\tchar buf[Pktmax], idxtmp[256], *sp[3];\n\tHash h, *have, *want;\n\tint nref, refsz, first;\n\tint i, n, req;\n\tvlong packsz;\n\tObject *o;\n\n\tnref = 0;\n\trefsz = 16;\n\tfirst = 1;\n\thave = eamalloc(refsz, sizeof(have[0]));\n\twant = eamalloc(refsz, sizeof(want[0]));\n\twhile(1){\n\t\tn = readpkt(c, buf, sizeof(buf));\n\t\tif(n == -1)\n\t\t\treturn -1;\n\t\tif(n == 0)\n\t\t\tbreak;\n\t\tif(strncmp(buf, \"ERR \", 4) == 0)\n\t\t\tsysfatal(\"%s\", buf + 4);\n\n\t\tif(first && n > strlen(buf))\n\t\t\thandlecaps(buf + strlen(buf) + 1);\n\t\tfirst = 0;\n\n\t\tgetfields(buf, sp, nelem(sp), 1, \" \\t\\n\\r\");\n\t\tif(strstr(sp[1], \"^{}\"))\n\t\t\tcontinue;\n\t\tif(fetchbranch && !branchmatch(sp[1], fetchbranch))\n\t\t\tcontinue;\n\t\tif(refsz == nref + 1){\n\t\t\trefsz *= 2;\n\t\t\thave = erealloc(have, refsz * sizeof(have[0]));\n\t\t\twant = erealloc(want, refsz * sizeof(want[0]));\n\t\t}\n\t\tif(hparse(&want[nref], sp[0]) == -1)\n\t\t\tsysfatal(\"invalid hash %s\", sp[0]);\n\t\tif (resolveremote(&have[nref], sp[1]) == -1)\n\t\t\tmemset(&have[nref], 0, sizeof(have[nref]));\n\t\tprint(\"remote %s %H local %H\\n\", sp[1], want[nref], have[nref]);\n\t\tnref++;\n\t}\n\tif(listonly){\n\t\tflushpkt(c);\n\t\treturn 0;\n\t}\n\n\tif(writephase(c) == -1)\n\t\tsysfatal(\"write: %r\");\n\treq = 0;\n\tfor(i = 0; i < nref; i++){\n\t\tif(hasheq(&have[i], &want[i]))\n\t\t\tcontinue;\n\t\tif((o = readobject(want[i])) != nil){\n\t\t\tunref(o);\n\t\t\tcontinue;\n\t\t}\n\t\tn = snprint(buf, sizeof(buf), \"want %H\\n\", want[i]);\n\t\tif(writepkt(c, buf, n) == -1)\n\t\t\tsysfatal(\"could not send want for %H\", want[i]);\n\t\treq = 1;\n\t}\n\tflushpkt(c);\n\tfor(i = 0; i < nref; i++){\n\t\tif(hasheq(&have[i], &Zhash))\n\t\t\tcontinue;\n\t\tn = snprint(buf, sizeof(buf), \"have %H\\n\", have[i]);\n\t\tif(writepkt(c, buf, n + 1) == -1)\n\t\t\tsysfatal(\"could not send have for %H\", have[i]);\n\t}\n\tif(!req)\n\t\tflushpkt(c);\n\n\tn = snprint(buf, sizeof(buf), \"done\\n\");\n\tif(writepkt(c, buf, n) == -1)\n\t\tsysfatal(\"write: %r\");\n\tif(!req)\n\t\treturn 0;\n\tif(readphase(c) == -1)\n\t\tsysfatal(\"read: %r\");\n\tif((n = readpkt(c, buf, sizeof(buf))) == -1)\n\t\tsysfatal(\"read: %r\");\n\tbuf[n] = 0;\n\n\tfprint(2, \"fetching...\\n\");\n\tpacksz = 0;\n\twhile(1){\n\t\tn = readn(c->rfd, buf, sizeof buf);\n\t\tif(n == 0)\n\t\t\tbreak;\n\t\tif(n == -1 || write(pfd, buf, n) != n)\n\t\t\tsysfatal(\"fetch packfile: %r\");\n\t\tpacksz += n;\n\t}\n\tcloseconn(c);\n\tif(seek(pfd, 0, 0) == -1)\n\t\tsysfatal(\"packfile seek: %r\");\n\tif(checkhash(pfd, packsz, &h) == -1)\n\t\tsysfatal(\"corrupt packfile: %r\");\n\tclose(pfd);\n\tn = strlen(packtmp) - strlen(\".tmp\");\n\tmemcpy(idxtmp, packtmp, n);\n\tmemcpy(idxtmp + n, \".idx\", strlen(\".idx\") + 1);\n\tif(indexpack(packtmp, idxtmp, h) == -1)\n\t\tsysfatal(\"could not index fetched pack: %r\");\n\tif(rename(packtmp, idxtmp, h) == -1)\n\t\tsysfatal(\"could not rename indexed pack: %r\");\n\treturn 0;\n}\n\nvoid\nusage(void)\n{\n\tfprint(2, \"usage: %s [-dl] [-b br] [-u upstream] remote\\n\", argv0);\n\tfprint(2, \"\\t-b br:\tonly fetch matching branch 'br'\\n\");\n\tfprint(2, \"remote:\tfetch from this repository\\n\");\n\texits(\"usage\");\n}\n\nvoid\nmain(int argc, char **argv)\n{\n\tint pfd;\n\tConn c;\n\n\tARGBEGIN{\n\tcase 'b':\tfetchbranch=EARGF(usage());\tbreak;\n\tcase 'u':\tupstream=EARGF(usage());\tbreak;\n\tcase 'd':\tchattygit++;\t\t\tbreak;\n\tcase 'l':\tlistonly++;\t\t\tbreak;\n\tdefault:\tusage();\t\t\tbreak;\n\t}ARGEND;\n\n\tgitinit();\n\tif(argc != 1)\n\t\tusage();\n\n\tif(mkoutpath(packtmp) == -1)\n\t\tsysfatal(\"could not create %s: %r\", packtmp);\n\tif((pfd = create(packtmp, ORDWR, 0644)) == -1)\n\t\tsysfatal(\"could not create %s: %r\", packtmp);\n\n\tif(gitconnect(&c, argv[0], \"upload\") == -1)\n\t\tsysfatal(\"could not dial %s: %r\", argv[0]);\n\tif(fetchpack(&c, pfd, packtmp) == -1)\n\t\tsysfatal(\"fetch failed: %r\");\n\tcloseconn(&c);\n\texits(nil);\n}\n", "source": "git9/fetch.c", "file_type": "c"}
{"text": "#include <u.h>\n#include <libc.h>\n#include <ctype.h>\n#include \"git.h\"\n\nenum {\n\tSinit,\n\tSiter,\n};\n\nstatic int\ncrackidx(char *path, int *np)\n{\n\tint fd;\n\tchar buf[4];\n\n\tif((fd = open(path, OREAD)) == -1)\n\t\treturn -1;\n\tif(seek(fd, 8 + 255*4, 0) == -1)\n\t\treturn -1;\n\tif(readn(fd, buf, sizeof(buf)) != sizeof(buf))\n\t\treturn -1;\n\t*np = GETBE32(buf);\n\treturn fd;\n}\n\nint\nisloosedir(char *s)\n{\n\treturn strlen(s) == 2 && isxdigit(s[0]) && isxdigit(s[1]);\n}\n\nint\nendswith(char *n, char *s)\n{\n\tint nn, ns;\n\n\tnn = strlen(n);\n\tns = strlen(s);\n\treturn nn > ns && strcmp(n + nn - ns, s) == 0;\n}\n\nint\nolsreadpacked(Objlist *ols, Hash *h)\n{\n\tchar *p;\n\tint i, j;\n\n\ti = ols->packidx;\n\tj = ols->entidx;\n\n\tif(ols->state == Siter)\n\t\tgoto step;\n\tfor(i = 0; i < ols->npack; i++){\n\t\tif(!endswith(ols->pack[i].name, \".idx\"))\n\t\t\tcontinue;\n\t\tif((p = smprint(\".git/objects/pack/%s\", ols->pack[i].name)) == nil)\n\t\t\tsysfatal(\"smprint: %r\");\n\t\tols->fd = crackidx(p, &ols->nent);\n\t\tfree(p);\n\t\tif(ols->fd == -1)\n\t\t\tcontinue;\n\t\tj = 0;\n\t\twhile(j < ols->nent){\n\t\t\tif(readn(ols->fd, h->h, sizeof(h->h)) != sizeof(h->h))\n\t\t\t\tcontinue;\n\t\t\tols->state = Siter;\n\t\t\tols->packidx = i;\n\t\t\tols->entidx = j;\n\t\t\treturn 0;\nstep:\n\t\t\tj++;\n\t\t}\n\t\tclose(ols->fd);\n\t}\n\tols->state = Sinit;\n\treturn -1;\n}\n\n\nint\nolsreadloose(Objlist *ols, Hash *h)\n{\n\tchar buf[64], *p;\n\tint i, j, n;\n\n\ti = ols->topidx;\n\tj = ols->looseidx;\n\tif(ols->state == Siter)\n\t\tgoto step;\n\tfor(i = 0; i < ols->ntop; i++){\n\t\tif(!isloosedir(ols->top[i].name))\n\t\t\tcontinue;\n\t\tif((p = smprint(\".git/objects/%s\", ols->top[i].name)) == nil)\n\t\t\tsysfatal(\"smprint: %r\");\n\t\tols->fd = open(p, OREAD);\n\t\tfree(p);\n\t\tif(ols->fd == -1)\n\t\t\tcontinue;\n\t\twhile((ols->nloose = dirread(ols->fd, &ols->loose)) > 0){\n\t\t\tj = 0;\n\t\t\twhile(j < ols->nloose){\n\t\t\t\tn = snprint(buf, sizeof(buf), \"%s%s\", ols->top[i].name, ols->loose[j].name);\n\t\t\t\tif(n >= sizeof(buf))\n\t\t\t\t\tgoto step;\n\t\t\t\tif(hparse(h, buf) == -1)\n\t\t\t\t\tgoto step;\n\t\t\t\tols->state = Siter;\n\t\t\t\tols->topidx = i;\n\t\t\t\tols->looseidx = j;\n\t\t\t\treturn 0;\nstep:\n\t\t\t\tj++;\n\t\t\t}\n\t\t\tfree(ols->loose);\n\t\t\tols->loose = nil;\n\t\t}\n\t\tclose(ols->fd);\n\t\tols->fd = -1;\n\t}\n\tols->state = Sinit;\n\treturn -1;\n}\n\nObjlist*\nmkols(void)\n{\n\tObjlist *ols;\n\n\tols = emalloc(sizeof(Objlist));\n\tif((ols->ntop = slurpdir(\".git/objects\", &ols->top)) == -1)\n\t\tsysfatal(\"read top level: %r\");\n\tif((ols->npack = slurpdir(\".git/objects/pack\", &ols->pack)) == -1)\n\t\tols->pack = nil;\n\tols->fd = -1;\n\treturn ols;\n}\n\nvoid\nolsfree(Objlist *ols)\n{\n\tif(ols == nil)\n\t\treturn;\n\tif(ols->fd != -1)\n\t\tclose(ols->fd);\n\tfree(ols->top);\n\tfree(ols->loose);\n\tfree(ols->pack);\n\tfree(ols);\n}\n\nint\nolsnext(Objlist *ols, Hash *h)\n{\n\tif(ols->stage == 0){\n\t\tif(olsreadloose(ols, h) != -1){\n\t\t\tols->idx++;\n\t\t\treturn 0;\n\t\t}\n\t\tols->stage++;\n\t}\n\tif(ols->stage == 1){\n\t\tif(olsreadpacked(ols, h) != -1){\n\t\t\tols->idx++;\n\t\t\treturn 0;\n\t\t}\n\t\tols->stage++;\n\t}\n\treturn -1;\n}\n", "source": "git9/ols.c", "file_type": "c"}
{"text": "#include <u.h>\n#include <libc.h>\n#include <ctype.h>\n\n#include \"git.h\"\n\ntypedef struct Eval\tEval;\n\nenum {\n\tBlank,\n\tKeep,\n\tDrop,\n\tSkip,\n};\n\nenum {\n\tLca,\n\tTwixt,\n\tRange,\n};\n\nstruct Eval {\n\tchar\t*str;\n\tchar\t*p;\n\tObject\t**stk;\n\tint\tnstk;\n\tint\tstksz;\n};\n\nstatic char *colors[] = {\n[Keep] \"keep\",\n[Drop] \"drop\",\n[Blank] \"blank\",\n[Skip] \"skip\",\n};\n\nstatic Object zcommit = {\n\t.type=GCommit\n};\n\nvoid\neatspace(Eval *ev)\n{\n\twhile(isspace(ev->p[0]))\n\t\tev->p++;\n}\n\nvoid\npush(Eval *ev, Object *o)\n{\n\tif(ev->nstk == ev->stksz){\n\t\tev->stksz = 2*ev->stksz + 1;\n\t\tev->stk = erealloc(ev->stk, ev->stksz*sizeof(Object*));\n\t}\n\tev->stk[ev->nstk++] = o;\n}\n\nObject*\npop(Eval *ev)\n{\n\tif(ev->nstk == 0)\n\t\tsysfatal(\"stack underflow\");\n\treturn ev->stk[--ev->nstk];\n}\n\nObject*\npeek(Eval *ev)\n{\n\tif(ev->nstk == 0)\n\t\tsysfatal(\"stack underflow\");\n\treturn ev->stk[ev->nstk - 1];\n}\n\nint\nisword(char e)\n{\n\treturn isalnum(e) || e == '/' || e == '-' || e == '_' || e == '.';\n}\n\nint\nword(Eval *ev, char *b, int nb)\n{\n\tchar *p, *e;\n\tint n;\n\n\tp = ev->p;\n\tfor(e = p; isword(*e) && strncmp(e, \"..\", 2) != 0; e++)\n\t\t/* nothing */;\n\t/* 1 for nul terminator */\n\tn = e - p + 1;\n\tif(n >= nb)\n\t\tn = nb;\n\tsnprint(b, n, \"%s\", p);\n\tev->p = e;\n\treturn n > 0;\n}\n\nint\ntake(Eval *ev, char *m)\n{\n\tint l;\n\n\tl = strlen(m);\n\tif(strncmp(ev->p, m, l) != 0)\n\t\treturn 0;\n\tev->p += l;\n\treturn 1;\n}\n\nstatic int\npaint(Hash *head, int nhead, Hash *tail, int ntail, Object ***res, int *nres, int mode)\n{\n\tQelt e;\n\tObjq objq;\n\tObjset keep, drop, skip;\n\tObject *o, *c, **range;\n\tint i, nskip, nrange;\n\n\tosinit(&keep);\n\tosinit(&drop);\n\tosinit(&skip);\n\tqinit(&objq);\n\trange = nil;\n\tnrange = 0;\n\tnskip = 0;\n\n\tfor(i = 0; i < nhead; i++){\n\t\tif(hasheq(&head[i], &Zhash))\n\t\t\tcontinue;\n\t\tif((o = readobject(head[i])) == nil){\n\t\t\tfprint(2, \"warning: %H does not point at commit\\n\", head[i]);\n\t\t\twerrstr(\"read head %H: %r\", head[i]);\n\t\t\treturn -1;\n\t\t}\n\t\tif(o->type != GCommit){\n\t\t\tfprint(2, \"warning: %H does not point at commit\\n\", o->hash);\n\t\t\tunref(o);\n\t\t\tcontinue;\n\t\t}\n\t\tdprint(1, \"init: keep %H\\n\", o->hash);\n\t\tqput(&objq, o, Keep);\n\t\tunref(o);\n\t}\t\t\n\tfor(i = 0; i < ntail; i++){\n\t\tif(hasheq(&tail[i], &Zhash))\n\t\t\tcontinue;\n\t\tif((o = readobject(tail[i])) == nil){\n\t\t\twerrstr(\"read tail %H: %r\", tail[i]);\n\t\t\treturn -1;\n\t\t}\n\t\tif(o->type != GCommit){\n\t\t\tfprint(2, \"warning: %H does not point at commit\\n\", o->hash);\n\t\t\tunref(o);\n\t\t\tcontinue;\n\t\t}\n\t\tdprint(1, \"init: drop %H\\n\", o->hash);\n\t\tqput(&objq, o, Drop);\n\t\tunref(o);\n\t}\n\n\tdprint(1, \"finding twixt commits\\n\");\n\twhile(nskip != objq.nheap && qpop(&objq, &e)){\n\t\tif(e.color == Skip)\n\t\t\tnskip--;\n\t\tif(oshas(&skip, e.o->hash))\n\t\t\tcontinue;\n\t\tswitch(e.color){\n\t\tcase Keep:\n\t\t\tif(oshas(&keep, e.o->hash))\n\t\t\t\tcontinue;\n\t\t\tif(oshas(&drop, e.o->hash))\n\t\t\t\te.color = Skip;\n\t\t\telse if(mode == Range){\n\t\t\t\trange = earealloc(range, nrange+1, sizeof(Object*));\n\t\t\t\trange[nrange++] = e.o;\n\t\t\t}\n\t\t\tosadd(&keep, e.o);\n\t\t\tbreak;\n\t\tcase Drop:\n\t\t\tif(oshas(&drop, e.o->hash))\n\t\t\t\tcontinue;\n\t\t\tif(oshas(&keep, e.o->hash))\n\t\t\t\te.color = Skip;\n\t\t\tosadd(&drop, e.o);\n\t\t\tbreak;\n\t\tcase Skip:\n\t\t\tosadd(&skip, e.o);\n\t\t\tbreak;\n\t\t}\n\t\to = readobject(e.o->hash);\n\t\tif(o->type != GCommit){\n\t\t\twerrstr(\"not a commit: %H\", o->hash);\n\t\t\tgoto error;\n\t\t}\n\t\tfor(i = 0; i < o->commit->nparent; i++){\n\t\t\tif((c = readobject(e.o->commit->parent[i])) == nil)\n\t\t\t\tgoto error;\n\t\t\tif(c->type != GCommit){\n\t\t\t\tfprint(2, \"warning: %H does not point at commit\\n\", c->hash);\n\t\t\t\tunref(c);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdprint(2, \"\\tenqueue: %s %H\\n\", colors[e.color], c->hash);\n\t\t\tqput(&objq, c, e.color);\n\t\t\tunref(c);\n\t\t\tif(e.color == Skip)\n\t\t\t\tnskip++;\n\t\t}\n\t\tunref(o);\n\t}\n\tswitch(mode){\n\tcase Lca:\n\t\tdprint(1, \"found ancestor\\n\");\n\t\to = nil;\n\t\tfor(i = 0; i < keep.sz; i++){\n\t\t\to = keep.obj[i];\n\t\t\tif(o != nil && oshas(&drop, o->hash) && !oshas(&skip, o->hash))\n\t\t\t\tbreak;\n\t\t}\n\t\tif(i == keep.sz){\n\t\t\t*nres = 0;\n\t\t\t*res = nil;\n\t\t}else{\n\t\t\t*nres = 1;\n\t\t\t*res = eamalloc(1, sizeof(Object*));\n\t\t\t(*res)[0] = o;\n\t\t}\n\t\tbreak;\n\tcase Twixt:\n\t\tdprint(1, \"found twixt\\n\");\n\t\t*res = eamalloc(keep.nobj, sizeof(Object*));\n\t\t*nres = 0;\n\t\tfor(i = 0; i < keep.sz; i++){\n\t\t\to = keep.obj[i];\n\t\t\tif(o != nil && !oshas(&drop, o->hash) && !oshas(&skip, o->hash)){\n\t\t\t\t(*res)[*nres] = o;\n\t\t\t\t(*nres)++;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase Range:\n\t\tdprint(1, \"found range\\n\");\n\t\t*res = eamalloc(nrange, sizeof(Object*));\n\t\t*nres = 0;\n\t\tfor(i = nrange - 1; i >= 0; i--){\n\t\t\to = range[i];\n\t\t\tif(!oshas(&drop, o->hash) && !oshas(&skip, o->hash)){\n\t\t\t\t(*res)[*nres] = o;\n\t\t\t\t(*nres)++;\n\t\t\t}\n\t\t}\n\t\tfree(range);\n\t\tbreak;\n\t}\n\tosclear(&keep);\n\tosclear(&drop);\n\tosclear(&skip);\n\treturn 0;\nerror:\n\tdprint(1, \"paint error: %r\\n\");\n\tfree(objq.heap);\n\tfree(range);\n\treturn -1;\n}\n\nint\nfindtwixt(Hash *head, int nhead, Hash *tail, int ntail, Object ***res, int *nres)\n{\n\treturn paint(head, nhead, tail, ntail, res, nres, Twixt);\n}\n\nObject*\nancestor(Object *a, Object *b)\n{\n\tObject **o, *r;\n\tint n;\n\n\tif(paint(&a->hash, 1, &b->hash, 1, &o, &n, Lca) == -1 || n == 0)\n\t\treturn nil;\n\tr = ref(o[0]);\n\tfree(o);\n\treturn r;\n}\n\nint\nlca(Eval *ev)\n{\n\tObject *a, *b, **o;\n\tint n;\n\n\tif(ev->nstk < 2){\n\t\twerrstr(\"ancestor needs 2 objects\");\n\t\treturn -1;\n\t}\n\tn = 0;\n\tb = pop(ev);\n\ta = pop(ev);\n\tpaint(&a->hash, 1, &b->hash, 1, &o, &n, Lca);\n\tif(n == 0)\n\t\treturn -1;\n\tpush(ev, *o);\n\tfree(o);\n\treturn 0;\n}\n\nstatic int\nparent(Eval *ev)\n{\n\tObject *o, *p;\n\n\to = pop(ev);\n\tif(o->type != GCommit){\n\t\twerrstr(\"not a commit: %H\", o->hash);\n\t\treturn -1;\n\t}\n\t/* Special case: first commit has no parent. */\n\tif(o->commit->nparent == 0)\n\t\tp = emptydir();\n\telse if ((p = readobject(o->commit->parent[0])) == nil){\n\t\twerrstr(\"no parent for %H\", o->hash);\n\t\treturn -1;\n\t}\n\t\t\n\tpush(ev, p);\n\treturn 0;\n}\n\nstatic int\nrange(Eval *ev)\n{\n\tObject *a, *b, **o;\n\tint i, n;\n\n\tb = pop(ev);\n\ta = pop(ev);\n\tif(hasheq(&b->hash, &Zhash))\n\t\tb = &zcommit;\n\tif(hasheq(&a->hash, &Zhash))\n\t\ta = &zcommit;\n\tif(a->type != GCommit || b->type != GCommit){\n\t\twerrstr(\"non-commit object in range\");\n\t\treturn -1;\n\t}\n\n\tif(paint(&b->hash, 1, &a->hash, 1, &o, &n, Range) == -1)\n\t\treturn -1;\n\tfor(i = 0; i < n; i++)\n\t\tpush(ev, o[i]);\n\tfree(o);\n\treturn 0;\n}\n\nint\nreadref(Hash *h, char *ref)\n{\n\tstatic char *try[] = {\"\", \"refs/\", \"refs/heads/\", \"refs/remotes/\", \"refs/tags/\", nil};\n\tchar buf[256], s[256], **pfx;\n\tint r, f, n;\n\n\t/* TODO: support hash prefixes */\n\tif((r = hparse(h, ref)) != -1)\n\t\treturn r;\n\tif(strcmp(ref, \"HEAD\") == 0){\n\t\tsnprint(buf, sizeof(buf), \".git/HEAD\");\n\t\tif((f = open(buf, OREAD)) == -1)\n\t\t\treturn -1;\n\t\tif((n = readn(f, s, sizeof(s) - 1))== -1)\n\t\t\treturn -1;\n\t\ts[n] = 0;\n\t\tstrip(s);\n\t\tr = hparse(h, s);\n\t\tgoto found;\n\t}\n\tfor(pfx = try; *pfx; pfx++){\n\t\tsnprint(buf, sizeof(buf), \".git/%s%s\", *pfx, ref);\n\t\tif((f = open(buf, OREAD)) == -1)\n\t\t\tcontinue;\n\t\tif((n = readn(f, s, sizeof(s) - 1)) == -1)\n\t\t\tcontinue;\n\t\ts[n] = 0;\n\t\tstrip(s);\n\t\tr = hparse(h, s);\n\t\tclose(f);\n\t\tgoto found;\n\t}\n\treturn -1;\n\nfound:\n\tif(r == -1 && strstr(s, \"ref: \") == s)\n\t\tr = readref(h, s + strlen(\"ref: \"));\n\treturn r;\n}\n\nint\nevalpostfix(Eval *ev)\n{\n\tchar name[256];\n\tObject *o;\n\tHash h;\n\n\teatspace(ev);\n\tif(!word(ev, name, sizeof(name))){\n\t\twerrstr(\"expected name in expression\");\n\t\treturn -1;\n\t}\n\tif(readref(&h, name) == -1){\n\t\twerrstr(\"invalid ref %s\", name);\n\t\treturn -1;\n\t}\n\tif(hasheq(&h, &Zhash))\n\t\to = &zcommit;\n\telse if((o = readobject(h)) == nil){\n\t\twerrstr(\"invalid ref %s (hash %H)\", name, h);\n\t\treturn -1;\n\t}\n\tpush(ev, o);\n\n\twhile(1){\n\t\teatspace(ev);\n\t\tswitch(ev->p[0]){\n\t\tcase '^':\n\t\tcase '~':\n\t\t\tev->p++;\n\t\t\tif(parent(ev) == -1)\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\t\tcase '@':\n\t\t\tev->p++;\n\t\t\tif(lca(ev) == -1)\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto done;\n\t\t\tbreak;\n\t\t}\t\n\t}\ndone:\n\treturn 0;\n}\n\nint\nevalexpr(Eval *ev, char *ref)\n{\n\tmemset(ev, 0, sizeof(*ev));\n\tev->str = ref;\n\tev->p = ref;\n\n\twhile(1){\n\t\tif(evalpostfix(ev) == -1)\n\t\t\treturn -1;\n\t\tif(ev->p[0] == '\\0')\n\t\t\treturn 0;\n\t\telse if(take(ev, \":\") || take(ev, \"..\")){\n\t\t\tif(evalpostfix(ev) == -1)\n\t\t\t\treturn -1;\n\t\t\tif(ev->p[0] != '\\0'){\n\t\t\t\twerrstr(\"junk at end of expression\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn range(ev);\n\t\t}\n\t}\n}\n\nint\nresolverefs(Hash **r, char *ref)\n{\n\tEval ev;\n\tHash *h;\n\tint i;\n\n\tif(evalexpr(&ev, ref) == -1){\n\t\tfree(ev.stk);\n\t\treturn -1;\n\t}\n\th = eamalloc(ev.nstk, sizeof(Hash));\n\tfor(i = 0; i < ev.nstk; i++)\n\t\th[i] = ev.stk[i]->hash;\n\t*r = h;\n\tfree(ev.stk);\n\treturn ev.nstk;\n}\n\nint\nresolveref(Hash *r, char *ref)\n{\n\tEval ev;\n\n\tif(evalexpr(&ev, ref) == -1){\n\t\tfree(ev.stk);\n\t\treturn -1;\n\t}\n\tif(ev.nstk != 1){\n\t\twerrstr(\"ambiguous ref expr\");\n\t\tfree(ev.stk);\n\t\treturn -1;\n\t}\n\t*r = ev.stk[0]->hash;\n\tfree(ev.stk);\n\treturn 0;\n}\n\nint\nreadrefdir(Hash **refs, char ***names, int *nrefs, char *dpath, char *dname)\n{\n\tDir *d, *e, *dir;\n\tchar *path, *name, *sep;\n\tint ndir;\n\n\tif((ndir = slurpdir(dpath, &dir)) == -1)\n\t\treturn -1;\n\tsep = (*dname == '\\0') ? \"\" : \"/\";\n\te = dir + ndir;\n\tfor(d = dir; d != e; d++){\n\t\tpath = smprint(\"%s/%s\", dpath, d->name);\n\t\tname = smprint(\"%s%s%s\", dname, sep, d->name);\n\t\tif(d->mode & DMDIR) {\n\t\t\tif(readrefdir(refs, names, nrefs, path, name) == -1)\n\t\t\t\tgoto noref;\n\t\t}else{\n\t\t\t*refs = erealloc(*refs, (*nrefs + 1)*sizeof(Hash));\n\t\t\t*names = erealloc(*names, (*nrefs + 1)*sizeof(char*));\n\t\t\tif(resolveref(&(*refs)[*nrefs], name) == -1)\n\t\t\t\tgoto noref;\n\t\t\t(*names)[*nrefs] = name;\n\t\t\t*nrefs += 1;\n\t\t\tgoto next;\n\t\t}\nnoref:\t\tfree(name);\nnext:\t\tfree(path);\n\t}\n\tfree(dir);\n\treturn 0;\n}\n\nint\nlistrefs(Hash **refs, char ***names)\n{\n\tint nrefs;\n\n\t*refs = nil;\n\t*names = nil;\n\tnrefs = 0;\n\tif(readrefdir(refs, names, &nrefs, \".git/refs\", \"\") == -1){\n\t\tfree(*refs);\n\t\treturn -1;\n\t}\n\treturn nrefs;\n}\n", "source": "git9/ref.c", "file_type": "c"}
{"text": "#include <u.h>\n#include <libc.h>\n#include \"git.h\"\n\ntypedef struct Objbuf Objbuf;\nstruct Objbuf {\n\tint off;\n\tchar *hdr;\n\tint nhdr;\n\tchar *dat;\n\tint ndat;\n};\n\nenum {\n\tMaxparents = 16,\n};\n\nchar\t*authorname;\nchar\t*authoremail;\nchar\t*committername;\nchar\t*committeremail;\nchar\t*commitmsg;\nHash\tparents[Maxparents];\nint\tnparents;\nIdxent\t*idx;\nint\tidxsz;\nint\tnidx;\nint\ngitmode(Dirent *e)\n{\n\tif(e->islink)\n\t\treturn 0120000;\n\telse if(e->ismod)\n\t\treturn 0160000;\n\telse if(e->mode & DMDIR)\n\t\treturn 0040000;\n\telse if(e->mode & 0100)\n\t\treturn 0100755;\n\telse\n\t\treturn 0100644;\n}\n\nint\nidxcmp(void *pa, void *pb)\n{\n\tIdxent *a, *b;\n\tint c;\n\n\ta = (Idxent*)pa;\n\tb = (Idxent*)pb;\n\tif((c = strcmp(a->path, b->path)) != 0)\n\t\treturn c;\n\tassert(a->order != b->order);\n\treturn a-> order < b->order ? -1 : 1;\n}\n\nint\nentcmp(void *pa, void *pb)\n{\n\tchar abuf[256], bbuf[256], *ae, *be;\n\tDirent *a, *b;\n\n\ta = pa;\n\tb = pb;\n\t/*\n\t * If the files have the same name, they're equal.\n\t * Otherwise, If they're trees, they sort as thoug\n\t * there was a trailing slash.\n\t *\n\t * Wat.\n\t */\n\tif(strcmp(a->name, b->name) == 0)\n\t\treturn 0;\n\n\tae = seprint(abuf, abuf + sizeof(abuf) - 1, a->name);\n\tbe = seprint(bbuf, bbuf + sizeof(bbuf) - 1, b->name);\n\tif(a->mode & DMDIR)\n\t\t*ae = '/';\n\tif(b->mode & DMDIR)\n\t\t*be = '/';\n\treturn strcmp(abuf, bbuf);\n}\n\nstatic int\nbwrite(void *p, void *buf, int nbuf)\n{\n\treturn Bwrite(p, buf, nbuf);\n}\n\nstatic int\nobjbytes(void *p, void *buf, int nbuf)\n{\n\tObjbuf *b;\n\tint r, n, o;\n\tchar *s;\n\n\tb = p;\n\tn = 0;\n\tif(b->off < b->nhdr){\n\t\tr = b->nhdr - b->off;\n\t\tr = (nbuf < r) ? nbuf : r;\n\t\tmemcpy(buf, b->hdr, r);\n\t\tb->off += r;\n\t\tnbuf -= r;\n\t\tn += r;\n\t}\n\tif(b->off < b->ndat + b->nhdr){\n\t\ts = buf;\n\t\to = b->off - b->nhdr;\n\t\tr = b->ndat - o;\n\t\tr = (nbuf < r) ? nbuf : r;\n\t\tmemcpy(s + n, b->dat + o, r);\n\t\tb->off += r;\n\t\tn += r;\n\t}\n\treturn n;\n}\n\nvoid\nwriteobj(Hash *h, char *hdr, int nhdr, char *dat, int ndat)\n{\n\tObjbuf b = {.off=0, .hdr=hdr, .nhdr=nhdr, .dat=dat, .ndat=ndat};\n\tchar s[64], o[256];\n\tSHA1state *st;\n\tBiobuf *f;\n\tint fd;\n\n\tst = sha1((uchar*)hdr, nhdr, nil, nil);\n\tst = sha1((uchar*)dat, ndat, nil, st);\n\tsha1(nil, 0, h->h, st);\n\n\tsnprint(s, sizeof(s), \"%H\", *h);\n\tfd = create(\".git/objects\", OREAD, DMDIR|0755);\n\tclose(fd);\n\tsnprint(o, sizeof(o), \".git/objects/%c%c\", s[0], s[1]);\n\tfd = create(o, OREAD, DMDIR | 0755);\n\tclose(fd);\n\tsnprint(o, sizeof(o), \".git/objects/%c%c/%s\", s[0], s[1], s + 2);\n\tif(readobject(*h) == nil){\n\t\tif((f = Bopen(o, OWRITE)) == nil)\n\t\t\tsysfatal(\"could not open %s: %r\", o);\n\t\tif(deflatezlib(f, bwrite, &b, objbytes, 9, 0) == -1)\n\t\t\tsysfatal(\"could not write %s: %r\", o);\n\t\tBterm(f);\n\t}\n}\n\nint\nwritetree(Dirent *ent, int nent, Hash *h)\n{\n\tchar *t, *txt, *etxt, hdr[128];\n\tint nhdr, n;\n\tDirent *d, *p;\n\n\tt = emalloc((16+256+20) * nent);\n\ttxt = t;\n\tetxt = t + (16+256+20) * nent;\n\n\t/* sqeeze out deleted entries */\n\tn = 0;\n\tp = ent;\n\tfor(d = ent; d != ent + nent; d++)\n\t\tif(d->name)\n\t\t\tp[n++] = *d;\n\tnent = n;\n\n\tqsort(ent, nent, sizeof(Dirent), entcmp);\n\tfor(d = ent; d != ent + nent; d++){\n\t\tif(strlen(d->name) >= 255)\n\t\t\tsysfatal(\"overly long filename: %s\", d->name);\n\t\tt = seprint(t, etxt, \"%o %s\", gitmode(d), d->name) + 1;\n\t\tmemcpy(t, d->h.h, sizeof(d->h.h));\n\t\tt += sizeof(d->h.h);\n\t}\n\tnhdr = snprint(hdr, sizeof(hdr), \"%T %lld\", GTree, (vlong)(t - txt)) + 1;\n\twriteobj(h, hdr, nhdr, txt, t - txt);\n\tfree(txt);\n\treturn nent;\n}\n\nvoid\nblobify(Dir *d, char *path, int *mode, Hash *bh)\n{\n\tchar h[64], *buf;\n\tint f, nh;\n\n\tif((d->mode & DMDIR) != 0)\n\t\tsysfatal(\"not file: %s\", path);\n\t*mode = d->mode;\n\tnh = snprint(h, sizeof(h), \"%T %lld\", GBlob, d->length) + 1;\n\tif((f = open(path, OREAD)) == -1)\n\t\tsysfatal(\"could not open %s: %r\", path);\n\tbuf = emalloc(d->length);\n\tif(readn(f, buf, d->length) != d->length)\n\t\tsysfatal(\"could not read blob %s: %r\", path);\n\twriteobj(bh, h, nh, buf, d->length);\n\tfree(buf);\n\tclose(f);\n}\n\nint\ntracked(char *path)\n{\n\tint r, lo, hi, mid;\n\n\tlo = 0;\n\thi = nidx-1;\n\twhile(lo <= hi){\n\t\tmid = (hi + lo) / 2;\n\t\tr = strcmp(path, idx[mid].path);\n\t\tif(r < 0)\n\t\t\thi = mid-1;\n\t\telse if(r > 0)\n\t\t\tlo = mid+1;\n\t\telse\n\t\t\treturn idx[mid].state != 'R';\n\t}\n\treturn 0; \n}\n\nint\npathelt(char *buf, int nbuf, char *p, int *isdir)\n{\n\tchar *b;\n\n\tb = buf;\n\tif(*p == '/')\n\t\tp++;\n\twhile(*p && *p != '/' && b != buf + nbuf)\n\t\t*b++ = *p++;\n\t*b = '\\0';\n\t*isdir = (*p == '/');\n\treturn b - buf;\n}\n\nDirent*\ndirent(Dirent **ent, int *nent, char *name)\n{\n\tDirent *d;\n\n\tfor(d = *ent; d != *ent + *nent; d++)\n\t\tif(d->name && strcmp(d->name, name) == 0)\n\t\t\treturn d;\n\t*nent += 1;\n\t*ent = erealloc(*ent, *nent * sizeof(Dirent));\n\td = *ent + (*nent - 1);\n\tmemset(d, 0, sizeof(*d));\n\td->name = estrdup(name);\n\treturn d;\n}\n\nint\ntreeify(Object *t, char **path, char **epath, int off, Hash *h)\n{\n\tint r, n, ne, nsub, nent, isdir;\n\tchar **p, **ep;\n\tchar elt[256];\n\tObject **sub;\n\tDirent *e, *ent;\n\tDir *d;\n\n\tr = -1;\n\tnsub = 0;\n\tnent = t->tree->nent;\n\tent = eamalloc(nent, sizeof(*ent));\n\tsub = eamalloc((epath - path), sizeof(Object*));\n\tmemcpy(ent, t->tree->ent, nent*sizeof(*ent));\n\tfor(p = path; p != epath; p = ep){\n\t\tne = pathelt(elt, sizeof(elt), *p + off, &isdir);\n\t\tfor(ep = p; ep != epath; ep++){\n\t\t\tif(strncmp(elt, *ep + off, ne) != 0)\n\t\t\t\tbreak;\n\t\t\tif((*ep)[off+ne] != '\\0' && (*ep)[off+ne] != '/')\n\t\t\t\tbreak;\n\t\t}\n\t\te = dirent(&ent, &nent, elt);\n\t\tif(e->islink)\n\t\t\tsysfatal(\"symlinks may not be modified: %s\", *path);\n\t\tif(e->ismod)\n\t\t\tsysfatal(\"submodules may not be modified: %s\", *path);\n\t\tif(isdir){\n\t\t\te->mode = DMDIR | 0755;\n\t\t\tsub[nsub] = readobject(e->h);\n\t\t\tif(sub[nsub] == nil || sub[nsub]->type != GTree)\n\t\t\t\tsub[nsub] = emptydir();\n\t\t\t/*\n\t\t\t * if after processing deletions, a tree is empty,\n\t\t\t * mark it for removal from the parent.\n\t\t\t *\n\t\t\t * Note, it is still written to the object store,\n\t\t\t * but this is fine -- and ensures that an empty\n\t\t\t * repository will continue to work.\n\t\t\t */\n\t\t\tn = treeify(sub[nsub], p, ep, off + ne + 1, &e->h);\n\t\t\tif(n == 0)\n\t\t\t\te->name = nil;\n\t\t\telse if(n == -1)\n\t\t\t\tgoto err;\n\t\t}else{\n\t\t\td = dirstat(*p);\n\t\t\tif(d != nil && tracked(*p))\n\t\t\t\tblobify(d, *p, &e->mode, &e->h);\n\t\t\telse\n\t\t\t\te->name = nil;\n\t\t\tfree(d);\n\t\t}\n\t}\n\tif(nent == 0){\n\t\twerrstr(\"%.*s: empty directory\", off, *path);\n\t\tgoto err;\n\t}\n\n\tr = writetree(ent, nent, h);\nerr:\n\tfree(sub);\n\treturn r;\t\t\n}\n\n\nvoid\nmkcommit(Hash *c, vlong date, Hash tree)\n{\n\tchar *s, h[64];\n\tint ns, nh, i;\n\tFmt f;\n\n\tfmtstrinit(&f);\n\tfmtprint(&f, \"tree %H\\n\", tree);\n\tfor(i = 0; i < nparents; i++)\n\t\tfmtprint(&f, \"parent %H\\n\", parents[i]);\n\tfmtprint(&f, \"author %s <%s> %lld +0000\\n\", authorname, authoremail, date);\n\tfmtprint(&f, \"committer %s <%s> %lld +0000\\n\", committername, committeremail, date);\n\tfmtprint(&f, \"\\n\");\n\tfmtprint(&f, \"%s\", commitmsg);\n\ts = fmtstrflush(&f);\n\n\tns = strlen(s);\n\tnh = snprint(h, sizeof(h), \"%T %d\", GCommit, ns) + 1;\n\twriteobj(c, h, nh, s, ns);\n\tfree(s);\n}\n\nObject*\nfindroot(void)\n{\n\tObject *t, *c;\n\tHash h;\n\n\tif(resolveref(&h, \"HEAD\") == -1)\n\t\treturn emptydir();\n\tif((c = readobject(h)) == nil || c->type != GCommit)\n\t\tsysfatal(\"could not read HEAD %H\", h);\n\tif((t = readobject(c->commit->tree)) == nil)\n\t\tsysfatal(\"could not read tree for commit %H\", h);\n\treturn t;\n}\n\nvoid\nusage(void)\n{\n\tfprint(2, \"usage: %s -n name -e email -m message -d date [files...]\\n\", argv0);\n\texits(\"usage\");\n}\n\nvoid\nmain(int argc, char **argv)\n{\n\tchar *ln, *dstr, *parts[4], cwd[1024];\n\tint i, r, line, ncwd;\n\tHash th, ch;\n\tvlong date;\n\tBiobuf *f;\n\tObject *t;\n\n\tgitinit();\n\tif(access(\".git\", AEXIST) != 0)\n\t\tsysfatal(\"could not find git repo: %r\");\n\tif(getwd(cwd, sizeof(cwd)) == nil)\n\t\tsysfatal(\"getcwd: %r\");\n\tdstr = nil;\n\tdate = time(nil);\n\tncwd = strlen(cwd);\n\n\tARGBEGIN{\n\tcase 'm':\n\t\tcommitmsg = EARGF(usage());\n\t\tbreak;\n\tcase 'n':\n\t\tauthorname = EARGF(usage());\n\t\tbreak;\n\tcase 'e':\n\t\tauthoremail = EARGF(usage());\n\t\tbreak;\n\tcase 'N':\n\t\tcommittername = EARGF(usage());\n\t\tbreak;\n\tcase 'E':\n\t\tcommitteremail = EARGF(usage());\n\t\tbreak;\n\tcase 'd':\n\t\tdstr = EARGF(usage());\n\t\tbreak;\n\tcase 'p':\n\t\tif(nparents >= Maxparents)\n\t\t\tsysfatal(\"too many parents\");\n\t\tif(resolveref(&parents[nparents++], EARGF(usage())) == -1)\n\t\t\tsysfatal(\"invalid parent: %r\");\n\t\tbreak;\n\tdefault:\n\t\tusage();\n\t\tbreak;\n\t}ARGEND;\n\n\tif(commitmsg == nil)\n\t\tsysfatal(\"missing message\");\n\tif(authorname == nil)\n\t\tsysfatal(\"missing name\");\n\tif(authoremail == nil)\n\t\tsysfatal(\"missing email\");\n\tif((committername == nil) != (committeremail == nil))\n\t\tsysfatal(\"partially specified committer\");\n\tif(committername == nil && committeremail == nil){\n\t\tcommittername = authorname;\n\t\tcommitteremail = authoremail;\n\t}\n\tif(dstr){\n\t\tdate=strtoll(dstr, &dstr, 10);\n\t\tif(strlen(dstr) != 0)\n\t\t\tsysfatal(\"could not parse date %s\", dstr);\n\t}\n\tfor(i = 0; i < argc; i++){\n\t\tcleanname(argv[i]);\n\t\tif(*argv[i] == '/' && strncmp(argv[i], cwd, ncwd) == 0)\n\t\t\targv[i] += ncwd;\n\t\twhile(*argv[i] == '/')\n\t\t\targv[i]++;\n\t}\n\n\tt = findroot();\n\tnidx = 0;\n\tidxsz = 32;\n\tidx = emalloc(idxsz*sizeof(Idxent));\n\tif((f = Bopen(\".git/INDEX9\", OREAD)) == nil)\n\t\tsysfatal(\"open index: %r\");\n\tline = 0;\n\twhile((ln = Brdstr(f, '\\n', 1)) != nil){\n\t\tline++;\n\t\tif(ln[0] == 0 || ln[0] == '\\n')\n\t\t\tcontinue;\n\t\tif(getfields(ln, parts, nelem(parts), 0, \" \\t\") != nelem(parts))\n\t\t\tsysfatal(\".git/INDEX9:%d: corrupt index\", line);\n\t\tif(nidx == idxsz){\n\t\t\tidxsz += idxsz/2;\n\t\t\tidx = realloc(idx, idxsz*sizeof(Idxent));\n\t\t}\n\t\tcleanname(parts[3]);\n\t\tidx[nidx].state = *parts[0];\n\t\tidx[nidx].qid = parseqid(parts[1]);\n\t\tidx[nidx].mode = strtol(parts[2], nil, 8);\n\t\tidx[nidx].path = strdup(parts[3]);\n\t\tidx[nidx].order = nidx;\n\t\tnidx++;\n\t\tfree(ln);\n\t}\n\tBterm(f);\n\tqsort(idx, nidx, sizeof(Idxent), idxcmp);\n\tr = treeify(t, argv, argv + argc, 0, &th);\n\tif(r == -1)\n\t\tsysfatal(\"could not commit: %r\\n\");\n\tmkcommit(&ch, date, th);\n\tprint(\"%H\\n\", ch);\n\texits(nil);\n}\n", "source": "git9/save.c", "file_type": "c"}
{"text": "#include <u.h>\n#include <libc.h>\n#include <ctype.h>\n#include <auth.h>\n\n#include \"git.h\"\n\nchar\t*pathpfx = nil;\nint\tallowwrite;\n\n_Noreturn static void\nfail(Conn *c, char *fmt, ...)\n{\n\tchar msg[ERRMAX];\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tvsnprint(msg, sizeof(msg), fmt, ap);\n\tva_end(ap);\n\tfmtpkt(c, \"ERR %s\\n\", msg);\n\tsysfatal(\"%s\", msg);\n}\n\nint\nshowrefs(Conn *c)\n{\n\tint i, ret, nrefs;\n\tHash head, *refs;\n\tchar **names;\n\n\tret = -1;\n\tnrefs = 0;\n\trefs = nil;\n\tnames = nil;\n\tif(resolveref(&head, \"HEAD\") != -1)\n\t\tif(fmtpkt(c, \"%H HEAD\\n\", head) == -1)\n\t\t\tgoto error;\n\n\tif((nrefs = listrefs(&refs, &names)) == -1)\n\t\tfail(c, \"listrefs: %r\");\n\tfor(i = 0; i < nrefs; i++){\n\t\tif(strncmp(names[i], \"heads/\", strlen(\"heads/\")) != 0)\n\t\t\tcontinue;\n\t\tif(fmtpkt(c, \"%H refs/%s\\n\", refs[i], names[i]) == -1)\n\t\t\tgoto error;\n\t}\n\tif(flushpkt(c) == -1)\n\t\tgoto error;\n\tret = 0;\nerror:\n\tfor(i = 0; i < nrefs; i++)\n\t\tfree(names[i]);\n\tfree(names);\n\tfree(refs);\n\treturn ret;\n}\n\nint\nservnegotiate(Conn *c, Hash **head, int *nhead, Hash **tail, int *ntail)\n{\n\tchar pkt[Pktmax];\n\tint n, acked;\n\tObject *o;\n\tHash h;\n\n\tif(showrefs(c) == -1)\n\t\treturn -1;\n\n\t*head = nil;\n\t*tail = nil;\n\t*nhead = 0;\n\t*ntail = 0;\n\twhile(1){\n\t\tif((n = readpkt(c, pkt, sizeof(pkt))) == -1)\n\t\t\tgoto error;\n\t\tif(n == 0)\n\t\t\tbreak;\n\t\tif(strncmp(pkt, \"want \", 5) != 0){\n\t\t\twerrstr(\" protocol garble %s\", pkt);\n\t\t\tgoto error;\n\t\t}\n\t\tif(hparse(&h, &pkt[5]) == -1){\n\t\t\twerrstr(\" garbled want\");\n\t\t\tgoto error;\n\t\t}\n\t\tif((o = readobject(h)) == nil){\n\t\t\twerrstr(\"requested nonexistent object\");\n\t\t\tgoto error;\n\t\t}\n\t\tunref(o);\n\t\t*head = erealloc(*head, (*nhead + 1)*sizeof(Hash));\n\t\t(*head)[*nhead] = h;\t\n\t\t*nhead += 1;\n\t}\n\n\tacked = 0;\n\twhile(1){\n\t\tif((n = readpkt(c, pkt, sizeof(pkt))) == -1)\n\t\t\tgoto error;\n\t\tif(strncmp(pkt, \"done\", 4) == 0)\n\t\t\tbreak;\n\t\tif(n == 0){\n\t\t\tif(!acked && fmtpkt(c, \"NAK\") == -1)\n\t\t\t\t\tgoto error;\n\t\t}\n\t\tif(strncmp(pkt, \"have \", 5) != 0){\n\t\t\twerrstr(\" protocol garble %s\", pkt);\n\t\t\tgoto error;\n\t\t}\n\t\tif(hparse(&h, &pkt[5]) == -1){\n\t\t\twerrstr(\" garbled have\");\n\t\t\tgoto error;\n\t\t}\n\t\tif((o = readobject(h)) == nil)\n\t\t\tcontinue;\n\t\tif(!acked){\n\t\t\tif(fmtpkt(c, \"ACK %H\", h) == -1)\n\t\t\t\tgoto error;\n\t\t\tacked = 1;\n\t\t}\n\t\tunref(o);\n\t\t*tail = erealloc(*tail, (*ntail + 1)*sizeof(Hash));\n\t\t(*tail)[*ntail] = h;\t\n\t\t*ntail += 1;\n\t}\n\tif(!acked && fmtpkt(c, \"NAK\\n\") == -1)\n\t\tgoto error;\n\treturn 0;\nerror:\n\tfmtpkt(c, \"ERR %r\\n\");\n\tfree(*head);\n\tfree(*tail);\n\treturn -1;\n}\n\nint\nservpack(Conn *c)\n{\n\tHash *head, *tail, h;\n\tint nhead, ntail;\n\n\tdprint(1, \"negotiating pack\\n\");\n\tif(servnegotiate(c, &head, &nhead, &tail, &ntail) == -1)\n\t\tfail(c, \"negotiate: %r\");\n\tdprint(1, \"writing pack\\n\");\n\tif(writepack(c->wfd, head, nhead, tail, ntail, &h) == -1)\n\t\tfail(c, \"send: %r\");\n\treturn 0;\n}\n\nint\nvalidref(char *s)\n{\n\tcleanname(s);\n\tif(strncmp(s, \"refs/\", 5) != 0)\n\t\treturn 0;\n\tfor(; *s != '\\0'; s++)\n\t\tif(!isalnum(*s) && strchr(\"/-_.\", *s) == nil)\n\t\t\treturn 0;\n\treturn 1;\n}\n\nint\nrecvnegotiate(Conn *c, Hash **cur, Hash **upd, char ***ref, int *nupd)\n{\n\tchar pkt[Pktmax], refpath[512], *sp[4];\n\tHash old, new;\n\tint n, i;\n\n\tif(showrefs(c) == -1)\n\t\treturn -1;\n\t*cur = nil;\n\t*upd = nil;\n\t*ref = nil;\n\t*nupd = 0;\n\twhile(1){\n\t\tif((n = readpkt(c, pkt, sizeof(pkt))) == -1)\n\t\t\tgoto error;\n\t\tif(n == 0)\n\t\t\tbreak;\n\t\tif(getfields(pkt, sp, nelem(sp), 1, \" \\t\\n\\r\") != 3){\n\t\t\tfmtpkt(c, \"ERR  protocol garble %s\\n\", pkt);\n\t\t\tgoto error;\n\t\t}\n\t\tif(hparse(&old, sp[0]) == -1){\n\t\t\tfmtpkt(c, \"ERR bad old hash %s\\n\", sp[0]);\n\t\t\tgoto error;\n\t\t}\n\t\tif(hparse(&new, sp[1]) == -1){\n\t\t\tfmtpkt(c, \"ERR bad new hash %s\\n\", sp[1]);\n\t\t\tgoto error;\n\t\t}\n\t\tif(!validref(sp[2])){\n\t\t\tfmtpkt(c, \"ERR invalid ref %s\\n\", sp[2]);\n\t\t\tgoto error;\n\t\t}\n\t\t*cur = erealloc(*cur, (*nupd + 1)*sizeof(Hash));\n\t\t*upd = erealloc(*upd, (*nupd + 1)*sizeof(Hash));\n\t\t*ref = erealloc(*ref, (*nupd + 1)*sizeof(Hash));\n\t\t(*cur)[*nupd] = old;\n\t\t(*upd)[*nupd] = new;\n\t\t(*ref)[*nupd] = estrdup(sp[2]);\n\t\tn = snprint(refpath, sizeof(refpath), \".git/%s\", sp[2]);\n\t\tif(n >= sizeof(refpath)-1){\n\t\t\tfmtpkt(c, \"ERR invalid ref %s\\n\", sp[2]);\n\t\t\tgoto error;\n\t\t}\n\t\tif(access(refpath, AWRITE) == -1\n\t\t&& access(refpath, AEXIST) == 0){\n\t\t\tfmtpkt(c, \"ERR read-only ref %s\\n\", sp[2]);\n\t\t\tgoto error;\n\t\t}\n\t\t*nupd += 1;\n\t}\t\t\n\treturn 0;\nerror:\n\tfree(*cur);\n\tfree(*upd);\n\tfor(i = 0; i < *nupd; i++)\n\t\tfree((*ref)[i]);\n\tfree(*ref);\n\treturn -1;\n}\n\nint\nrename(char *pack, char *idx, Hash h)\n{\n\tchar name[128], path[196];\n\tDir st;\n\n\tnulldir(&st);\n\tst.name = name;\n\tsnprint(name, sizeof(name), \"%H.pack\", h);\n\tsnprint(path, sizeof(path), \".git/objects/pack/%s\", name);\n\tif(access(path, AEXIST) == 0)\n\t\tfprint(2, \"warning, pack %s already pushed\\n\", name);\n\telse if(dirwstat(pack, &st) == -1)\n\t\treturn -1;\n\tsnprint(name, sizeof(name), \"%H.idx\", h);\n\tsnprint(path, sizeof(path), \".git/objects/pack/%s\", name);\n\tif(access(path, AEXIST) == 0)\n\t\tfprint(2, \"warning, pack %s already indexed\\n\", name);\n\telse if(dirwstat(idx, &st) == -1)\n\t\treturn -1;\n\treturn 0;\n}\n\nint\ncheckhash(int fd, vlong sz, Hash *hcomp)\n{\n\tDigestState *st;\n\tHash hexpect;\n\tchar buf[Pktmax];\n\tvlong n, r;\n\tint nr;\n\t\n\tif(sz < 28){\n\t\twerrstr(\"undersize packfile\");\n\t\treturn -1;\n\t}\n\n\tst = nil;\n\tn = 0;\n\tif(seek(fd, 0, 0) == -1)\n\t\tsysfatal(\"packfile seek: %r\");\n\twhile(n != sz - 20){\n\t\tnr = sizeof(buf);\n\t\tif(sz - n - 20 < sizeof(buf))\n\t\t\tnr = sz - n - 20;\n\t\tr = readn(fd, buf, nr);\n\t\tif(r != nr){\n\t\t\twerrstr(\"short read\");\n\t\t\treturn -1;\n\t\t}\n\t\tst = sha1((uchar*)buf, nr, nil, st);\n\t\tn += r;\n\t}\n\tsha1(nil, 0, hcomp->h, st);\n\tif(readn(fd, hexpect.h, sizeof(hexpect.h)) != sizeof(hexpect.h))\n\t\tsysfatal(\"truncated packfile\");\n\tif(!hasheq(hcomp, &hexpect)){\n\t\twerrstr(\"bad hash: %H != %H\", *hcomp, hexpect);\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nint\nmkdir(char *dir)\n{\n\tchar buf[ERRMAX];\n\tint f;\n\n\tif(access(dir, AEXIST) == 0)\n\t\treturn 0;\n\tif((f = create(dir, OREAD, DMDIR | 0755)) == -1){\n\t\trerrstr(buf, sizeof(buf));\n\t\tif(strstr(buf, \"exist\") == nil)\n\t\t\treturn -1;\n\t}\n\tclose(f);\n\treturn 0;\n}\n\nint\nupdatepack(Conn *c)\n{\n\tchar buf[Pktmax], packtmp[128], idxtmp[128], ebuf[ERRMAX];\n\tint n, pfd, packsz;\n\tHash h;\n\n\t/* make sure the needed dirs exist */\n\tif(mkdir(\".git/objects\") == -1)\n\t\treturn -1;\n\tif(mkdir(\".git/objects/pack\") == -1)\n\t\treturn -1;\n\tif(mkdir(\".git/refs\") == -1)\n\t\treturn -1;\n\tif(mkdir(\".git/refs/heads\") == -1)\n\t\treturn -1;\n\tsnprint(packtmp, sizeof(packtmp), \".git/objects/pack/recv-%d.pack.tmp\", getpid());\n\tsnprint(idxtmp, sizeof(idxtmp), \".git/objects/pack/recv-%d.idx.tmp\", getpid());\n\tif((pfd = create(packtmp, ORDWR, 0644)) == -1)\n\t\treturn -1;\n\tpacksz = 0;\n\twhile(1){\n\t\tn = read(c->rfd, buf, sizeof(buf));\n\t\tif(n == 0)\n\t\t\tbreak;\n\t\tif(n == -1){\n\t\t\trerrstr(ebuf, sizeof(ebuf));\n\t\t\tif(strstr(ebuf, \"hungup\") == nil)\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\t\t}\n\t\tif(write(pfd, buf, n) != n)\n\t\t\treturn -1;\n\t\tpacksz += n;\n\t}\n\tif(checkhash(pfd, packsz, &h) == -1){\n\t\tdprint(1, \"hash mismatch\\n\");\n\t\tgoto error1;\n\t}\n\tif(indexpack(packtmp, idxtmp, h) == -1){\n\t\tdprint(1, \"indexing failed: %r\\n\");\n\t\tgoto error1;\n\t}\n\tif(rename(packtmp, idxtmp, h) == -1){\n\t\tdprint(1, \"rename failed: %r\\n\");\n\t\tgoto error2;\n\t}\n\treturn 0;\n\nerror2:\tremove(idxtmp);\nerror1:\tremove(packtmp);\n\treturn -1;\n}\t\n\nint\nlockrepo(void)\n{\n\tint fd, i;\n\n\tfor(i = 0; i < 10; i++) {\n\t\tif((fd = create(\".git/_lock\", ORCLOSE|ORDWR|OTRUNC|OEXCL, 0644))!= -1)\n\t\t\treturn fd;\n\t\tsleep(250);\n\t}\n\treturn -1;\n}\n\nint\nupdaterefs(Conn *c, Hash *cur, Hash *upd, char **ref, int nupd)\n{\n\tchar refpath[512], buf[128];\n\tint i, newidx, hadref, fd, ret, lockfd;\n\tvlong newtm;\n\tObject *o;\n\tHash h;\n\n\tret = -1;\n\thadref = 0;\n\tnewidx = -1;\n\t/*\n\t * Date of Magna Carta.\n\t * Wrong because it  was computed using\n\t * the proleptic gregorian calendar.\n\t */\n\tnewtm = -23811206400;\t\n\tif((lockfd = lockrepo()) == -1){\n\t\tsnprint(buf, sizeof(buf), \"repo locked\\n\");\n\t\treturn -1;\n\t}\n\tfor(i = 0; i < nupd; i++){\n\t\tif(resolveref(&h, ref[i]) == 0){\n\t\t\thadref = 1;\n\t\t\tif(!hasheq(&h, &cur[i])){\n\t\t\t\tsnprint(buf, sizeof(buf), \"old ref changed: %s\", ref[i]);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t\tif(snprint(refpath, sizeof(refpath), \".git/%s\", ref[i]) == sizeof(refpath)){\n\t\t\tsnprint(buf, sizeof(buf), \"ref path too long: %s\", ref[i]);\n\t\t\tgoto error;\n\t\t}\n\t\tif(hasheq(&upd[i], &Zhash)){\n\t\t\tremove(refpath);\n\t\t\tcontinue;\n\t\t}\n\t\tif((o = readobject(upd[i])) == nil){\n\t\t\tsnprint(buf, sizeof(buf), \"update to nonexistent hash %H\", upd[i]);\n\t\t\tgoto error;\n\t\t}\n\t\tif(o->type != GCommit){\n\t\t\tsnprint(buf, sizeof(buf), \"not commit: %H\", upd[i]);\n\t\t\tgoto error;\n\t\t}\n\t\tif(o->commit->mtime > newtm){\n\t\t\tnewtm = o->commit->mtime;\n\t\t\tnewidx = i;\n\t\t}\n\t\tunref(o);\n\t\tif((fd = create(refpath, OWRITE|OTRUNC, 0644)) == -1){\n\t\t\tsnprint(buf, sizeof(buf), \"open ref: %r\");\n\t\t\tgoto error;\n\t\t}\n\t\tif(fprint(fd, \"%H\", upd[i]) == -1){\n\t\t\tsnprint(buf, sizeof(buf), \"upate ref: %r\");\n\t\t\tclose(fd);\n\t\t\tgoto error;\n\t\t}\n\t\tclose(fd);\n\t}\n\t/*\n\t * Heuristic:\n\t * If there are no valid refs, and HEAD is invalid, then\n\t * pick the ref with the newest commits as the default\n\t * branch.\n\t *\n\t * Several people have been caught out by pushing to\n\t * a repo where HEAD named differently from what got\n\t * pushed, and this is going to be more of a footgun\n\t * when 'master', 'main', and 'front' are all in active\n\t * use. This should make us pick a useful default in\n\t * those cases, instead of silently failing.\n\t */\n\tif(resolveref(&h, \"HEAD\") == -1 && hadref == 0 && newidx != -1){\n\t\tif((fd = create(\".git/HEAD\", OWRITE|OTRUNC, 0644)) == -1){\n\t\t\tsnprint(buf, sizeof(buf), \"open HEAD: %r\");\n\t\t\tgoto error;\n\t\t}\n\t\tif(fprint(fd, \"ref: %s\", ref[0]) == -1){\n\t\t\tsnprint(buf, sizeof(buf), \"write HEAD ref: %r\");\n\t\t\tgoto error;\n\t\t}\n\t\tclose(fd);\n\t}\n\tret = 0;\nerror:\n\tfmtpkt(c, \"ERR %s\", buf);\n\tclose(lockfd);\n\twerrstr(buf);\n\treturn ret;\n}\n\nint\nrecvpack(Conn *c)\n{\n\tHash *cur, *upd;\n\tchar **ref;\n\tint nupd;\n\n\tif(!allowwrite)\n\t\tfail(c, \"read-only repo\");\n\tif(recvnegotiate(c, &cur, &upd, &ref, &nupd) == -1)\n\t\tfail(c, \"negotiate refs: %r\");\n\tif(nupd != 0 && updatepack(c) == -1)\n\t\tsysfatal(\"update pack: %r\");\n\tif(nupd != 0 && updaterefs(c, cur, upd, ref, nupd) == -1)\n\t\tsysfatal(\"update refs: %r\");\n\treturn 0;\n}\n\nchar*\nparsecmd(char *buf, char *cmd, int ncmd)\n{\n\tint i;\n\tchar *p;\n\n\tfor(p = buf, i = 0; *p && i < ncmd - 1; i++, p++){\n\t\tif(*p == ' ' || *p == '\\t'){\n\t\t\tcmd[i] = 0;\n\t\t\tbreak;\n\t\t}\n\t\tcmd[i] = *p;\n\t}\n\twhile(*p == ' ' || *p == '\\t')\n\t\tp++;\n\treturn p;\n}\n\nvoid\nusage(void)\n{\n\tfprint(2, \"usage: %s [-dw] [-r rel]\\n\", argv0);\n\texits(\"usage\");\n}\n\nvoid\nmain(int argc, char **argv)\n{\n\tchar *repo, cmd[32], buf[512];\n\tConn c;\n\n\tARGBEGIN{\n\tcase 'd':\n\t\tchattygit++;\n\t\tbreak;\n\tcase 'r':\n\t\tpathpfx = EARGF(usage());\n\t\tif(*pathpfx != '/')\n\t\t\tsysfatal(\"path prefix must begin with '/'\");\n\t\tbreak;\n\tcase 'w':\n\t\tallowwrite++;\n\t\tbreak;\n\tdefault:\n\t\tusage();\n\t\tbreak;\n\t}ARGEND;\n\n\tgitinit();\n\tinteractive = 0;\n\tif(rfork(RFNAMEG) == -1)\n\t\tsysfatal(\"rfork: %r\");\n\tif(pathpfx != nil){\n\t\tif(bind(pathpfx, \"/\", MREPL) == -1)\n\t\t\tsysfatal(\"bind: %r\");\n\t}\n\tif(rfork(RFNOMNT) == -1)\n\t\tsysfatal(\"rfork: %r\");\n\n\tinitconn(&c, 0, 1);\n\tif(readpkt(&c, buf, sizeof(buf)) == -1)\n\t\tsysfatal(\"readpkt: %r\");\n\trepo = parsecmd(buf, cmd, sizeof(cmd));\n\tcleanname(repo);\n\tif(strncmp(repo, \"../\", 3) == 0)\n\t\tfail(&c, \"invalid path %s\\n\", repo);\n\tif(bind(repo, \"/\", MREPL) == -1)\n\t\tfail(&c, \"no such repo\", repo);\n\tif(chdir(\"/\") == -1)\n\t\tfail(&c, \"no such repo\");\n\tif(access(\".git\", AREAD) == -1)\n\t\tfail(&c, \"no such repo\");\n\tif(strcmp(cmd, \"git-receive-pack\") == 0)\n\t\trecvpack(&c);\n\telse if(strcmp(cmd, \"git-upload-pack\") == 0)\n\t\tservpack(&c);\n\telse\n\t\tfail(&c, \"unsupported command '%s'\", cmd);\n\texits(nil);\n}\n", "source": "git9/serve.c", "file_type": "c"}
{"text": "#include <u.h>\n#include <libc.h>\n\n#include \"git.h\"\n\nenum {\n\tMinchunk\t= 128,\n\tMaxchunk\t= 8192,\n\tSplitmask\t= (1<<8)-1,\n};\n\nstatic u32int geartab[] = {\n    0x67ed26b7, 0x32da500c, 0x53d0fee0, 0xce387dc7, 0xcd406d90, 0x2e83a4d4, 0x9fc9a38d, 0xb67259dc,\n    0xca6b1722, 0x6d2ea08c, 0x235cea2e, 0x3149bb5f, 0x1beda787, 0x2a6b77d5, 0x2f22d9ac, 0x91fc0544,\n    0xe413acfa, 0x5a30ff7a, 0xad6fdde0, 0x444fd0f5, 0x7ad87864, 0x58c5ff05, 0x8d2ec336, 0x2371f853,\n    0x550f8572, 0x6aa448dd, 0x7c9ddbcf, 0x95221e14, 0x2a82ec33, 0xcbec5a78, 0xc6795a0d, 0x243995b7,\n    0x1c909a2f, 0x4fded51c, 0x635d334b, 0x0e2b9999, 0x2702968d, 0x856de1d5, 0x3325d60e, 0xeb6a7502,\n    0xec2a9844, 0x0905835a, 0xa1820375, 0xa4be5cab, 0x96a6c058, 0x2c2ccd70, 0xba40fce3, 0xd794c46b,\n    0x8fbae83e, 0xc3aa7899, 0x3d3ff8ed, 0xa0d42b5b, 0x571c0c97, 0xd2811516, 0xf7e7b96c, 0x4fd2fcbd,\n    0xe2fdec94, 0x282cc436, 0x78e8e95c, 0x80a3b613, 0xcfbee20c, 0xd4a32d1c, 0x2a12ff13, 0x6af82936,\n    0xe5630258, 0x8efa6a98, 0x294fb2d1, 0xdeb57086, 0x5f0fddb3, 0xeceda7ce, 0x4c87305f, 0x3a6d3307,\n    0xe22d2942, 0x9d060217, 0x1e42ed02, 0xb6f63b52, 0x4367f39f, 0x055cf262, 0x03a461b2, 0x5ef9e382,\n    0x386bc03a, 0x2a1e79c7, 0xf1a0058b, 0xd4d2dea9, 0x56baf37d, 0x5daff6cc, 0xf03a951d, 0xaef7de45,\n    0xa8f4581e, 0x3960b555, 0xffbfff6d, 0xbe702a23, 0x8f5b6d6f, 0x061739fb, 0x98696f47, 0x3fd596d4,\n    0x151eac6b, 0xa9fcc4f5, 0x69181a12, 0x3ac5a107, 0xb5198fe7, 0x96bcb1da, 0x1b5ddf8e, 0xc757d650,\n    0x65865c3a, 0x8fc0a41a, 0x87435536, 0x99eda6f2, 0x41874794, 0x29cff4e8, 0xb70efd9a, 0x3103f6e7,\n    0x84d2453b, 0x15a450bd, 0x74f49af1, 0x60f664b1, 0xa1c86935, 0xfdafbce1, 0xe36353e3, 0x5d9ba739,\n    0xbc0559ba, 0x708b0054, 0xd41d808c, 0xb2f31723, 0x9027c41f, 0xf136d165, 0xb5374b12, 0x9420a6ac,\n    0x273958b6, 0xe6c2fad0, 0xebdc1f21, 0xfb33af8b, 0xc71c25cd, 0xe9a2d8e5, 0xbeb38a50, 0xbceb7cc2,\n    0x4e4e73f0, 0xcd6c251d, 0xde4c032c, 0x4b04ac30, 0x725b8b21, 0x4eb8c33b, 0x20d07b75, 0x0567aa63,\n    0xb56b2bb7, 0xc1f5fd3a, 0xcafd35ca, 0x470dd4da, 0xfe4f94cd, 0xfb8de424, 0xe8dbcf40, 0xfe50a37a,\n    0x62db5b5d, 0xf32f4ab6, 0x2c4a8a51, 0x18473dc0, 0xfe0cbb6e, 0xfe399efd, 0xdf34ecc9, 0x6ccd5055,\n    0x46097073, 0x139135c2, 0x721c76f6, 0x1c6a94b4, 0x6eee014d, 0x8a508e02, 0x3da538f5, 0x280d394f,\n    0x5248a0c4, 0x3ce94c6c, 0x9a71ad3a, 0x8493dd05, 0xe43f0ab6, 0x18e4ed42, 0x6c5c0e09, 0x42b06ec9,\n    0x8d330343, 0xa45b6f59, 0x2a573c0c, 0xd7fd3de6, 0xeedeab68, 0x5c84dafc, 0xbbd1b1a8, 0xa3ce1ad1,\n    0x85b70bed, 0xb6add07f, 0xa531309c, 0x8f8ab852, 0x564de332, 0xeac9ed0c, 0x73da402c, 0x3ec52761,\n    0x43af2f4d, 0xd6ff45c8, 0x4c367462, 0xd553bd6a, 0x44724855, 0x3b2aa728, 0x56e5eb65, 0xeaf16173,\n    0x33fa42ff, 0xd714bb5d, 0xfbd0a3b9, 0xaf517134, 0x9416c8cd, 0x534cf94f, 0x548947c2, 0x34193569,\n    0x32f4389a, 0xfe7028bc, 0xed73b1ed, 0x9db95770, 0x468e3922, 0x0440c3cd, 0x60059a62, 0x33504562,\n    0x2b229fbd, 0x5174dca5, 0xf7028752, 0xd63c6aa8, 0x31276f38, 0x0646721c, 0xb0191da8, 0xe00e6de0,\n    0x9eac1a6e, 0x9f7628a5, 0xed6c06ea, 0x0bb8af15, 0xf119fb12, 0x38693c1c, 0x732bc0fe, 0x84953275,\n    0xb82ec888, 0x33a4f1b3, 0x3099835e, 0x028a8782, 0x5fdd51d7, 0xc6c717b3, 0xb06caf71, 0x17c8c111,\n    0x61bad754, 0x9fd03061, 0xe09df1af, 0x3bc9eb73, 0x85878413, 0x9889aaf2, 0x3f5a9e46, 0x42c9f01f,\n    0x9984a4f4, 0xd5de43cc, 0xd294daed, 0xbecba2d2, 0xf1f6e72c, 0x5551128a, 0x83af87e2, 0x6f0342ba,\n};\n\nstatic u64int\nhash(void *p, int n)\n{\n\treturn murmurhash2(p, n);\n}\n\nstatic void\naddblk(Dtab *dt, void *buf, int len, int off, u64int h)\n{\n\tint i, sz, probe;\n\tDblock *db;\n\n\tprobe = h % dt->sz;\n\twhile(dt->b[probe].buf != nil){\n\t\tif(len == dt->b[probe].len && memcmp(buf, dt->b[probe].buf, len) == 0)\n\t\t\treturn;\n\t\tprobe = (probe + 1) % dt->sz;\n\t}\n\tassert(dt->b[probe].buf == nil);\n\tdt->b[probe].buf = buf;\n\tdt->b[probe].len = len;\n\tdt->b[probe].off = off;\n\tdt->b[probe].hash = h;\n\tdt->nb++;\n\tif(dt->sz < 2*dt->nb){\n\t\tsz = dt->sz;\n\t\tdb = dt->b;\n\t\tdt->sz *= 2;\n\t\tdt->nb = 0;\n\t\tdt->b = eamalloc(dt->sz, sizeof(Dblock));\n\t\tfor(i = 0; i < sz; i++)\n\t\t\tif(db[i].buf != nil)\n\t\t\t\taddblk(dt, db[i].buf, db[i].len, db[i].off, db[i].hash);\n\t\tfree(db);\n\t}\t\t\n}\n\nstatic Dblock*\nlookup(Dtab *dt, uchar *p, int n)\n{\n\tint probe;\n\tu64int h;\n\n\th = hash(p, n);\n\tfor(probe = h % dt->sz; dt->b[probe].buf != nil; probe = (probe + 1) % dt->sz){\n\t\tif(dt->b[probe].hash != h)\n\t\t\tcontinue;\n\t\tif(n != dt->b[probe].len)\n\t\t\tcontinue;\n\t\tif(memcmp(p, dt->b[probe].buf, n) != 0)\n\t\t\tcontinue;\n\t\treturn &dt->b[probe];\n\t}\n\treturn nil;\n}\n\nstatic int\nnextblk(uchar *s, uchar *e)\n{\n\tu32int gh;\n\tuchar *p;\n\n\tif((e - s) < Minchunk)\n\t\treturn e - s;\n\tp = s + Minchunk;\n\tif((e - s) > Maxchunk)\n\t\te = s + Maxchunk;\n\tgh = 0;\n\twhile(p != e){\n\t\tgh = (gh<<1) + geartab[*p++];\n\t\tif((gh & Splitmask) == 0)\n\t\t\tbreak;\n\t}\n\treturn p - s;\n}\n\nvoid\ndtinit(Dtab *dt, Object *obj)\n{\n\tuchar *s, *e;\n\tu64int h;\n\tvlong n, o;\n\t\n\to = 0;\n\ts = (uchar*)obj->data;\n\te = s + obj->size;\n\tdt->o = ref(obj);\n\tdt->nb = 0;\n\tdt->sz = 128;\n\tdt->b = eamalloc(dt->sz, sizeof(Dblock));\n\tdt->base = (uchar*)obj->data;\n\tdt->nbase = obj->size;\n\twhile(s != e){\n\t\tn = nextblk(s, e);\n\t\th = hash(s, n);\n\t\taddblk(dt, s, n, o, h);\n\t\ts += n;\n\t\to += n;\n\t}\n}\n\nvoid\ndtclear(Dtab *dt)\n{\n\tunref(dt->o);\n\tfree(dt->b);\n}\n\nstatic int\nemitdelta(Delta **pd, int *nd, int cpy, int off, int len)\n{\n\tDelta *d;\n\n\t*nd += 1;\n\t*pd = earealloc(*pd, *nd, sizeof(Delta));\n\td = &(*pd)[*nd - 1];\n\td->cpy = cpy;\n\td->off = off;\n\td->len = len;\n\treturn len;\n}\n\nstatic int\nstretch(Dtab *dt, Dblock *b, uchar *s, uchar *e, int n)\n{\n\tuchar *p0, *p, *q, *eb;\n\n\tif(b == nil)\n\t\treturn n;\n\tp = s + n;\n\tq = dt->base + b->off + n;\n\tp0 = p;\n\tif(dt->nbase < (1<<24)-1)\n\t\teb = dt->base + dt->nbase;\n\telse\n\t\teb = dt->base + (1<<24)-1;\n\twhile(1){\n\t\tif(p == e || q == eb)\n\t\t\tbreak;\n\t\tif(*p != *q)\n\t\t\tbreak;\n\t\tp++;\n\t\tq++;\n\t}\n\treturn n + (p - p0);\n}\n\nDelta*\ndeltify(Object *obj, Dtab *dt, int *pnd)\n{\n\tDelta *d;\n\tDblock *b;\n\tuchar *s, *e;\n\tvlong n, o;\n\t\n\to = 0;\n\td = nil;\n\ts = (uchar*)obj->data;\n\te = s + obj->size;\n\t*pnd = 0;\n\twhile(s != e){\n\t\tn = nextblk(s, e);\n\t\tb = lookup(dt, s, n);\n\t\tn = stretch(dt, b, s, e, n);\n\t\tif(b != nil)\n\t\t\temitdelta(&d, pnd, 1, b->off, n);\n\t\telse\n\t\t\temitdelta(&d, pnd, 0, o, n);\n\t\ts += n;\n\t\to += n;\n\t}\n\treturn d;\n}\n", "source": "git9/delta.c", "file_type": "c"}
{"text": "#!/bin/rc -e\n\ncd $1\nshift\n\nrfork ne\nnl='\n'\n\nfn htcat {\n\tsed '\n\t\ts/&/\\&amp;/g;\n\t\ts/</\\&lt;/g;\n\t\ts/>/\\&gt;/g;\n\t\ts/\"/\\&quot;/g;\n\t\ts/''/\\&#39;/g\n\t' $*\n}\n\nfn resolveref {\n\tif(~ $refname HEAD)\n\t\techo $refname\n\tif not if(test -d $gitfs/branch/$refname/tree)\n\t\techo branch/$refname\n\tif not if(test -d $gitfs/object/$refname/tree)\n\t\techo object/$refname\n\tif not\n\t\tstatus='bad ref'\n}\n\nfn repons {\n\tmntgen\n\tmntgen /mnt/mnt\n\tbind /bin /mnt/bin\n\tbind /tmp /mnt/tmp\n\tbind -c /env /mnt/env\n\tbind $1 /mnt/$repo\n\tbind /mnt /\n\tcd /mnt/$repo\n\tgit/fs\n\trfork m\n}\n\n\nfn prelude {\n\techo '\n\t<!DOCTYPE html>\n\t<html>\n\t\n\t<head>\n\t\t<style type=\"text/css\">\n\t\t\tbody{\n\t\t\t\tmargin: 3em auto;\n\t\t\t\tmax-width: 50em;\n\t\t\t\tfont-family: sans-serif;\n\t\t\t}\n\t\t\th1,h2{\n\t\t\t\tfont-size: 1.3em;\n\t\t\t\tcolor: #4c4c99;\n\t\t\t}\n\t\t\th3{\n\t\t\t\tfont-size: 1em;\n\t\t\t\tcolor: #4c4c99;\n\t\t\t}\n\t\t\t#desc{\n\t\t\t}\n\t\t\t#code{\n\t\t\t\tbackground: #ffffea;\n\t\t\t\tborder: #99994cff\n\t\t\t}\n\t\t</style>\n\t \t<link rel=\"alternate\" type=\"application/rss+xml\" href=\"feed.rss\" title=\"rss\">\n\t\t<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\">\n\t\t<title>git webls</title>\n\t</head>\n\t<body>\n\t'\n}\n\nswitch($1){\ncase 'tar'\n\trepo=$2\n\trefname=$3\n\t@{\n\trepons $2\n\tif(! ref=`{resolveref $refname}){\n\t\techo '<b>invalid ref '$refname'</b>'\n\t\texit\n\t}\n\tbind $gitfs/$ref/tree /mnt/$repo\n\tcd /mnt\n\ttar cz $repo\n\t}\n\ncase 'list'\n\trfork m\n\tprelude\n\techo '\t<h1>Repos</h1>\n\t\t<dl>'\n\tfor(repo in `$nl{ls}){\n\t\tif(test -e $repo/.git/webpublish){\n\t\t\techo '<dt><a href=\"/git/'$repo'/HEAD/info.html\">'$repo'</a></dt>'\n\t\t\techo '<dd>'\n\t\t\tif(test -f $repo/.git/desc)\n\t\t\t\thtcat $repo/.git/desc\n\t\t\tif not\n\t\t\t\techo 'code some guy wrote'\n\t\t\techo '</dd>'\n\t\t}\n\t}\n\techo '</dl>'\n\ncase 'info'\n\trepo=$2\n\trepodir=/mnt/$repo/.git\n\trefname=$3\n\t@{\n\trepons $repo\n\tif(! ref=`{resolveref $refname}){\n\t\techo '<b>invalid ref '$refname'</b>'\n\t\texit\n\t}\n\tcd $gitfs/$ref/tree\n\thash=`{cat $gitfs/$ref/hash}\n\n\tprelude $repo $ref $repo\n\techo '\t<h1><a href=\"/git/repos.html\">Git</a>: <a\n\t\thref=/git/'$repo'/'$ref'/info.html>'$repo'</a></h1>\n\t\t<p>'$repo' @ <a href='/git/$repo/$hash/f.html'>'$hash'</a>\n\t\t<pre id=\"desc\">'\n\thtcat $gitfs/object/$hash/msg\n\techo '\t</pre>\n\t\t<h2>Code</h2>\n\t\t<p>\n\t\t<b>clone:</b> git://orib.dev/'$repo', gits://orib.dev/'$repo'<br>\n\t\t<b>push:</b> hjgit://orib.dev/'$repo'<br>\n\t\t<b>tar:</b> <a href=\"'/git/$repo/$hash/snap.tar.gz'\">snap.tar.gz</a><br>'\n\tif(test -f $repodir/contact)\n\t\techo '<b>patches to: </b>'^`$nl{cat $repodir/contact}^'<br>\n\t\t\t</p>\n\t\t\t<pre id=\"code\">'\n\tfor(f in `$nl{ls}){\n\t\turl=`$nl{echo -n $f/f.html | urlencode}\n\t\tfname=`$nl{echo -n $f | htcat}\n\t\techo '<a href=\"'$url'\">'$fname'</a>'\n\t}\t\t\n\techo '</pre>\n\t\t<h2>About This Repo</h2>\n\t\t<pre id=\"desc\">'\n\tif(test -f $repodir/README)\n\t\thtcat $repodir/README\n\tif not if(test -f README)\n\t\thtcat README\n\tif not if (test -f README.md)\n\t\thtcat README.md\n\tif not if(test -f $repodir/desc)\n\t\thtcat $repodir/desc\n\tif not\n\t\techo 'this repo has no description'\n\techo '\n\t\t</pre>\n\t\t</body>\n\t\t</html>\n\t'\n\t}\n\ncase 'view'\n\trepo=$2\n\trepodir=/mnt/$repo/.git\n\trefname=$3\n\tfile=$4\n\t@{\n\trepons $repo\n\tif(! ref=`{resolveref $refname}){\n\t\techo '<b>invalid ref '$refname'</b>'\n\t\texit\n\t}\n\tcd $gitfs/$ref/tree\n\tif(~ $file '')\n\t\tfile='.'\n\thash=`{cat $gitfs/$ref/hash}\n\n\tprelude\n\techo '\t<h1><a href=\"/git/repos.html\">Git</a>: <a\n\t\thref='/git/$repo/$ref/info.html'>'$repo'</a></h1>\n\t\t<p>'$repo' @ <a href=\"'/git/$repo/$hash/f.html'\">'$hash'</a>\n\t\t<pre id=\"code\">'\n\tif(test -f $file){\n\t\thtcat $file\n\t}\n\tif not if(test -d $file){\n\t\tcd $file\n\t\tfor(f in `$nl{ls}){\n\t\t\turl=`$nl{echo -n $f/f.html | urlencode}\n\t\t\tfname=`$nl{echo -n $f | htcat}\n\t\t\techo '<a href=\"'$url'\">'$fname'</a>'\n\t\t}\n\t}\n\techo '\t</pre>\n\t\t</body>\n\t\t</html>'\n\t}\n}\n", "source": "git9/extra/gitls", "file_type": "rc"}
{"text": "testlet : Integer -> Integer\ntestlet $x = let y = prim__add_Integer x x in \n                 prim__add_Integer y y \n\ndata Nat : Type where\n     Z : Nat\n     S : Nat -> Nat\n\nplus : Nat -> Nat -> Nat\nplus Z     $y = y\nplus (S $k) $y = S (plus k y)\n\nfn2 : Nat -> Nat -> Nat\nfn2 $x $y \n    = let w : Nat\n          w = plus x x;\n          help : Nat -> Nat\n          help $z = plus z w in\n          plus (help y) w\n\nfn : Nat -> Nat -> Nat\nfn $x $y \n    = let w : ?; w = plus x x in\n      let foo = plus x x in\n      let help : Nat -> Nat;\n          help $z = plus z w in\n      plus (help y) foo\n\nlocaldata : Nat -> Nat\nlocaldata $var =\n   let data Bool : Type where\n            False : Bool\n            True : Bool\n\n       isS : Nat -> Bool\n       isS Z = False\n       isS (S $k) = True\n\n       boolToNat : Bool -> Nat\n       boolToNat False = Z\n       boolToNat True = S var in\n   boolToNat (isS var)\n", "source": "Idris 2/tests/ttimp/nest001/Let.yaff", "file_type": "rc"}
{"text": "testlet 2\nfn (S Z) (S Z)\nfn2 (S Z) (S Z)\nlocaldata Z\nlocaldata (S (S Z))\n:q\n", "source": "Idris 2/tests/ttimp/nest001/input", "file_type": "rc"}
{"text": "data Nat : Type where\n     Z : Nat\n     S : Nat -> Nat\n\ndata List : Type -> Type where\n     Nil : List $a\n     Cons : $a -> List $a -> List $a\n\ndata Elem : $a -> List $a -> Type where\n     Here : Elem $x (Cons $x $xs)\n     There : Elem $x $xs -> Elem $x (Cons $y $xs)\n\ndata Pair : Type -> Type -> Type where\n     MkPair : $a -> $b -> Pair $a $b\n\nfst : {0 a, b : _} -> Pair a b -> a\nfst (MkPair $x _) = x\n\nsnd : {0 a, b : _} -> Pair a b -> b\nsnd (MkPair _ $y) = y\n\n%pair Pair fst snd\n\nisThere : Elem Z (Cons (S Z) (Cons Z Nil))\nisThere = %search\n\nisThere2 : Elem (S Z) (Cons (S Z) (Cons Z Nil))\nisThere2 = %search\n\nisThere3 : Elem (S (S Z)) (Cons (S Z) (Cons Z Nil))\n-- isThere3 = %search\n\nfn : $a -> $b -> $a\nfn = %search\n\napp : ($a -> $b) -> $a -> $b\napp = %search\n\ntest : $a -> Pair (Integer -> $a) Integer\ntest $y = MkPair (\\x => y) 42\n\nfoo : Pair (Integer -> $a) (Pair $c $b) -> Integer -> Pair $b $a\nfoo = %search\n\nbar : Pair (Int -> $a) (Pair $c $b) -> Int -> Pair $b Char\n\n\n", "source": "Idris 2/tests/ttimp/search001/Auto.yaff", "file_type": "rc"}
{"text": "0 ICON \"idris.ico\"\n", "source": "Idris 2/icons/idris_icon.rc", "file_type": "rc"}
{"text": "</$objtype/mkfile\n\nBIN=/$objtype/bin\nTARG=idris2\nCFLAGS=$CFLAGS -I. -I../../plan9 -D__plan9__ -DIDRIS_TARGET_OS=\"plan9\" '-DIDRIS_TARGET_TRIPLE=\"'$objtype'-unknown-plan9\"'\n\nOFILES=\\\n\tgetline.$O\\\n\tidris_bitstring.$O\\\n\tidris_buffer.$O\\\n\tidris_gc.$O\\\n\tidris_gmp.$O\\\n\tidris_heap.$O\\\n\tidris_main.$O\\\n\tidris_net_plan9.$O\\\n\tidris_opts.$O\\\n\tidris_rts.$O\\\n\tidris_stats.$O\\\n\tidris_stdfgn_plan9.$O\\\n\tidris_utf8.$O\\\n\tmini-gmp.$O\\\n\tidris2.$O\\\n\nHFILES=\\\n\tgetline.h\\\n\tidris_bitstring.h\\\n\tidris_buffer.h\\\n\tidris_gc.h\\\n\tidris_gmp.h\\\n\tidris_heap.h\\\n\tidris_net.h\\\n\tidris_opts.h\\\n\tidris_rts.h\\\n\tidris_stats.h\\\n\tidris_stdfgn.h\\\n\tidris_utf8.h\\\n\tmini-gmp.h\\\n\n</sys/src/cmd/mkone\n\nidris2.$O: ../../idris2.c\n\t$CC $CFLAGS ../../idris2.c\n", "source": "Idris 2/dist/rts/mkfile", "file_type": "mkfile"}
{"text": "#ifndef __PLATFORM_H__\n#define __PLATFORM_H__\n#ifdef __plan9__\n#include <u.h>\n#include <libc.h>\n#include <stdio.h>\n#include <ctype.h>\ntypedef long ssize_t;\ntypedef unsigned long size_t;\ntypedef enum { false, true } bool;\ntypedef s8int int8_t;\ntypedef u8int uint8_t;\ntypedef s16int int16_t;\ntypedef u16int uint16_t;\ntypedef s32int int32_t;\ntypedef u32int uint32_t;\ntypedef s64int int64_t;\ntypedef u64int uint64_t;\ntypedef long long intptr_t; /* FIXME define one for 32bit */\ntypedef long long i_int; /* FIXME ??? */\ntypedef unsigned long long uintptr_t; /* FIXME define one for 32bit */\ntypedef long long ptrdiff_t; /* FIXME define one for 32bit */\n#define exit(x) exits(x ? \"failed\" : nil)\n#define EXIT_SUCCESS nil\n#define EXIT_FAILURE \"failed\"\n#define PRIdPTR \"lld\"\n#define PRIu64 \"llu\"\n#define PRIu16 \"u\"\n#define PRIu32 \"u\"\n#define CHAR_BIT 8\n#else\n#include <assert.h>\n#include <inttypes.h>\n#include <ctype.h>\n#include <limits.h>\n#include <locale.h>\n#include <stdbool.h>\n#include <stddef.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <time.h>\n#include <dirent.h>\n#include <unistd.h>\n#ifdef HAS_PTHREAD\n#include <stdarg.h>\n#include <pthread.h>\n#endif\n#endif\n#endif\n", "source": "Idris 2/dist/rts/platform.h", "file_type": "h"}
{"text": "</$objtype/mkfile\nLIB=/$objtype/lib/libmicroui.a\n\nOFILES=\\\n\tmicroui.$O\\\n\nHFILES=\\\n\t/sys/include/microui.h\\\n\n/sys/include/%.h: %.h\n\tcp $stem.h /sys/include/$stem.h\n\n</sys/src/cmd/mksyslib\n", "source": "microui/mkfile", "file_type": "mkfile"}
{"text": "#include <u.h>\n#include <libc.h>\n#include <draw.h>\n#include <microui.h>\n\n#define MU_REAL_FMT \"%g\"\n#define MU_SLIDER_FMT \"%.2f\"\n\n#define MIN(a, b) ((a) < (b) ? (a) : (b))\n#define MAX(a, b) ((a) > (b) ? (a) : (b))\n#define CLAMP(x, a, b) MIN(b, MAX(a, x))\n\nstatic mu_Rect unclipped_rect = { 0, 0, 0x1000000, 0x1000000 };\n\nstatic u8int atlasraw[] = {\n\t0x63, 0x6f, 0x6d, 0x70, 0x72, 0x65, 0x73, 0x73, 0x65, 0x64, 0x0a, 0x20, 0x20, 0x20, 0x72, 0x38,\n\t0x67, 0x38, 0x62, 0x38, 0x61, 0x38, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t0x20, 0x30, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x30, 0x20, 0x20,\n\t0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x33, 0x34, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t0x20, 0x20, 0x20, 0x20, 0x32, 0x35, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t0x32, 0x35, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x34, 0x33, 0x39, 0x20, 0x80,\n\t0x00, 0x7c, 0x00, 0x7c, 0x00, 0x7c, 0x00, 0x78, 0x00, 0x7c, 0x00, 0x7c, 0x00, 0x7c, 0x00, 0x7c,\n\t0x00, 0x7c, 0x00, 0x7c, 0x00, 0x7c, 0x00, 0x7c, 0x00, 0x7c, 0x00, 0x7c, 0x00, 0x34, 0x00, 0x80,\n\t0x14, 0x00, 0x00, 0x80, 0x5c, 0x00, 0x00, 0x54, 0x1f, 0x04, 0x1b, 0x04, 0x23, 0x24, 0x13, 0x7c,\n\t0x00, 0x3c, 0x00, 0x80, 0x20, 0x00, 0x00, 0x80, 0xc0, 0x00, 0x00, 0x04, 0x07, 0x44, 0x1f, 0x80,\n\t0x5e, 0x00, 0x00, 0x80, 0xff, 0x00, 0x00, 0x80, 0x70, 0x00, 0x00, 0x34, 0x1b, 0x04, 0x13, 0x04,\n\t0x1b, 0x04, 0x23, 0x24, 0x17, 0x7c, 0x00, 0x2c, 0x00, 0x80, 0x21, 0x00, 0x00, 0x80, 0xe0, 0x00,\n\t0x00, 0x80, 0xea, 0x00, 0x00, 0x80, 0x2c, 0x00, 0x00, 0x54, 0x27, 0x14, 0x6f, 0x24, 0x8b, 0x44,\n\t0x13, 0x14, 0x00, 0x7c, 0x00, 0x4c, 0x83, 0x80, 0x2d, 0x00, 0x00, 0x74, 0x2f, 0x24, 0x77, 0x74,\n\t0x83, 0x7c, 0x00, 0x1c, 0x83, 0x80, 0xe1, 0x00, 0x00, 0x80, 0xeb, 0x00, 0x00, 0x7c, 0x83, 0x3c,\n\t0x8b, 0x74, 0x83, 0x24, 0x00, 0x80, 0x0e, 0x00, 0x00, 0x7c, 0x83, 0x7c, 0x83, 0x7c, 0x87, 0x3c,\n\t0x00, 0x14, 0x00, 0x80, 0x3d, 0x00, 0x00, 0x80, 0xed, 0x00, 0x00, 0x80, 0x45, 0x00, 0x00, 0x24,\n\t0x17, 0x80, 0x22, 0x00, 0x00, 0x7c, 0x83, 0x7d, 0x97, 0x75, 0x97, 0x14, 0x00, 0x80, 0x13, 0x00,\n\t0x00, 0x80, 0xd0, 0x00, 0x00, 0x80, 0xf6, 0x00, 0x00, 0x14, 0x8b, 0x24, 0x83, 0x80, 0x2e, 0x00,\n\t0x00, 0x7c, 0x79, 0x7e, 0xa7, 0x54, 0x8b, 0x54, 0x8b, 0x80, 0x63, 0x00, 0x00, 0x7c, 0x83, 0x4c,\n\t0x00, 0x7f, 0xb7, 0x3f, 0xb7, 0x54, 0x8b, 0x04, 0x2b, 0x80, 0xec, 0x00, 0x00, 0x7c, 0x83, 0x3c,\n\t0x00, 0x80, 0x14, 0x00, 0x00, 0x80, 0x5c, 0x00, 0x00, 0x54, 0x1f, 0x04, 0x1b, 0x04, 0x23, 0x24,\n\t0x13, 0x54, 0x8b, 0x80, 0xbc, 0x00, 0x00, 0x7c, 0x83, 0x7c, 0x00, 0x7c, 0x00, 0x0c, 0x00, 0x7c,\n\t0x00, 0x7c, 0x00, 0x7c, 0x00, 0x7c, 0x00, 0x7c, 0x00, 0x7c, 0x00, 0x7c, 0x00, 0x7c, 0x00, 0x7c,\n\t0x00, 0x7c, 0x00, 0x64, 0x00, 0x80, 0x5a, 0x00, 0x00, 0x06, 0x6b, 0x14, 0x07, 0x80, 0x8f, 0x00,\n\t0x00, 0x44, 0x27, 0x7c, 0x00, 0x7c, 0x00, 0x64, 0x00, 0x80, 0x3c, 0x00, 0x00, 0x80, 0xaa, 0x00,\n\t0x00, 0x04, 0x07, 0x04, 0x83, 0x54, 0x8b, 0x44, 0x17, 0x14, 0x2f, 0x7c, 0x65, 0x7c, 0x00, 0x34,\n\t0x00, 0x54, 0x8b, 0x34, 0x17, 0x64, 0xb3, 0x7c, 0x00, 0x0c, 0x00, 0x80, 0x6e, 0x00, 0x00, 0x05,\n\t0x03, 0x35, 0x0f, 0x64, 0x8b, 0x34, 0x17, 0x7c, 0x83, 0x7c, 0x00, 0x80, 0xa5, 0x00, 0x00, 0x15,\n\t0x4f, 0x26, 0x1f, 0x64, 0x83, 0x74, 0xa3, 0x7c, 0x00, 0x7c, 0x00, 0x7c, 0x63, 0x81, 0x00, 0x00,\n\t0x34, 0x27, 0x7c, 0x4d, 0x4c, 0x00, 0x80, 0x55, 0x00, 0x00, 0x80, 0x37, 0x00, 0x00, 0x04, 0x0b,\n\t0x04, 0x07, 0x04, 0x0f, 0x04, 0x0b, 0x80, 0x1e, 0x00, 0x00, 0x04, 0x0b, 0x04, 0x07, 0x64, 0x83,\n\t0x7c, 0x00, 0x7c, 0x00, 0x16, 0xef, 0x05, 0x8f, 0x75, 0x97, 0x54, 0x00, 0x7c, 0x00, 0x7c, 0x00,\n\t0x7d, 0x0f, 0x0d, 0x0f, 0x64, 0x3f,\n};\n\nstatic mu_Rect default_atlas_icons[] = {\n\t[MU_ICON_CHECK] = {0, 0, 18, 18},\n\t[MU_ICON_CLOSE] = {18, 0, 16, 16},\n\t[MU_ICON_COLLAPSED] = {27, 16, 5, 7},\n\t[MU_ICON_EXPANDED] = {0, 18, 7, 5},\n\t[MU_ICON_RESIZE] = {18, 16, 9, 9},\n\t[ATLAS_DIMENSIONS] = {0, 0, 34, 25},\n};\n\nmu_Context mu_ctx;\nmu_Style mu_style = {\n\t.font = nil,\n\t.size = { 68, 10 },\n\t.padding = 6,\n\t.spacing = 4,\n\t.indent = 24,\n\t.title_height = 26,\n\t.scrollbar_size = 12,\n\t.thumb_size = 8,\n\t.colors = {nil},\n};\n\nImage *atlasimage = nil;\nmu_Rect *atlasicons = default_atlas_icons;\nu8int defaultcolors[MU_COLOR_MAX][4] = {\n\t[MU_COLOR_BG] = {119, 119, 119, 255},\n\t[MU_COLOR_TEXT] = {230, 230, 230, 255},\n\t[MU_COLOR_BORDER] = {25, 25, 25, 255},\n\t[MU_COLOR_WINDOWBG] = {50, 50, 50, 255},\n\t[MU_COLOR_TITLEBG] = {25, 25, 25, 255},\n\t[MU_COLOR_TITLETEXT] = {240, 240, 240, 255},\n\t[MU_COLOR_PANELBG] = {0, 0, 0, 0},\n\t[MU_COLOR_BUTTON] = {75, 75, 75, 255},\n\t[MU_COLOR_BUTTONHOVER] = {95, 95, 95, 255},\n\t[MU_COLOR_BUTTONFOCUS] = {115, 115, 115, 255},\n\t[MU_COLOR_BASE] = {30, 30, 30, 255},\n\t[MU_COLOR_BASEHOVER] = {35, 35, 35, 255},\n\t[MU_COLOR_BASEFOCUS] = {40, 40, 40, 255},\n\t[MU_COLOR_SCROLLBASE] = {43, 43, 43, 255},\n\t[MU_COLOR_SCROLLTHUMB] = {30, 30, 30, 255},\n};\n\nstatic void\nbuffer_grow(void **buf, int onesz, int *bufmax, int bufnum)\n{\n\twhile (*bufmax <= bufnum) {\n\t\t*bufmax = MAX(16, *bufmax) * 2;\n\t\tif ((*buf = realloc(*buf, *bufmax*onesz)) == nil)\n\t\t\tsysfatal(\"not enough memory for %d items (%d bytes)\", *bufmax, *bufmax*onesz);\n\t}\n}\n\nmu_Rect\nmu_rect(int x, int y, int w, int h)\n{\n\tmu_Rect res;\n\tres.x = x, res.y = y, res.w = w, res.h = h;\n\treturn res;\n}\n\nImage *\nmu_color(u8int r, u8int g, u8int b, u8int a)\n{\n\tImage *c;\n\tif ((c = allocimage(display, Rect(0, 0, 1, 1), RGBA32, 1, setalpha(r<<24 | g<<16 | b<<8, a))) == nil)\n\t\tsysfatal(\"couldn't allocate color\");\n\treturn c;\n}\n\nstatic Rectangle\nscreenrect(mu_Rect r)\n{\n\tRectangle rect;\n\trect.min = screen->r.min;\n\trect.min.x += r.x;\n\trect.min.y += r.y;\n\trect.max = rect.min;\n\trect.max.x += r.w;\n\trect.max.y += r.h;\n\treturn rect;\n}\n\nstatic mu_Rect\nexpand_rect(mu_Rect rect, int n) {\n\treturn mu_rect(rect.x - n, rect.y - n, rect.w + n * 2, rect.h + n * 2);\n}\n\n\nstatic mu_Rect\nclip_rect(mu_Rect r1, mu_Rect r2)\n{\n\tint x1 = MAX(r1.x, r2.x);\n\tint y1 = MAX(r1.y, r2.y);\n\tint x2 = MAX(MIN(r1.x + r1.w, r2.x + r2.w), x1);\n\tint y2 = MAX(MIN(r1.y + r1.h, r2.y + r2.h), y1);\n\treturn mu_rect(x1, y1, x2 - x1, y2 - y1);\n}\n\n\nstatic int\nrect_overlaps_vec2(mu_Rect r, Point p)\n{\n\treturn p.x >= r.x && p.x < r.x + r.w && p.y >= r.y && p.y < r.y + r.h;\n}\n\nstatic void\ndraw_frame(mu_Rect rect, int colorid)\n{\n\tmu_draw_rect(rect, mu_style.colors[colorid]);\n\tif (colorid == MU_COLOR_SCROLLBASE\t|| colorid == MU_COLOR_SCROLLTHUMB || colorid == MU_COLOR_TITLEBG)\n\t\treturn;\n\t/* draw border */\n\tmu_draw_box(expand_rect(rect, 1), mu_style.colors[MU_COLOR_BORDER]);\n}\n\nstatic int\ntext_width(Font *font, const char *text, int len)\n{\n\treturn stringnwidth(font, text, len >= 0 ? len : strlen(text));\n}\n\nvoid\nmu_init(void)\n{\n\tRectangle r;\n\tint res, i;\n\n\tif (atlasimage == nil) {\n\t\tr = Rect(0, 0, atlasicons[ATLAS_DIMENSIONS].w, atlasicons[ATLAS_DIMENSIONS].h);\n\t\tatlasimage = allocimage(display, r, RGBA32, 1, DTransparent);\n\t\tif (memcmp(atlasraw, \"compressed\\n\", 11) == 0)\n\t\t\tres = cloadimage(atlasimage, r, atlasraw+11+5*12, sizeof(atlasraw)-11-5*12);\n\t\telse\n\t\t\tres = loadimage(atlasimage, r, atlasraw, sizeof(atlasraw));\n\t\tif (res < 0)\n\t\t\tsysfatal(\"failed to load atlas: %r\");\n\t}\n\n\tif (mu_style.colors[0] == nil) {\n\t\tfor (i = 0; i < MU_COLOR_MAX; i++) {\n\t\t\tmu_style.colors[i] = mu_color(\n\t\t\t\tdefaultcolors[i][0],\n\t\t\t\tdefaultcolors[i][1],\n\t\t\t\tdefaultcolors[i][2],\n\t\t\t\tdefaultcolors[i][3]\n\t\t\t);\n\t\t}\n\t}\n}\n\nvoid\nmu_begin(void)\n{\n\tmu_ctx.cmdsnum = mu_ctx.rootnum = 0;\n\tmu_ctx.strnum = 0;\n\tmu_ctx.scroll_target = nil;\n\tmu_ctx.last_hover_root = mu_ctx.hover_root;\n\tmu_ctx.hover_root = nil;\n\tmu_ctx.mouse_delta.x = mu_ctx.mouse_pos.x - mu_ctx.last_mouse_pos.x;\n\tmu_ctx.mouse_delta.y = mu_ctx.mouse_pos.y - mu_ctx.last_mouse_pos.y;\n}\n\nstatic int\ncompare_zindex(const void *a, const void *b)\n{\n\treturn (*(mu_Container**)a)->zindex - (*(mu_Container**)b)->zindex;\n}\n\nvoid\nmu_end(void)\n{\n\tint i, n;\n\t/* check stacks */\n\tassert(mu_ctx.cntnum == 0);\n\tassert(mu_ctx.clipnum == 0);\n\tassert(mu_ctx.idsnum == 0);\n\tassert(mu_ctx.layoutsnum == 0);\n\n\t/* handle scroll input */\n\tif (mu_ctx.scroll_target) {\n\t\tmu_ctx.scroll_target->scroll.x += mu_ctx.scroll_delta.x;\n\t\tmu_ctx.scroll_target->scroll.y += mu_ctx.scroll_delta.y;\n\t}\n\n\t/* unset focus if focus id was not touched this frame */\n\tif (!mu_ctx.updated_focus)\n\t\tmu_ctx.focus = 0;\n\tmu_ctx.updated_focus = 0;\n\n\t/* bring hover root to front if mouse was pressed */\n\tif (mu_ctx.mouse_pressed && mu_ctx.hover_root && mu_ctx.hover_root->zindex < mu_ctx.last_zindex)\n\t\tmu_bring_to_front(mu_ctx.hover_root);\n\n\t/* reset input state */\n\tmu_ctx.key_pressed = 0;\n\tmu_ctx.text_input[0] = 0;\n\tmu_ctx.mouse_pressed = 0;\n\tmu_ctx.scroll_delta = ZP;\n\tmu_ctx.last_mouse_pos = mu_ctx.mouse_pos;\n\n\t/* sort root containers by zindex */\n\tn = mu_ctx.rootnum;\n\tqsort(mu_ctx.root, n, sizeof(*mu_ctx.root), compare_zindex);\n\n\t/* set root container jump commands */\n\tfor (i = 0; i < n; i++) {\n\t\tmu_Container *cnt = mu_ctx.root[i];\n\t\t/* if this is the first container then make the first command jump to it.\n\t\t** otherwise set the previous container's tail to jump to this one */\n\t\tif (i == 0)\n\t\t\tmu_ctx.cmds[0].jump.dst = cnt->head + 1;\n\t\telse\n\t\t\tmu_ctx.cmds[mu_ctx.root[i - 1]->tail].jump.dst = cnt->head + 1;\n\n\t\t/* make the last container's tail jump to the end of command list */\n\t\tif (i == n - 1)\n\t\t\tmu_ctx.cmds[cnt->tail].jump.dst = mu_ctx.cmdsnum;\n\t}\n}\n\n\nvoid\nmu_set_focus(mu_Id id)\n{\n\tmu_ctx.focus = id;\n\tmu_ctx.updated_focus = 1;\n}\n\n/* 32bit fnv-1a hash */\n#define HASH_INITIAL 2166136261U\n\nstatic void\nhash(mu_Id *hash, const void *data, int size)\n{\n\tconst unsigned char *p = data;\n\twhile (size--) {\n\t\t*hash = (*hash ^ *p++) * 16777619;\n\t}\n}\n\n\nmu_Id\nmu_get_id(const void *data, int size)\n{\n\tint idx = mu_ctx.idsnum;\n\tmu_Id res = (idx > 0) ? mu_ctx.ids[idx - 1] : HASH_INITIAL;\n\thash(&res, data, size);\n\tmu_ctx.last_id = res;\n\treturn res;\n}\n\n\nvoid\nmu_push_id(const void *data, int size)\n{\n\tbuffer_grow(&mu_ctx.ids, sizeof(*mu_ctx.ids), &mu_ctx.idsmax, mu_ctx.idsnum);\n\tmu_ctx.ids[mu_ctx.idsnum++] = mu_get_id(data, size);\n}\n\nvoid\nmu_pop_id(void)\n{\n\tmu_ctx.idsnum--;\n}\n\nvoid\nmu_push_clip_rect(mu_Rect rect)\n{\n\tmu_Rect last = mu_get_clip_rect();\n\tbuffer_grow(&mu_ctx.clip, sizeof(*mu_ctx.clip), &mu_ctx.clipmax, mu_ctx.clipnum);\n\tmu_ctx.clip[mu_ctx.clipnum++] = clip_rect(rect, last);\n}\n\n\nvoid\nmu_pop_clip_rect(void)\n{\n\tmu_ctx.clipnum--;\n}\n\n\nmu_Rect\nmu_get_clip_rect(void)\n{\n\tassert(mu_ctx.clipnum > 0);\n\treturn mu_ctx.clip[mu_ctx.clipnum - 1];\n}\n\n\nint\nmu_check_clip(mu_Rect r)\n{\n\tmu_Rect cr = mu_get_clip_rect();\n\tif (r.x > cr.x + cr.w || r.x + r.w < cr.x || r.y > cr.y + cr.h || r.y + r.h < cr.y)\n\t\treturn MU_CLIP_ALL;\n\tif (r.x >= cr.x && r.x + r.w <= cr.x + cr.w && r.y >= cr.y && r.y + r.h <= cr.y + cr.h)\n\t\treturn MU_CLIP_NONE;\n\treturn MU_CLIP_PART;\n}\n\n\nstatic void\npush_layout(mu_Rect body, Point scroll)\n{\n\tmu_Layout layout;\n\tint width = 0;\n\tmemset(&layout, 0, sizeof(mu_Layout));\n\tlayout.body = mu_rect(body.x - scroll.x, body.y - scroll.y, body.w, body.h);\n\tlayout.max = Pt(-0x1000000, -0x1000000);\n\tbuffer_grow(&mu_ctx.layouts, sizeof(*mu_ctx.layouts), &mu_ctx.layoutsmax, mu_ctx.layoutsnum);\n\tmu_ctx.layouts[mu_ctx.layoutsnum++] = layout;\n\tmu_layout_row(1, &width, 0);\n}\n\nstatic mu_Layout *\nget_layout(void)\n{\n\treturn &mu_ctx.layouts[mu_ctx.layoutsnum - 1];\n}\n\n\nstatic void\npush_container(mu_Container *cnt)\n{\n\tbuffer_grow(&mu_ctx.cnt, sizeof(*mu_ctx.cnt), &mu_ctx.cntmax, mu_ctx.cntnum);\n\tmu_ctx.cnt[mu_ctx.cntnum++] = cnt;\n\tmu_push_id(&cnt, sizeof(mu_Container*));\n}\n\n\nstatic void\npop_container(void)\n{\n\tmu_Container *cnt = mu_get_container();\n\tmu_Layout *layout = get_layout();\n\tcnt->content_size.x = layout->max.x - layout->body.x;\n\tcnt->content_size.y = layout->max.y - layout->body.y;\n\tmu_ctx.cntnum--;\n\tmu_ctx.layoutsnum--;\n\tmu_pop_id();\n}\n\n\nmu_Container *\nmu_get_container(void)\n{\n\tassert(mu_ctx.cntnum > 0);\n\treturn mu_ctx.cnt[mu_ctx.cntnum - 1];\n}\n\n\nvoid\nmu_init_window(mu_Container *cnt, int opt)\n{\n\tmemset(cnt, 0, sizeof(*cnt));\n\tcnt->inited = 1;\n\tcnt->open = opt & MU_OPT_CLOSED ? 0 : 1;\n\tcnt->rect = mu_rect(100, 100, 300, 300);\n\tmu_bring_to_front(cnt);\n}\n\n\nvoid\nmu_bring_to_front(mu_Container *cnt)\n{\n\tcnt->zindex = ++mu_ctx.last_zindex;\n}\n\n\n/*============================================================================\n** input handlers\n**============================================================================*/\n\nvoid\nmu_input_mousemove(int x, int y)\n{\n\tmu_ctx.mouse_pos = Pt(x, y);\n}\n\n\nvoid\nmu_input_mousedown(int x, int y, int btn)\n{\n\tmu_input_mousemove(x, y);\n\tmu_ctx.mouse_down |= btn;\n\tmu_ctx.mouse_pressed |= btn;\n}\n\n\nvoid\nmu_input_mouseup(int x, int y, int btn)\n{\n\tmu_input_mousemove(x, y);\n\tmu_ctx.mouse_down &= ~btn;\n}\n\n\nvoid\nmu_input_scroll(int x, int y)\n{\n\tmu_ctx.scroll_delta.x += x;\n\tmu_ctx.scroll_delta.y += y;\n}\n\n\nvoid\nmu_input_keydown(int key)\n{\n\tmu_ctx.key_pressed |= key;\n\tmu_ctx.key_down |= key;\n}\n\n\nvoid\nmu_input_keyup(int key)\n{\n\tmu_ctx.key_down &= ~key;\n}\n\n\nvoid\nmu_input_text(const char *text)\n{\n\tint len = strlen(mu_ctx.text_input);\n\tint size = strlen(text) + 1;\n\tassert(len + size <= (int) sizeof(mu_ctx.text_input));\n\tmemcpy(mu_ctx.text_input + len, text, size);\n}\n\n/*============================================================================\n** commandlist\n**============================================================================*/\n\nmu_Command *\nmu_push_command(int type)\n{\n\tmu_Command *cmd;\n\n\tbuffer_grow(&mu_ctx.cmds, sizeof(mu_Command), &mu_ctx.cmdsmax, mu_ctx.cmdsnum);\n\tcmd = &mu_ctx.cmds[mu_ctx.cmdsnum++];\n\tmemset(cmd, 0, sizeof(*cmd));\n\tcmd->type = type;\n\n\treturn cmd;\n}\n\nstatic int\npush_jump(int dst)\n{\n\tmu_Command *cmd;\n\tcmd = mu_push_command(MU_COMMAND_JUMP);\n\tcmd->jump.dst = dst;\n\treturn mu_ctx.cmdsnum-1;\n}\n\nvoid\nmu_set_clip(mu_Rect rect)\n{\n\tmu_Command *cmd;\n\tcmd = mu_push_command(MU_COMMAND_CLIP);\n\tcmd->clip.rect = rect;\n}\n\nvoid\nmu_draw_rect(mu_Rect rect, Image *color)\n{\n\tmu_Command *cmd;\n\tmu_Rect clipped;\n\tclipped = clip_rect(rect, mu_get_clip_rect());\n\tif (rect.w > 0 && rect.h > 0) {\n\t\tcmd = mu_push_command(MU_COMMAND_RECT);\n\t\tcmd->rect.rect = clipped;\n\t\tcmd->rect.position = subpt(Pt(clipped.x, clipped.y), Pt(rect.x, rect.y));\n\t\tcmd->rect.color = color;\n\t}\n}\n\nvoid\nmu_draw_box(mu_Rect rect, Image *color)\n{\n\tmu_draw_rect(mu_rect(rect.x + 1, rect.y, rect.w - 2, 1), color);\n\tmu_draw_rect(mu_rect(rect.x+1, rect.y + rect.h-1, rect.w-2, 1), color);\n\tmu_draw_rect(mu_rect(rect.x, rect.y, 1, rect.h), color);\n\tmu_draw_rect(mu_rect(rect.x + rect.w - 1, rect.y, 1, rect.h), color);\n}\n\n\nvoid\nmu_draw_text(Font *font, const char *s, int len, Point pos, Image *color)\n{\n\tmu_Command *cmd;\n\tmu_Rect rect;\n\tint clipped;\n\n\tif (len < 0)\n\t\tlen = strlen(s);\n\trect = mu_rect(pos.x, pos.y, text_width(font, s, len), font->height);\n\tclipped = mu_check_clip(rect);\n\n\tif (clipped == MU_CLIP_ALL )\n\t\treturn;\n\tif (clipped == MU_CLIP_PART)\n\t\tmu_set_clip(mu_get_clip_rect());\n\n\tif (mu_ctx.strmax <= mu_ctx.strnum+len+1) {\n\t\tmu_ctx.strmax = MAX(mu_ctx.strmax, mu_ctx.strnum+len+1) * 2;\n\t\tif ((mu_ctx.str = realloc(mu_ctx.str, mu_ctx.strmax)) == nil)\n\t\t\tsysfatal(\"not enough memory for %d chars\", mu_ctx.strmax);\n\t}\n\tcmd = mu_push_command(MU_COMMAND_TEXT);\n\tcmd->text.s = mu_ctx.strnum;\n\tmemmove(mu_ctx.str+mu_ctx.strnum, s, len);\n\tmu_ctx.strnum += len;\n\tmu_ctx.str[mu_ctx.strnum++] = 0;\n\tcmd->text.pos = pos;\n\tcmd->text.color = color;\n\tcmd->text.font = font;\n\n\t/* reset clipping if it was set */\n\tif (clipped)\n\t\tmu_set_clip(unclipped_rect);\n}\n\n\nvoid\nmu_draw_icon(int id, mu_Rect rect)\n{\n\tmu_Command *cmd;\n\t/* do clip command if the rect isn't fully contained within the cliprect */\n\tint clipped = mu_check_clip(rect);\n\tif (clipped == MU_CLIP_ALL )\n\t\treturn;\n\tif (clipped == MU_CLIP_PART)\n\t\tmu_set_clip(mu_get_clip_rect());\n\t/* do icon command */\n\tcmd = mu_push_command(MU_COMMAND_ICON);\n\tcmd->icon.id = id;\n\tcmd->icon.rect = rect;\n\t/* reset clipping if it was set */\n\tif (clipped)\n\t\tmu_set_clip(unclipped_rect);\n}\n\n\n/*============================================================================\n** layout\n**============================================================================*/\n\nenum\n{\n\tRELATIVE = 1,\n\tABSOLUTE,\n};\n\n\nvoid\nmu_layout_begin_column(void)\n{\n\tpush_layout(mu_layout_next(), ZP);\n}\n\n\nvoid\nmu_layout_end_column(void)\n{\n\tmu_Layout *a, *b;\n\tb = get_layout();\n\tmu_ctx.layoutsnum--;\n\t/* inherit position/next_row/max from child layout if they are greater */\n\ta = get_layout();\n\ta->position.x = MAX(a->position.x, b->position.x + b->body.x - a->body.x);\n\ta->next_row = MAX(a->next_row, b->next_row + b->body.y - a->body.y);\n\ta->max.x = MAX(a->max.x, b->max.x);\n\ta->max.y = MAX(a->max.y, b->max.y);\n}\n\n\nvoid\nmu_layout_row(int items, const int *widths, int height)\n{\n\tmu_Layout *layout = get_layout();\n\tif (widths) {\n\t\tassert(items <= MU_MAX_WIDTHS);\n\t\tmemcpy(layout->widths, widths, items * sizeof(widths[0]));\n\t}\n\tlayout->items = items;\n\tlayout->position = Pt(layout->indent, layout->next_row);\n\tlayout->size.y = height;\n\tlayout->row_index = 0;\n}\n\n\nvoid\nmu_layout_width(int width)\n{\n\tget_layout()->size.x = width;\n}\n\n\nvoid\nmu_layout_height(int height)\n{\n\tget_layout()->size.y = height;\n}\n\n\nvoid\nmu_layout_set_next(mu_Rect r, int relative)\n{\n\tmu_Layout *layout = get_layout();\n\tlayout->next = r;\n\tlayout->next_type = relative ? RELATIVE : ABSOLUTE;\n}\n\n\nmu_Rect\nmu_layout_next(void)\n{\n\tmu_Layout *layout = get_layout();\n\tmu_Rect res;\n\n\tif (layout->next_type) {\n\t\t/* handle rect set by `mu_layout_set_next` */\n\t\tint type = layout->next_type;\n\t\tlayout->next_type = 0;\n\t\tres = layout->next;\n\t\tif (type == ABSOLUTE) {\n\t\t\tmu_ctx.last_rect = res;\n\t\t\treturn res;\n\t\t}\n\n\t} else {\n\t\t/* handle next row */\n\t\tif (layout->row_index == layout->items)\n\t\t\tmu_layout_row(layout->items, nil, layout->size.y);\n\n\t\t/* position */\n\t\tres.x = layout->position.x;\n\t\tres.y = layout->position.y;\n\n\t\t/* size */\n\t\tres.w = layout->items > -1 ? layout->widths[layout->row_index] : layout->size.x;\n\t\tres.h = layout->size.y;\n\t\tif (res.w == 0)\n\t\t\tres.w = mu_style.size.x + mu_style.padding * 2;\n\t\tif (res.h == 0)\n\t\t\tres.h = mu_style.size.y + mu_style.padding * 2;\n\t\tif (res.w <\t0)\n\t\t\tres.w += layout->body.w - res.x + 1;\n\t\tif (res.h <\t0)\n\t\t\tres.h += layout->body.h - res.y + 1;\n\n\t\tlayout->row_index++;\n\t}\n\n\t/* update position */\n\tlayout->position.x += res.w + mu_style.spacing;\n\tlayout->next_row = MAX(layout->next_row, res.y + res.h + mu_style.spacing);\n\n\t/* apply body offset */\n\tres.x += layout->body.x;\n\tres.y += layout->body.y;\n\n\t/* update max position */\n\tlayout->max.x = MAX(layout->max.x, res.x + res.w);\n\tlayout->max.y = MAX(layout->max.y, res.y + res.h);\n\n\tmu_ctx.last_rect = res;\n\treturn res;\n}\n\n\n/*============================================================================\n** controls\n**============================================================================*/\n\nstatic int\nin_hover_root(void)\n{\n\tint i = mu_ctx.cntnum;\n\twhile (i--) {\n\t\tif (mu_ctx.cnt[i] == mu_ctx.last_hover_root)\n\t\t\treturn 1;\n\t\t/* only root containers have their `head` field set; stop searching if we've\n\t\t** reached the current root container */\n\t\tif (mu_ctx.cnt[i]->head >= 0)\n\t\t\tbreak;\n\t}\n\treturn 0;\n}\n\n\nvoid\nmu_draw_control_frame(mu_Id id, mu_Rect rect, int colorid, int opt)\n{\n\tif (opt & MU_OPT_NOFRAME)\n\t\treturn;\n\tcolorid += (mu_ctx.focus == id) ? 2 : (mu_ctx.hover == id) ? 1 : 0;\n\tdraw_frame(rect, colorid);\n}\n\n\nvoid\nmu_draw_control_text(const char *str, mu_Rect rect, int colorid, int opt)\n{\n\tPoint pos;\n\tFont *font = mu_style.font;\n\tint tw = text_width(font, str, -1);\n\tmu_push_clip_rect(rect);\n\tpos.y = rect.y + (rect.h - font->height) / 2;\n\tif (opt & MU_OPT_ALIGNCENTER)\n\t\tpos.x = rect.x + (rect.w - tw) / 2;\n\telse if (opt & MU_OPT_ALIGNRIGHT)\n\t\tpos.x = rect.x + rect.w - tw - mu_style.padding;\n\telse\n\t\tpos.x = rect.x + mu_style.padding;\n\n\tmu_draw_text(font, str, -1, pos, mu_style.colors[colorid]);\n\tmu_pop_clip_rect();\n}\n\n\nint\nmu_mouse_over(mu_Rect rect)\n{\n\treturn rect_overlaps_vec2(rect, mu_ctx.mouse_pos) &&\n\t\trect_overlaps_vec2(mu_get_clip_rect(), mu_ctx.mouse_pos) &&\n\t\tin_hover_root();\n}\n\n\nvoid\nmu_update_control(mu_Id id, mu_Rect rect, int opt)\n{\n\tint mouseover = mu_mouse_over(rect);\n\n\tif (mu_ctx.focus == id)\n\t\tmu_ctx.updated_focus = 1;\n\tif (opt & MU_OPT_NOINTERACT)\n\t\treturn;\n\tif (mouseover && !mu_ctx.mouse_down)\n\t\tmu_ctx.hover = id;\n\n\tif (mu_ctx.focus == id) {\n\t\tif (mu_ctx.mouse_pressed && !mouseover)\n\t\t\tmu_set_focus(0);\n\t\tif (!mu_ctx.mouse_down && ~opt & MU_OPT_HOLDFOCUS)\n\t\t\tmu_set_focus(0);\n\t}\n\n\tif (mu_ctx.hover == id) {\n\t\tif (!mouseover)\n\t\t\tmu_ctx.hover = 0;\n\t\telse if (mu_ctx.mouse_pressed)\n\t\t\tmu_set_focus(id);\n\t}\n}\n\n\nvoid\nmu_text(const char *text)\n{\n\tconst char *start, *end, *p = text;\n\tint width = -1;\n\tFont *font = mu_style.font;\n\tImage *color = mu_style.colors[MU_COLOR_TEXT];\n\tmu_layout_begin_column();\n\tmu_layout_row(1, &width, font->height);\n\tdo {\n\t\tmu_Rect r = mu_layout_next();\n\t\tint w = 0;\n\t\tstart = end = p;\n\t\tdo {\n\t\t\tconst char* word = p;\n\t\t\twhile (*p && *p != ' ' && *p != '\\n')\n\t\t\t\tp++;\n\t\t\tw += text_width(font, word, p - word);\n\t\t\tif (w > r.w && end != start)\n\t\t\t\tbreak;\n\t\t\tw += text_width(font, p, 1);\n\t\t\tend = p++;\n\t\t} while (*end && *end != '\\n');\n\t\tmu_draw_text(font, start, end - start, Pt(r.x, r.y), color);\n\t\tp = end + 1;\n\t} while (*end);\n\tmu_layout_end_column();\n}\n\n\nvoid\nmu_label(const char *text)\n{\n\tmu_draw_control_text(text, mu_layout_next(), MU_COLOR_TEXT, 0);\n}\n\n\nint\nmu_button_ex(const char *label, int icon, int opt) {\n\tint res = 0;\n\tmu_Id id = label ? mu_get_id(label, strlen(label)) : mu_get_id(&icon, sizeof(icon));\n\tmu_Rect r = mu_layout_next();\n\tmu_update_control(id, r, opt);\n\t/* handle click */\n\tif (mu_ctx.mouse_pressed == MU_MOUSE_LEFT && mu_ctx.focus == id)\n\t\tres |= MU_RES_SUBMIT;\n\n\t/* draw */\n\tmu_draw_control_frame(id, r, MU_COLOR_BUTTON, opt);\n\tif (label)\n\t\tmu_draw_control_text(label, r, MU_COLOR_TEXT, opt);\n\tif (icon)\n\t\tmu_draw_icon(icon, r);\n\treturn res;\n}\n\n\nint\nmu_button(const char *label)\n{\n\treturn mu_button_ex(label, 0, MU_OPT_ALIGNCENTER);\n}\n\n\nint\nmu_checkbox(int *state, const char *label)\n{\n\tint res = 0;\n\tmu_Id id = mu_get_id(&state, sizeof(state));\n\tmu_Rect r = mu_layout_next();\n\tmu_Rect box = mu_rect(r.x, r.y, r.h, r.h);\n\tmu_update_control(id, r, 0);\n\t/* handle click */\n\tif (mu_ctx.mouse_pressed == MU_MOUSE_LEFT && mu_ctx.focus == id) {\n\t\tres |= MU_RES_CHANGE;\n\t\t*state = !*state;\n\t}\n\t/* draw */\n\tmu_draw_control_frame(id, box, MU_COLOR_BASE, 0);\n\tif (*state)\n\t\tmu_draw_icon(MU_ICON_CHECK, box);\n\n\tr = mu_rect(r.x + box.w, r.y, r.w - box.w, r.h);\n\tmu_draw_control_text(label, r, MU_COLOR_TEXT, 0);\n\treturn res;\n}\n\n\nint\nmu_textbox_raw(char *buf, int bufsz, mu_Id id, mu_Rect r, int opt)\n{\n\tint res = 0;\n\tmu_update_control(id, r, opt | MU_OPT_HOLDFOCUS);\n\n\tif (mu_ctx.focus == id) {\n\t\t/* handle text input */\n\t\tint len = strlen(buf);\n\t\tint n = MIN(bufsz - len - 1, (int)strlen(mu_ctx.text_input));\n\t\tif (n > 0) {\n\t\t\tmemcpy(buf + len, mu_ctx.text_input, n);\n\t\t\tlen += n;\n\t\t\tbuf[len] = '\\0';\n\t\t\tres |= MU_RES_CHANGE;\n\t\t}\n\t\t/* handle backspace */\n\t\tif (mu_ctx.key_pressed & MU_KEY_BACKSPACE && len > 0) {\n\t\t\t/* skip utf-8 continuation bytes */\n\t\t\twhile ((buf[--len] & 0xc0) == 0x80 && len > 0);\n\t\t\tbuf[len] = '\\0';\n\t\t\tres |= MU_RES_CHANGE;\n\t\t}\n\t\tif (mu_ctx.key_pressed & MU_KEY_NACK && len > 0) {\n\t\t\tbuf[0] = '\\0';\n\t\t\tres |= MU_RES_CHANGE;\n\t\t}\n\t\t/* handle return */\n\t\tif (mu_ctx.key_pressed & MU_KEY_RETURN) {\n\t\t\tmu_set_focus(0);\n\t\t\tres |= MU_RES_SUBMIT;\n\t\t}\n\t}\n\n\t/* draw */\n\tmu_draw_control_frame(id, r, MU_COLOR_BASE, opt);\n\tif (mu_ctx.focus == id) {\n\t\tImage *color = mu_style.colors[MU_COLOR_TEXT];\n\t\tFont *font = mu_style.font;\n\t\tint textw = text_width(font, buf, -1);\n\t\tint texth = font->height;\n\t\tint ofx = r.w - mu_style.padding - textw - 1;\n\t\tint textx = r.x + MIN(ofx, mu_style.padding);\n\t\tint texty = r.y + (r.h - texth) / 2;\n\t\tmu_push_clip_rect(r);\n\t\tmu_draw_text(font, buf, -1, Pt(textx, texty), color);\n\t\tmu_draw_rect(mu_rect(textx + textw, texty, 1, texth), color);\n\t\tmu_pop_clip_rect();\n\t} else {\n\t\tmu_draw_control_text(buf, r, MU_COLOR_TEXT, opt);\n\t}\n\n\treturn res;\n}\n\n\nstatic int\nnumber_textbox(double *value, mu_Rect r, mu_Id id)\n{\n\tif (((mu_ctx.mouse_pressed == MU_MOUSE_LEFT && mu_ctx.key_down & MU_KEY_SHIFT) || mu_ctx.mouse_pressed == MU_MOUSE_RIGHT) && mu_ctx.hover == id) {\n\t\tmu_ctx.number_editing = id;\n\t\tsprint(mu_ctx.number_buf, MU_REAL_FMT, *value);\n\t}\n\tif (mu_ctx.number_editing == id) {\n\t\tint res = mu_textbox_raw(mu_ctx.number_buf, sizeof(mu_ctx.number_buf), id, r, 0);\n\t\tif (res & MU_RES_SUBMIT || mu_ctx.focus != id) {\n\t\t\t*value = strtod(mu_ctx.number_buf, nil);\n\t\t\tmu_ctx.number_editing = 0;\n\t\t} else {\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\n\nint\nmu_textbox_ex(char *buf, int bufsz, int opt)\n{\n\tmu_Id id = mu_get_id(&buf, sizeof(buf));\n\tmu_Rect r = mu_layout_next();\n\treturn mu_textbox_raw(buf, bufsz, id, r, opt);\n}\n\n\nint\nmu_textbox(char *buf, int bufsz)\n{\n\treturn mu_textbox_ex(buf, bufsz, 0);\n}\n\n\nint\nmu_slider_ex(double *value, double low, double high, double step, const char *fmt, int opt)\n{\n\tchar buf[MU_MAX_FMT + 1];\n\tmu_Rect thumb;\n\tint w, res = 0;\n\tdouble normalized, last = *value, v = last;\n\tmu_Id id = mu_get_id(&value, sizeof(value));\n\tmu_Rect base = mu_layout_next();\n\n\t/* handle text input mode */\n\tif (number_textbox(&v, base, id))\n\t\treturn res;\n\n\t/* handle normal mode */\n\tmu_update_control(id, base, opt);\n\n\t/* handle input */\n\tif (mu_ctx.focus == id) {\n\t\tif (mu_ctx.mouse_down == MU_MOUSE_LEFT)\n\t\t\tv = low + ((double)(mu_ctx.mouse_pos.x - base.x) / base.w) * (high - low);\n\t} else if (mu_ctx.hover == id) {\n\t\tif ((mu_ctx.key_pressed & (MU_KEY_LEFT | MU_KEY_RIGHT)) == MU_KEY_LEFT) {\n\t\t\tv -= step ? step : 1;\n\t\t\tif (v < low)\n\t\t\t\tv = low;\n\t\t} else if ((mu_ctx.key_pressed & (MU_KEY_LEFT | MU_KEY_RIGHT)) == MU_KEY_RIGHT) {\n\t\t\tv += step ? step : 1;\n\t\t\tif (v > high)\n\t\t\t\tv = high;\n\t\t}\n\t}\n\n\tif (step)\n\t\tv = ((long)((v + (v > 0 ? step/2 : (-step/2))) / step)) * step;\n\t/* clamp and store value, update res */\n\t*value = v = CLAMP(v, low, high);\n\tif (last != v)\n\t\tres |= MU_RES_CHANGE;\n\n\t/* draw base */\n\tmu_draw_control_frame(id, base, MU_COLOR_BASE, opt);\n\t/* draw thumb */\n\tw = mu_style.thumb_size;\n\tnormalized = (v - low) / (high - low);\n\tthumb = mu_rect(base.x + normalized * (base.w - w), base.y, w, base.h);\n\tmu_draw_control_frame(id, thumb, MU_COLOR_BUTTON, opt);\n\t/* draw text\t*/\n\tsprint(buf, fmt, v);\n\tmu_draw_control_text(buf, base, MU_COLOR_TEXT, opt);\n\n\treturn res;\n}\n\n\nint\nmu_slider(double *value, double low, double high)\n{\n\treturn mu_slider_ex(value, low, high, 0, MU_SLIDER_FMT, MU_OPT_ALIGNCENTER);\n}\n\n\nint\nmu_number_ex(double *value, double step, const char *fmt, int opt)\n{\n\tchar buf[MU_MAX_FMT + 1];\n\tint res = 0;\n\tmu_Id id = mu_get_id(&value, sizeof(value));\n\tmu_Rect base = mu_layout_next();\n\tdouble last = *value;\n\n\t/* handle text input mode */\n\tif (number_textbox(value, base, id))\n\t\treturn res;\n\n\t/* handle normal mode */\n\tmu_update_control(id, base, opt);\n\n\t/* handle input */\n\tif (mu_ctx.focus == id && mu_ctx.mouse_down == MU_MOUSE_LEFT)\n\t\t*value += mu_ctx.mouse_delta.x * step;\n\n\t/* set flag if value changed */\n\tif (*value != last)\n\t\tres |= MU_RES_CHANGE;\n\n\t/* draw base */\n\tmu_draw_control_frame(id, base, MU_COLOR_BASE, opt);\n\t/* draw text\t*/\n\tsprint(buf, fmt, *value);\n\tmu_draw_control_text(buf, base, MU_COLOR_TEXT, opt);\n\n\treturn res;\n}\n\n\nint\nmu_number(double *value, double step)\n{\n\treturn mu_number_ex(value, step, MU_SLIDER_FMT, MU_OPT_ALIGNCENTER);\n}\n\n\nstatic int\nheader(int *state, const char *label, int istreenode)\n{\n\tmu_Rect r;\n\tmu_Id id;\n\tint width = -1;\n\tmu_layout_row(1, &width, 0);\n\tr = mu_layout_next();\n\tid = mu_get_id(&state, sizeof(state));\n\tmu_update_control(id, r, 0);\n\t/* handle click */\n\tif (mu_ctx.mouse_pressed == MU_MOUSE_LEFT && mu_ctx.focus == id)\n\t\t*state = !(*state);\n\n\t/* draw */\n\tif (istreenode) {\n\t\tif (mu_ctx.hover == id)\n\t\t\tdraw_frame(r, MU_COLOR_BUTTONHOVER);\n\t} else {\n\t\tmu_draw_control_frame(id, r, MU_COLOR_BUTTON, 0);\n\t}\n\tmu_draw_icon(\n\t\t*state ? MU_ICON_EXPANDED : MU_ICON_COLLAPSED,\n\t\tmu_rect(r.x, r.y, r.h, r.h)\n\t);\n\tr.x += r.h - mu_style.padding;\n\tr.w -= r.h - mu_style.padding;\n\tmu_draw_control_text(label, r, MU_COLOR_TEXT, 0);\n\treturn *state ? MU_RES_ACTIVE : 0;\n}\n\n\nint\nmu_header(int *state, const char *label)\n{\n\treturn header(state, label, 0);\n}\n\n\nint\nmu_begin_treenode(int *state, const char *label)\n{\n\tint res = header(state, label, 1);\n\tif (res & MU_RES_ACTIVE) {\n\t\tget_layout()->indent += mu_style.indent;\n\t\tmu_push_id(&state, sizeof(void*));\n\t}\n\treturn res;\n}\n\n\nvoid\nmu_end_treenode(void)\n{\n\tget_layout()->indent -= mu_style.indent;\n\tmu_pop_id();\n}\n\nstatic void\nscrollbar(mu_Container *cnt, mu_Rect *b, Point cs, int v)\n{\n\t/* only add scrollbar if content size is larger than body */\n\tint maxscroll = v ? cs.y - b->h : cs.x - b->w;\n\n\tif (maxscroll > 0 && (v ? b->h : b->x) > 0) {\n\t\tmu_Rect base, thumb;\n\t\tmu_Id id = mu_get_id(v ? \"!scrollbary\" : \"!scrollbarx\", 11);\n\n\t\t/* get sizing / positioning */\n\t\tbase = *b;\n\t\tif (v) {\n\t\t\tbase.x = b->x + b->w;\n\t\t\tbase.w = mu_style.scrollbar_size;\n\t\t} else {\n\t\t\tbase.y = b->y + b->h;\n\t\t\tbase.h = mu_style.scrollbar_size;\n\t\t}\n\n\t\t/* handle input */\n\t\tmu_update_control(id, base, 0);\n\t\tif (mu_ctx.focus == id && mu_ctx.mouse_down == MU_MOUSE_LEFT) {\n\t\t\tif (v)\n\t\t\t\tcnt->scroll.y += mu_ctx.mouse_delta.y * cs.y / base.h;\n\t\t\telse\n\t\t\t\tcnt->scroll.x += mu_ctx.mouse_delta.x * cs.x / base.w;\n\t\t}\n\t\t/* clamp scroll to limits */\n\t\tif (v)\n\t\t\tcnt->scroll.y = CLAMP(cnt->scroll.y, 0, maxscroll);\n\t\telse\n\t\t\tcnt->scroll.x = CLAMP(cnt->scroll.x, 0, maxscroll);\n\n\t\t/* draw base and thumb */\n\t\tdraw_frame(base, MU_COLOR_SCROLLBASE);\n\t\tthumb = base;\n\t\tif (v) {\n\t\t\tthumb.h = MAX(mu_style.thumb_size, base.h * b->h / cs.y);\n\t\t\tthumb.y += cnt->scroll.y * (base.h - thumb.h) / maxscroll;\n\t\t} else {\n\t\t\tthumb.w = MAX(mu_style.thumb_size, base.w * b->w / cs.x);\n\t\t\tthumb.x += cnt->scroll.x * (base.w - thumb.w) / maxscroll;\n\t\t}\n\t\tdraw_frame(thumb, MU_COLOR_SCROLLTHUMB);\n\n\t\t/* set this as the scroll_target (will get scrolled on mousewheel) */\n\t\t/* if the mouse is over it */\n\t\tif (mu_mouse_over(*b))\n\t\t\tmu_ctx.scroll_target = cnt;\n\t} else if (v) {\n\t\tcnt->scroll.y = 0;\n\t} else {\n\t\tcnt->scroll.x = 0;\n\t}\n}\n\nstatic void\nscrollbars(mu_Container *cnt, mu_Rect *body)\n{\n\tint sz = mu_style.scrollbar_size;\n\tPoint cs = cnt->content_size;\n\tcs.x += mu_style.padding * 2;\n\tcs.y += mu_style.padding * 2;\n\tmu_push_clip_rect(*body);\n\t/* resize body to make room for scrollbars */\n\tif (cs.y > cnt->body.h)\n\t\tbody->w -= sz;\n\tif (cs.x > cnt->body.w)\n\t\tbody->h -= sz;\n\t/* to create a horizontal or vertical scrollbar almost-identical code is\n\t** used; only the references to `x|y` `w|h` need to be switched */\n\tscrollbar(cnt, body, cs, 1);\n\tscrollbar(cnt, body, cs, 0);\n\tmu_pop_clip_rect();\n}\n\nstatic void\npush_container_body(mu_Container *cnt, mu_Rect body, int opt)\n{\n\tif (~opt & MU_OPT_NOSCROLL)\n\t\tscrollbars(cnt, &body);\n\tpush_layout(expand_rect(body, -mu_style.padding), cnt->scroll);\n\tcnt->body = body;\n}\n\nstatic void\nbegin_root_container(mu_Container *cnt)\n{\n\tpush_container(cnt);\n\n\t/* push container to roots list and push head command */\n\tbuffer_grow(&mu_ctx.root, sizeof(*mu_ctx.root), &mu_ctx.rootmax, mu_ctx.rootnum);\n\tmu_ctx.root[mu_ctx.rootnum++] = cnt;\n\tcnt->head = push_jump(-1);\n\n\t/* set as hover root if the mouse is overlapping this container and it has a\n\t** higher zindex than the current hover root */\n\tif (rect_overlaps_vec2(cnt->rect, mu_ctx.mouse_pos) && (!mu_ctx.hover_root || cnt->zindex > mu_ctx.hover_root->zindex))\n\t\tmu_ctx.hover_root = cnt;\n\n\t/* clipping is reset here in case a root-container is made within\n\t** another root-containers's begin/end block; this prevents the inner\n\t** root-container being clipped to the outer */\n\tbuffer_grow(&mu_ctx.clip, sizeof(*mu_ctx.clip), &mu_ctx.clipmax, mu_ctx.clipnum);\n\tmu_ctx.clip[mu_ctx.clipnum++] = unclipped_rect;\n}\n\n\nstatic void\nend_root_container(void)\n{\n\t/* push tail 'goto' jump command and set head 'skip' command. the final steps\n\t** on initing these are done in mu_end() */\n\tmu_Container *cnt = mu_get_container();\n\tcnt->tail = push_jump(-1);\n\tmu_ctx.cmds[cnt->head].jump.dst = mu_ctx.cmdsnum;\n\t/* pop base clip rect and container */\n\tmu_pop_clip_rect();\n\tpop_container();\n}\n\n\nint\nmu_begin_window_ex(mu_Container *cnt, const char *title, int opt)\n{\n\tmu_Rect rect, body, titlerect;\n\n\tif (!cnt->inited)\n\t\tmu_init_window(cnt, opt);\n\tif (!cnt->open)\n\t\treturn 0;\n\n\tbegin_root_container(cnt);\n\trect = cnt->rect;\n\tbody = rect;\n\n\t/* draw frame */\n\tif (~opt & MU_OPT_NOFRAME)\n\t\tdraw_frame(rect, MU_COLOR_WINDOWBG);\n\n\t/* moving all windows by \"dragging\" background */\n\tif (mu_ctx.last_hover_root == nil && mu_ctx.hover_root == nil && mu_ctx.mouse_pressed == MU_MOUSE_LEFT)\n\t\tmu_ctx.moving = 1;\n\telse if (mu_ctx.mouse_down != MU_MOUSE_LEFT)\n\t\tmu_ctx.moving = 0;\n\tif (mu_ctx.moving) {\n\t\tcnt->rect.x += mu_ctx.mouse_delta.x;\n\t\tcnt->rect.y += mu_ctx.mouse_delta.y;\n\t}\n\n\t/* do title bar */\n\ttitlerect = rect;\n\ttitlerect.h = mu_style.title_height;\n\tif (~opt & MU_OPT_NOTITLE) {\n\t\tmu_Id id = mu_get_id(\"!title\", 6);\n\n\t\tdraw_frame(titlerect, MU_COLOR_TITLEBG);\n\n\t\t/* do title text */\n\t\tmu_update_control(id, titlerect, opt);\n\t\tmu_draw_control_text(title, titlerect, MU_COLOR_TITLETEXT, opt);\n\t\tif (id == mu_ctx.focus && mu_ctx.mouse_down == MU_MOUSE_LEFT) {\n\t\t\tcnt->rect.x += mu_ctx.mouse_delta.x;\n\t\t\tcnt->rect.y += mu_ctx.mouse_delta.y;\n\t\t}\n\t\tbody.y += titlerect.h;\n\t\tbody.h -= titlerect.h;\n\n\t\t/* do `close` button */\n\t\tif (~opt & MU_OPT_NOCLOSE) {\n\t\t\tmu_Id id = mu_get_id(\"!close\", 6);\n\t\t\tmu_Rect r = mu_rect(\n\t\t\t\ttitlerect.x + titlerect.w - titlerect.h,\n\t\t\t\ttitlerect.y, titlerect.h, titlerect.h\n\t\t\t);\n\t\t\ttitlerect.w -= r.w;\n\t\t\tmu_draw_icon(MU_ICON_CLOSE, r);\n\t\t\tmu_update_control(id, r, opt);\n\t\t\tif (mu_ctx.mouse_pressed == MU_MOUSE_LEFT && id == mu_ctx.focus)\n\t\t\t\tcnt->open = 0;\n\t\t}\n\t}\n\n\tpush_container_body(cnt, body, opt);\n\n\t/* do `resize` handle */\n\tif (~opt & MU_OPT_NORESIZE) {\n\t\tint sz = mu_style.scrollbar_size;\n\t\tmu_Id id = mu_get_id(\"!resize\", 7);\n\t\tmu_Rect r = mu_rect(rect.x + rect.w - sz, rect.y + rect.h - sz, sz, sz);\n\t\tmu_update_control(id, r, opt);\n\t\tmu_draw_icon(MU_ICON_RESIZE, r);\n\t\tif (id == mu_ctx.focus && mu_ctx.mouse_down == MU_MOUSE_LEFT) {\n\t\t\tcnt->rect.w = MAX(96, cnt->rect.w + mu_ctx.mouse_delta.x);\n\t\t\tcnt->rect.h = MAX(64, cnt->rect.h + mu_ctx.mouse_delta.y);\n\t\t}\n\t}\n\n\t/* resize to content size */\n\tif (opt & MU_OPT_AUTOSIZE) {\n\t\tmu_Rect r = get_layout()->body;\n\t\tif (opt & MU_OPT_AUTOSIZE_W)\n\t\t\tcnt->rect.w = cnt->content_size.x + (cnt->rect.w - r.w);\n\t\tif (opt & MU_OPT_AUTOSIZE_H)\n\t\t\tcnt->rect.h = cnt->content_size.y + (cnt->rect.h - r.h);\n\t}\n\n\t/* close if this is a popup window and elsewhere was clicked */\n\tif (opt & MU_OPT_POPUP && mu_ctx.mouse_pressed && mu_ctx.last_hover_root != cnt)\n\t\tcnt->open = 0;\n\n\tmu_push_clip_rect(cnt->body);\n\treturn MU_RES_ACTIVE;\n}\n\n\nint\nmu_begin_window(mu_Container *cnt, const char *title)\n{\n\treturn mu_begin_window_ex(cnt, title, 0);\n}\n\n\nvoid\nmu_end_window(void)\n{\n\tmu_pop_clip_rect();\n\tend_root_container();\n}\n\n\nvoid\nmu_open_popup(mu_Container *cnt)\n{\n\t/* set as hover root so popup isn't closed in begin_window_ex() */\n\tmu_ctx.last_hover_root = mu_ctx.hover_root = cnt;\n\t/* init container if not inited */\n\tif (!cnt->inited)\n\t\tmu_init_window(cnt, 0);\n\t/* position at mouse cursor, open and bring-to-front */\n\tcnt->rect = mu_rect(mu_ctx.mouse_pos.x, mu_ctx.mouse_pos.y, 0, 0);\n\tcnt->open = 1;\n\tmu_bring_to_front(cnt);\n}\n\n\nint\nmu_begin_popup(mu_Container *cnt)\n{\n\treturn mu_begin_window_ex(cnt, \"\", MU_OPT_POPUP | MU_OPT_AUTOSIZE | MU_OPT_NORESIZE | MU_OPT_NOSCROLL | MU_OPT_NOTITLE | MU_OPT_CLOSED);\n}\n\n\nvoid\nmu_end_popup(void)\n{\n\tmu_end_window();\n}\n\n\nvoid\nmu_begin_panel_ex(mu_Container *cnt, int opt)\n{\n\tcnt->rect = mu_layout_next();\n\tif (~opt & MU_OPT_NOFRAME)\n\t\tdraw_frame(cnt->rect, MU_COLOR_PANELBG);\n\n\tpush_container(cnt);\n\tpush_container_body(cnt, cnt->rect, opt);\n\tmu_push_clip_rect(cnt->body);\n}\n\n\nvoid\nmu_begin_panel(mu_Container *cnt)\n{\n\tmu_begin_panel_ex(cnt, 0);\n}\n\n\nvoid\nmu_end_panel(void)\n{\n\tmu_pop_clip_rect();\n\tpop_container();\n}\n\nint\nmu_render(int force)\n{\n\tmu_Command *cmd;\n\tmu_Rect r, iconr;\n\n\tif (force || !eqrect(mu_ctx.screen, screen->r) != 0)\n\t\tmu_ctx.screen = screen->r;\n\telse if (mu_ctx.oldcmdsnum == mu_ctx.cmdsnum && memcmp(mu_ctx.oldcmds, mu_ctx.cmds, mu_ctx.cmdsnum*sizeof(mu_Command)) == 0)\n\t\tif (mu_ctx.oldstrnum == mu_ctx.strnum && memcmp(mu_ctx.oldstr, mu_ctx.str, mu_ctx.strnum) == 0)\n\t\t\treturn 0;\n\n\tif (mu_ctx.oldcmdsmax != mu_ctx.cmdsmax && (mu_ctx.oldcmds = realloc(mu_ctx.oldcmds, mu_ctx.cmdsmax*sizeof(mu_Command))) == nil)\n\t\tsysfatal(\"couldn't allocate memory for old cmds\");\n\tmu_ctx.oldcmdsmax = mu_ctx.cmdsmax;\n\tmu_ctx.oldcmdsnum = mu_ctx.cmdsnum;\n\tmemmove(mu_ctx.oldcmds, mu_ctx.cmds, mu_ctx.cmdsnum*sizeof(mu_Command));\n\n\tif (mu_ctx.oldstrmax != mu_ctx.strmax && (mu_ctx.oldstr = realloc(mu_ctx.oldstr, mu_ctx.strmax)) == nil)\n\t\tsysfatal(\"couldn't allocate memory for old strings\");\n\tmu_ctx.oldstrmax = mu_ctx.strmax;\n\tmu_ctx.oldstrnum = mu_ctx.strnum;\n\tmemmove(mu_ctx.oldstr, mu_ctx.str, mu_ctx.strnum);\n\n\tdraw(screen, screen->r, mu_style.colors[MU_COLOR_BG], nil, ZP);\n\n\tfor (cmd = mu_ctx.cmds; cmd < mu_ctx.cmds + mu_ctx.cmdsnum;) {\n\t\tswitch (cmd->type) {\n\t\tcase MU_COMMAND_TEXT:\n\t\t\tif (cmd->text.color != nil)\n\t\t\t\tstring(screen, addpt(screen->r.min, cmd->text.pos), cmd->text.color, ZP, mu_style.font, mu_ctx.str+cmd->text.s);\n\t\t\tbreak;\n\n\t\tcase MU_COMMAND_RECT:\n\t\t\tif (cmd->rect.color != nil)\n\t\t\t\tdraw(screen, screenrect(cmd->rect.rect), cmd->rect.color, nil, cmd->rect.position);\n\t\t\tbreak;\n\n\t\tcase MU_COMMAND_ICON:\n\t\t\tr = cmd->icon.rect;\n\t\t\ticonr = atlasicons[cmd->icon.id];\n\t\t\tr.x += (r.w - iconr.w) / 2;\n\t\t\tr.y += (r.h - iconr.h) / 2;\n\t\t\tr.w = iconr.w;\n\t\t\tr.h = iconr.h;\n\t\t\tdraw(screen, screenrect(r), atlasimage, nil, Pt(iconr.x, iconr.y));\n\t\t\tbreak;\n\n\t\tcase MU_COMMAND_CLIP:\n\t\t\treplclipr(screen, 0, screenrect(cmd->clip.rect));\n\t\t\tbreak;\n\n\t\tcase MU_COMMAND_JUMP:\n\t\t\tif (cmd->jump.dst < 0)\n\t\t\t\treturn 1;\n\t\t\tcmd = &mu_ctx.cmds[cmd->jump.dst];\n\t\t\tcontinue;\n\t\t}\n\n\t\tcmd++;\n\t}\n\n\treturn 1;\n}\n", "source": "microui/microui.c", "file_type": "c"}
{"text": "#include <u.h>\n#include <libc.h>\n#include <draw.h>\n#include <microui.h>\n\nstatic char logbuf[64000];\nstatic int logbuf_updated = 0;\n\nstatic void\nwrite_log(const char *text)\n{\n\tif (logbuf[0])\n\t\tstrcat(logbuf, \"\\n\");\n\tstrcat(logbuf, text);\n\tlogbuf_updated = 1;\n}\n\n#define text_width(s) (stringwidth(mu_style.font, s) + 6)\n#define text_height() mu_style.font->height\n#define max(a, b) ((a) > (b) ? (a) : (b))\n\nstatic void\ntest_window(void)\n{\n\tstatic mu_Container window;\n\n\t/* init window manually so we can set its position and size */\n\tif (!window.inited) {\n\t\tmu_init_window(&window, 0);\n\t\twindow.rect = mu_rect(40, 40, 320, 500);\n\t}\n\n\t/* limit window to minimum size */\n\twindow.rect.w = max(window.rect.w, 240);\n\twindow.rect.h = max(window.rect.h, 300);\n\n\t/* do window */\n\tif (mu_begin_window(&window, \"Demo Window\")) {\n\n\t\t/* window info */\n\t\tstatic int show_info = 0;\n\t\tif (mu_header(&show_info, \"Window Info\")) {\n\t\t\tchar buf[64];\n\t\t\tconst int widths[] = { text_width(\"Position:\"), -1 };\n\t\t\tmu_layout_row(2, widths, 0);\n\t\t\tmu_label(\"Position:\");\n\t\t\tsprint(buf, \"%d, %d\", window.rect.x, window.rect.y); mu_label(buf);\n\t\t\tmu_label(\"Size:\");\n\t\t\tsprint(buf, \"%d, %d\", window.rect.w, window.rect.h); mu_label(buf);\n\t\t}\n\n\t\t/* labels + buttons */\n\t\tstatic int show_buttons = 1;\n\t\tif (mu_header(&show_buttons, \"Test Buttons\")) {\n\t\t\tconst int widths[] = { text_width(\"Test buttons 2:\"), -text_width(\"Button 2\t\"), -1 };\n\t\t\tmu_layout_row(3, widths, 0);\n\t\t\tmu_label(\"Test buttons 1:\");\n\t\t\tif (mu_button(\"Button 1\")) { write_log(\"Pressed button 1\"); }\n\t\t\tif (mu_button(\"Button 2\")) { write_log(\"Pressed button 2\"); }\n\t\t\tmu_label(\"Test buttons 2:\");\n\t\t\tif (mu_button(\"Button 3\")) { write_log(\"Pressed button 3\"); }\n\t\t\tif (mu_button(\"Button 4\")) { write_log(\"Pressed button 4\"); }\n\t\t}\n\n\t\t/* tree */\n\t\tstatic int show_tree = 1;\n\t\tif (mu_header(&show_tree, \"Tree and Text\")) {\n\t\t\tint widths[] = { text_width(\"Test 1a\")+text_height()*2+text_width(\"Button 3\")+6, -1 };\n\t\t\tmu_layout_row(2, widths, 0);\n\t\t\tmu_layout_begin_column();\n\t\t\tstatic int states[8];\n\t\t\tif (mu_begin_treenode(&states[0], \"Test 1\")) {\n\t\t\t\tif (mu_begin_treenode(&states[1], \"Test 1a\")) {\n\t\t\t\t\tmu_label(\"Hello\");\n\t\t\t\t\tmu_label(\"world\");\n\t\t\t\t\tmu_end_treenode();\n\t\t\t\t}\n\t\t\t\tif (mu_begin_treenode(&states[2], \"Test 1b\")) {\n\t\t\t\t\tif (mu_button(\"Button 1\")) { write_log(\"Pressed button 1\"); }\n\t\t\t\t\tif (mu_button(\"Button 2\")) { write_log(\"Pressed button 2\"); }\n\t\t\t\t\tmu_end_treenode();\n\t\t\t\t}\n\t\t\t\tmu_end_treenode();\n\t\t\t}\n\t\t\tif (mu_begin_treenode(&states[3], \"Test 2\")) {\n\t\t\t\tint widths[2];\n\t\t\t\twidths[0] = widths[1] = text_width(\"Button 3\");\n\t\t\t\tmu_layout_row(2, widths, 0);\n\t\t\t\tif (mu_button(\"Button 3\")) { write_log(\"Pressed button 3\"); }\n\t\t\t\tif (mu_button(\"Button 4\")) { write_log(\"Pressed button 4\"); }\n\t\t\t\tif (mu_button(\"Button 5\")) { write_log(\"Pressed button 5\"); }\n\t\t\t\tif (mu_button(\"Button 6\")) { write_log(\"Pressed button 6\"); }\n\t\t\t\tmu_end_treenode();\n\t\t\t}\n\t\t\tif (mu_begin_treenode(&states[4], \"Test 3\")) {\n\t\t\t\tstatic int checks[3] = { 1, 0, 1 };\n\t\t\t\tmu_checkbox(&checks[0], \"Checkbox 1\");\n\t\t\t\tmu_checkbox(&checks[1], \"Checkbox 2\");\n\t\t\t\tmu_checkbox(&checks[2], \"Checkbox 3\");\n\t\t\t\tmu_end_treenode();\n\t\t\t}\n\t\t\tmu_layout_end_column();\n\n\t\t\tmu_layout_begin_column();\n\t\t\twidths[0] = -1;\n\t\t\tmu_layout_row(1, widths, 0);\n\t\t\tmu_text(\"Lorem ipsum dolor sit amet, consectetur adipiscing \"\n\t\t\t\t\"elit. Maecenas lacinia, sem eu lacinia molestie, mi risus faucibus \"\n\t\t\t\t\"ipsum, eu varius magna felis a nulla.\");\n\t\t\tmu_layout_end_column();\n\t\t}\n\n\t\tmu_end_window();\n\t}\n}\n\n\nstatic void\nlog_window(void)\n{\n\tstatic mu_Container window;\n\n\t/* init window manually so we can set its position and size */\n\tif (!window.inited) {\n\t\tmu_init_window(&window, 0);\n\t\twindow.rect = mu_rect(370, 40, 340, 200);\n\t}\n\n\tif (mu_begin_window(&window, \"Log Window\")) {\n\t\tint widths[] = { -1, -1 };\n\n\t\t/* output text panel */\n\t\tstatic mu_Container panel;\n\t\tmu_layout_row(1, widths, -28);\n\t\tmu_begin_panel(&panel);\n\t\tmu_layout_row(1, widths, -1);\n\t\tmu_text(logbuf);\n\t\tmu_end_panel();\n\t\tif (logbuf_updated) {\n\t\t\tpanel.scroll.y = panel.content_size.y;\n\t\t\tlogbuf_updated = 0;\n\t\t}\n\n\t\t/* input textbox + submit button */\n\t\tstatic char buf[128];\n\t\tint submitted = 0;\n\t\twidths[0] = -text_width(\"Submit\")-8;\n\t\tmu_layout_row(2, widths, -1);\n\t\tif (mu_textbox(buf, sizeof(buf)) & MU_RES_SUBMIT) {\n\t\t\tmu_set_focus(mu_ctx.last_id);\n\t\t\tsubmitted = 1;\n\t\t}\n\t\tif (mu_button(\"Submit\")) { submitted = 1; }\n\t\tif (submitted) {\n\t\t\twrite_log(buf);\n\t\t\tbuf[0] = '\\0';\n\t\t}\n\n\t\tmu_end_window();\n\t}\n}\n\n\nstatic int\nuint8_slider(unsigned char *value, int low, int high)\n{\n\tstatic double tmp;\n\tmu_push_id(&value, sizeof(value));\n\ttmp = *value;\n\tint res = mu_slider_ex(&tmp, low, high, 0, \"%.0f\", MU_OPT_ALIGNCENTER);\n\t*value = tmp;\n\tmu_pop_id();\n\treturn res;\n}\n\nstatic void\nstyle_window(void)\n{\n\tstatic mu_Container window;\n\tstatic u8int cur[MU_COLOR_MAX][4], old[MU_COLOR_MAX][4];\n\tstatic struct { const char *label; int idx; } colors[] = {\n\t\t{ \"background:\", MU_COLOR_BG },\n\t\t{ \"text:\", MU_COLOR_TEXT },\n\t\t{ \"border:\", MU_COLOR_BORDER },\n\t\t{ \"windowbg:\", MU_COLOR_WINDOWBG },\n\t\t{ \"titlebg:\", MU_COLOR_TITLEBG },\n\t\t{ \"titletext:\", MU_COLOR_TITLETEXT },\n\t\t{ \"panelbg:\", MU_COLOR_PANELBG },\n\t\t{ \"button:\", MU_COLOR_BUTTON },\n\t\t{ \"buttonhover:\", MU_COLOR_BUTTONHOVER },\n\t\t{ \"buttonfocus:\", MU_COLOR_BUTTONFOCUS },\n\t\t{ \"base:\", MU_COLOR_BASE },\n\t\t{ \"basehover:\", MU_COLOR_BASEHOVER },\n\t\t{ \"basefocus:\", MU_COLOR_BASEFOCUS },\n\t\t{ \"scrollbase:\", MU_COLOR_SCROLLBASE },\n\t\t{ \"scrollthumb:\", MU_COLOR_SCROLLTHUMB },\n\t\t{ nil }\n\t};\n\n\t/* init window manually so we can set its position and size */\n\tif (!window.inited) {\n\t\tmu_init_window(&window, 0);\n\t\twindow.rect = mu_rect(370, 250, 340, 290);\n\t\tmemmove(cur, defaultcolors, sizeof(cur));\n\t\tmemmove(old, defaultcolors, sizeof(old));\n\t}\n\n\tif (mu_begin_window(&window, \"Style Editor\")) {\n\t\tint sw = max(text_width(\"255\"), mu_get_container()->body.w * 0.14);\n\t\tconst int widths[] = { text_width(\"scrollthumb:\"), sw, sw, sw, sw, -1 };\n\t\tmu_layout_row(6, widths, 0);\n\t\tfor (int i = 0; colors[i].label; i++) {\n\t\t\tmu_label(colors[i].label);\n\t\t\tuint8_slider(&cur[i][0], 0, 255);\n\t\t\tuint8_slider(&cur[i][1], 0, 255);\n\t\t\tuint8_slider(&cur[i][2], 0, 255);\n\t\t\tuint8_slider(&cur[i][3], 0, 255);\n\t\t\tif (memcmp(cur[i], old[i], 4) != 0) {\n\t\t\t\tfreeimage(mu_style.colors[i]);\n\t\t\t\tmu_style.colors[i] = mu_color(cur[i][0], cur[i][1], cur[i][2], cur[i][3]);\n\t\t\t\tmemmove(old[i], cur[i], 4);\n\t\t\t}\n\t\t\tmu_draw_rect(mu_layout_next(), mu_style.colors[i]);\n\t\t}\n\t\tmu_end_window();\n\t}\n}\n\nvoid\nprocess_frame(void)\n{\n\tmu_begin();\n\ttest_window();\n\tlog_window();\n\tstyle_window();\n\tmu_end();\n}\n", "source": "microui/demo/frame.c", "file_type": "c"}
{"text": "#include <u.h>\n#include <libc.h>\n#include <draw.h>\n#include <mouse.h>\n#include <keyboard.h>\n#include <thread.h>\n#include <bio.h>\n#include <microui.h>\n\nvoid process_frame(void);\n\nvoid\nthreadmain(int argc, char **argv)\n{\n\tMousectl *mctl;\n\tchar *s;\n\tBiobuf *snarf;\n\tKeyboardctl *kctl;\n\tint redraw;\n\tRune key;\n\tMouse m;\n\tAlt a[] = {\n\t\t{ nil, &m, CHANRCV },\n\t\t{ nil, nil, CHANRCV },\n\t\t{ nil, &key, CHANRCV },\n\t\t{ nil, nil,  CHANEND},\n\t};\n\tint oldbuttons, b, nkey, gotevent;\n\tchar text[5];\n\n\tUSED(argc); USED(argv);\n\n\tif (initdraw(nil, nil, \"microui demo\") < 0)\n\t\tsysfatal(\"initdraw: %r\");\n\tif ((mctl = initmouse(nil, screen)) == nil)\n\t\tsysfatal(\"initmouse: %r\");\n\tif ((kctl = initkeyboard(nil)) == nil)\n\t\tsysfatal(\"initkeyboard: %r\");\n\n\ta[0].c = mctl->c;\n\ta[1].c = mctl->resizec;\n\ta[2].c = kctl->c;\n\n\tsrand(time(0));\n\tthreadsetname(\"microui demo\");\n\n\tmu_init();\n\tmu_style.font = font;\n\tmu_style.size.y = font->height;\n\tmu_style.title_height = mu_style.size.y + 6;\n\tprocess_frame();\n\n\toldbuttons = 0;\n\tredraw = 0;\n\tfor (;;) {\n\t\tprocess_frame();\n\t\tif (mu_render(redraw))\n\t\t\tflushimage(display, 1);\n\n\t\tredraw = 0;\n\t\tgotevent = 1;\n\t\tswitch (alt(a)) {\n\t\tcase 0: /* mouse */\n\t\t\tm.xy.x -= screen->r.min.x;\n\t\t\tm.xy.y -= screen->r.min.y;\n\t\t\tmu_input_mousemove(m.xy.x, m.xy.y);\n\t\t\tif ((b = (m.buttons & 1)) != (oldbuttons & 1))\n\t\t\t\t(b ? mu_input_mousedown : mu_input_mouseup)(m.xy.x, m.xy.y, MU_MOUSE_LEFT);\n\t\t\telse if ((b = (m.buttons & 2)) != (oldbuttons & 2))\n\t\t\t\t(b ? mu_input_mousedown : mu_input_mouseup)(m.xy.x, m.xy.y, MU_MOUSE_MIDDLE);\n\t\t\telse if ((b = (m.buttons & 4)) != (oldbuttons & 4))\n\t\t\t\t(b ? mu_input_mousedown : mu_input_mouseup)(m.xy.x, m.xy.y, MU_MOUSE_RIGHT);\n\t\t\tif (m.buttons == 5 && (snarf = Bopen(\"/dev/snarf\", OREAD)) != nil) {\n\t\t\t\tif ((s = Brdstr(snarf, 0, 1)) != nil) {\n\t\t\t\t\tmu_input_text(s);\n\t\t\t\t\tfree(s);\n\t\t\t\t}\n\t\t\t\tBterm(snarf);\n\t\t\t}\n\t\t\toldbuttons = m.buttons;\n\t\t\tbreak;\n\n\t\tcase 1: /* resize */\n\t\t\tgetwindow(display, Refnone);\n\t\t\tredraw = 1;\n\t\t\tbreak;\n\n\t\tcase 2: /* keyboard */\n\t\t\tnkey = -1;\n\t\t\tswitch (key) {\n\t\t\tcase Kdel: goto end;\n\t\t\tcase Kshift: nkey = MU_KEY_SHIFT; break;\n\t\t\tcase Kbs: nkey = MU_KEY_BACKSPACE; break;\n\t\t\tcase '\\n': nkey = MU_KEY_RETURN; break;\n\t\t\tcase Knack: nkey = MU_KEY_NACK; break;\n\t\t\tcase Kleft: nkey = MU_KEY_LEFT; break;\n\t\t\tcase Kright: nkey = MU_KEY_RIGHT; break;\n\t\t\tcase Kesc: mu_set_focus(0); break;\n\t\t\tdefault:\n\t\t\t\tif (key < 0xf000 || key > 0xffff) {\n\t\t\t\t\tmemset(text, 0, sizeof(text));\n\t\t\t\t\tif (runetochar(text, &key) > 0)\n\t\t\t\t\t\tmu_input_text(text);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (nkey >= 0) {\n\t\t\t\tmu_input_keydown(nkey);\n\t\t\t\tmu_input_keyup(nkey);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tgotevent = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (gotevent)\n\t\t\tprocess_frame();\n\t}\n\nend:\n\tthreadexitsall(nil);\n}\n", "source": "microui/demo/plan9.c", "file_type": "c"}
{"text": "</$objtype/mkfile\n\nTARG=demo\n\nOFILES=\\\n\tframe.$O\\\n\tplan9.$O\\\n\ndefault:V:\tall\n\n</sys/src/cmd/mkone\n", "source": "microui/demo/mkfile", "file_type": "mkfile"}
{"text": "#include <u.h>\n#include <libc.h>\n#include \"frame.h\"\n\nFrame *\nnewframe(int w, int h, u8int *yuv[3], int ystride, int uvstride)\n{\n\tFrame *f;\n\n\tassert(w > 2 && h > 2);\n\tassert(ystride > 2 && uvstride > 2);\n\tassert(yuv[0] != nil && yuv[1] != nil && yuv[2] != nil);\n\n\tif((f = malloc(sizeof(*f) + (ystride+uvstride)*h)) == nil)\n\t\treturn nil;\n\n\tf->w = w;\n\tf->h = h;\n\tf->ystride = ystride;\n\tf->uvstride = uvstride;\n\tf->yuv[0] = f->data;\n\tf->yuv[1] = f->yuv[0] + ystride*h;\n\tf->yuv[2] = f->yuv[1] + uvstride*h/2;\n\tmemmove(f->yuv[0], yuv[0], ystride*h);\n\tmemmove(f->yuv[1], yuv[1], uvstride*h/2);\n\tmemmove(f->yuv[2], yuv[2], uvstride*h/2);\n\n\treturn f;\n}\n", "source": "treason/frame.c", "file_type": "c"}
{"text": "#!/bin/rc -e\nrfork ne\n\n# required by opus things\n@{cd /sys/src/cmd/audio/libogg && mk}\n\nfor(d in dav1d aacdec mcfs mcfs/extra openh264 libvpx opus/opus opus/libopusenc opus/opusfile opus/opus-tools)\n\t@{cd $d && mk install}\n\necho committing treason\ncd treason && mk install && echo treason has been committed\n", "source": "treason/install.rc", "file_type": "rc"}
{"text": "</$objtype/mkfile\n\nCFLAGS=$CFLAGS -D__plan9__ -p -D__${objtype}__\\\n -I../dav1d/include/dav1d -I../dav1d/src/plan9\\\n -I../libvpx/vpx\\\n -I../openh264/codec -I../openh264/codec/api/svc -I../openh264/codec/common/inc -I../openh264/codec/decoder/core/inc\n\nTARG=treason\nBIN=/$objtype/bin\nCLEANFILES=$TARG.gz\n\nHFILES=\\\n\tdecoder.h\\\n\tframe.h\\\n\tmisc.h\\\n\tstream.h\\\n\nOFILES=\\\n\tdecoder.$O\\\n\tdecoder_av1.$O\\\n\tdecoder_h264.$O\\\n\tdecoder_vpx.$O\\\n\tframe.$O\\\n\tmain.$O\\\n\tmisc.$O\\\n\tstream.$O\\\n\tstream_audio.$O\\\n\tstream_ivf.$O\\\n\tstream_mc.$O\\\n\tstream_sub.$O\\\n\tyuv.$O\\\n\ndefault:V:\tall\n\nrelease:V: $TARG.gz\n\n../opus:\n\tmkdir -p ../opus\n\tcd ../opus\n\tfor(o in opus libopusenc opusfile opus-tools)\n\t\tgit/clone https://github.com/qwx9/$o\n\n$TARG.gz: ../opus\n\tdisk/mkfs -a -s .. proto | gzip -9 > $target\n\tdu -hs $target\n\n</sys/src/cmd/mkone\n", "source": "treason/mkfile", "file_type": "mkfile"}
{"text": "#include <u.h>\n#include <libc.h>\n#include <bio.h>\n#include \"misc.h\"\n#include \"stream.h\"\n\nenum {\n\tOnesec = 2*2*44100, /* 16-bit, stereo */\n\tFramesz = Onesec/5, /* \u2155 second */\n};\n\nstatic char *progs[] = {\n\t[FmtAAC] = \"/bin/audio/aacdec\",\n\t[FmtMp3] = \"/bin/audio/mp3dec\",\n\t[FmtOpus] = \"/bin/audio/opusdec\",\n\t[FmtVorbis] = \"/bin/audio/oggdec\",\n\t[FmtFlac] = \"/bin/audio/flacdec\",\n};\n\nextern Streamops audops;\n\nint\naudopenfd(int fd, Stream *s, int *failed)\n{\n\tint p[2], pid;\n\tchar *prog;\n\tDir *d;\n\n\tif(fd < 0)\n\t\treturn -1;\n\tif(s->fmt >= nelem(progs) || (prog = progs[s->fmt]) == nil){\n\t\twerrstr(\"unsupported audio format %d\", s->fmt);\n\t\tgoto err;\n\t}\n\n\t*failed = 1;\n\tif((d = dirstat(prog)) == nil){\n\t\twerrstr(\"can't decode, %s isn't available\", prog);\n\t\tgoto err;\n\t}\n\tfree(d);\n\n\tpipe(p);\n\tif((pid = rfork(RFFDG|RFPROC)) == 0){\n\t\tdup(fd, 0); close(fd);\n\t\tclose(p[0]);\n\t\tdup(p[1], 1); close(p[1]);\n\t\tif(!debug){\n\t\t\tdup(fd = open(\"/dev/null\", OWRITE), 2);\n\t\t\tclose(fd);\n\t\t}\n\t\texecl(prog, prog, nil);\n\t\tsysfatal(\"exec: %r\");\n\t}\n\tclose(p[1]);\n\tif(pid < 0){\n\t\tclose(p[0]);\n\t\tgoto err;\n\t}\n\tclose(fd);\n\n\ts->type = Saudio;\n\ts->timebase.denum = 1;\n\ts->timebase.num = 1;\n\ts->b = Bfdopen(p[0], OREAD);\n\tmemmove(&s->ops, &audops, sizeof(audops));\n\t*failed = 0;\n\n\treturn 0;\nerr:\n\tclose(fd);\n\treturn -1;\n}\n\nstatic Stream *\naudopen(char *path, int *num, int *failed)\n{\n\tStream *s;\n\n\tif((s = calloc(1, sizeof(*s))) == nil){\n\t\t*failed = 1;\n\t\treturn nil;\n\t}\n\n\t*num = 1;\n\tif(audopenfd(open(path, OREAD), s, failed) != 0){\n\t\tfree(s);\n\t\ts = nil;\n\t}\n\n\treturn s;\n}\n\nstatic int\naudread(Stream *s, Streamframe *f)\n{\n\tif(s->buf == nil)\n\t\ts->buf = malloc(Framesz);\n\tf->buf = s->buf;\n\tf->timestamp = s->timestamp;\n\tif((f->sz = Bread(s->b, f->buf, Framesz)) < 0){ /* eof */\n\t\tf->sz = 0;\n\t\treturn -1;\n\t}\n\n\tf->dt = f->sz * 1000000000ULL / Onesec;\n\ts->timestamp += f->dt;\n\n\treturn 0;\n}\n\nstatic void\naudclose(Stream *s)\n{\n\tBterm(s->b);\n\tfree(s->buf);\n}\n\nStreamops audops = {\n\t.open = audopen,\n\t.read = audread,\n\t.close = audclose,\n};\n", "source": "treason/stream_audio.c", "file_type": "c"}
{"text": "#include <u.h>\n#include <libc.h>\n#include <tos.h>\n#include \"misc.h\"\n#include \"stream.h\"\n\nint nproc, debug;\n\nstatic char *fmts[Numfmt] = {\n\t[FmtAAC]  = \"aac\",\n\t[FmtAV1]  = \"av1\",\n\t[FmtFlac] = \"flac\",\n\t[FmtH264] = \"h264\",\n\t[FmtMp3]  = \"mp3\",\n\t[FmtOpus] = \"opus\",\n\t[FmtSrt]  = \"srt\",\n\t[FmtVP8]  = \"vp8\",\n\t[FmtVP9]  = \"vp9\",\n\t[FmtVorbis] = \"vorbis\",\n};\n\nint\nstr2fmt(char *s)\n{\n\tint i;\n\n\tfor(i = 0; i < nelem(fmts); i++){\n\t\tif(fmts[i] != nil && strcmp(fmts[i], s) == 0)\n\t\t\treturn i;\n\t}\n\n\treturn -1;\n}\n\nchar *\nfmt2str(int fmt)\n{\n\tif(fmt >= 0 && fmt < nelem(fmts))\n\t\treturn fmts[fmt];\n\n\treturn \"???\";\n}\n\nuvlong\nnanosec(void)\n{\n\tstatic uvlong fasthz, xstart;\n\tuvlong x, div;\n\n\tif(fasthz == ~0ULL)\n\t\treturn nsec() - xstart;\n\n\tif(fasthz == 0){\n\t\tfasthz = _tos->cyclefreq;\n\t\tif(fasthz == 0){\n\t\t\tfasthz = ~0ULL;\n\t\t\txstart = nsec();\n\t\t\tfprint(2, \"cyclefreq not available, falling back to nsec()\\n\");\n\t\t\tfprint(2, \"you might want to disable aux/timesync\\n\");\n\t\t}else{\n\t\t\tcycles(&xstart);\n\t\t}\n\t\treturn 0;\n\t}\n\tcycles(&x);\n\tx -= xstart;\n\n\t/* this is ugly */\n\tfor(div = 1000000000ULL; x < 0x1999999999999999ULL && div > 1 ; div /= 10ULL, x *= 10ULL);\n\n\treturn x / (fasthz / div);\n}\n\nvoid\nnsleep(uvlong ns)\n{\n#define Nmsec 1000000ULL\n\tuvlong start, end;\n\n\tstart = nanosec();\n\tend = start + ns;\n\tns = start;\n\tdo{\n\t\tif(end - ns > 85*Nmsec)\n\t\t\tsleep(80);\n\t\telse if (end - ns > 25*Nmsec)\n\t\t\tsleep(20);\n\t\telse if (end - ns > 1*Nmsec)\n\t\t\tsleep(1);\n\t\telse\n\t\t\tbreak;\n\t\tns = nanosec();\n\t}while(ns < end);\n}\n", "source": "treason/misc.c", "file_type": "c"}
{"text": "#include <u.h>\n#include <libc.h>\n#include <bio.h>\n#include \"stream.h\"\n\nextern Streamops ivfops;\n\nstatic int\nBu16le(Biobuf *b, u16int *o)\n{\n\tint x;\n\n\tx = Bgetc(b);\n\tx |= Bgetc(b)<<8;\n\t*o = x;\n\tif(x < 0)\n\t\twerrstr(\"failed to read 2 bytes\");\n\n\treturn x < 0 ? -1 : 0;\n}\n\nstatic int\nBu32le(Biobuf *b, u32int *o)\n{\n\tint x, i;\n\n\t*o = 0;\n\tfor(i = 0; i < 4; *o |= x<<(i*8), i++){\n\t\tif((x = Bgetc(b)) < 0){\n\t\t\twerrstr(\"failed to read 4 bytes\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int\nBu64le(Biobuf *b, u64int *o)\n{\n\tint x, i;\n\n\t*o = 0;\n\tfor(i = 0; i < 8; *o |= x<<(i*8), i++){\n\t\tif((x = Bgetc(b)) < 0){\n\t\t\twerrstr(\"failed to read 8 bytes\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint\nivfopenb(void *bio, Stream *s, int *failed)\n{\n\tu16int hlen, w, h, fmt;\n\tu32int tbdenum, tbnum;\n\tchar tmp[6];\n\n\tif(bio == nil){\n\t\twerrstr(\"nil bio\");\n\t\treturn -1;\n\t}\n\tif(Bread(bio, tmp, 6) != 6 || Bu16le(bio, &hlen) < 0){\n\t\twerrstr(\"header read failed\");\n\t\tBterm(bio);\n\t\treturn -1;\n\t}\n\tif(memcmp(tmp, \"DKIF\", 4) != 0){\n\t\twerrstr(\"expected DKIF, got %02x%02x%02x%02x\", tmp[0], tmp[1], tmp[2], tmp[3]);\n\t\tBterm(bio);\n\t\treturn -1;\n\t}\n\tif(hlen < 0x20 || Bread(bio, tmp, 4) != 4){\n\t\twerrstr(\"invalid header: hlen=%d\", hlen);\n\t\tgoto err;\n\t}\n\n\tif(memcmp(tmp, \"AV01\", 4) == 0)\n\t\tfmt = FmtAV1;\n\telse if(memcmp(tmp, \"VP90\", 4) == 0)\n\t\tfmt = FmtVP9;\n\telse if(memcmp(tmp, \"VP80\", 4) == 0)\n\t\tfmt = FmtVP8;\n\telse if(memcmp(tmp, \"AVC1\", 4) == 0) /* FIXME that's non-standard */\n\t\tfmt = FmtH264;\n\telse{\n\t\twerrstr(\"unsupported format %.*s\", 4, tmp);\n\t\tgoto err;\n\t}\n\n\tif(Bu16le(bio, &w) < 0 || Bu16le(bio, &h) < 0 || Bu32le(bio, &tbdenum) < 0 || Bu32le(bio, &tbnum) < 0){\n\t\twerrstr(\"invalid header: %r\");\n\t\tgoto err;\n\t}\n\tif(Bseek(bio, hlen, 0) != hlen){\n\t\twerrstr(\"invalid IVF stream\");\n\t\tgoto err;\n\t}\n\n\ts->type = Svideo;\n\ts->fmt = fmt;\n\ts->video.w = w;\n\ts->video.h = h;\n\ts->timebase.denum = tbdenum;\n\ts->timebase.num = tbnum;\n\ts->b = bio;\n\tmemmove(&s->ops, &ivfops, sizeof(ivfops));\n\n\treturn 0;\nerr:\n\t*failed = 1;\n\tBterm(bio);\n\tfree(s);\n\treturn -1;\n}\n\nstatic Stream *\nivfopen(char *path, int *num, int *failed)\n{\n\tStream *s;\n\n\tif((s = calloc(1, sizeof(*s))) == nil){\n\t\t*failed = 1;\n\t\treturn nil;\n\t}\n\n\t*num = 1;\n\tif(ivfopenb(Bopen(path, OREAD|OCEXEC), s, failed) != 0){\n\t\tfree(s);\n\t\ts = nil;\n\t}\n\n\treturn s;\n}\n\nstatic int\nivfread(Stream *s, Streamframe *f)\n{\n\tu64int timestamp;\n\tu32int sz;\n\tu8int *buf;\n\tint n;\n\n\tif(Bu32le(s->b, &sz) < 0 || Bu64le(s->b, &timestamp) < 0 || (int)sz < 0){\n\t\t/* eof */\n\t\tf->sz = 0;\n\t\treturn 0;\n\t}\n\tbuf = s->buf;\n\tif(s->ops.alloc != nil)\n\t\tbuf = s->ops.alloc(s->ops.aux, sz);\n\telse if(sz > s->bufsz){\n\t\tif((buf = realloc(s->buf, sz)) == nil){\n\t\t\twerrstr(\"frame is too big: %d bytes\", sz);\n\t\t\tgoto err;\n\t\t}\n\t\ts->buf = buf;\n\t}\n\tif((n = Bread(s->b, buf, sz)) != sz){\n\t\twerrstr(\"short read (%d < %d)\", n, sz);\n\t\tgoto err;\n\t}\n\tf->buf = buf;\n\tf->sz = sz;\n\tf->timestamp = timestamp;\n\n\treturn 0;\nerr:\n\twerrstr(\"ivf: %r\");\n\treturn -1;\n}\n\nstatic void\nivfclose(Stream *s)\n{\n\tif(s->b != nil){\n\t\tBterm(s->b);\n\t\ts->b = nil;\n\t}\n\tfree(s->buf);\n\ts->buf = nil;\n}\n\nStreamops ivfops = {\n\t.open = ivfopen,\n\t.read = ivfread,\n\t.close = ivfclose,\n};\n", "source": "treason/stream_ivf.c", "file_type": "c"}
{"text": "#include <u.h>\n#include <libc.h>\n#include <thread.h>\n#include \"stream.h\"\n#include \"decoder.h\"\n#include \"frame.h\"\n\nextern Decoderops av1ops, h264ops, vpxops;\n\nstatic struct {\n\tchar *name;\n\tDecoderops *o;\n\tint fmt;\n}ops[] = {\n\t{\"AV1\", &av1ops, FmtAV1},\n\t{\"H264\", &h264ops, FmtH264},\n\t{\"VP8\", &vpxops, FmtVP8},\n\t{\"VP9\", &vpxops, FmtVP9},\n};\n\nDecoder *\nDopen(Stream *s)\n{\n\tDecoder *d;\n\tint i;\n\n\tif((d = calloc(1, sizeof(*d))) == nil)\n\t\treturn nil;\n\n\td->timebase = (double)s->timebase.num/(double)s->timebase.denum;\n\td->s = s;\n\td->frames = chancreate(sizeof(Frame*), 24);\n\td->finished = chancreate(sizeof(void*), 0);\n\n\tfor(i = 0; i < nelem(ops); i++){\n\t\tif(ops[i].fmt == s->fmt){\n\t\t\tif(ops[i].o->open(d) < 0){\n\t\t\t\twerrstr(\"%s: %r\", ops[i].name);\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\td->ops = ops[i].o;\n\t\t\tsnprint(d->info, sizeof(d->info), \"%s\", ops[i].name);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tassert(i < nelem(ops));\n\n\treturn d;\nerr:\n\treturn nil;\n}\n\nvoid\nDclose(Decoder *d)\n{\n\td->ops->close(d);\n\tchanclose(d->frames);\n\trecvp(d->finished);\n\tfree(d);\n}\n", "source": "treason/decoder.c", "file_type": "c"}
{"text": "#include <u.h>\n#include <libc.h>\n#include \"stream.h\"\n\nextern Streamops ivfops, mcops, audops;\n\nstatic struct {\n\tchar *name;\n\tStreamops *o;\n}ops[] = {\n\t{\"ivf\", &ivfops},\n\t{\"mc\", &mcops},\n\t{\"audio\", &audops},\n};\n\nStream *\nSopen(char *filename, int *num)\n{\n\tint i, failed;\n\tStream *s;\n\tchar *f;\n\n\t*num = 0;\n\tfor(i = 0; i < nelem(ops); i++){\n\t\tfailed = 0;\n\t\tif((s = ops[i].o->open(filename, num, &failed)) != nil){\n\t\t\tf = utfrrune(filename, '/');\n\t\t\tif(f == nil)\n\t\t\t\tf = filename;\n\t\t\telse\n\t\t\t\tf++;\n\t\t\tsnprint(s->info, sizeof(s->info), \"%s [%s]\", ops[i].name, f);\n\t\t\ts->t\u2080 = Zt\u2080;\n\t\t\treturn s;\n\t\t}\n\t\tif(failed){\n\t\t\twerrstr(\"%s: %r\", ops[i].name);\n\t\t\treturn nil;\n\t\t}\n\t}\n\n\twerrstr(\"unknown format\");\n\n\treturn nil;\n}\n\nvoid\nSclose(Stream *s)\n{\n\tif(s == nil || s->type < 0)\n\t\treturn;\n\ts->ops.close(s);\n\ts->type = -1;\n\tif(s->freeaux != nil)\n\t\ts->freeaux(s->aux);\n}\n\nint\nSread(Stream *s, Streamframe *f)\n{\n\tint res;\n\n\tif(s == nil || s->type < 0){\n\t\twerrstr(\"invalid stream\");\n\t\treturn -1;\n\t}\n\tif((res = s->ops.read(s, f)) == 0){\n\t\tif(s->t\u2080 == Zt\u2080)\n\t\t\ts->t\u2080 = f->timestamp;\n\t\t/*\n\t\t * timestamps going backwards means clock wasn't monotonically\n\t\t * increasing. perhaps nanosec() or nsec() is to blame.\n\t\t * just work around it in any case, instead of hanging without\n\t\t * displaying any frames.\n\t\t */\n\t\tif(f->timestamp > s->t\u2080)\n\t\t\tf->timestamp -= s->t\u2080;\n\t\telse\n\t\t\tf->timestamp = 0;\n\t}\n\n\treturn res;\n}\n", "source": "treason/stream.c", "file_type": "c"}
{"text": "#include <u.h>\n#include <libc.h>\n#include <bio.h>\n#include <ctype.h>\n#include \"misc.h\"\n#include \"stream.h\"\n\nextern Streamops subops;\n\nint\nsubopenfd(int fd, Stream *s, int *failed)\n{\n\tif(fd < 0)\n\t\treturn -1;\n\n\ts->type = Ssubtitles;\n\ts->timebase.denum = 1;\n\ts->timebase.num = 1;\n\ts->b = Bfdopen(fd, OREAD);\n\tmemmove(&s->ops, &subops, sizeof(subops));\n\t*failed = 0;\n\n\treturn 0;\n}\n\nStream *\nsubopen(char *path, int *num, int *failed)\n{\n\tStream *s;\n\n\tif((s = calloc(1, sizeof(*s))) == nil){\n\t\t*failed = 1;\n\t\treturn nil;\n\t}\n\n\t*num = 1;\n\tif(subopenfd(open(path, OREAD), s, failed) != 0){\n\t\tfree(s);\n\t\ts = nil;\n\t}\n\n\treturn s;\n}\n\nstatic int\nsubts2ns(char *s, char **e, uvlong *ns)\n{\n\tif(strlen(s) < 9){\n\t\twerrstr(\"timestamp too short\");\n\t\tgoto err;\n\t}\n\t*ns = 0;\n\ts--;\n\tdo{\n\t\ts++;\n\t\t*ns *= 60;\n\t\t*ns += strtod(s, &s)*1000000000.0;\n\t\tif(*s == ','){\n\t\t\t*ns += strtod(s+1, &s)*1000000.0;\n\t\t\tbreak;\n\t\t}\n\t}while(*s == ':');\n\n\t*e = s;\n\n\treturn 0;\nerr:\n\twerrstr(\"subts2ns: %r\");\n\treturn -1;\n}\n\nstatic int\nsubread(Stream *s, Streamframe *f)\n{\n\tuvlong end;\n\tchar *x;\n\tint i, n;\n\n\tBrdline(s->b, '\\n'); /* index */\n\tif((x = Brdline(s->b, '\\n')) == nil){ /* timestamp */\n\t\tf->sz = 0;\n\t\treturn 0;\n\t}\n\tif((n = Blinelen(s->b)) < 1){\n\t\twerrstr(\"unexpected empty line\");\n\t\tgoto err;\n\t}\n\tx[n-1] = 0;\n\tif(subts2ns(x, &x, &f->timestamp) != 0)\n\t\tgoto err;\n\twhile(isspace(*x))\n\t\tx++;\n\tif(strncmp(x, \"-->\", 3) != 0){\n\t\twerrstr(\"no timestamp delimeter: %s\", x);\n\t\tgoto err;\n\t}\n\tx += 3;\n\tif(subts2ns(x, &x, &end) != 0)\n\t\tgoto err;\n\tf->dt = end - f->timestamp;\n\n\tfor(i = 0; i < nelem(f->lines); i++){\n\t\tif((x = Brdstr(s->b, '\\n', 1)) == nil || *x == 0){\n\t\t\tfree(x);\n\t\t\tbreak;\n\t\t}\n\t\tf->lines[i] = x;\n\t}\n\tf->nlines = i;\n\n\ts->timestamp = f->timestamp;\n\n\treturn 0;\nerr:\n\twerrstr(\"subread: %r\");\n\treturn -1;\n}\n\nstatic void\nsubclose(Stream *s)\n{\n\tBterm(s->b);\n\tfree(s->buf);\n}\n\nStreamops subops = {\n\t.open = subopen,\n\t.read = subread,\n\t.close = subclose,\n};\n", "source": "treason/stream_sub.c", "file_type": "c"}
{"text": "#include <u.h>\n#include <libc.h>\n#include <bio.h>\n#include \"stream.h\"\n#include \"misc.h\"\n\nenum {\n\tMaxstreams = 3,\n\tBufsz = 64*1024,\n};\n\ntypedef struct MCaux MCaux;\n\nstruct MCaux {\n\tint fd;\n\tBiobuf bio;\n\tu8int buf[Bufsz];\n};\n\nextern uvlong trackpref;\n\nstatic int\nmcfs(char **argv, int *pipefd)\n{\n\tint p[2], pid;\n\n\tpipe(p);\n\tif((pid = rfork(RFFDG|RFPROC)) == 0){\n\t\tclose(0);\n\t\tclose(p[0]);\n\t\tdup(p[1], 1); close(p[1]);\n\t\texec(\"/bin/mcfs\", argv);\n\t\tsysfatal(\"exec: %r\");\n\t}\n\tclose(p[1]);\n\tif(pid < 0)\n\t\tclose(p[0]);\n\t*pipefd = p[0];\n\n\treturn pid;\n}\n\nstatic void\nfreeaux(void *aux)\n{\n\tMCaux *a;\n\n\ta = aux;\n\tclose(a->fd);\n\tfree(a);\n}\n\nstatic Stream *\nmcopen(char *filename, int *num, int *failed)\n{\n\tWaitmsg *w;\n\tchar *line;\n\tint p, pid, n, ns;\n\tBiobuf b;\n\tMCaux *a;\n\tchar *argv[] = {\n\t\t\"mcfs\",\n\t\tfilename,\n\t\tnil,\n\t\tnil,\n\t\tnil,\n\t};\n\tStream *s, *streams;\n\tint nvideo, naudio, nsub, sp;\n\tchar *v[8];\n\n\tif((pid = mcfs(argv, &p)) < 0)\n\t\treturn nil;\n\tif((streams = calloc(Maxstreams, sizeof(Stream))) == nil)\n\t\treturn nil;\n\n\tBinit(&b, p, OREAD);\n\tfor(ns = naudio = nvideo = nsub = 0; ns < Maxstreams && (line = Brdstr(&b, '\\n', 1)) != nil;){\n\t\tn = tokenize(line, v, nelem(v));\n\t\tif(trackpref != 0 && (trackpref & (1<<atoi(v[0]))) == 0)\n\t\t\tcontinue;\n\t\tif(n >= 3 && str2fmt(v[2]) >= 0){\n\t\t\targv[1] = \"-t\";\n\t\t\targv[2] = v[0]; /* stream id */\n\t\t\targv[3] = filename;\n\t\t\ts = streams+ns;\n\n\t\t\tif(n >= 5 && nvideo < 1 && strcmp(v[1], \"video\") == 0){\n\t\t\t\ts->video.w = atoi(v[3]);\n\t\t\t\ts->video.h = atoi(v[4]);\n\t\t\t\tif(mcfs(argv, &sp) > 0){\n\t\t\t\t\tif((a = malloc(sizeof(*a))) == nil)\n\t\t\t\t\t\tsysfatal(\"memory\");\n\t\t\t\t\ta->fd = sp;\n\t\t\t\t\ts->aux = a;\n\t\t\t\t\ts->freeaux = freeaux;\n\t\t\t\t\tif(Binits(&a->bio, sp, OREAD, a->buf, Bufsz) == 0 && ivfopenb(&a->bio, s, failed) == 0){\n\t\t\t\t\t\tnvideo++;\n\t\t\t\t\t\tns++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else if(n >= 5 && naudio < 1 && strcmp(v[1], \"audio\") == 0 && (s->fmt = str2fmt(v[2])) >= 0){\n\t\t\t\ts->audio.nchan = atoi(v[3]);\n\t\t\t\ts->audio.srate = atoi(v[4]);\n\t\t\t\tsnprint(s->info, sizeof(s->info), \"%s (%d %d)\", v[2], s->audio.nchan, s->audio.srate);\n\t\t\t\tif(mcfs(argv, &sp) > 0 && audopenfd(sp, s, failed) == 0){\n\t\t\t\t\tnaudio++;\n\t\t\t\t\tns++;\n\t\t\t\t}\n\t\t\t}else if(n >= 3 && nsub < 1 && strcmp(v[1], \"subtitle\") == 0 && (s->fmt = str2fmt(v[2])) >= 0){\n\t\t\t\tsnprint(s->info, sizeof(s->info), \"%s (%s)\", v[2], (n > 3 && *v[3]) ? v[3] : \"default\");\n\t\t\t\tif(mcfs(argv, &sp) > 0 && subopenfd(sp, s, failed) == 0){\n\t\t\t\t\tnsub++;\n\t\t\t\t\tns++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfree(line);\n\t}\n\tBterm(&b);\n\n\t*num = ns;\n\tif(ns < 1){\n\t\twerrstr(\"no supported video streams\");\n\t\t*failed = 1;\n\n\t\tfree(streams);\n\t\tstreams = nil;\n\n\t\twhile((w = wait()) != nil){\n\t\t\tif(w->pid == pid){\n\t\t\t\tif(w->msg[0] != 0){\n\t\t\t\t\twerrstr(\"%s\", w->msg);\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t\tfree(w);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfree(w);\n\t\t}\n\t}\n\n\treturn streams;\nerr:\n\tfree(w);\n\tfree(streams);\n\treturn nil;\n}\n\nStreamops mcops = {\n\t.open = mcopen,\n};\n", "source": "treason/stream_mc.c", "file_type": "c"}
{"text": "#include <u.h>\n#include <libc.h>\n#include <draw.h>\n#include <memdraw.h>\n#include <mouse.h>\n#include <keyboard.h>\n#include <thread.h>\n#include \"frame.h\"\n#include \"misc.h\"\n#include \"stream.h\"\n#include \"decoder.h\"\n\nint mainstacksize = 128*1024;\n\nuvlong trackpref;\n\nstatic Streamframe subfr[8];\nstatic int nsubfr;\nstatic Image *curim;\nstatic Rectangle videor;\nstatic u8int *curpx;\nstatic uvlong firstframe, lastframe;\nstatic int audiofd = -1;\nstatic Channel *audiosync;\nstatic Channel *audiofinished;\nstatic char info[256];\nstatic int showinfo;\nstatic int paused;\nstatic uvlong dispdelay;\nstatic int framedrop;\nstatic uvlong late;\nstatic uvlong vidts;\nstatic int bw;\nstatic int benchmark;\n\nstatic void\naudioproc(void *x)\n{\n\tStreamframe f;\n\tStream *s;\n\tint audiofd, synced;\n\tuvlong sent, ts, ats, skip;\n\n\tsynced = 0;\n\tsent = 0;\n\tskip = 0;\n\tts = 0;\n\tif((audiofd = open(\"/dev/audio\", OWRITE|OCEXEC)) < 0){\n\t\tfprint(2, \"runaudio: %r\\n\");\n\t}else{\n\t\tfor(s = x; Sread(s, &f) == 0 && f.sz > 0;){\n\t\t\tif(!synced || paused){\n\t\t\t\trecv(audiosync, &ts);\n\t\t\t\tchanclose(audiosync);\n\t\t\t\tats = (sent*2500000ULL)/441ULL;\n\t\t\t\tif(ats > ts)\n\t\t\t\t\tnsleep(ats - ts);\n\t\t\t\telse\n\t\t\t\t\tskip = ((ts - ats)*441ULL)/2500000ULL;\n\t\t\t\tsynced = 1;\n\t\t\t}\n\t\t\tif(skip){\n\t\t\t\tif(skip > f.sz)\n\t\t\t\t\tskip -= f.sz;\n\t\t\t\telse\n\t\t\t\t\tskip = 0;\n\t\t\t}else\n\t\t\t\twrite(audiofd, f.buf, f.sz);\n\t\t\tsent += f.sz;\n\t\t}\n\t\tclose(audiofd);\n\t}\n\tif(!synced){\n\t\trecv(audiosync, &ts);\n\t\tchanclose(audiosync);\n\t}\n\n\tsendp(audiofinished, nil);\n\n\tthreadexits(nil);\n}\n\nstatic void\ndrawsub(Stream *s)\n{\n\tStreamframe *f;\n\tint i, l, h;\n\tuvlong ts;\n\tPoint p;\n\n\tif(s == nil)\n\t\treturn;\n\n\t/* read until we have something to show, but don't go too far */\n\tts = lastframe - firstframe;\n\tfor(; nsubfr < nelem(subfr) && (nsubfr == 0 || subfr[nsubfr-1].timestamp <= ts); nsubfr++){\n\t\tf = &subfr[nsubfr];\n\t\tif(Sread(s, f) != 0){\n\t\t\tfprint(2, \"%r\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tif(f->nlines == 0)\n\t\t\treturn;\n\t}\n\n\t/* remove stale text, calculate height of the lines currently displayed */\n\th = 0;\n\tfor(i = 0; i < nsubfr; i++){\n\t\tf = &subfr[i];\n\n\t\tif(f->timestamp + f->dt < ts){\n\t\t\tfor(l = 0; l < nelem(f->lines) && f->lines[l] != nil; l++)\n\t\t\t\tfree(f->lines[l]);\n\t\t\tts = lastframe - firstframe;\n\t\t\tmemmove(subfr+i, subfr+i+1, sizeof(Streamframe)*(nsubfr-i));\n\t\t\tnsubfr--;\n\t\t\ti--;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif(f->timestamp <= ts && f->timestamp+f->dt >= ts)\n\t\t\th += font->height*(f->nlines + 1); /* one extra for spacing */\n\t}\n\n\t/* draw */\n\tp.y = videor.max.y - h;\n\tfor(i = 0; i < nsubfr; i++){\n\t\tf = &subfr[i];\n\t\tif(f->timestamp <= ts && f->timestamp+f->dt >= ts){\n\t\t\tfor(l = 0; l < nelem(f->lines) && f->lines[l] != nil; l++){\n\t\t\t\tp.x = screen->r.min.x + Dx(screen->r)/2 - stringwidth(font, f->lines[l])/2;\n\t\t\t\tstringbg(screen, p, display->white, ZP, font, f->lines[l], display->black, ZP);\n\t\t\t\tp.y += font->height;\n\t\t\t}\n\t\t\tp.y += font->height; /* spacing */\n\t\t}\n\t}\n}\n\nstatic void\ndrawframe(Frame *f)\n{\n\tuvlong x, end, left;\n\tRectangle r, clip;\n\tint y;\n\n\tx = nanosec();\n\tif(lastframe == 0){\n\t\tvidts = 0;\n\t\tfirstframe = x;\n\t\tlastframe = x;\n\t}\n\n\tend = lastframe + f->dt;\n\tvidts += f->dt;\n\tif(x+dispdelay >= end){\n\t\tlate = x+dispdelay - end;\n\t\tif(late > 0 && framedrop)\n\t\t\tgoto drop;\n\t}else{\n\t\tlate = 0;\n\t}\n\n\tif(curim != nil && (Dx(curim->r) != f->w || Dy(curim->r) != f->h)){\n\t\tfreeimage(curim);\n\t\tcurim = nil;\n\t\tfree(curpx);\n\t\tcurpx = nil;\n\t}\n\tr = Rect(0,0,f->w,f->h);\n\tif(bw){\n\t\tif(curim == nil)\n\t\t\tcurim = allocimage(display, r, GREY8, 0, DNofill);\n\t\tif(curpx == nil)\n\t\t\tcurpx = malloc(f->w*f->h);\n\t\tfor(y = 0; y < f->h; y++)\n\t\t\tmemmove(curpx+f->w*y, f->yuv[0]+f->ystride*y, f->w);\n\t\tloadimage(curim, r, curpx, f->w*f->h);\n\t}else{\n\t\tif(curim == nil)\n\t\t\tcurim = allocimage(display, r, XRGB32, 0, DNofill);\n\t\tif(curpx == nil)\n\t\t\tcurpx = malloc(f->w*f->h*4);\n\t\tyuv420_xrgb32(f->w, f->h, f->yuv[0], f->yuv[1], f->yuv[2], f->ystride, f->uvstride, curpx, f->w*4);\n\t\tloadimage(curim, r, curpx, f->w*f->h*4);\n\t}\n\n\tdispdelay = nanosec() - x;\n\n\tif(!benchmark)\n\twhile(1){\n\t\tx = nanosec();\n\t\tif(x >= end - 1*1000ULL*1000ULL)\n\t\t\tbreak;\n\t\tleft = end - x;\n\t\tif(left > 80ULL*1000ULL*1000ULL)\n\t\t\tsleep(70);\n\t\telse if(left > 30ULL*1000ULL*1000ULL)\n\t\t\tsleep(20);\n\t}\n\n\tclip = Rect(f->crop.left, f->crop.top, f->crop.right, f->crop.bottom);\n\tif(badrect(clip))\n\t\tclip = curim->r;\n\treplclipr(curim, 0, clip);\n\n\tif(Dx(clip) < Dx(screen->r) && Dy(clip) < Dy(screen->r))\n\t\tr = rectsubpt(screen->r, divpt(Pt(Dx(clip)-Dx(screen->r), Dy(clip)-Dy(screen->r)), 2));\n\telse\n\t\tr = screen->r;\n\tdraw(screen, r, curim, nil, ZP);\n\tvideor.min = r.min;\n\tvideor.max.x = r.min.x + Dx(clip);\n\tvideor.max.y = r.min.y + Dy(clip);\n\tif(showinfo)\n\t\tstringbg(screen, screen->r.min, display->white, ZP, font, info, display->black, ZP);\n\n\tdispdelay += nanosec() - x;\ndrop:\n\tif(audiosync != nil)\n\t\tsend(audiosync, &vidts);\n\tlastframe += f->dt;\n\n\tfree(f);\n}\n\nstatic void\nusage(void)\n{\n\tfprint(2, \"usage: %s [-a audiofile] [-S subtitlesfile] [-t n -t m ...] file.mp4\\n\", argv0);\n\tthreadexitsall(\"usage\");\n}\n\nvoid\nthreadmain(int argc, char **argv)\n{\n\tenum {\n\t\tCframe,\n\t\tCplayerdone,\n\t\tCmouse,\n\t\tCkeyboard,\n\t\tCresize,\n\t\tCnum,\n\t};\n\tFrame *frame;\n\tMousectl *mctl;\n\tKeyboardctl *kctl;\n\tRune key;\n\tMouse m;\n\tchar *s, *audio, *sub, *status;\n\tStream *stream, *svideo, *saudio, *ssub;\n\tDecoder *d;\n\tint i, j, end, done, forced, res, nstreams;\n\tAlt a[Cnum+1] =\n\t{\n\t\t[Cframe] = { nil, &frame, CHANRCV },\n\t\t[Cplayerdone] = { nil, &status, CHANRCV },\n\t\t[Cmouse] = { nil, &m, CHANRCV },\n\t\t[Ckeyboard] = { nil, &key, CHANRCV },\n\t\t[Cresize] =  { nil, nil, CHANRCV },\n\t\t[Cnum] = { nil, nil, CHANEND },\n\t};\n\n\tquotefmtinstall();\n\tfmtinstall('H', encodefmt);\n\n\tdebug = 0;\n\taudio = nil;\n\tsub = nil;\n\ttrackpref = 0;\n\tARGBEGIN{\n\tcase 'a':\n\t\tif(audio != nil){\n\t\t\tfprint(2, \"only one audio file can be specified\\n\");\n\t\t\tusage();\n\t\t}\n\t\taudio = EARGF(usage());\n\t\tbreak;\n\tcase 'B':\n\t\tbenchmark++;\n\t\tbreak;\n\tcase 'b':\n\t\tbw++;\n\t\tbreak;\n\tcase 'D':\n\t\tframedrop++;\n\t\tbreak;\n\tcase 'd':\n\t\tdebug++;\n\t\tbreak;\n\tcase 'S':\n\t\tif(sub != nil){\n\t\t\tfprint(2, \"only one subtitle file can be specified\\n\");\n\t\t\tusage();\n\t\t}\n\t\tsub = EARGF(usage());\n\t\tbreak;\n\tcase 't':\n\t\ttrackpref |= 1<<atoi(EARGF(usage()));\n\t\tbreak;\n\tdefault:\n\t\tusage();\n\t}ARGEND\n\n\tif(argc < 1)\n\t\tusage();\n\n\tnproc = atoi((s = getenv(\"NPROC\")) != nil ? s : \"1\");\n\tif(nproc < 1)\n\t\tnproc = 1;\n\telse if(nproc > 4)\n\t\tnproc = 4;\n\n\tsrand(nanosec());\n\tif(initdraw(nil, nil, \"treason\") < 0)\n\t\tsysfatal(\"initdraw: %r\");\n\tif((mctl = initmouse(nil, screen)) == nil)\n\t\tsysfatal(\"initmouse: %r\");\n\tif((kctl = initkeyboard(nil)) == nil)\n\t\tsysfatal(\"initkeyboard: %r\");\n\n\ta[Cmouse].c = mctl->c;\n\ta[Cresize].c = mctl->resizec;\n\ta[Ckeyboard].c = kctl->c;\n\n\tsaudio = audio ? Sopen(audio, &nstreams) : nil;\n\tssub = sub ? subopen(sub, &nstreams, &i) : nil;\n\n\tfor(end = i = 0; !end && i < argc; i++){\n\t\tdraw(screen, screen->r, display->black, nil, ZP);\n\n\t\tif((stream = Sopen(argv[i], &nstreams)) == nil)\n\t\t\tsysfatal(\"%r\");\n\n\t\tsvideo = nil;\n\t\tfor(j = 0; j < nstreams; j++){\n\t\t\tif(stream[j].type == Svideo && svideo == nil)\n\t\t\t\tsvideo = stream+j;\n\t\t\telse if(stream[j].type == Saudio && saudio == nil && !benchmark)\n\t\t\t\tsaudio = stream+j;\n\t\t\telse if(stream[j].type == Ssubtitles && ssub == nil)\n\t\t\t\tssub = stream+j;\n\t\t\telse\n\t\t\t\tSclose(stream+j);\n\t\t}\n\t\tif(svideo == nil)\n\t\t\tsysfatal(\"%s: no video\", argv[i]);\n\n\t\tif((d = Dopen(svideo)) == nil)\n\t\t\tsysfatal(\"%r\");\n\n\t\ta[Cframe].c = d->frames;\n\t\ta[Cplayerdone].c = d->finished;\n\t\tlastframe = 0;\n\t\tnsubfr = 0;\n\n\t\tif(saudio != nil){\n\t\t\taudiosync = chancreate(sizeof(uvlong), 1);\n\t\t\taudiofinished = chancreate(sizeof(void*), 0);\n\t\t\tproccreate(audioproc, saudio, 4096);\n\t\t}else{\n\t\t\taudiosync = nil;\n\t\t\taudiofinished = nil;\n\t\t}\n\n\t\tfor(done = forced = 0; !done && !end;){\n\t\t\tres = alt(a);\n\t\t\tswitch(res){\n\t\t\tcase Cframe:\n\t\t\t\tif(showinfo){\n\t\t\t\t\tsnprint(\n\t\t\t\t\t\tinfo, sizeof(info),\n\t\t\t\t\t\t\"decode=%-5lld yuv\u2192rgb=%-3lld display=%-3lld total=%-3lld late=%-3lld %dx%d %s %s %s %s\",\n\t\t\t\t\t\td->decodetime/1000000ULL,\n\t\t\t\t\t\tyuv\u2192rgb/1000000ULL,\n\t\t\t\t\t\tdispdelay/1000000ULL,\n\t\t\t\t\t\t(d->decodetime + yuv\u2192rgb + dispdelay)/1000000ULL,\n\t\t\t\t\t\tlate/1000000ULL,\n\t\t\t\t\t\tframe->w, frame->h,\n\t\t\t\t\t\td->info,\n\t\t\t\t\t\td->s->info,\n\t\t\t\t\t\tsaudio ? saudio->info : \"no audio\",\n\t\t\t\t\t\tssub ? ssub->info : \"no subtitles\"\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tdrawframe(frame);\n\t\t\t\tdrawsub(ssub);\n\t\t\t\tflushimage(display, 1);\n\t\t\t\tbreak;\n\n\t\t\tcase Cplayerdone:\n\t\t\t\tdone = 1;\n\t\t\t\tif(status != nil)\n\t\t\t\t\tforced = 1;\n\t\t\t\tbreak;\n\n\t\t\tcase Cmouse:\n\t\t\t\tbreak;\n\n\t\t\tcase Ckeyboard:\n\t\t\t\tend = key == 'q' || key == Kdel;\n\t\t\t\tdone = key == '\\n';\n\t\t\t\tshowinfo ^= key == 'i';\n\t\t\t\tif(key == 'p'){\n\t\t\t\t\tif(!paused){\n\t\t\t\t\t\taudiosync = chancreate(sizeof(uvlong), 1);\n\t\t\t\t\t\ta[Cframe].op = CHANNOP;\n\t\t\t\t\t}else{\n\t\t\t\t\t\ta[Cframe].op = CHANRCV;\n\t\t\t\t\t\tlastframe = nanosec();\n\t\t\t\t\t\tfirstframe = lastframe - vidts;\n\t\t\t\t\t}\n\t\t\t\t\tpaused ^= 1;\n\t\t\t\t}\n\t\t\t\tforced = 1;\n\t\t\t\tbreak;\n\n\t\t\tcase Cresize:\n\t\t\t\tif(getwindow(display, Refnone) < 0)\n\t\t\t\t\tsysfatal(\"getwindow: %r\");\n\t\t\t\tdraw(screen, screen->r, display->black, nil, ZP);\n\t\t\t\tflushimage(display, 1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif(forced && saudio != nil){\n\t\t\tSclose(saudio);\n\t\t\tchanclose(audiosync);\n\t\t}\n\t\tif(audiofinished != nil){\n\t\t\trecvp(audiofinished);\n\t\t\tchanclose(audiofinished);\n\t\t\taudiofinished = nil;\n\t\t}\n\t\tif(!forced)\n\t\t\tSclose(saudio);\n\t\tsaudio = nil;\n\n\t\tif(ssub != nil){\n\t\t\tSclose(ssub);\n\t\t\tif(sub != nil)\n\t\t\t\tfree(ssub);\n\t\t}\n\n\t\tDclose(d);\n\t\tfor(i = 0; i < nstreams; i++)\n\t\t\tSclose(stream+i);\n\t\tfree(stream);\n\t}\n\n\tthreadexitsall(nil);\n}\n", "source": "treason/main.c", "file_type": "c"}
{"text": "#include <u.h>\n#include \"misc.h\"\n\nuvlong yuv\u2192rgb;\n\nvoid yuv420_xrgb32(\n\tint width, int height,\n\tu8int *y, u8int *u, u8int *v,\n\tu32int ystride, u32int uvstride,\n\tu8int *rgb, u32int rgbstride)\n{\n\tu32int w, h;\n\tint r, g, b;\n\tint yy, cb, cr, go;\n\tuvlong start;\n\n\tstart = nanosec();\n\tfor(h = 0; h < height-1; h += 2){\n\t\tfor(w = 0; w < width-1; w += 2){\n\t\t\tcb = *u - 0x80;\n\t\t\tcr = *v - 0x80;\n\t\t\tgo = 22554*cb + 46802*cr;\n\n\t\t\tcb *= 116130;\n\t\t\tcr *= 91881;\n\n#define ONE do{ \\\n\t\t\tyy = *y * 0x10101; \\\n\t\t\tb = yy + cb; \\\n\t\t\trgb[0] = (b >> 24) ? ~(b >> 31) : (b>>16); \\\n\t\t\tg = yy - go; \\\n\t\t\trgb[1] = (g >> 24) ? ~(g >> 31) : (g>>16); \\\n\t\t\tr = yy + cr; \\\n\t\t\trgb[2] = (r >> 24) ? ~(r >> 31) : (r>>16); \\\n}while(0)\n\t\t\tONE; y += 1;       rgb += 4;\n\t\t\tONE; y += ystride; rgb += rgbstride;\n\t\t\tONE; y -= 1;       rgb -= 4;\n\t\t\tONE; y -= ystride; rgb -= rgbstride - 8;\n#undef ONE\n\n\t\t\ty += 2;\n\t\t\tu += 1;\n\t\t\tv += 1;\n\t\t}\n\n\t\ty += ystride*2 - w;\n\t\tu += uvstride - w/2;\n\t\tv += uvstride - w/2;\n\t\trgb += rgbstride*2 - 4*w;\n\t}\n\tyuv\u2192rgb = nanosec() - start;\n}\n", "source": "treason/yuv.c", "file_type": "c"}
{"text": "</$objtype/mkfile\n\nP=theme\n\nLIB=lib$P.$O.a\nOFILES=$P.$O\nHFILES=/sys/include/$P.h\n\n</sys/src/cmd/mklib\n\ninstall:V:\t$LIB\n\tcp $LIB /$objtype/lib/lib$P.a\n\tcp $P.h /sys/include/$P.h\n\tcp $P.man2 /sys/man/2/$P\n\nuninstall:V:\n\trm -f /$objtype/lib/lib$P.a /sys/include/$P.h /sys/man/2/$P\n\nclean:V:\n\trm -f *.[$OS] [$OS].* $LIB\n\n$O.%:\t%.$O $OFILES $LIB $TESTLIB\n\t$LD $LDFLAGS -o $target $prereq\n\ntest:VQ:\n\tmk $O.theme_test\n\techo $O.theme_test\n\t$O.theme_test\n", "source": "libtheme/mkfile", "file_type": "mkfile"}
{"text": "#include <u.h>\n#include <libc.h>\n#include <draw.h>\n#include <bio.h>\n#include <ndb.h>\n\ntypedef struct colmap colmap;\nstruct colmap {\n\tchar *name;\n\tulong value;\n};\n\nstatic colmap coltab[] = {\n\t{\"black\",\t\tDBlack},\n\t{\"white\", \t\tDWhite},\n\t{\"red\",\t\t\tDRed},\n\t{\"green\",\t\tDGreen},\n\t{\"blue\",\t\tDBlue},\n\t{\"cyan\",\t\tDCyan},\n\t{\"magenta\",\t\tDMagenta},\n\t{\"paleyellow\",\t\tDPaleyellow},\n\t{\"darkyellow\",\t\tDDarkyellow},\n\t{\"darkgreen\",\t\tDDarkgreen},\n\t{\"palegreen\",\t\tDPalegreen},\n\t{\"medgreen\",\t\tDMedgreen},\n\t{\"darkblue\",\t\tDDarkblue},\n\t{\"palebluegreen\",\tDPalebluegreen},\n\t{\"paleblue\",\t\tDPaleblue},\n\t{\"bluegreen\",\t\tDBluegreen},\n\t{\"greygreen\",\t\tDGreygreen},\n\t{\"palegreygreen\",\tDPalegreygreen},\n\t{\"yellowgreen\",\t\tDYellowgreen},\n\t{\"medblue\",\t\tDMedblue},\n\t{\"greyblue\",\t\tDGreyblue},\n\t{\"palegreyblue\",\tDPalegreyblue},\n\t{\"purpleblue\",\t\tDPurpleblue},\n};\n\nstatic ulong\nname2col(char *name)\n{\n\tint i;\n\n\tfor(i = 0; i < nelem(coltab); i++){\n\t\tif(strcmp(name, coltab[i].name) == 0)\n\t\t\treturn coltab[i].value;\n\t}\n\n\treturn DNotacolor;\n}\n\nstatic Ndb *themedb;\nstatic QLock themelock;\nstatic char *themename;\n\nvoid\nthemeinit(char *theme)\n{\n\tchar *home, *db;\n\n\tthemename = strdup(theme);\n\tif(themename == nil)\n\t\tsysfatal(\"theme: strdup: %r\");\n\n\thome = getenv(\"home\");\n\tif(home == nil)\n\t\thome = \"\";\n\n\tdb = smprint(\"%s/lib/theme\", home);\n\tassert(db != nil);\n\n\tqlock(&themelock);\n\tassert(themedb == nil);\n\n\tthemedb = ndbopen(db);\n\t/* if there's no db in $home, try /lib. */\n\tif(themedb == nil)\n\t\tthemedb = ndbopen(\"/lib/theme\");\n\n\t/* if themedb is nil, silently fail. */\n\n\tqunlock(&themelock);\n\tfree(db);\n\tfree(home);\n}\n\nvoid\nthemeend(void)\n{\n\tfree(themename);\n\tqlock(&themelock);\n\tif(themedb != nil)\n\t\tndbclose(themedb);\n\tthemedb = nil;\n\tqunlock(&themelock);\n}\n\nstatic ulong\nconvcolor(char *color)\n{\n\tulong r;\n\tchar *p;\n\n\tr = strtoul(color, &p, 0);\n\t/* successfully parsed? */\n\tif(color != p && *p == '\\0')\n\t\treturn r;\n\n\treturn name2col(color);\n}\n\nulong\nthemeget(char *color, ulong def)\n{\n\tulong r;\n\tNdbs s;\n\tchar *val;\n\n\tr = def;\n\n\tqlock(&themelock);\n\n\t/* if themedb is nil, return default. */\n\tif(themedb == nil)\n\t\tgoto done;\n\n\t/* first try with theme */\n\tval = ndbgetvalue(themedb, &s, \"theme\", themename, color, nil);\n\tif(val != nil){\n\t\tr = convcolor(val);\n\t\tif(r == DNotacolor)\n\t\t\tr = def;\n\n\t\tgoto done;\n\t}\n\n\t/* no theme */\n\tval = ndbgetvalue(themedb, &s, \"theme\", \"default\", color, nil);\n\tif(val != nil){\n\t\tr = convcolor(val);\n\t\tif(r == DNotacolor)\n\t\t\tr = def;\n\n\t\tgoto done;\n\t}\n\ndone:\n\tqunlock(&themelock);\n\n\treturn r;\n}\n", "source": "libtheme/theme.c", "file_type": "c"}
{"text": "//! Api demonstration of the regex implementation\n//! -> Running on my x270:\n//!\n//! $ ./target/release/examples/regex_demo\n//! regex: \"([0-9]+)-([0-9]+)\"\n//! input \"this should work 123-456 other stuff\"\n//! compile time (micro seconds): 15\n//!\n//! :: matching against a str\n//! match time (micro seconds): 4\n//! Submatch $1: Some(\"123\")\n//! Submatch $2: Some(\"456\")\n//! Match ($0):  \"123-456\"\n\nuse ad_editor::{buffer::GapBuffer, regex::Regex};\nuse std::time::Instant;\n\nfn main() {\n    let mut haystack = \"\ud83e\udd8a\".repeat(10000);\n    haystack.push('\\n');\n    haystack = haystack.repeat(100);\n    haystack.push_str(\"this should work 123-456 other stuff\");\n\n    let re = \"([0-9]+)-([0-9]+)\";\n    let t1 = Instant::now();\n    let r = Regex::compile(re).unwrap();\n    let d_compile = Instant::now().duration_since(t1).as_micros();\n    println!(\"compile time (micro seconds): {d_compile}\");\n\n    let mut gb = GapBuffer::from(haystack);\n    gb.make_contiguous();\n\n    println!(\"\\n:: matching against a gap buffer\");\n    let t1 = Instant::now();\n    let m = r.find(&gb).unwrap();\n    let d_match = Instant::now().duration_since(t1).as_millis();\n    println!(\"match time (ms): {d_match}\");\n\n    println!(\"Submatch $1: {:?}\", m.submatch_text(1, &gb));\n    println!(\"Submatch $2: {:?}\", m.submatch_text(2, &gb));\n    println!(\"Match ($0):  {:?}\", m.match_text(&gb));\n}\n", "source": "ad/examples/regex_demo.rs", "file_type": "rc"}
{"text": "//! A one-shot run of Burntsushi's full torture test for the regex engine\n//!\n//! See the full benchmark tests in '/benches' for a trimmed down version of this test that\n//! runs under criterion. (Cut down because the ad engine is not fast enough currently to\n//! handle the full test in a reasonable time.)\nuse ad_editor::regex::Regex;\nuse std::{fs, time::Instant};\n\nfn main() {\n    let s = fs::read_to_string(\"data/burnt-sushi-torture-test/torture-test.haystack\").unwrap();\n    let re = fs::read_to_string(\"data/burnt-sushi-torture-test/torture-test.pattern\").unwrap();\n\n    println!(\"Haystack length: {}\", s.len());\n    println!(\"Pattern length: {}\", re.len());\n\n    let t1 = Instant::now();\n    let r = Regex::compile(re.trim_end()).unwrap();\n    let d_compile = Instant::now().duration_since(t1).as_micros();\n    println!(\"Compile time: {d_compile} microseconds\");\n\n    let t1 = Instant::now();\n    assert!(r.matches(&s.as_str()));\n    let d_match = Instant::now().duration_since(t1).as_secs();\n    println!(\"Match time: {d_match} seconds\");\n}\n", "source": "ad/examples/torture_test.rs", "file_type": "rc"}
{"text": "// https://github.com/matklad/cargo-xtask\nuse std::{\n    env,\n    path::{Path, PathBuf},\n    process::exit,\n};\n\nmod setup;\nmod ts;\n\ntype DynResult = Result<(), Box<dyn std::error::Error>>;\n\n#[macro_export]\nmacro_rules! err {\n    ($msg:expr) => {\n        Err($msg.to_string().into())\n    };\n\n    ($template:expr, $($arg:expr),+) => {\n        Err(format!($template, $($arg),+).into())\n    };\n}\n\nfn main() {\n    if let Err(e) = try_main() {\n        eprintln!(\"{e}\");\n        exit(1);\n    }\n}\n\nfn try_main() -> DynResult {\n    let task = env::args().nth(1);\n\n    match task.as_deref() {\n        Some(\"lint-ts-queries\") => ts::lint_ts_queries()?,\n        Some(\"gen-man-page\") => setup::generate_manpage()?,\n        Some(\"setup-dotfiles\") => setup::setup_dotfiles()?,\n\n        _ => list_tasks(),\n    }\n\n    Ok(())\n}\n\nfn list_tasks() {\n    eprintln!(\n        \"Available tasks:\n  * setup-dotfiles          copy over the default dotfiles from the /data directory\n  * lint-ts-queries         ensure that the tree-sitter queries in /data are valid\n  * gen-man-page            re-generate the man page\"\n    );\n}\n\nfn project_root() -> PathBuf {\n    Path::new(&env!(\"CARGO_MANIFEST_DIR\"))\n        .ancestors()\n        .nth(1)\n        .unwrap()\n        .to_path_buf()\n}\n\nfn dist_dir() -> PathBuf {\n    project_root().join(\"target/dist\")\n}\n", "source": "ad/xtask/src/main.rs", "file_type": "rc"}
{"text": "//! Data driven tests that run the editor in headless mode to provide full testing\n//! of the main editor behaviour (other than the UI).\n//!\n//! See TestCase::from_archive for details of the supported file sections.\nuse ad_editor::{\n    Config, Editor, EditorMode, LogBuffer, PlumbingRules,\n    buffer::BufferId,\n    editor::{Action, Click, MiniBufferState},\n    input::Event,\n    key::Input,\n    system::DefaultSystem,\n    term::CurShape,\n    ui::{Layout, StateChange, UserInterface},\n};\nuse assert_fs::TempDir;\nuse ninep::sync::client::UnixClient;\nuse simple_test_case::dir_cases;\nuse simple_txtar::{Archive, File};\nuse std::{\n    env, fs, io,\n    path::{Path, PathBuf},\n    str::FromStr,\n    sync::{Arc, Mutex, mpsc::Sender},\n    thread::{sleep, spawn},\n    time::Duration,\n};\n\n/// The number of milliseconds to sleep before sending a noop when a render is triggered while we\n/// have an outstanding fsys operation pending.\n/// Also used as our poll interval while we wait for fsys to come up before starting a test run\n/// that requires it to be running.\nconst FSYS_SLEEP_MS: u64 = 100;\n/// The maximum number of times we will check to see if the fsys socket has been created before\n/// bailing on a test case that requires it.\nconst FSYS_MAX_TRIES: usize = 10;\n\n#[dir_cases(\n    \"tests/data/editor-scenarios/edit_mode\",\n    \"tests/data/editor-scenarios/exec\",\n    \"tests/data/editor-scenarios/fsys\",\n    \"tests/data/editor-scenarios/general\",\n    \"tests/data/editor-scenarios/issues\",\n    \"tests/data/editor-scenarios/plumbing\"\n)]\n#[test]\nfn editor_scenarios(path: &str, content: &str) {\n    // Parse the given test case file and validate it before initialising the editor\n    let TestCase {\n        mut setup,\n        assertions,\n        status_messages,\n    } = TestCase::from_archive(path, content);\n\n    if assertions.is_empty() {\n        panic!(\"no assertions provided\");\n    }\n\n    // Create a new temp directory to hold our test files while the test runs\n    let tmp = TempDir::new().unwrap();\n    let test_file_dir = tmp.join(\"files\");\n    let socket_path = tmp.join(\"sock\");\n    setup.ui.socket_path = socket_path.clone();\n\n    fs::create_dir_all(&test_file_dir).expect(\"unable to create temp directory\");\n    println!(\"using temp directory: {}\", tmp.path().display());\n    println!(\"using {} for the fsys socket\", socket_path.display());\n    println!(\"using {} for test files\", test_file_dir.display());\n\n    // Write out all of our test files into the new temp directory and store the paths\n    // so they can be passed to the editor.\n    let file_paths: Vec<PathBuf> = setup\n        .files\n        .into_iter()\n        .map(|f| {\n            let p = test_file_dir.join(&f.name);\n            if let Some(parent) = p.parent() {\n                _ = fs::create_dir_all(parent);\n            }\n            if let Err(e) = fs::write(&p, f.content) {\n                panic!(\"failed to write test file {}: {e}\", f.name);\n            }\n\n            p\n        })\n        .collect();\n\n    let mut e = Editor::new_with_system_and_initial_files(\n        setup.config_res,\n        setup.plumbing_rules_res,\n        EditorMode::Boxed(Box::new(setup.ui)),\n        LogBuffer::default(),\n        DefaultSystem::without_clipboard_provider(),\n        &file_paths,\n    );\n\n    e.run_with_explicit_fsys_path(socket_path);\n\n    let status_hist = status_messages.lock().unwrap().join(\"\\n\");\n    println!(\">> STATUS HISTORY:\\n{status_hist}\");\n\n    assertions.verify(&e, &test_file_dir);\n}\n\n/// A parsed test case from a scenario file\n#[derive(Debug)]\nstruct TestCase {\n    setup: Setup,\n    assertions: Assertions,\n    status_messages: Arc<Mutex<Vec<String>>>,\n}\n\nimpl TestCase {\n    /// A bare bones parser for the txtar test file format used by the editor_scenarios test above.\n    ///\n    /// If the file being parsed is malformed in any way this method will panic in order to fail\n    /// the test. The parsing of each section of the archive is documented in inline comments\n    /// within parser itself.\n    fn from_archive(path: &str, content: &str) -> Self {\n        let arr = Archive::from(content);\n        let home = env::var(\"HOME\").expect(\"HOME env var required for parsing config\");\n        let uname = env::var(\"USER\").expect(\"USER env var required for connecting to fsys\");\n\n        // If there is a top level comment to the archive we print it for additional debugging\n        // context if the test case fails or the rest of the file fails to parse.\n        let comment = arr.comment();\n        if !comment.is_empty() {\n            println!(\"{}\", comment.trim());\n        }\n\n        // -- config --\n        // Default config can overwritten by providing a config file inline or as a file path by\n        // providing a single line of the form \"path: path/to/config.toml\".\n        let config_res = match arr.get(\"config\") {\n            Some(f) => {\n                let s = f.content.trim();\n                match s.strip_prefix(\"path: \") {\n                    Some(p) => Config::try_load_from_path(p, &home),\n                    None => Config::try_load_from_str(s, path, &home),\n                }\n            }\n            None => Ok(Config::default()),\n        };\n\n        // -- plumbing-rules --\n        // Same idea for plumbing rules\n        let plumbing_rules_res = match arr.get(\"plumbing-rules\") {\n            Some(f) => {\n                let s = f.content.trim();\n                match s.strip_prefix(\"path: \") {\n                    Some(p) => PlumbingRules::try_load_from_path(p),\n                    None => PlumbingRules::from_str(s),\n                }\n            }\n            None => Ok(PlumbingRules::default()),\n        };\n\n        // -- actions --\n        // Actions are not required as the setup of the test alone may be all we need but\n        // we provide a default sleep no-op action to handle the first render call that\n        // comes through when the editor starts up.\n        let actions = match arr.get(\"actions\") {\n            Some(f) => parse_actions(f.content.trim()),\n            None => vec![TestAction::SleepMs(100)],\n        };\n\n        // -- buffer-list --\n        // The buffer list is just a raw string that we compare to the final listing that\n        // the user can open in the minibuffer using 2\"<space> b\". We trim the working\n        // directory from the start of each path in the real listing so the content in a\n        // test case should just be the paths as provided in -- file-X -- sections.\n        // (See the file-X section below for more details)\n        let buffer_list = arr.get(\"buffer-list\").map(|f| f.content.trim().to_string());\n\n        // -- expected-windows --\n        // Expected windows are specified as the ordered buffer IDs per column, one\n        // column per line. So,\n        // ```\n        // 1 2\n        // 3 4 5\n        // ```\n        // Would expect there to be two column in the UI layout, the first containing\n        // buffers 1 and 2 (top to bottom) and the second containing buffers 3, 4 and\n        // 5 (again, top to bottom).\n        let windows = match arr.get(\"expected-windows\") {\n            Some(f) => {\n                let mut windows = Vec::with_capacity(f.content.lines().count());\n                for line in f.content.lines() {\n                    if line.starts_with('#') || line.is_empty() {\n                        continue;\n                    }\n                    let col: Vec<BufferId> = line\n                        .split_whitespace()\n                        .map(|s| s.parse().unwrap())\n                        .collect();\n                    windows.push(col);\n                }\n                windows\n            }\n            None => Vec::new(),\n        };\n\n        // The remaining file sections are defined using prefixes rather than each\n        // having a pre-defined name. They may be repeated as often as desired but\n        // collisions in names are invalid and will result in a panic.\n        let mut files: Vec<File> = Vec::new();\n        let mut buffer_dots: Vec<(BufferId, String)> = Vec::new();\n        let mut buffer_contents: Vec<(BufferId, String)> = Vec::new();\n\n        let strip_trailing_newline = |f: &mut File| {\n            if f.content.ends_with('\\n') {\n                f.content.pop();\n            }\n        };\n        let parse_bufid = |str_id: &str| {\n            str_id\n                .parse::<BufferId>()\n                .unwrap_or_else(|_| panic!(\"invalid buffer ID: {str_id:?}\"))\n        };\n\n        for mut file in arr.into_iter() {\n            if let Some(fname) = file.name.strip_prefix(\"file-\") {\n                // -- file-$filepath --\n                // File sections define a file that should be present and loaded in the editor\n                // as part of startup (as if the file path had been provided as an argument on\n                // the command line).\n                // Trailing newlines are stripped so that it is possible to have a completely\n                // empty input file by providing a file section without any content.\n                file.name = fname.to_string();\n                if files.iter().any(|f| f.name == file.name) {\n                    panic!(\">>> ERROR duplicate test file name: {:?}\", file.name);\n                }\n                strip_trailing_newline(&mut file);\n                files.push(file);\n            } else if let Some(str_id) = file.name.strip_prefix(\"expected-buffer-dot-\") {\n                // --expected-buffer-dot-$bufid --\n                // Specify the expected content of the dot for a given buffer after all test\n                // actions have been run.\n                let id = parse_bufid(str_id);\n                if buffer_dots.iter().any(|(known_id, _)| *known_id == id) {\n                    panic!(\">>> ERROR duplicate expected-buffer-dot section for ID={id}\");\n                }\n                strip_trailing_newline(&mut file);\n                buffer_dots.push((id, file.content));\n            } else if let Some(str_id) = file.name.strip_prefix(\"expected-buffer-\") {\n                // --expected-buffer-$bufid --\n                // Specify the expected content of a given buffer after all test actions have\n                // been run.\n                let id = parse_bufid(str_id);\n                if buffer_contents.iter().any(|(known_id, _)| *known_id == id) {\n                    panic!(\">>> ERROR duplicate expected-buffer section for ID={id}\");\n                }\n                strip_trailing_newline(&mut file);\n                buffer_contents.push((id, file.content));\n            }\n        }\n\n        let (ui, status_messages) = ScriptedUi::new(uname, actions);\n        let setup = Setup {\n            config_res,\n            plumbing_rules_res,\n            files,\n            ui,\n        };\n        let assertions = Assertions {\n            buffer_list,\n            windows,\n            buffer_contents,\n            buffer_dots,\n        };\n\n        Self {\n            setup,\n            assertions,\n            status_messages,\n        }\n    }\n}\n\n#[derive(Debug)]\nstruct Setup {\n    config_res: Result<Config, String>,\n    plumbing_rules_res: Result<PlumbingRules, String>,\n    files: Vec<File>,\n    ui: ScriptedUi,\n}\n\n#[derive(Debug)]\nstruct Assertions {\n    buffer_list: Option<String>,\n    windows: Vec<Vec<BufferId>>,\n    buffer_contents: Vec<(BufferId, String)>,\n    buffer_dots: Vec<(BufferId, String)>,\n}\n\nimpl Assertions {\n    fn is_empty(&self) -> bool {\n        self.buffer_list.is_none()\n            && self.windows.is_empty()\n            && self.buffer_contents.is_empty()\n            && self.buffer_dots.is_empty()\n    }\n\n    fn verify(&self, e: &Editor<DefaultSystem>, test_dir: &Path) {\n        if let Some(s) = self.buffer_list.as_ref() {\n            println!(\">> {:?}\\n\\n\", e.buffer_list());\n            let blist = e\n                .buffer_list()\n                .join(\"\\n\")\n                .replace(&format!(\"{}/\", test_dir.display()), \"\")\n                .replace(\"/private\", \"\"); // OSX-ism\n\n            assert_eq!(s, &blist, \"incorrect buffer listing\");\n        }\n\n        if !self.windows.is_empty() {\n            assert_eq!(self.windows, e.layout_ids(), \"incorrect window state\")\n        }\n\n        for (id, expected) in self.buffer_contents.iter() {\n            assert_eq!(\n                Some(expected),\n                e.buffer_content(*id).as_ref(),\n                \"incorrect buffer content for id={id}\"\n            );\n        }\n\n        for (id, expected) in self.buffer_dots.iter() {\n            assert_eq!(\n                Some(expected),\n                e.buffer_dot(*id).as_ref(),\n                \"incorrect buffer dot content for id={id}\"\n            );\n        }\n    }\n}\n\n#[derive(Debug)]\nstruct ScriptedUi {\n    uname: String,\n    socket_path: PathBuf,\n    actions: Vec<TestAction>,\n    pending_fsys: Arc<Mutex<bool>>,\n    status_messages: Arc<Mutex<Vec<String>>>,\n    tx: Option<Sender<Event>>,\n}\n\nimpl ScriptedUi {\n    fn new(uname: String, actions: Vec<TestAction>) -> (Self, Arc<Mutex<Vec<String>>>) {\n        let status_messages = Arc::new(Mutex::new(Vec::new()));\n        let ui = ScriptedUi {\n            uname,\n            socket_path: PathBuf::new(),\n            actions,\n            pending_fsys: Arc::new(Mutex::new(false)),\n            status_messages: status_messages.clone(),\n            tx: None,\n        };\n\n        (ui, status_messages)\n    }\n\n    fn spawn_fsys(&self, f: Fsys) {\n        match UnixClient::new_unix_with_explicit_path(&self.uname, &self.socket_path, \"\") {\n            Ok(client) => {\n                // We need to mark that we are pending before spawning the background thread\n                // for running the fsys operation otherwise we race with the main editor\n                // event loop and can fail to wait for the client to connect.\n                let pending = self.pending_fsys.clone();\n                *pending.lock().unwrap() = true;\n                spawn(move || f.run(client, pending));\n            }\n            Err(e) => {\n                // Not panicking here so we can let the rest of the test run to completion\n                // and allow the cleanup logic to run.\n                println!(\">>> UNABLE TO CREATE FSYS CLIENT: {e}\");\n            }\n        }\n    }\n}\n\nimpl UserInterface for ScriptedUi {\n    fn init(&mut self, tx: Sender<Event>) -> (usize, usize) {\n        self.tx = Some(tx);\n\n        let need_fsys_socket = self\n            .actions\n            .iter()\n            .any(|a| matches!(a, TestAction::Fsys(_)));\n\n        if need_fsys_socket {\n            let mut n = 0;\n            while !fs::exists(&self.socket_path).unwrap() {\n                n += 1;\n                if n == FSYS_MAX_TRIES {\n                    panic!(\"fsys failed to come up...\");\n                }\n\n                println!(\"waiting for fsys to come up\");\n                sleep(Duration::from_millis(FSYS_SLEEP_MS));\n            }\n        }\n\n        (60, 80)\n    }\n\n    fn shutdown(&mut self) {}\n\n    fn state_change(&mut self, change: StateChange) {\n        match change {\n            StateChange::ConfigUpdated => (),\n            StateChange::StatusMessage { msg } => {\n                self.status_messages.lock().unwrap().push(msg);\n            }\n        }\n    }\n\n    fn refresh(\n        &mut self,\n        _mode_name: &str,\n        _layout: &mut Layout,\n        _n_running: usize,\n        _pending_keys: &[Input],\n        _held_click: Option<&Click>,\n        _mb: Option<MiniBufferState<'_>>,\n    ) {\n        let event = if *self.pending_fsys.lock().unwrap() {\n            // We need to allow for the fsys thread to communicate with the main editor event loop\n            // which triggers additional refreshes for when our message actually comes through to\n            // the event loop\n            sleep(Duration::from_millis(FSYS_SLEEP_MS));\n            Event::Action(Action::Noop)\n        } else {\n            match self.actions.pop() {\n                Some(TestAction::Fsys(f)) => {\n                    self.spawn_fsys(f);\n                    Event::Action(Action::Noop)\n                }\n\n                Some(TestAction::SleepMs(n)) => {\n                    sleep(Duration::from_millis(n));\n                    Event::Action(Action::Noop)\n                }\n\n                Some(TestAction::Input(input)) => Event::Input(input),\n\n                None => Event::Action(Action::Exit { force: true }),\n            }\n        };\n\n        self.tx.as_ref().unwrap().send(event).unwrap();\n    }\n\n    fn set_cursor_shape(&mut self, _cur_shape: CurShape) {}\n}\n\n#[derive(Debug)]\nenum Fsys {\n    Read(String),\n    ReadDir(String),\n    Write(String, String),\n}\n\nimpl Fsys {\n    fn run(self, mut client: UnixClient, pending: Arc<Mutex<bool>>) {\n        let inner = move || {\n            match self {\n                Fsys::Read(path) => {\n                    let s = client.read_str(&path)?;\n                    println!(\"read {path}: {s:?}\");\n                }\n\n                Fsys::ReadDir(path) => {\n                    for stat in client.read_dir(&path)?.into_iter() {\n                        println!(\"read dir ({path}): {}\", stat.fm.name);\n                    }\n                }\n\n                Fsys::Write(path, content) => {\n                    client.write_str(&path, 0, &content)?;\n                    println!(\"wrote to {path}: {content:?}\");\n                }\n            }\n\n            io::Result::Ok(())\n        };\n\n        if let Err(e) = inner() {\n            println!(\">>> FSYS ERROR: {e}\");\n        }\n\n        *pending.lock().unwrap() = false;\n    }\n}\n\n/// User input actions to send to the editor.\n/// Note that the whitespace after the colon following the action name is required for the simple\n/// parser being used here. Blank lines and lines beginning with a '#' will be treated as comments\n/// and are ignored, for valid action definitions see each of the variants of the enum.\n#[derive(Debug)]\nenum TestAction {\n    /// Send input to the editor as if it had been typed at the keyboard.\n    ///\n    /// # Examples\n    ///\n    /// type: ihello, world!\n    /// type: <esc>\n    /// type: <alt>$single_character\n    /// type: <ctrl>$single_character\n    /// type: <ctrl-alt>$single_character\n    Input(Input),\n    /// Sleep for a given number of milliseconds.\n    /// This may be required when running external programs through loading and executing.\n    ///\n    /// # Examples\n    ///\n    /// sleep_ms: 200\n    SleepMs(u64),\n    /// Read or write a control file from the 9p virtual filesystem.\n    ///\n    /// # Examples\n    ///\n    /// fsys: read buffers/1/body\n    /// fsys: write buffers/1/dot\n    /// fsys: ls buffers/1\n    Fsys(Fsys),\n}\n\n/// See [TestAction] for example valid input lines.\nfn parse_actions(raw: &str) -> Vec<TestAction> {\n    let mut actions = Vec::with_capacity(raw.lines().count());\n\n    for line in raw.lines() {\n        if line.starts_with('#') || line.is_empty() {\n            continue;\n        } else if let Some(s) = line.strip_prefix(\"sleep_ms: \") {\n            let n: u64 = match s.trim().parse() {\n                Ok(n) => n,\n                Err(e) => panic!(\"invalid sleep duration: {e}\"),\n            };\n            actions.push(TestAction::SleepMs(n));\n        } else if let Some(s) = line.strip_prefix(\"type: \") {\n            // We need to provide a special syntax for control characters etc.\n            // Rather than make things complicated and try to support marking sequences of characters\n            // as being typed while control characters are held, we required that they are given one\n            // per line. (\"normal\" typing can be given as a concatenation).\n            match s {\n                \"<esc>\" => actions.push(TestAction::Input(Input::Esc)),\n\n                s if s.starts_with(\"<alt>\") => {\n                    let tail = escape(s.strip_prefix(\"<alt>\").unwrap().trim());\n                    let mut it = tail.chars();\n                    match (it.next(), it.next()) {\n                        (Some('\\n'), None) => actions.push(TestAction::Input(Input::AltReturn)),\n                        (Some(ch), None) => actions.push(TestAction::Input(Input::Alt(ch))),\n                        (None, _) => panic!(\"invalid <alt> input: expected a character\"),\n                        (_, Some(_)) => {\n                            panic!(\"invalid <alt> input: expected a single char, got {tail:?}\");\n                        }\n                    }\n                }\n\n                s if s.starts_with(\"<ctrl>\") => {\n                    let tail = escape(s.strip_prefix(\"<ctrl>\").unwrap().trim());\n                    let mut it = tail.chars();\n                    match (it.next(), it.next()) {\n                        (Some(ch), None) => actions.push(TestAction::Input(Input::Ctrl(ch))),\n                        (None, _) => panic!(\"invalid <ctrl> input: expected a character\"),\n                        (_, Some(_)) => {\n                            panic!(\"invalid <ctrl> input: expected a single char, got {tail:?}\");\n                        }\n                    }\n                }\n\n                s if s.starts_with(\"<ctrl-alt>\") => {\n                    let tail = escape(s.strip_prefix(\"<ctrl-alt>\").unwrap().trim());\n                    let mut it = tail.chars();\n                    match (it.next(), it.next()) {\n                        (Some(ch), None) => actions.push(TestAction::Input(Input::CtrlAlt(ch))),\n                        (None, _) => panic!(\"invalid <ctrl-alt> input: expected a character\"),\n                        (_, Some(_)) => {\n                            panic!(\n                                \"invalid <ctrl-alt> input: expected a single char, got {tail:?}\"\n                            );\n                        }\n                    }\n                }\n\n                _ => {\n                    for ch in escape(s).chars() {\n                        actions.push(TestAction::Input(char_as_input(ch)));\n                    }\n                }\n            }\n        } else if let Some(s) = line.strip_prefix(\"fsys: \") {\n            let f = match s.split_once(' ') {\n                Some((\"read\", path)) => Fsys::Read(path.to_string()),\n                Some((\"ls\", path)) => Fsys::ReadDir(path.to_string()),\n                Some((\"write\", tail)) => match tail.split_once(' ') {\n                    Some((path, content)) => Fsys::Write(path.to_string(), content.to_string()),\n                    None => panic!(\"invalid fsys line: {s:?}\"),\n                },\n\n                _ => panic!(\"invalid fsys line: {s:?}\"),\n            };\n\n            actions.push(TestAction::Fsys(f));\n        } else {\n            panic!(\"malformed action line: {line:?}\");\n        }\n    }\n\n    actions.reverse(); // so we can pop from the end while running\n    actions\n}\n\nfn escape(s: &str) -> String {\n    s.replace(\"\\\\n\", \"\\n\")\n        .replace(\"\\\\t\", \"\\t\")\n        .replace(\"\\\\\\\\\", \"\\\\\")\n}\n\nfn char_as_input(ch: char) -> Input {\n    match ch {\n        '\\n' => Input::Return,\n        '\\t' => Input::Tab,\n        _ => Input::Char(ch),\n    }\n}\n", "source": "ad/tests/scenario_tests.rs", "file_type": "rc"}
{"text": "use ad_editor::{\n    CliAction, Cmd9p, Config, ConfigSource, Editor, EditorMode, LOG_LEVEL_ENV_VAR, LogBuffer,\n    ParsedArgs, PlumbingRules, Program, USAGE, VERSION, buffer::GapBuffer, exec::SystemRunner,\n    regex::CachingStream,\n};\nuse ninep::{sansio::server::socket_dir, sync::client::UnixClient};\nuse std::{\n    env, fmt, fs,\n    io::{self, Read, stdin},\n    path::PathBuf,\n    process::exit,\n};\nuse tracing::{level_filters::LevelFilter, subscriber::set_global_default};\n\nfn main() {\n    let ParsedArgs {\n        action,\n        config_source,\n    } = match ParsedArgs::try_parse() {\n        Ok(parsed) => parsed,\n        Err(msg) => {\n            println!(\"{msg}\");\n            exit(1);\n        }\n    };\n\n    let files = match action {\n        // Only the OpenEditor action results in running the main editor behaviour\n        CliAction::OpenEditor { files } => files,\n\n        // All other actions are run immediately before exiting\n        CliAction::ShowHelp => print_and_exit(USAGE),\n        CliAction::ShowVersion => print_and_exit(&format!(\"ad v{VERSION}\")),\n        CliAction::RunScript { script, files } => return run_script(&script, files),\n        CliAction::NineP { aname, cmd, path } => return run_9p(aname, cmd, path),\n        CliAction::ListSessions => return list_open_sessions(),\n        CliAction::RmSockets => return remove_open_sockets(),\n    };\n\n    let log_buffer = LogBuffer::default();\n    let builder = tracing_subscriber::fmt()\n        .compact()\n        .with_ansi(false)\n        .with_target(false)\n        .with_writer(log_buffer.clone())\n        .with_max_level(log_level_from_env());\n\n    let subscriber = builder.finish();\n    set_global_default(subscriber).expect(\"unable to set a global tracing subscriber\");\n\n    let config = match config_source {\n        ConfigSource::Default => Ok(Config::default()),\n        ConfigSource::User => Config::try_load(),\n        ConfigSource::Custom(path) => {\n            let home = env::var(\"HOME\").unwrap();\n            Config::try_load_from_path(&path.to_string_lossy(), &home)\n        }\n    };\n\n    let mut e = Editor::new_with_initial_files(\n        config,\n        PlumbingRules::try_load(),\n        EditorMode::Terminal,\n        log_buffer,\n        &files,\n    );\n\n    e.run()\n}\n\nfn fatal(msg: impl fmt::Display) -> ! {\n    eprintln!(\"{msg}\");\n    exit(1);\n}\n\nfn print_and_exit(msg: &str) -> ! {\n    println!(\"{msg}\");\n    exit(0);\n}\n\nfn log_level_from_env() -> LevelFilter {\n    match env::var(LOG_LEVEL_ENV_VAR) {\n        Ok(s) => s.parse().unwrap_or(LevelFilter::INFO),\n        Err(_) => LevelFilter::INFO,\n    }\n}\n\nfn run_script(script: &str, files: Vec<PathBuf>) {\n    let prog = match Program::try_parse(script) {\n        Ok(prog) => prog,\n        Err(e) => {\n            eprintln!(\"error parsing script: {e:?}\");\n            exit(1);\n        }\n    };\n    let mut stdout = io::stdout();\n    let mut runner = SystemRunner::new(env::current_dir().unwrap());\n\n    if files.is_empty() {\n        let mut haystack = CachingStream::new(stdin());\n        match prog.execute(&mut haystack, &mut runner, \"stdin\", &mut stdout) {\n            Ok(_) => return,\n            Err(e) => {\n                eprintln!(\"error running script: {e:?}\");\n                exit(1);\n            }\n        }\n    }\n\n    for path in files.iter() {\n        let s = match fs::read_to_string(path) {\n            Ok(s) => s,\n            Err(e) => {\n                eprintln!(\"unable to open file '{}': {e}\", path.display());\n                exit(1);\n            }\n        };\n\n        let mut gb = GapBuffer::from(s);\n        runner.set_dir(path.parent().unwrap());\n        if let Err(e) = prog.execute(&mut gb, &mut runner, path.to_str().unwrap(), &mut stdout) {\n            eprintln!(\"error running script: {e:?}\");\n            exit(1);\n        }\n    }\n}\n\nfn run_9p(aname: String, action: Cmd9p, path: String) {\n    let (ns, path) = match path.split_once('/') {\n        Some((ns, path)) => (ns, path),\n        None => (path.as_str(), \"\"),\n    };\n\n    let client = match client_for_ns(ns, aname) {\n        Ok(client) => client,\n        Err(e) => fatal(e.to_string()),\n    };\n\n    if let Err(e) = run_9p_command(action, path, client) {\n        fatal(e.to_string());\n    }\n}\n\nfn run_9p_command(action: Cmd9p, path: &str, mut client: UnixClient) -> io::Result<()> {\n    match action {\n        Cmd9p::Read => {\n            for line in client.iter_lines(path)? {\n                println!(\"{line}\");\n            }\n        }\n\n        Cmd9p::Write => {\n            let mut content = String::new();\n            io::stdin().read_to_string(&mut content)?;\n            client.write_str(path, 0, &content)?;\n        }\n\n        Cmd9p::List => {\n            for stat in client.read_dir(path)?.into_iter() {\n                println!(\"{}\", stat.fm.name);\n            }\n        }\n    }\n\n    Ok(())\n}\n\n/// Depending on the requested namespace and the presence or absence of an \"AD_PID\" env var we may\n/// need to adjust the ns to include an ad PID\nfn client_for_ns(ns: &str, aname: String) -> io::Result<UnixClient> {\n    if ns != \"ad\" {\n        return UnixClient::new_unix(ns, aname);\n    }\n\n    let mut ns = ns.to_string();\n    if let Ok(pid) = env::var(\"AD_PID\") {\n        ns.push('-');\n        ns.push_str(&pid);\n    } else {\n        // If there is only a single running ad instance then we can attach to that, otherwise we\n        // need to error out and prompt the user to select the appropriate instance they want to\n        // connect to.\n        let mut ad_sockets = open_9p_sockets()?;\n        match ad_sockets.len() {\n            1 => ns = ad_sockets.remove(0),\n            0 => fatal(\"No such file or directory\"),\n            _ => fatal(format!(\n                \"please specify which ad instance to connect to:\\n{}\",\n                ad_sockets.join(\"\\n\")\n            )),\n        }\n    };\n\n    UnixClient::new_unix(ns, aname)\n}\n\nfn open_9p_sockets() -> io::Result<Vec<String>> {\n    let mut ad_sockets = Vec::new();\n    for entry in fs::read_dir(socket_dir())? {\n        let entry = entry?;\n        let fname = entry.file_name();\n        if let Some(s) = fname.to_str()\n            && s.starts_with(\"ad-\")\n        {\n            ad_sockets.push(s.to_string());\n        }\n    }\n\n    Ok(ad_sockets)\n}\n\nfn list_open_sessions() {\n    fn inner() -> io::Result<()> {\n        let mut had_unresponsive = false;\n\n        for ns in open_9p_sockets()?.into_iter() {\n            let mut client = match UnixClient::new_unix(&ns, \"\") {\n                Ok(client) => client,\n                Err(e) => {\n                    println!(\"{ns}\\tunresponsive: {e}\");\n                    had_unresponsive = true;\n                    continue;\n                }\n            };\n            let id = client.read_str(\"buffers/current\")?;\n            let fname = client.read_str(format!(\"buffers/{id}/filename\"))?;\n            println!(\"{ns}\\t{fname}\");\n        }\n\n        if had_unresponsive {\n            println!(\"\\nYou can remove unresponsive sockets using --rm-sockets\");\n        }\n\n        Ok(())\n    }\n\n    if let Err(e) = inner() {\n        fatal(format!(\"unable to list open editor sessions: {e}\"));\n    }\n}\n\nfn remove_open_sockets() {\n    fn inner() -> io::Result<()> {\n        let d = socket_dir();\n        for ns in open_9p_sockets()?.into_iter() {\n            if UnixClient::new_unix(&ns, \"\").is_err() {\n                let path = d.join(ns);\n                println!(\"removing unresponsive ad socket at {}\", path.display());\n                fs::remove_file(path)?;\n            }\n        }\n\n        Ok(())\n    }\n\n    if let Err(e) = inner() {\n        fatal(format!(\"unable to remove open 9p sockets: {e}\"));\n    }\n}\n", "source": "ad/src/main.rs", "file_type": "rc"}
{"text": "//! A simple trie data structure for supporting key bindings and autocompletions in a composible\n//! way with the rest of the ad internal APIs.\nuse std::{collections::BTreeMap, fmt, ops::Range, sync::Arc};\n\n/// A singly initialised Trie mapping key sequences to a value.\n///\n/// It is not permitted for values to be mapped to a key that is a prefix of another key also\n/// existing in the same Trie.\n///\n/// There are convenience methods provided for `Trie<char, V>` for when &str values are used as keys.\n#[derive(Clone, PartialEq, Eq)]\npub struct Trie<K, V>\nwhere\n    K: Clone + PartialEq + Ord,\n    V: Clone,\n{\n    nodes: Arc<[Node<K>]>,\n    values: Arc<[V]>,\n    n_roots: usize,\n}\n\nimpl<K, V> fmt::Debug for Trie<K, V>\nwhere\n    K: Clone + PartialEq + Ord + fmt::Debug,\n    V: Clone + fmt::Debug,\n{\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_struct(\"Trie\")\n            .field(\"nodes\", &self.nodes)\n            .field(\"values\", &self.values)\n            .field(\"n_roots\", &self.n_roots)\n            .finish()\n    }\n}\n\nimpl<K, V> Default for Trie<K, V>\nwhere\n    K: Clone + PartialEq + Ord,\n    V: Clone,\n{\n    fn default() -> Self {\n        Self {\n            nodes: Arc::from(Vec::new()),\n            values: Arc::from(Vec::new()),\n            n_roots: 0,\n        }\n    }\n}\n\nimpl<K, V> Trie<K, V>\nwhere\n    K: Clone + PartialEq + Ord,\n    V: Clone,\n{\n    /// Construct a new Trie from key-value pairs.\n    ///\n    /// Will panic if there are any key collisions or if there are any sequences that nest\n    /// under a prefix that is already required to hold a value\n    pub fn try_from_iter(it: impl IntoIterator<Item = (Vec<K>, V)>) -> Result<Self, &'static str> {\n        let mut roots = Vec::new();\n        for (key, value) in it.into_iter() {\n            insert(key, value, &mut roots)?;\n        }\n\n        if roots.is_empty() {\n            return Ok(Self::default());\n        }\n\n        let mut nodes = Vec::new();\n        let mut values = Vec::new();\n        let (_, n_roots) = flatten(roots, &mut nodes, &mut values);\n\n        Ok(Trie {\n            nodes: Arc::from(nodes),\n            values: Arc::from(values),\n            n_roots,\n        })\n    }\n\n    /// Merge two Tries.\n    ///\n    /// If the resulting Trie would be invalid to construct directly, an error is returned.\n    ///\n    /// Consumes both inputs.\n    pub fn merge(self, other: Self) -> Result<Self, &'static str> {\n        if self.is_empty() {\n            return Ok(other);\n        } else if other.is_empty() {\n            return Ok(self);\n        }\n\n        let mut pairs = Vec::with_capacity(self.len() + other.len());\n        self.extract_pairs(&mut pairs, Vec::new(), 0..self.n_roots);\n        other.extract_pairs(&mut pairs, Vec::new(), 0..other.n_roots);\n\n        Self::try_from_iter(pairs)\n    }\n\n    /// Merge two Tries preferring keys from `other` in the case of collisions.\n    ///\n    /// If the resulting Trie would be invalid to construct directly, an error is returned.\n    ///\n    /// Consumes both inputs.\n    pub fn merge_overriding(self, other: Self) -> Result<Self, &'static str> {\n        if self.is_empty() {\n            return Ok(other);\n        } else if other.is_empty() {\n            return Ok(self);\n        }\n\n        let mut pairs = Vec::with_capacity(self.len() + other.len());\n        self.extract_pairs(&mut pairs, Vec::new(), 0..self.n_roots);\n\n        let mut m = BTreeMap::from_iter(pairs.drain(..));\n        other.extract_pairs(&mut pairs, Vec::new(), 0..other.n_roots);\n        m.extend(pairs.drain(..));\n\n        Self::try_from_iter(m)\n    }\n\n    fn extract_pairs(&self, pairs: &mut Vec<(Vec<K>, V)>, key: Vec<K>, indices: Range<usize>) {\n        for i in indices {\n            let node = &self.nodes[i];\n            let mut child_key = key.clone();\n            child_key.push(node.key.clone());\n\n            match node.data {\n                Data::Leaf { i } => pairs.push((child_key, self.values[i].clone())),\n\n                Data::Internal {\n                    child_start,\n                    n_children,\n                } => self.extract_pairs(pairs, child_key, child_start..child_start + n_children),\n            }\n        }\n    }\n\n    /// Query this [Trie] for a given key or key prefix\n    ///\n    /// If the key maps to a leaf then the value is returned, if it maps to a sub-trie then\n    /// `Partial` is returned to denote that the given key is a parent of one or more values. If\n    /// the key is not found within the `Trie` then `Missing` is returned.\n    pub fn get<'a>(&'a self, key: &[K]) -> QueryResult<'a, V> {\n        if key.is_empty() {\n            return QueryResult::Missing;\n        }\n\n        let mut indices = 0..self.n_roots;\n        let mut key_index = 0;\n\n        'outer: while key_index < key.len() {\n            let target = &key[key_index];\n\n            // Binary search within the current level (assumes sorted children)\n            for i in indices {\n                let node = &self.nodes[i];\n                if &node.key == target {\n                    key_index += 1;\n\n                    match node.data {\n                        Data::Leaf { i } => {\n                            return if key_index == key.len() {\n                                QueryResult::Val(&self.values[i])\n                            } else {\n                                QueryResult::Missing\n                            };\n                        }\n\n                        Data::Internal {\n                            child_start,\n                            n_children,\n                        } => {\n                            indices = child_start..child_start + n_children;\n                            continue 'outer;\n                        }\n                    }\n                } else if node.key > *target {\n                    // We've moved past where the node would be in sorted order\n                    return QueryResult::Missing;\n                }\n            }\n\n            return QueryResult::Missing;\n        }\n\n        QueryResult::Partial\n    }\n\n    /// Query this [Trie] for a given key or key prefix requiring the key to match exactly.\n    ///\n    /// If the key maps to a leaf then the `Some(value)` is returned, otherwise `None`.\n    pub fn get_exact<'a>(&'a self, key: &[K]) -> Option<&'a V> {\n        self.get(key).into()\n    }\n\n    /// The number of leaf values in this Trie\n    pub fn len(&self) -> usize {\n        self.nodes.iter().filter(|n| n.is_leaf()).count()\n    }\n\n    /// Whether this Trie is empty\n    pub fn is_empty(&self) -> bool {\n        self.nodes.is_empty()\n    }\n}\n\n// Implementation for char-based convenience methods\nimpl<V> Trie<char, V>\nwhere\n    V: Clone,\n{\n    /// Construct a new [Trie] with [char] internal keys from string keys.\n    pub fn from_str_keys(pairs: Vec<(&str, V)>) -> Result<Self, &'static str> {\n        let char_pairs: Vec<(Vec<char>, V)> = pairs\n            .into_iter()\n            .map(|(k, v)| (k.chars().collect(), v))\n            .collect();\n\n        Self::try_from_iter(char_pairs)\n    }\n\n    /// Query this [Trie] using a string key.\n    ///\n    /// Both full and partial matches are possible.\n    pub fn get_str<'a>(&'a self, key: &str) -> QueryResult<'a, V> {\n        self.get(&key.chars().collect::<Vec<_>>())\n    }\n\n    /// Query this [Trie] using a string key.\n    ///\n    /// Only fll matches will be returned.\n    pub fn get_str_exact<'a>(&'a self, key: &str) -> Option<&'a V> {\n        self.get_exact(&key.chars().collect::<Vec<_>>())\n    }\n}\n\n/// A single node within a [Trie].\n///\n/// Contains the last element of the key that traverses down to this node alongside [Data] that\n/// identifies this node as being internal or a leaf.\n#[derive(Debug, Clone, PartialEq, Eq)]\nstruct Node<K>\nwhere\n    K: Clone + PartialEq + Ord,\n{\n    key: K,\n    data: Data,\n}\n\nimpl<K> Node<K>\nwhere\n    K: Clone + PartialEq + PartialOrd + Ord,\n{\n    fn new_internal(key: K, child_start: usize, n_children: usize) -> Self {\n        Self {\n            key,\n            data: Data::Internal {\n                child_start,\n                n_children,\n            },\n        }\n    }\n\n    fn new_leaf(key: K, i: usize) -> Self {\n        Self {\n            key,\n            data: Data::Leaf { i },\n        }\n    }\n\n    fn is_leaf(&self) -> bool {\n        matches!(self.data, Data::Leaf { .. })\n    }\n}\n\n/// The internal data held at each node in a Trie.\n///\n/// Internal nodes are \"pointers\" to their children while leaves hold the value associated with the\n/// full key used to traverse down to them.\n#[derive(Debug, Copy, Clone, PartialEq, Eq)]\nenum Data {\n    Internal {\n        /// Index of the first child node\n        child_start: usize,\n        /// Number of child nodes\n        n_children: usize,\n    },\n    Leaf {\n        // Index of the value associated with the full key-path down to this node\n        i: usize,\n    },\n}\n\n#[derive(Debug)]\nstruct BuildNode<K, V>\nwhere\n    K: PartialEq + Ord,\n{\n    k: K,\n    data: BuildNodeData<K, V>,\n}\n\n#[derive(Debug)]\nenum BuildNodeData<K, V>\nwhere\n    K: PartialEq + Ord,\n{\n    Internal(Vec<BuildNode<K, V>>),\n    Leaf(V),\n}\n\nfn insert<K, V>(\n    mut key: Vec<K>,\n    v: V,\n    current: &mut Vec<BuildNode<K, V>>,\n) -> Result<(), &'static str>\nwhere\n    K: PartialEq + Ord,\n{\n    for n in current.iter_mut() {\n        if key[0] == n.k {\n            if key.len() <= 1 {\n                return Err(\"duplicate entry for key\");\n            }\n\n            key.remove(0);\n            return match &mut n.data {\n                BuildNodeData::Internal(nodes) => insert(key, v, nodes),\n                BuildNodeData::Leaf(_) => Err(\"attempt to insert into value node\"),\n            };\n        }\n    }\n\n    let k = key.remove(0);\n\n    if key.is_empty() {\n        current.push(BuildNode {\n            k,\n            data: BuildNodeData::Leaf(v),\n        });\n    } else {\n        let mut children = vec![];\n        insert(key, v, &mut children)?;\n        current.push(BuildNode {\n            k,\n            data: BuildNodeData::Internal(children),\n        });\n    }\n\n    Ok(())\n}\n\nfn flatten<K, V>(\n    mut roots: Vec<BuildNode<K, V>>,\n    nodes: &mut Vec<Node<K>>,\n    values: &mut Vec<V>,\n) -> (usize, usize)\nwhere\n    K: Clone + PartialEq + Ord,\n    V: Clone,\n{\n    roots.sort_by(|l, r| l.k.cmp(&r.k));\n\n    let child_start = nodes.len();\n    let n_children = roots.len();\n\n    let mut child_stack = Vec::new();\n\n    // Insert roots first, storing any child nodes that need to be inserted later.\n    for BuildNode { k, data } in roots.into_iter() {\n        match data {\n            BuildNodeData::Internal(children) => {\n                let i = nodes.len();\n                nodes.push(Node::new_internal(k, 0, children.len()));\n                child_stack.push((i, children));\n            }\n\n            BuildNodeData::Leaf(v) => {\n                let i = values.len();\n                values.push(v);\n                nodes.push(Node::new_leaf(k, i))\n            }\n        }\n    }\n\n    // Insert the child nodes for each root node, updating their state now that we know the offsets\n    // of their children.\n    for (i, children) in child_stack.into_iter() {\n        let (start, _) = flatten(children, nodes, values);\n        match &mut nodes[i] {\n            Node {\n                data: Data::Internal { child_start, .. },\n                ..\n            } => {\n                *child_start = start;\n            }\n\n            _ => unreachable!(),\n        }\n    }\n\n    (child_start, n_children)\n}\n\n/// A default handler for mapping a single length key to an `Option<V>`.\n///\n/// This is used to avoid having to specify large numbers of single length keys that should all be\n/// handled in a similar way.\npub type DefaultMapping<K, V> = fn(&K) -> Option<V>;\n\n/// The result of querying a [Trie] for a particular Key.\n#[derive(Debug, Clone, PartialEq, Eq)]\npub enum QueryResult<'a, V> {\n    /// A leaf value associated with the key used in the query\n    Val(&'a V),\n    /// The key used to query is a prefix to multiple values\n    Partial,\n    /// The key does not exist within the [Trie]\n    Missing,\n}\n\nimpl<'a, V> From<Option<&'a V>> for QueryResult<'a, V> {\n    fn from(opt: Option<&'a V>) -> Self {\n        match opt {\n            Some(v) => QueryResult::Val(v),\n            None => QueryResult::Missing,\n        }\n    }\n}\n\nimpl<'a, V> From<QueryResult<'a, V>> for Option<&'a V> {\n    fn from(q: QueryResult<'a, V>) -> Self {\n        match q {\n            QueryResult::Val(v) => Some(v),\n            _ => None,\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use simple_test_case::test_case;\n\n    #[test]\n    fn duplicate_keys_errors() {\n        assert!(Trie::try_from_iter(vec![(vec![42], 1), (vec![42], 2)]).is_err());\n    }\n\n    #[test]\n    fn children_under_a_value_node_errors() {\n        assert!(Trie::try_from_iter(vec![(vec![42], 1), (vec![42, 69], 2)]).is_err());\n    }\n\n    #[test_case(\"foo\", QueryResult::Val(&1); \"val 1\")]\n    #[test_case(\"bar\", QueryResult::Val(&2); \"val 2\")]\n    #[test_case(\"baz\", QueryResult::Val(&3); \"val 3\")]\n    #[test_case(\"ba\", QueryResult::Partial; \"partial 1\")] // typos:ignore\n    #[test_case(\"fo\", QueryResult::Partial; \"partial 2\")] // typos:ignore\n    #[test_case(\"barf\", QueryResult::Missing; \"overshoot\")]\n    #[test_case(\"have you any wool?\", QueryResult::Missing; \"fully missing\")]\n    #[test]\n    fn get_works(key: &str, expected: QueryResult<'_, usize>) {\n        let t = Trie::from_str_keys(vec![(\"foo\", 1), (\"bar\", 2), (\"baz\", 3)]).unwrap();\n        assert_eq!(t.get_str(key), expected);\n    }\n\n    #[test_case(&[42], None; \"partial should be None\")]\n    #[test_case(&[144], None; \"missing should be None\")]\n    #[test_case(&[42, 69, 144], None; \"overshoot should be None\")]\n    #[test_case(&[42, 69], Some(1); \"exact should be Some\")]\n    #[test]\n    fn get_exact_works(key: &[usize], expected: Option<usize>) {\n        let t = Trie::try_from_iter(vec![(vec![42, 69], 1)]).unwrap();\n        assert_eq!(t.get_exact(key), expected.as_ref());\n    }\n\n    #[test_case(\"fo\", None; \"partial\")] // typos:ignore\n    #[test_case(\"bar\", None; \"missing\")]\n    #[test_case(\"fool\", None; \"overshoot\")]\n    #[test_case(\"foo\", Some(1); \"found\")]\n    #[test]\n    fn get_str_exact_works(key: &str, expected: Option<usize>) {\n        let t = Trie::from_str_keys(vec![(\"foo\", 1)]).unwrap();\n        assert_eq!(t.get_str_exact(key), expected.as_ref());\n    }\n\n    #[test]\n    fn merge_works() {\n        let t1 = Trie::from_str_keys(vec![(\"foo\", 1), (\"bar\", 2)]).unwrap();\n        let t2 = Trie::from_str_keys(vec![(\"baz\", 3), (\"qux\", 4)]).unwrap();\n\n        let merged = t1.merge(t2).unwrap();\n\n        assert_eq!(merged.get_str_exact(\"foo\"), Some(&1));\n        assert_eq!(merged.get_str_exact(\"bar\"), Some(&2));\n        assert_eq!(merged.get_str_exact(\"baz\"), Some(&3));\n        assert_eq!(merged.get_str_exact(\"qux\"), Some(&4));\n        assert_eq!(merged.len(), 4);\n    }\n\n    #[test]\n    fn merge_conflicts_error() {\n        let t1 = Trie::from_str_keys(vec![(\"foo\", 1)]).unwrap();\n        let t2 = Trie::from_str_keys(vec![(\"foo\", 2)]).unwrap();\n\n        assert!(t1.merge(t2).is_err());\n    }\n\n    #[test]\n    fn merge_overriding_works() {\n        let t1 = Trie::from_str_keys(vec![(\"foo\", 1), (\"bar\", 2)]).unwrap();\n        let t2 = Trie::from_str_keys(vec![(\"baz\", 3), (\"foo\", 4)]).unwrap();\n\n        let merged = t1.merge_overriding(t2).unwrap();\n\n        assert_eq!(merged.get_str_exact(\"foo\"), Some(&4));\n        assert_eq!(merged.get_str_exact(\"bar\"), Some(&2));\n        assert_eq!(merged.get_str_exact(\"baz\"), Some(&3));\n        assert_eq!(merged.len(), 3);\n    }\n\n    #[test]\n    fn merge_overriding_conflicts_are_ok() {\n        let t1 = Trie::from_str_keys(vec![(\"foo\", 1)]).unwrap();\n        let t2 = Trie::from_str_keys(vec![(\"foo\", 2)]).unwrap();\n\n        assert!(t1.merge_overriding(t2).is_ok());\n    }\n}\n", "source": "ad/src/trie.rs", "file_type": "rc"}
{"text": "//! Utility functions\nuse crate::{config::config_path, editor::built_in_commands, mode::keybindings};\nuse std::{\n    fs,\n    os::unix::fs::PermissionsExt,\n    path::Path,\n    sync::{Arc, LockResult, RwLock, RwLockReadGuard},\n};\nuse tracing::warn;\n\n/// A wrapper around an `Arc<RwLock<T>>` so that the owner is only\n/// permitted read access to the underlying value.\n#[derive(Debug, Default, Clone)]\npub struct ReadOnlyLock<T>(Arc<RwLock<T>>);\n\nimpl<T> ReadOnlyLock<T> {\n    /// Construct a new ReadOnlyLock wrapping an inner `Arc<RwLock<T>>`\n    pub fn new(inner: Arc<RwLock<T>>) -> Self {\n        Self(inner)\n    }\n\n    /// Obtain a read guard from the underlying `RwLock`\n    pub fn read(&self) -> LockResult<RwLockReadGuard<'_, T>> {\n        self.0.read()\n    }\n}\n\n/// Pull in data from the ad crate itself to auto-generate the docs on the functionality\n/// available in the editor.\npub(crate) fn gen_help_docs() -> String {\n    let help_template = include_str!(\"../data/help-template.txt\");\n\n    help_template\n        .replace(\"{{KEY_BINDINGS}}\", &keybindings_section())\n        .replace(\"{{BUILT_IN_COMMANDS}}\", &commands_section())\n        .replace(\"{{CONFIG_PATH}}\", &config_path())\n}\n\nfn keybindings_section() -> String {\n    let raw = keybindings();\n    let mut sections = Vec::with_capacity(raw.len());\n\n    for (mode, bindings) in raw.into_iter() {\n        let w_max = bindings.iter().map(|(s, _)| s.len()).max().unwrap();\n        let mut section = format!(\"{mode} mode\\n\");\n\n        for (keys, desc) in bindings.into_iter() {\n            section.push_str(&format!(\"  {:width$} -- {desc}\\n\", keys, width = w_max));\n        }\n\n        sections.push(section);\n    }\n\n    sections.join(\"\\n\\n\")\n}\n\nfn commands_section() -> String {\n    let commands = built_in_commands();\n    let mut buf = Vec::with_capacity(commands.len());\n\n    for (cmds, desc) in commands.into_iter() {\n        buf.push((cmds.join(\" | \"), desc));\n    }\n\n    let w_max = buf.iter().map(|(s, _)| s.len()).max().unwrap();\n    let mut s = String::new();\n\n    for (cmds, desc) in buf.into_iter() {\n        s.push_str(&format!(\"{:width$} -- {desc}\\n\", cmds, width = w_max));\n    }\n\n    s\n}\n\npub(crate) fn normalize_line_endings(mut s: String) -> String {\n    if !s.contains('\\r') {\n        return s;\n    }\n\n    warn!(\"normalizing \\\\r characters to \\\\n\");\n    s = s.replace(\"\\r\\n\", \"\\n\");\n    s.replace(\"\\r\", \"\\n\")\n}\n\n/// Locate the first parent directory containing a target file\npub(crate) fn parent_dir_containing<'a>(initial: &'a Path, target: &str) -> Option<&'a Path> {\n    initial\n        .ancestors()\n        .find(|&p| p.is_dir() && p.join(target).exists())\n}\n\n/// Check whether or not a given command can be found as an executable within the provided set of path directories\n#[allow(dead_code)]\npub(crate) fn exists_on_path_as_executable(cmd: &str, cwd: &Path, path_str: &str) -> bool {\n    let cwd_candidate = cwd.join(cmd);\n    let candidates = path_str.split(':').map(|dir| Path::new(dir).join(cmd));\n\n    for candidate in std::iter::once(cwd_candidate).chain(candidates) {\n        if let Ok(meta) = fs::metadata(candidate)\n            && meta.is_file()\n            && meta.permissions().mode() & 0o111 != 0\n        {\n            return true;\n        }\n    }\n\n    false\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use simple_test_case::test_case;\n    use std::{env, path::PathBuf};\n\n    #[test_case(\"cat\", true; \"cat exists\")]\n    #[test_case(\"dog\", false; \"dog does not exist\")]\n    #[test]\n    fn executable_checking_works(cmd: &str, expected: bool) {\n        let path = env::var(\"PATH\").unwrap();\n        let exists = exists_on_path_as_executable(cmd, &PathBuf::from(\"/tmp\"), &path);\n\n        assert_eq!(exists, expected);\n    }\n}\n", "source": "ad/src/util.rs", "file_type": "rc"}
{"text": "//! A plumbing interface for user defined \"loading\" of text inspired by plan 9's plumber.\n//!\n//! See the following papers and man pages for references on the original plan 9 system:\n//!   - <http://doc.cat-v.org/plan_9/4th_edition/papers/plumb>\n//!   - <http://man.cat-v.org/plan_9_3rd_ed/1/plumb>\n//!   - <http://man.cat-v.org/plan_9_3rd_ed/2/plumb>\n//!   - <http://man.cat-v.org/plan_9_3rd_ed/4/plumber>\n//!   - <http://man.cat-v.org/plan_9_3rd_ed/6/plumb>\nuse crate::regex::Regex;\nuse std::{\n    collections::BTreeMap,\n    env, fs, io,\n    process::{Command, Stdio},\n    str::FromStr,\n};\nuse tracing::debug;\n\n/// An ordered list of plumbing rules to use whenever something is \"loaded\" within the editor.\n#[derive(Debug, Default, PartialEq, Eq)]\npub struct PlumbingRules {\n    rules: Vec<Rule>,\n    vars: BTreeMap<String, String>,\n}\n\nimpl FromStr for PlumbingRules {\n    type Err = String;\n\n    fn from_str(s: &str) -> Result<Self, Self::Err> {\n        let mut prs = Self::default();\n\n        for raw_block in s.split(\"\\n\\n\") {\n            let lines: Vec<_> = raw_block\n                .trim()\n                .lines()\n                .filter(|l| !l.starts_with('#'))\n                .collect();\n\n            let mut block = lines.join(\"\\n\");\n            if block.is_empty() {\n                continue;\n            }\n\n            match block.split_once(' ') {\n                // Parse variable declaration blocks\n                Some((_, s)) if s.starts_with(\"=\") => {\n                    for line in block.lines() {\n                        match line.split_once(\"=\") {\n                            Some((var, val)) => {\n                                let mut k = non_empty_string(var.trim(), line)?;\n                                k.insert(0, '$');\n                                prs.vars.insert(k, non_empty_string(val.trim(), line)?);\n                            }\n                            _ => return Err(format!(\"malformed line: {line:?}\")),\n                        }\n                    }\n                }\n\n                // Apply variables and parse rule blocks\n                _ => {\n                    for (k, v) in prs.vars.iter() {\n                        block = block.replace(k, v);\n                    }\n                    prs.rules.push(Rule::from_str(&block)?);\n                }\n            }\n        }\n\n        Ok(prs)\n    }\n}\n\nimpl PlumbingRules {\n    /// Attempt to load plumbing rules from the default location\n    pub fn try_load() -> Result<Self, String> {\n        let home = env::var(\"HOME\").unwrap();\n\n        Self::try_load_from_path(&format!(\"{home}/.ad/plumbing.rules\"))\n    }\n\n    /// Attempt to load plumbing rules from a specified file\n    pub fn try_load_from_path(path: &str) -> Result<Self, String> {\n        let s = match fs::read_to_string(path) {\n            Ok(s) => s,\n            Err(e) if e.kind() == io::ErrorKind::NotFound => return Ok(Self::default()),\n            Err(e) => return Err(format!(\"Unable to load plumbing rules: {e}\")),\n        };\n\n        match Self::from_str(&s) {\n            Ok(cfg) => Ok(cfg),\n            Err(e) => Err(format!(\"Invalid plumbing rules: {e}\")),\n        }\n    }\n\n    /// Run the provided message through the plumbing rules to determine how it should be\n    /// handled. If no rules match then None is returned and default handling for a load\n    /// takes place instead. The returned message may differ from the one passed in if\n    /// rules carry out rewrites.\n    pub fn plumb(&mut self, msg: PlumbingMessage) -> Option<MatchOutcome> {\n        let vars = msg.initial_vars();\n        debug!(\"plumbing message: {msg:?}\");\n\n        for (n, rule) in self.rules.iter_mut().enumerate() {\n            debug!(\"checking rule {n}\");\n            let mut rule_vars = vars.clone();\n            if let Some(msg) = rule.try_match(msg.clone(), &mut rule_vars) {\n                debug!(\"rule matched\");\n                return Some(msg);\n            }\n        }\n\n        debug!(\"no matching rules\");\n        None\n    }\n}\n\n/// The deserialized form of a plumbing message sent by a client.\n#[derive(Debug, Default, PartialEq, Eq, Clone)]\npub struct PlumbingMessage {\n    /// The application or service generating the message\n    pub src: Option<String>,\n    /// The destination \"port\" for the message\n    pub dst: Option<String>,\n    /// The working directory (used when data is a filename)\n    pub wdir: Option<String>,\n    /// The offset within 'data' where the user's cursor currently lies (default=0).\n    /// If a rule specifies a 'narrows-to' rule it will be used to narrow initial data\n    /// to only include the specified cursor, otherwise the match will be rejected.\n    pub cur: usize,\n    /// Name=value pairs. Must not contain newlines\n    pub attrs: BTreeMap<String, String>,\n    /// The string content of the message itself\n    pub data: String,\n}\n\nimpl PlumbingMessage {\n    fn initial_vars(&self) -> BTreeMap<String, String> {\n        let mut vars = BTreeMap::new();\n        if let Some(s) = self.src.clone() {\n            vars.insert(\"$src\".to_string(), s);\n        }\n        if let Some(s) = self.dst.clone() {\n            vars.insert(\"$dst\".to_string(), s);\n        }\n        if let Some(s) = self.wdir.clone() {\n            vars.insert(\"$wdir\".to_string(), s);\n        }\n        vars.insert(\"$data\".to_string(), self.data.clone());\n\n        vars\n    }\n}\n\nmacro_rules! parse_field {\n    ($line:expr, $field_name:expr, $prefix:expr, $field:expr) => {\n        match ($line.strip_prefix($prefix), &mut $field) {\n            (Some(val), None) => {\n                $field = Some(val.to_string());\n                continue;\n            }\n            (Some(_), Some(_)) => return Err(format!(\"duplicate {} field\", $field_name)),\n            (None, _) => (),\n        }\n    };\n}\n\nfn parse_attr_list(s: &str) -> Result<BTreeMap<String, String>, String> {\n    let mut attrs = BTreeMap::new();\n    for pair in s.split(' ') {\n        match pair.split_once('=') {\n            Some((k, v)) => {\n                if k.is_empty() || v.is_empty() {\n                    return Err(format!(\"malformed attrs: {pair:?}\"));\n                }\n                attrs.insert(k.to_string(), v.to_string());\n            }\n            None => return Err(format!(\"malformed attrs: {pair:?}\")),\n        }\n    }\n\n    Ok(attrs)\n}\n\nimpl FromStr for PlumbingMessage {\n    type Err = String;\n\n    fn from_str(s: &str) -> Result<Self, Self::Err> {\n        let mut msg = Self::default();\n        let mut it = s.lines();\n        let mut ndata = 0;\n        let mut cur_set = false;\n\n        for line in &mut it {\n            parse_field!(line, \"src\", \"src: \", msg.src);\n            parse_field!(line, \"dst\", \"dst: \", msg.dst);\n            parse_field!(line, \"wdir\", \"wdir: \", msg.wdir);\n\n            match (line.strip_prefix(\"cur: \"), &mut msg.cur) {\n                (Some(_), _) if cur_set => return Err(\"duplicate cur field\".to_string()),\n                (Some(val), _) => {\n                    msg.cur = match val.parse() {\n                        Ok(cur) => cur,\n                        Err(e) => return Err(format!(\"malformed cur field: {e}\")),\n                    };\n                    cur_set = true;\n                    continue;\n                }\n                (None, _) => (),\n            }\n\n            match (line.strip_prefix(\"attrs: \"), msg.attrs.is_empty()) {\n                (Some(s), true) => {\n                    msg.attrs = parse_attr_list(s)?;\n                    continue;\n                }\n                (Some(_), false) => return Err(\"duplicate attrs field\".to_string()),\n                (None, _) => (),\n            }\n\n            match line.strip_prefix(\"ndata: \") {\n                Some(n) => {\n                    ndata = match n.parse() {\n                        Ok(ndata) => ndata,\n                        Err(_) => return Err(format!(\"invalid ndata field {n:?}\")),\n                    };\n                    break;\n                }\n                None => return Err(format!(\"malformed message: {line:?}\")),\n            }\n        }\n\n        if ndata > 0 {\n            let stripped_lines: Vec<&str> = it.collect();\n            let joined = stripped_lines.join(\"\\n\");\n            match joined.strip_prefix(\"data: \") {\n                Some(data) => msg.data = data.to_string(),\n                None => return Err(\"malformed message: missing data field\".to_string()),\n            }\n            if msg.data.len() != ndata {\n                return Err(format!(\n                    \"malformed data. Expected {ndata} bytes but received {}: {:?}\",\n                    msg.data.len(),\n                    msg.data\n                ));\n            }\n        }\n\n        Ok(msg)\n    }\n}\n\n#[derive(Debug, Clone, PartialEq, Eq)]\nenum Pattern {\n    AddAttrs(BTreeMap<String, String>),\n    DelAttr(String),\n    DataFrom(String),\n    IsFile(String),\n    IsDir(String),\n    Is(Field, String),\n    Matches(Field, Regex),\n    NarrowsTo(Regex),\n    Set(Field, String),\n}\n\nimpl Pattern {\n    fn kind_str(&self) -> &'static str {\n        match self {\n            Self::AddAttrs(_) => \"add-attrs\",\n            Self::DelAttr(_) => \"del-attr\",\n            Self::DataFrom(_) => \"data-from\",\n            Self::IsFile(_) => \"is-file\",\n            Self::IsDir(_) => \"is-dir\",\n            Self::Is(_, _) => \"is\",\n            Self::Matches(_, _) => \"matches\",\n            Self::NarrowsTo(_) => \"narrows-to\",\n            Self::Set(_, _) => \"set\",\n        }\n    }\n\n    fn match_and_update(\n        &mut self,\n        msg: &mut PlumbingMessage,\n        vars: &mut BTreeMap<String, String>,\n    ) -> bool {\n        let apply_vars = |mut s: String| {\n            for (k, v) in vars.iter() {\n                s = s.replace(k, v);\n            }\n            s\n        };\n\n        let re_match_and_update =\n            |f: Field, re: &mut Regex, vars: &mut BTreeMap<String, String>| {\n                debug!(\"regex match against {}\", f.name());\n                let opt = match f {\n                    Field::Src => msg.src.as_ref(),\n                    Field::Dst => msg.dst.as_ref(),\n                    Field::Wdir => msg.wdir.as_ref(),\n                    Field::Data => Some(&msg.data),\n                };\n                let s = match opt {\n                    Some(s) => s,\n                    None => {\n                        debug!(\"unable to match against {} (not set in message)\", f.name());\n                        return false;\n                    }\n                };\n\n                if let Some(m) = re.find(&s.as_str()) {\n                    debug!(\"matched: updating vars\");\n                    vars.insert(\"$0\".to_string(), m.match_text(&s.as_str()).into_owned());\n                    for n in 1..10 {\n                        match m.submatch_text(n, &s.as_str()) {\n                            Some(txt) => {\n                                vars.insert(format!(\"${n}\"), txt.into_owned());\n                            }\n                            None => return true,\n                        }\n                    }\n                    return true;\n                }\n\n                debug!(\"message data did not match the provided regex\");\n                false\n            };\n\n        debug!(\"checking {} pattern\", self.kind_str());\n        match self {\n            Self::AddAttrs(attrs) => {\n                debug!(\"adding attrs: {attrs:?}\");\n                msg.attrs.extend(\n                    attrs\n                        .clone()\n                        .into_iter()\n                        .map(|(k, v)| (apply_vars(k), apply_vars(v))),\n                );\n            }\n\n            Self::DelAttr(a) => {\n                debug!(\"removing attr: {a}\");\n                msg.attrs.remove(a);\n            }\n\n            Self::IsFile(s) => {\n                debug!(\"checking if {s:?} is a file\");\n                let path = apply_vars(s.clone());\n                match fs::metadata(&path) {\n                    Ok(m) => {\n                        if m.is_file() {\n                            debug!(\"{path:?} exists and is a file\");\n                            vars.insert(\"$file\".to_string(), path);\n                        } else {\n                            debug!(\"{path:?} exists but is not a file\");\n                            return false;\n                        }\n                    }\n\n                    Err(e) => {\n                        debug!(\"unable to check {path:?}: {e}\");\n                        return false;\n                    }\n                }\n            }\n\n            Self::IsDir(s) => {\n                debug!(\"checking if {s:?} is a directory\");\n                let path = apply_vars(s.clone());\n                match fs::metadata(&path) {\n                    Ok(m) => {\n                        if m.is_dir() {\n                            debug!(\"{path:?} exists and is a directory\");\n                            vars.insert(\"$dir\".to_string(), path);\n                        } else {\n                            debug!(\"{path:?} exists but is not a directory\");\n                            return false;\n                        }\n                    }\n\n                    Err(e) => {\n                        debug!(\"unable to check {path:?}: {e}\");\n                        return false;\n                    }\n                }\n            }\n\n            Self::Is(Field::Src, s) => {\n                let res = msg.src.as_ref() == Some(s);\n                debug!(\"checking src == {s:?}: {res}\");\n                return res;\n            }\n            Self::Is(Field::Dst, s) => {\n                let res = msg.dst.as_ref() == Some(s);\n                debug!(\"checking dst == {s:?}: {res}\");\n                return res;\n            }\n            Self::Is(Field::Wdir, s) => {\n                let res = msg.wdir.as_ref() == Some(s);\n                debug!(\"checking wdir == {s:?}: {res}\");\n                return res;\n            }\n            Self::Is(Field::Data, s) => {\n                let res = &msg.data == s;\n                debug!(\"checking data == {s:?}: {res}\");\n                return res;\n            }\n\n            Self::Set(Field::Src, s) => {\n                let updated = apply_vars(s.clone());\n                debug!(\"setting src to {updated:?}\");\n                msg.src = Some(updated.clone());\n                vars.insert(\"$src\".to_string(), updated);\n            }\n            Self::Set(Field::Dst, s) => {\n                let updated = apply_vars(s.clone());\n                debug!(\"setting dst to {updated:?}\");\n                msg.dst = Some(updated.clone());\n                vars.insert(\"$dst\".to_string(), updated);\n            }\n            Self::Set(Field::Wdir, s) => {\n                let updated = apply_vars(s.clone());\n                debug!(\"setting wdir to {updated:?}\");\n                msg.wdir = Some(updated.clone());\n                vars.insert(\"$wdir\".to_string(), updated);\n            }\n            Self::Set(Field::Data, s) => {\n                let updated = apply_vars(s.clone());\n                debug!(\"setting data to {updated:?}\");\n                msg.data = updated.clone();\n                vars.insert(\"$data\".to_string(), updated);\n            }\n\n            Self::Matches(f, re) => return re_match_and_update(*f, re, vars),\n\n            Self::NarrowsTo(re) => {\n                debug!(%msg.cur, \"narrowing for provided cur\");\n                for m in re.find_iter(&msg.data.as_str()) {\n                    let (from, to) = m.loc();\n                    if from <= msg.cur && msg.cur <= to {\n                        debug!(%from, %to, \"successfully narrowed\");\n                        msg.data = m.match_text(&msg.data.as_str()).into_owned();\n                        msg.cur = 0; // consume the cursor as it is now invalid\n                        return true;\n                    }\n                }\n\n                return false; // unable to narrow to cur\n            }\n\n            Self::DataFrom(cmd) => {\n                debug!(\"running {cmd:?} to set message data\");\n                let mut command = Command::new(\"sh\");\n                command\n                    .args([\"-c\", apply_vars(cmd.clone()).as_str()])\n                    .stderr(Stdio::null());\n                let output = match command.output() {\n                    Ok(output) => output,\n                    Err(_) => return false,\n                };\n                msg.data = String::from_utf8(output.stdout).unwrap_or_default();\n            }\n        }\n\n        true\n    }\n}\n\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\nenum Field {\n    Src,\n    Dst,\n    Wdir,\n    Data,\n}\n\nimpl Field {\n    fn name(&self) -> &'static str {\n        match self {\n            Self::Src => \"src\",\n            Self::Dst => \"dst\",\n            Self::Wdir => \"wdir\",\n            Self::Data => \"data\",\n        }\n    }\n}\n\nimpl FromStr for Field {\n    type Err = String;\n\n    fn from_str(s: &str) -> Result<Self, Self::Err> {\n        match s {\n            \"src\" => Ok(Self::Src),\n            \"dst\" => Ok(Self::Dst),\n            \"wdir\" => Ok(Self::Wdir),\n            \"data\" => Ok(Self::Data),\n            s => Err(format!(\"unknown field: {s:?}\")),\n        }\n    }\n}\n\n#[derive(Debug, Clone, PartialEq, Eq)]\nenum Action {\n    To(String),\n    Start(String),\n}\n\n/// The result of a successful rule match that should be handled by ad.\n#[derive(Debug, Clone, PartialEq, Eq)]\npub enum MatchOutcome {\n    /// A message that should be handled by ad\n    Message(PlumbingMessage),\n    /// A command that should be run instead of handling the message\n    Run(String),\n}\n\n/// A parsed plumbing rule for matching against incoming messages.\n/// If all patterns match then the resulting actions are run until\n/// one succeeds.\n#[derive(Debug, Default, Clone, PartialEq, Eq)]\npub struct Rule {\n    patterns: Vec<Pattern>,\n    actions: Vec<Action>,\n}\n\nimpl FromStr for Rule {\n    type Err = String;\n\n    fn from_str(s: &str) -> Result<Self, Self::Err> {\n        let mut rule = Self::default();\n\n        for line in s.lines() {\n            if line.starts_with('#') {\n                continue;\n            }\n\n            // actions and patterns that start with a fixed prefix\n            if let Some(s) = line.strip_prefix(\"attr add \") {\n                rule.patterns.push(Pattern::AddAttrs(parse_attr_list(s)?));\n            } else if let Some(s) = line.strip_prefix(\"attr delete \") {\n                rule.patterns\n                    .push(Pattern::DelAttr(non_empty_string(s, line)?));\n            } else if let Some(s) = line.strip_prefix(\"arg isfile \") {\n                rule.patterns\n                    .push(Pattern::IsFile(non_empty_string(s, line)?));\n            } else if let Some(s) = line.strip_prefix(\"arg isdir \") {\n                rule.patterns\n                    .push(Pattern::IsDir(non_empty_string(s, line)?));\n            } else if let Some(s) = line.strip_prefix(\"data from \") {\n                rule.patterns\n                    .push(Pattern::DataFrom(non_empty_string(s, line)?));\n            } else if let Some(s) = line.strip_prefix(\"plumb to \") {\n                rule.actions.push(Action::To(non_empty_string(s, line)?));\n            } else if let Some(s) = line.strip_prefix(\"plumb start \") {\n                rule.actions.push(Action::Start(non_empty_string(s, line)?));\n            } else if let Some(s) = line.strip_prefix(\"data narrows \") {\n                rule.patterns.push(Pattern::NarrowsTo(\n                    Regex::compile(s).map_err(|e| format!(\"malformed regex ({e:?}): {s}\"))?,\n                ));\n            } else {\n                // patterns of the form $field $op $value\n                let (field, rest) = line\n                    .split_once(' ')\n                    .ok_or_else(|| format!(\"malformed rule line: {line}\"))?;\n                let field = Field::from_str(field)?;\n                let (op, value) = rest\n                    .split_once(' ')\n                    .ok_or_else(|| format!(\"malformed rule line: {line}\"))?;\n                let value = non_empty_string(value, line)?;\n\n                match op {\n                    \"is\" => rule.patterns.push(Pattern::Is(field, value)),\n                    \"set\" => rule.patterns.push(Pattern::Set(field, value)),\n                    \"matches\" => rule.patterns.push(Pattern::Matches(\n                        field,\n                        Regex::compile(&value)\n                            .map_err(|e| format!(\"malformed regex ({e:?}): {value}\"))?,\n                    )),\n                    _ => return Err(format!(\"unknown rule operation: {op}\")),\n                }\n            }\n        }\n\n        if rule.patterns.is_empty() {\n            Err(\"rule without patterns\".to_string())\n        } else if rule.actions.is_empty() {\n            Err(\"rule without actions\".to_string())\n        } else {\n            Ok(rule)\n        }\n    }\n}\n\nimpl Rule {\n    fn try_match(\n        &mut self,\n        mut msg: PlumbingMessage,\n        vars: &mut BTreeMap<String, String>,\n    ) -> Option<MatchOutcome> {\n        for p in self.patterns.iter_mut() {\n            if !p.match_and_update(&mut msg, vars) {\n                debug!(\"pattern failed to match\");\n                return None;\n            }\n        }\n\n        for a in self.actions.iter() {\n            match a {\n                // TODO: when other ports are supported they will need handling here!\n                Action::To(port) if port == \"edit\" => return Some(MatchOutcome::Message(msg)),\n                Action::Start(cmd) => {\n                    let mut s = cmd.clone();\n                    for (k, v) in vars.iter() {\n                        s = s.replace(k, v);\n                    }\n\n                    return Some(MatchOutcome::Run(s));\n                }\n                _ => continue,\n            }\n        }\n\n        None\n    }\n}\n\nfn non_empty_string(s: &str, line: &str) -> Result<String, String> {\n    if s.is_empty() {\n        Err(format!(\"malformed rule line: {line:?}\"))\n    } else {\n        Ok(s.to_string())\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use simple_test_case::dir_cases;\n    use simple_txtar::Archive;\n\n    #[test]\n    fn parse_default_rules_works() {\n        let rules = PlumbingRules::from_str(include_str!(\"../data/plumbing.rules\"));\n        assert!(rules.is_ok(), \"{rules:?}\");\n    }\n\n    #[test]\n    fn happy_path_plumb_works() {\n        let mut rules = PlumbingRules::from_str(include_str!(\"../data/plumbing.rules\")).unwrap();\n        let m = PlumbingMessage {\n            data: \"data/plumbing.rules:5:17:\".to_string(),\n            ..Default::default()\n        };\n\n        let outcome = rules.plumb(m);\n        let m = match outcome {\n            Some(MatchOutcome::Message(m)) => m,\n            _ => panic!(\"expected message, got {outcome:?}\"),\n        };\n\n        let expected = PlumbingMessage {\n            data: \"data/plumbing.rules\".to_string(),\n            attrs: [(\"addr\".to_string(), \"5:17\".to_string())]\n                .into_iter()\n                .collect(),\n            ..Default::default()\n        };\n\n        assert_eq!(m, expected);\n    }\n\n    #[test]\n    fn parse_message_works() {\n        let m = PlumbingMessage::from_str(include_str!(\n            \"../data/plumbing_tests/messages/valid/all-fields.txt\"\n        ))\n        .unwrap();\n\n        let expected = PlumbingMessage {\n            src: Some(\"bash\".to_string()),\n            dst: Some(\"ad\".to_string()),\n            wdir: Some(\"/home/foo/bar\".to_string()),\n            cur: 0,\n            attrs: [\n                (\"a\".to_string(), \"b\".to_string()),\n                (\"c\".to_string(), \"d\".to_string()),\n            ]\n            .into_iter()\n            .collect(),\n            data: \"hello, world!\".to_string(),\n        };\n\n        assert_eq!(m, expected);\n    }\n\n    #[dir_cases(\"data/plumbing_tests/messages/valid\")]\n    #[test]\n    fn parse_valid_message(_: &str, content: &str) {\n        let res = PlumbingMessage::from_str(content);\n        assert!(res.is_ok(), \"{res:?}\");\n    }\n\n    #[dir_cases(\"data/plumbing_tests/messages/invalid\")]\n    #[test]\n    fn parse_invalid_message(_: &str, content: &str) {\n        let res = PlumbingMessage::from_str(content);\n        assert!(res.is_err(), \"{res:?}\");\n    }\n\n    #[test]\n    fn parse_rule_works() {\n        let m = Rule::from_str(include_str!(\n            \"../data/plumbing_tests/rules/valid/everything.txt\"\n        ))\n        .unwrap();\n\n        let expected = Rule {\n            patterns: vec![\n                Pattern::AddAttrs([(\"a\".to_string(), \"b\".to_string())].into_iter().collect()),\n                Pattern::DelAttr(\"c\".to_string()),\n                Pattern::IsFile(\"$data\".to_string()),\n                Pattern::IsDir(\"/var/lib\".to_string()),\n                Pattern::Is(Field::Src, \"ad\".to_string()),\n                Pattern::Is(Field::Dst, \"editor\".to_string()),\n                Pattern::Set(Field::Wdir, \"/foo/bar\".to_string()),\n                Pattern::Matches(Field::Data, Regex::compile(r#\"(.+):(\\d+):(\\d+):\"#).unwrap()),\n                Pattern::Set(Field::Data, \"$1:$2,$3\".to_string()),\n            ],\n            actions: vec![\n                Action::To(\"editor\".to_string()),\n                Action::Start(\"ad $file\".to_string()),\n            ],\n        };\n\n        assert_eq!(m, expected);\n    }\n\n    #[dir_cases(\"data/plumbing_tests/rules/valid\")]\n    #[test]\n    fn parse_valid_rule(_: &str, content: &str) {\n        let res = Rule::from_str(content);\n        assert!(res.is_ok(), \"{res:?}\");\n    }\n\n    #[dir_cases(\"data/plumbing_tests/rules/invalid\")]\n    #[test]\n    fn parse_invalid_rule(_: &str, content: &str) {\n        let res = Rule::from_str(content);\n        assert!(res.is_err(), \"{res:?}\");\n    }\n\n    #[dir_cases(\"data/plumbing_tests/match-tests\")]\n    #[test]\n    fn match_tests(_fname: &str, content: &str) {\n        let arr = Archive::from(content);\n        let comment = arr.comment();\n        if !comment.is_empty() {\n            println!(\"{comment}\"); // help with debugging\n        }\n\n        let mut rules =\n            PlumbingRules::from_str(&arr.get(\"rules\").expect(\"missing rules\").content).unwrap();\n        let initial =\n            PlumbingMessage::from_str(&arr.get(\"initial\").expect(\"missing initial\").content)\n                .unwrap();\n\n        let raw_processed = &arr.get(\"processed\").expect(\"missing processed\").content;\n        let processed = if raw_processed.is_empty() {\n            None\n        } else {\n            Some(MatchOutcome::Message(\n                PlumbingMessage::from_str(raw_processed).unwrap(),\n            ))\n        };\n\n        let outcome = rules.plumb(initial);\n        assert_eq!(outcome, processed);\n    }\n}\n", "source": "ad/src/plumb.rs", "file_type": "rc"}
{"text": "//! An abstraction around system interactions to support testing and\n//! platform specific behaviour\nuse crate::{editor::Action, input::Event, util::normalize_line_endings};\nuse std::{\n    env, fmt,\n    io::{self, BufRead, BufReader, Read, Write},\n    path::Path,\n    process::{Child, Command, Stdio},\n    sync::mpsc::Sender,\n    thread::spawn,\n};\nuse tracing::info;\n\n/// Wrapper around storing system interactions\npub trait System: fmt::Debug {\n    /// Set the clipboard to the given string\n    fn set_clipboard(&mut self, s: &str) -> io::Result<()>;\n\n    /// Read the current contents of the clipboard\n    fn read_clipboard(&self) -> io::Result<String>;\n\n    /// Store a handle to a running [Child] followinga  call to [System::run_command].\n    fn store_child_handle(&mut self, cmd: &str, child: Child);\n\n    /// Provide an ordered list of currently running child processes by their command string\n    fn running_children(&self) -> Vec<String>;\n\n    /// The number of currently running child processes\n    fn n_running_children(&self) -> usize {\n        self.running_children().len()\n    }\n\n    /// Cleanup any resources associated with a child process that is now complete\n    fn cleanup_child(&mut self, id: u32);\n\n    /// Kill a child process by its index in the list returned from [System::running_children].\n    fn kill_child(&mut self, idx: usize);\n\n    /// Run an external command and collect its output.\n    fn run_command_blocking(&self, cmd: &str, cwd: &Path, bufid: usize) -> io::Result<String> {\n        run_command_blocking(cmd, cwd, bufid)\n    }\n\n    /// Run an external command and append its output to the output buffer for `bufid` from a\n    /// background thread. If the command is successfully spawned then a [Child] should be stored\n    /// for later resource cleanup and support for user initiated killing.\n    fn run_command(\n        &mut self,\n        cmd: &str,\n        cwd: &Path,\n        bufid: usize,\n        tx: Sender<Event>,\n    ) -> io::Result<()> {\n        let child = run_command(cmd, cwd, bufid, tx)?;\n        self.store_child_handle(cmd, child);\n\n        Ok(())\n    }\n\n    /// Pipe input text through an external command, returning the output\n    fn pipe_through_command(\n        &self,\n        cmd: &str,\n        input: &str,\n        cwd: &Path,\n        bufid: usize,\n    ) -> io::Result<String> {\n        pipe_through_command(cmd, input, cwd, bufid)\n    }\n}\n\n#[derive(Debug, Clone)]\nstruct ClipboardProvider {\n    copy_cmd: &'static str,\n    copy_args: Vec<&'static str>,\n    paste_cmd: &'static str,\n    paste_args: Vec<&'static str>,\n}\n\nimpl ClipboardProvider {\n    pub fn try_from_env() -> Option<Self> {\n        let paths = env::var(\"PATH\").expect(\"path not set\");\n        let exists = |cmd: &str| env::split_paths(&paths).any(|dir| dir.join(cmd).is_file());\n\n        let (copy_cmd, copy_args, paste_cmd, paste_args) = if exists(\"pbcopy\") {\n            info!(\"clipboard provider found: pbcopy\");\n            (\"pbcopy\", vec![], \"pbpaste\", vec![])\n        } else if env::var(\"WAYLAND_DISPLAY\").is_ok() && exists(\"wl-copy\") && exists(\"wl-paste\") {\n            info!(\"clipboard provider found: wl-copy\");\n            (\n                \"wl-copy\",\n                vec![\"--foreground\", \"--type\", \"text/plain\"],\n                \"wl-paste\",\n                vec![\"--no-newline\"],\n            )\n        } else if env::var(\"DISPLAY\").is_ok() && exists(\"xclip\") {\n            info!(\"clipboard provider found: xclip\");\n            (\n                \"xclip\",\n                vec![\"-i\", \"-selection\", \"clipboard\"],\n                \"xclip\",\n                vec![\"-o\", \"-selection\", \"clipboard\"],\n            )\n        } else {\n            info!(\"no clipboard provider found\");\n            return None;\n        };\n\n        Some(Self {\n            copy_cmd,\n            copy_args,\n            paste_cmd,\n            paste_args,\n        })\n    }\n}\n\n/// A default implementation for system interactions\n#[derive(Debug)]\npub struct DefaultSystem {\n    selection: String,\n    cp: Option<ClipboardProvider>,\n    running_children: Vec<(String, Child)>,\n}\n\nimpl DefaultSystem {\n    pub fn from_env() -> Self {\n        Self {\n            selection: String::new(),\n            cp: ClipboardProvider::try_from_env(),\n            running_children: Vec::new(),\n        }\n    }\n\n    pub fn without_clipboard_provider() -> Self {\n        Self {\n            selection: String::new(),\n            cp: None,\n            running_children: Vec::new(),\n        }\n    }\n}\n\nimpl System for DefaultSystem {\n    fn set_clipboard(&mut self, s: &str) -> io::Result<()> {\n        match &self.cp {\n            Some(cp) => {\n                let mut child = Command::new(cp.copy_cmd)\n                    .args(&cp.copy_args)\n                    .stdin(Stdio::piped())\n                    .spawn()?;\n\n                child.stdin.take().unwrap().write_all(s.as_bytes())\n            }\n\n            None => {\n                self.selection = s.to_string();\n                Ok(())\n            }\n        }\n    }\n\n    fn read_clipboard(&self) -> io::Result<String> {\n        match &self.cp {\n            Some(cp) => {\n                let output = Command::new(cp.paste_cmd).args(&cp.paste_args).output()?;\n\n                Ok(String::from_utf8(output.stdout).unwrap_or_default())\n            }\n\n            None => Ok(self.selection.clone()),\n        }\n    }\n\n    fn store_child_handle(&mut self, cmd: &str, child: Child) {\n        self.running_children.push((cmd.to_owned(), child));\n    }\n\n    fn running_children(&self) -> Vec<String> {\n        self.running_children\n            .iter()\n            .map(|(cmd, _)| cmd.clone())\n            .collect()\n    }\n\n    fn n_running_children(&self) -> usize {\n        self.running_children.len()\n    }\n\n    fn cleanup_child(&mut self, id: u32) {\n        for (_, child) in self.running_children.iter_mut() {\n            if child.id() == id {\n                _ = child.wait();\n            }\n        }\n\n        self.running_children.retain(|(_, child)| child.id() != id);\n    }\n\n    fn kill_child(&mut self, idx: usize) {\n        let (_, mut child) = self.running_children.remove(idx);\n        _ = child.kill();\n        _ = child.wait();\n    }\n}\n\nfn prepare_command(cmd: &str, cwd: &Path, bufid: usize) -> Command {\n    let mut args: Vec<&str> = cmd.split_whitespace().collect();\n    if args.is_empty() {\n        return Command::new(\"\");\n    }\n\n    let cmd = args.remove(0);\n    let path = env::var(\"PATH\").unwrap();\n    let home = env::var(\"HOME\").unwrap();\n    let mut command = Command::new(cmd);\n    command\n        .env(\"PATH\", format!(\"{home}/.ad/bin:{path}\"))\n        .env(\"AD_PID\", crate::pid().to_string())\n        .env(\"AD_BUFID\", bufid.to_string())\n        .current_dir(cwd)\n        .args(args);\n\n    command\n}\n\nfn run_command_blocking(cmd: &str, cwd: &Path, bufid: usize) -> io::Result<String> {\n    let output = prepare_command(cmd, cwd, bufid).output()?;\n    let mut stdout = String::from_utf8(output.stdout).unwrap_or_default();\n    let stderr = String::from_utf8(output.stderr).unwrap_or_default();\n    stdout.push_str(&stderr);\n\n    Ok(normalize_line_endings(stdout))\n}\n\nfn run_command(cmd: &str, cwd: &Path, bufid: usize, tx: Sender<Event>) -> io::Result<Child> {\n    let mut child = prepare_command(cmd, cwd, bufid)\n        .stdout(Stdio::piped())\n        .stderr(Stdio::piped())\n        .spawn()?;\n\n    let stdout = BufReader::new(child.stdout.take().unwrap());\n    let stderr = BufReader::new(child.stderr.take().unwrap());\n    let id = child.id();\n\n    spawn(move || {\n        let tx2 = tx.clone();\n        spawn(move || send_lines(bufid, stderr.lines(), tx2));\n        send_lines(bufid, stdout.lines(), tx.clone());\n        _ = tx.send(Event::Action(Action::CleanupChild { id }));\n    });\n\n    Ok(child)\n}\n\nfn send_lines(bufid: usize, it: impl Iterator<Item = io::Result<String>>, tx: Sender<Event>) {\n    for res in it {\n        match res {\n            Ok(mut line) => {\n                line.push('\\n');\n                _ = tx.send(Event::Action(Action::AppendToOutputBuffer {\n                    bufid,\n                    content: normalize_line_endings(line),\n                }));\n            }\n            Err(_) => break,\n        }\n    }\n}\n\n/// Pipe input text through an external command, returning the output\npub fn pipe_through_command(\n    cmd: &str,\n    input: &str,\n    cwd: &Path,\n    bufid: usize,\n) -> io::Result<String> {\n    let mut child = prepare_command(cmd, cwd, bufid)\n        .stdin(Stdio::piped())\n        .stdout(Stdio::piped())\n        .stderr(Stdio::piped())\n        .spawn()?;\n\n    let mut buf = String::new();\n    child.stdin.take().unwrap().write_all(input.as_bytes())?;\n    child.stdout.take().unwrap().read_to_string(&mut buf)?;\n    child.stderr.take().unwrap().read_to_string(&mut buf)?;\n    _ = child.wait();\n\n    Ok(normalize_line_endings(buf))\n}\n", "source": "ad/src/system.rs", "file_type": "rc"}
{"text": "//! Terminal TUI support.\nuse crate::die;\nuse libc::{\n    BRKINT, CS8, ECHO, ICANON, ICRNL, IEXTEN, ISIG, ISTRIP, IXON, OPOST, SA_SIGINFO, SIGWINCH,\n    STDOUT_FILENO, TCSAFLUSH, TIOCGWINSZ, VMIN, VTIME, c_int, c_void, ioctl, sigaction,\n    sighandler_t, siginfo_t, tcgetattr, tcsetattr, termios as Termios,\n};\nuse serde::Deserialize;\nuse std::{\n    fmt,\n    io::{self, Write},\n    mem, ptr,\n    sync::atomic::{AtomicBool, Ordering},\n};\n\n// ANSI escape codes:\n//   https://vt100.net/docs/vt100-ug/chapter3.html\nconst CLEAR_SCREEN: &str = \"\\x1b[2J\";\nconst ENABLE_MOUSE_SUPPORT: &str = \"\\x1b[?1000h\\x1b[?1002h\\x1b[?1015h\\x1b[?1006h\";\nconst DISABLE_MOUSE_SUPPORT: &str = \"\\x1b[?1006l\\x1b[?1015l\\x1b[?1002l\\x1b[?1000l\";\nconst ENABLE_ALTERNATE_SCREEN: &str = \"\\x1b[?1049h\";\nconst DISABLE_ALTERNATE_SCREEN: &str = \"\\x1b[?1049l\";\nconst ENABLE_BRACKETED_PASTE: &str = \"\\x1b[?2004h\";\nconst DISABLE_BRACKETED_PASTE: &str = \"\\x1b[?2004l\";\npub const RESET_STYLE: &str = \"\\x1b[m\";\n\n/// Used for storing and checking whether or not we've received a signal that our window\n/// size has changed.\nstatic WIN_SIZE_CHANGED: AtomicBool = AtomicBool::new(false);\n\nextern \"C\" fn handle_win_size_change(_: c_int, _: *mut siginfo_t, _: *mut c_void) {\n    WIN_SIZE_CHANGED.store(true, Ordering::Relaxed)\n}\n\n#[inline]\npub(crate) fn win_size_changed() -> bool {\n    WIN_SIZE_CHANGED.swap(false, Ordering::Relaxed)\n}\n\n/// # Safety\n/// must only be called once\npub unsafe fn register_signal_handler() {\n    let mut maybe_sa = mem::MaybeUninit::<sigaction>::uninit();\n    // SAFETY: we are meeting the C API requirements around usage of null pointers\n    unsafe {\n        if libc::sigemptyset(&mut (*maybe_sa.as_mut_ptr()).sa_mask) == -1 {\n            die!(\n                \"Unable to register signal handler: {}\",\n                io::Error::last_os_error()\n            )\n        }\n\n        let mut sa_ptr = *maybe_sa.as_mut_ptr();\n        sa_ptr.sa_sigaction = handle_win_size_change as *const () as sighandler_t;\n        sa_ptr.sa_flags = SA_SIGINFO;\n\n        if libc::sigaction(SIGWINCH, &sa_ptr as *const _, ptr::null_mut()) == -1 {\n            die!(\n                \"Unable to register signal handler: {}\",\n                io::Error::last_os_error()\n            )\n        }\n    }\n}\n\n#[derive(Debug, Default, Clone, Copy, PartialEq, Eq, Deserialize)]\n#[serde(try_from = \"String\", into = \"String\")]\npub struct Color {\n    r: u8,\n    g: u8,\n    b: u8,\n}\n\nimpl Color {\n    pub fn as_rgb_hex_string(&self) -> String {\n        let rgb: u32 = ((self.r as u32) << 16) + ((self.g as u32) << 8) + self.b as u32;\n        format!(\"#{:0>6X}\", rgb)\n    }\n}\n\nimpl From<Color> for String {\n    fn from(value: Color) -> Self {\n        value.as_rgb_hex_string()\n    }\n}\n\nimpl TryFrom<&str> for Color {\n    type Error = String;\n\n    fn try_from(s: &str) -> Result<Self, String> {\n        let [_, r, g, b] = match u32::from_str_radix(s.strip_prefix('#').unwrap_or(s), 16) {\n            Ok(hex) => hex.to_be_bytes(),\n            Err(e) => return Err(format!(\"invalid color ('{s}'): {e}\")),\n        };\n\n        Ok(Self { r, g, b })\n    }\n}\n\nimpl TryFrom<String> for Color {\n    type Error = String;\n\n    fn try_from(value: String) -> Result<Self, Self::Error> {\n        Self::try_from(value.as_str())\n    }\n}\n\n#[derive(Debug, Default, Clone, Copy, PartialEq, Eq)]\npub struct Styles {\n    pub fg: Option<Color>,\n    pub bg: Option<Color>,\n    pub bold: bool,\n    pub italic: bool,\n    pub underline: bool,\n}\n\nimpl fmt::Display for Styles {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        if let Some(fg) = self.fg {\n            write!(f, \"{}\", Style::Fg(fg))?;\n        }\n        if let Some(bg) = self.bg {\n            write!(f, \"{}\", Style::Bg(bg))?;\n        }\n        if self.bold {\n            write!(f, \"{}\", Style::Bold)?;\n        }\n        if self.italic {\n            write!(f, \"{}\", Style::Italic)?;\n        }\n        if self.underline {\n            write!(f, \"{}\", Style::Underline)?;\n        }\n\n        Ok(())\n    }\n}\n\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum Style {\n    Fg(Color),\n    Bg(Color),\n    Bold,\n    NoBold,\n    Italic,\n    NoItalic,\n    Underline,\n    NoUnderline,\n    Reverse,\n    NoReverse,\n    Reset,\n}\n\n// https://gist.github.com/fnky/458719343aabd01cfb17a3a4f7296797#8-16-colors\nimpl fmt::Display for Style {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        use Style::*;\n\n        match self {\n            Fg(Color { r, b, g }) => write!(f, \"\\x1b[38;2;{r};{g};{b}m\"),\n            Bg(Color { r, b, g }) => write!(f, \"\\x1b[48;2;{r};{g};{b}m\"),\n            Bold => write!(f, \"\\x1b[1m\"),\n            NoBold => write!(f, \"\\x1b[22m\"),\n            Italic => write!(f, \"\\x1b[3m\"),\n            NoItalic => write!(f, \"\\x1b[23m\"),\n            Underline => write!(f, \"\\x1b[4m\"),\n            NoUnderline => write!(f, \"\\x1b[24m\"),\n            Reverse => write!(f, \"\\x1b[7m\"),\n            NoReverse => write!(f, \"\\x1b[27m\"),\n            Reset => write!(f, \"\\x1b[m\"),\n        }\n    }\n}\n\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub(crate) enum Cursor {\n    To(usize, usize),\n    ToStart,\n    Hide,\n    Show,\n    ClearRight,\n}\n\nimpl fmt::Display for Cursor {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        use Cursor::*;\n\n        match self {\n            To(x, y) => write!(f, \"\\x1b[{y};{x}H\"),\n            ToStart => write!(f, \"\\x1b[H\"),\n            Hide => write!(f, \"\\x1b[?25l\"),\n            Show => write!(f, \"\\x1b[?25h\"),\n            ClearRight => write!(f, \"\\x1b[K\"),\n        }\n    }\n}\n\n#[allow(dead_code)]\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum CurShape {\n    Block,\n    Bar,\n    Underline,\n    BlinkingBlock,\n    BlinkingBar,\n    BlinkingUnderline,\n}\n\nimpl fmt::Display for CurShape {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        use CurShape::*;\n\n        match self {\n            BlinkingBlock => write!(f, \"\\x1b[\\x31 q\"),\n            Block => write!(f, \"\\x1b[\\x32 q\"),\n            BlinkingUnderline => write!(f, \"\\x1b[\\x33 q\"),\n            Underline => write!(f, \"\\x1b[\\x34 q\"),\n            BlinkingBar => write!(f, \"\\x1b[\\x35 q\"),\n            Bar => write!(f, \"\\x1b[\\x36 q\"),\n        }\n    }\n}\n\n/// Request the current terminal size from the kernel using ioctl\npub(crate) fn get_termsize() -> (usize, usize) {\n    #[repr(C)]\n    struct Termsize {\n        r: u16,\n        c: u16,\n        x: u16,\n        y: u16,\n    }\n\n    let mut ts = Termsize {\n        r: 0,\n        c: 0,\n        x: 0,\n        y: 0,\n    };\n\n    // SAFETY: ts is a valid termsize struct to pass as a pointer here\n    unsafe { ioctl(STDOUT_FILENO, TIOCGWINSZ, &mut ts as *mut _) };\n\n    (ts.r as usize, ts.c as usize)\n}\n\n#[inline]\nfn write_control_seq(seq: &str, desc: &str, stdout: &mut impl Write) {\n    if let Err(e) = stdout.write_all(seq.as_bytes()) {\n        panic!(\"unable to {desc}: {e}\");\n    }\n    if let Err(e) = stdout.flush() {\n        panic!(\"unable to {desc}: {e}\");\n    }\n}\n\npub(crate) fn clear_screen(stdout: &mut impl Write) {\n    write_control_seq(\n        &format!(\"{CLEAR_SCREEN}{}\", Cursor::ToStart),\n        \"clear screen\",\n        stdout,\n    )\n}\n\npub(crate) fn enable_mouse_support(stdout: &mut impl Write) {\n    write_control_seq(ENABLE_MOUSE_SUPPORT, \"enable mouse support\", stdout)\n}\n\npub(crate) fn disable_mouse_support(stdout: &mut impl Write) {\n    write_control_seq(DISABLE_MOUSE_SUPPORT, \"disable mouse support\", stdout)\n}\n\npub(crate) fn enable_alternate_screen(stdout: &mut impl Write) {\n    write_control_seq(ENABLE_ALTERNATE_SCREEN, \"enable alternate screen\", stdout)\n}\n\npub(crate) fn disable_alternate_screen(stdout: &mut impl Write) {\n    write_control_seq(DISABLE_ALTERNATE_SCREEN, \"disable alternate screen\", stdout)\n}\n\npub(crate) fn enable_bracketed_paste(stdout: &mut impl Write) {\n    write_control_seq(ENABLE_BRACKETED_PASTE, \"enable bracketed paste\", stdout)\n}\n\npub(crate) fn disable_bracketed_paste(stdout: &mut impl Write) {\n    write_control_seq(DISABLE_BRACKETED_PASTE, \"disable bracketed paste\", stdout)\n}\n\npub(crate) fn enable_raw_mode(mut t: Termios) {\n    t.c_iflag &= !(BRKINT | ICRNL | ISTRIP | IXON);\n    t.c_oflag &= !OPOST;\n    t.c_cflag |= CS8;\n    t.c_lflag &= !(ECHO | ICANON | IEXTEN | ISIG);\n    t.c_cc[VMIN] = 0;\n    t.c_cc[VTIME] = 1;\n\n    set_termios(t);\n}\n\npub(crate) fn set_termios(t: Termios) {\n    // SAFETY: t is a valid termios struct to use as a pointer here\n    if unsafe { tcsetattr(STDOUT_FILENO, TCSAFLUSH, &t) } == -1 {\n        die!(\"tcsetattr\");\n    }\n}\n\npub(crate) fn get_termios() -> Termios {\n    // SAFETY: passing a null pointer here is valid\n    unsafe {\n        let mut t: Termios = mem::zeroed();\n        if tcgetattr(STDOUT_FILENO, &mut t as *mut _) == -1 {\n            die!(\"tcgetattr\");\n        }\n\n        t\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn color_roundtrip() {\n        let s = \"#FF9E3B\";\n        let c: Color = s.try_into().unwrap();\n\n        assert_eq!(c.as_rgb_hex_string(), s);\n    }\n}\n", "source": "ad/src/term.rs", "file_type": "rc"}
{"text": "//! CLI parser\n//! See main.rs for the usage of the parsed arguments\nuse lexopt::{Parser, prelude::*};\nuse std::{fs, path::PathBuf};\n\npub const USAGE: &str = \"\\\nusage: ad [options] [file ...]     Edit file(s)\n\noptions:\n  -e, --expression <script>        Execute edit script on file(s)\n  -f, --script-file <script-file>  Execute edit script loaded from a script-file on file(s)\n  -9p [-A aname] read [path]       Read the contents of a file on a 9p file server\n  -9p [-A aname] write [path]      Write the contents of stdin to a file on a 9p file server\n  -9p [-A aname] ls [path]         List the contents of a directory on a 9p file server\n  -l, --list-sessions              List the current open editor 9p sessions\n  --rm-sockets                     Remove all unresponsive ad 9p sockets from the default namespace directory\n  -c, --config <path>              Load config from the specified path\n  --default-config                 Force default config instead of loading the user config file\n  -h, --help                       Print this help message\n  -v, --version                    Print version information\n\";\n\n#[derive(Debug)]\npub enum CliAction {\n    OpenEditor {\n        files: Vec<PathBuf>,\n    },\n    RunScript {\n        script: String,\n        files: Vec<PathBuf>,\n    },\n    NineP {\n        aname: String,\n        cmd: Cmd9p,\n        path: String,\n    },\n    ListSessions,\n    RmSockets,\n    ShowHelp,\n    ShowVersion,\n}\n\n#[derive(Debug)]\npub enum Cmd9p {\n    Read,\n    Write,\n    List,\n}\n\n#[derive(Debug)]\npub struct ParsedArgs {\n    pub action: CliAction,\n    pub config_source: ConfigSource,\n}\n\n#[derive(Debug)]\npub enum ConfigSource {\n    Default,\n    User,\n    Custom(PathBuf),\n}\n\nimpl ParsedArgs {\n    pub fn try_parse() -> Result<Self, String> {\n        let mut parser = Parser::from_env();\n\n        Self::try_from_parser(&mut parser).map_err(|e| e.to_string())\n    }\n\n    fn try_from_parser(parser: &mut Parser) -> Result<Self, lexopt::Error> {\n        let mut action: Option<CliAction> = None;\n        let mut config_source = ConfigSource::User;\n        let mut config_set = false;\n\n        loop {\n            // If we've already parsed a valid action and there are arguments remaining then the\n            // command line as a whole is invalid.\n            if action.is_some()\n                && let Some(raw_args) = parser.try_raw_args()\n            {\n                match raw_args.peek() {\n                    Some(arg) => return Err(lexopt::Error::UnexpectedArgument(arg.to_os_string())),\n                    None => break,\n                }\n            }\n\n            if let Some(true) = is_9p_option(parser) {\n                action = Some(parse_9p(parser)?);\n                continue;\n            }\n\n            match parser.next()? {\n                Some(arg) => match arg {\n                    Short('e') | Long(\"expression\") => {\n                        let script = parser\n                            .value()?\n                            .into_string()\n                            .map_err(lexopt::Error::NonUnicodeValue)?;\n                        let files: Vec<PathBuf> = match parser.values() {\n                            Ok(vals) => vals.map(PathBuf::from).collect(),\n                            Err(_) => Vec::new(),\n                        };\n                        action = Some(CliAction::RunScript { script, files });\n                    }\n\n                    Short('f') | Long(\"script-file\") => {\n                        let fname = parser.value()?;\n                        match fs::read_to_string(&fname) {\n                            Ok(script) => {\n                                let files: Vec<PathBuf> = match parser.values() {\n                                    Ok(vals) => vals.map(PathBuf::from).collect(),\n                                    Err(_) => Vec::new(),\n                                };\n                                action = Some(CliAction::RunScript { script, files });\n                            }\n\n                            Err(e) => {\n                                return Err(lexopt::Error::from(format!(\n                                    \"unable to load script file from {}: {e}\",\n                                    fname.to_string_lossy()\n                                )));\n                            }\n                        }\n                    }\n\n                    Short('l') | Long(\"list-sessions\") => action = Some(CliAction::ListSessions),\n                    Short('v') | Long(\"version\") => action = Some(CliAction::ShowVersion),\n                    Short('h') | Long(\"help\") => action = Some(CliAction::ShowHelp),\n                    Long(\"rm-sockets\") => action = Some(CliAction::RmSockets),\n\n                    Short('c') | Long(\"config\") => {\n                        if config_set {\n                            return Err(lexopt::Error::from(\"config source already specified\"));\n                        }\n                        let path = PathBuf::from(parser.value()?);\n                        if !path.exists() {\n                            return Err(lexopt::Error::from(format!(\n                                \"config path does not exist: {}\",\n                                path.display()\n                            )));\n                        } else if !path.is_file() {\n                            return Err(lexopt::Error::from(format!(\n                                \"config path is not a file: {}\",\n                                path.display()\n                            )));\n                        }\n                        config_source = ConfigSource::Custom(path);\n                        config_set = true;\n                    }\n\n                    Long(\"default-config\") => {\n                        if config_set {\n                            return Err(lexopt::Error::from(\"config source already specified\"));\n                        }\n                        config_source = ConfigSource::Default;\n                        config_set = true;\n                    }\n\n                    Value(fname) if action.is_none() => {\n                        let files: Vec<PathBuf> = match parser.values() {\n                            Ok(vals) => std::iter::once(fname)\n                                .chain(vals)\n                                .map(PathBuf::from)\n                                .collect(),\n                            Err(_) => vec![PathBuf::from(fname)],\n                        };\n\n                        action = Some(CliAction::OpenEditor { files });\n                    }\n\n                    _ => return Err(arg.unexpected()),\n                },\n\n                None => break,\n            }\n        }\n\n        Ok(ParsedArgs {\n            action: action.unwrap_or_else(|| CliAction::OpenEditor { files: Vec::new() }),\n            config_source,\n        })\n    }\n}\n\nfn is_9p_option(parser: &mut Parser) -> Option<bool> {\n    let mut raw = parser.try_raw_args()?;\n    let arg = raw.peek()?.to_str()?;\n\n    if arg == \"-9p\" {\n        raw.next(); // consume the -9p arg\n        Some(true)\n    } else {\n        Some(false)\n    }\n}\n\nfn parse_9p(parser: &mut Parser) -> Result<CliAction, lexopt::Error> {\n    let arg = parser.next()?.ok_or(lexopt::Error::MissingValue {\n        option: Some(\"9p\".into()),\n    })?;\n\n    let mut aname = String::new();\n\n    let next = match arg {\n        Short('A') => {\n            aname = parser\n                .value()?\n                .into_string()\n                .map_err(lexopt::Error::NonUnicodeValue)?;\n            parser.next()?\n        }\n        Value(val) => Some(Value(val)),\n        _ => return Err(arg.unexpected()),\n    };\n\n    let cmd = match next {\n        Some(arg) => match arg {\n            Value(cmd) => match cmd.to_str() {\n                Some(\"read\") => Cmd9p::Read,\n                Some(\"write\") => Cmd9p::Write,\n                Some(\"ls\") => Cmd9p::List,\n                _ => return Err(Value(cmd).unexpected()),\n            },\n            _ => return Err(arg.unexpected()),\n        },\n        None => return Err(lexopt::Error::from(\"no command provided for -9p\")),\n    };\n\n    let path = match parser.next()? {\n        Some(Value(s)) => s.into_string().map_err(lexopt::Error::NonUnicodeValue)?,\n        Some(arg) => return Err(arg.unexpected()),\n        None => return Err(lexopt::Error::from(\"no path provided for -9p\")),\n    };\n\n    Ok(CliAction::NineP { aname, cmd, path })\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use simple_test_case::test_case;\n\n    #[test_case(\"\"; \"no args at all\")]\n    #[test_case(\"foo.txt\"; \"single file\")]\n    #[test_case(\"foo.txt bar.json\"; \"multiple files\")]\n    #[test_case(\"-e 'script' foo.txt\"; \"edit script\")]\n    #[test_case(\"-e 'script'\"; \"edit script with no files\")]\n    #[test_case(\"--expression 'script' foo.txt\"; \"edit script long\")]\n    #[test_case(\"--expression 'script'\"; \"edit script with no files long\")]\n    #[test_case(\"-f README.md foo.txt\"; \"script file\")] // needs to be a real file\n    #[test_case(\"-f README.md\"; \"script file with no files\")]\n    #[test_case(\"--script-file README.md foo.txt\"; \"script file long\")] // needs to be a real file\n    #[test_case(\"--script-file README.md\"; \"script file with no files long\")]\n    #[test_case(\"-9p read ad/buffers/index\"; \"9p read\")]\n    #[test_case(\"-9p write ad/buffers/1/dot\"; \"9p write\")]\n    #[test_case(\"-9p ls ad/buffers\"; \"9p ls\")]\n    #[test_case(\"-9p -A foo read ad/buffers/index\"; \"9p read with aname\")]\n    #[test_case(\"-9p -A foo write ad/buffers/1/dot\"; \"9p write with aname\")]\n    #[test_case(\"-9p -A foo ls ad/buffers\"; \"9p ls with aname\")]\n    #[test_case(\"-h\"; \"short help\")]\n    #[test_case(\"--help\"; \"long help\")]\n    #[test_case(\"-v\"; \"short version\")]\n    #[test_case(\"--version\"; \"long version\")]\n    #[test_case(\"-c README.md\"; \"config short\")]\n    #[test_case(\"--config README.md\"; \"config long\")]\n    #[test_case(\"--default-config\"; \"default config\")]\n    #[test_case(\"-c README.md foo.txt\"; \"config with file\")]\n    #[test_case(\"--default-config foo.txt\"; \"default config with file\")]\n    #[test]\n    fn valid_args(cmd_line: &str) {\n        let it = cmd_line.split_whitespace().map(|s| s.to_string());\n        let mut parser = Parser::from_args(it);\n        let res = ParsedArgs::try_from_parser(&mut parser);\n\n        assert!(res.is_ok(), \"{res:?}\");\n    }\n\n    // actually invalid argument cases\n    #[test_case(\"-e\"; \"edit script with no script\")]\n    #[test_case(\"--expression\"; \"edit script with no script long\")]\n    #[test_case(\"-f\"; \"script file with no script file\")]\n    #[test_case(\"--script-file\"; \"script file with no script file long\")]\n    #[test_case(\"-f foo.txt\"; \"script file with unknown script file\")]\n    #[test_case(\"--script-file foo.txt\"; \"script file with unknown script file long\")]\n    #[test_case(\"-c\"; \"config with no path\")]\n    #[test_case(\"--config\"; \"config with no path long\")]\n    #[test_case(\"-c nonexistent.toml\"; \"config with nonexistent path\")]\n    #[test_case(\"--config nonexistent.toml\"; \"config with nonexistent path long\")]\n    #[test_case(\"--default-config -c README.md\"; \"both default and custom config\")]\n    #[test_case(\"-c README.md --default-config\"; \"both custom and default config\")]\n    #[test_case(\"-c README.md -c README.md\"; \"duplicate config flag\")]\n    #[test]\n    fn invalid_args(cmd_line: &str) {\n        let it = cmd_line.split_whitespace().map(|s| s.to_string());\n        let mut parser = Parser::from_args(it);\n        let res = ParsedArgs::try_from_parser(&mut parser);\n\n        assert!(res.is_err(), \"{res:?}\");\n    }\n}\n", "source": "ad/src/cli.rs", "file_type": "rc"}
{"text": "//! A terminal UI for ad\nuse crate::{\n    ORIGINAL_TERMIOS,\n    buffer::{Buffer, Chars, GapBuffer},\n    config::{ColorScheme, Config},\n    config_handle, die,\n    dot::Range,\n    editor::{Click, MiniBufferState},\n    input::Event,\n    key::{Input, MouseButton, MouseEvent},\n    restore_terminal_state,\n    syntax::{LineIter, RangeToken},\n    term::{\n        CurShape, Cursor, RESET_STYLE, Style, Styles, clear_screen, enable_alternate_screen,\n        enable_bracketed_paste, enable_mouse_support, enable_raw_mode, get_termios, get_termsize,\n        register_signal_handler, win_size_changed,\n    },\n    ui::{\n        Layout, StateChange, UserInterface,\n        layout::{Column, Scratch, Window},\n    },\n    ziplist,\n};\nuse std::{\n    char,\n    cmp::Ordering,\n    collections::HashMap,\n    fmt::Write as _,\n    io::{self, BufWriter, Read, StdoutLock, Write, stdin, stdout},\n    iter::{Peekable, repeat_n},\n    panic,\n    sync::{Arc, RwLock, mpsc::Sender},\n    thread::{JoinHandle, spawn},\n    time::Instant,\n};\nuse tracing::debug;\nuse unicode_width::{UnicodeWidthChar, UnicodeWidthStr};\n\n// If the screen dimensions drop below these values then we disable rendering\nconst MIN_COLS: usize = 20;\nconst MIN_ROWS: usize = 5;\n\nconst H_STR: &str = \"\u2500\";\nconst V_STR: &str = \"\u2502\";\nconst TR_STR: &str = \"\u251c\";\nconst TL_STR: &str = \"\u2524\";\nconst X_STR: &str = \"\u253c\";\n\npub type Tui = GenericTui<StdoutLock<'static>>;\n\n#[derive(Debug)]\npub struct GenericTui<W: Write> {\n    stdout: BufWriter<W>,\n    config: Arc<RwLock<Config>>,\n    status_message: String,\n    last_status: Instant,\n    mb_last_frame: bool,\n    frame: Frame,\n}\n\nimpl Default for Tui {\n    fn default() -> Self {\n        Self::new(Default::default())\n    }\n}\n\nimpl<W: Write> Drop for GenericTui<W> {\n    fn drop(&mut self) {\n        restore_terminal_state(&mut self.stdout);\n    }\n}\n\nimpl Tui {\n    pub fn new(config: Arc<RwLock<Config>>) -> Self {\n        Self::new_with_stdout_handle(config, stdout().lock())\n    }\n}\n\nimpl<W: Write> GenericTui<W> {\n    pub fn new_with_stdout_handle(config: Arc<RwLock<Config>>, stdout: W) -> Self {\n        Self {\n            stdout: BufWriter::new(stdout),\n            config,\n            status_message: String::new(),\n            last_status: Instant::now(),\n            mb_last_frame: false,\n            frame: Frame::new(),\n        }\n    }\n\n    pub fn set_size(&mut self, rows: usize, cols: usize) {\n        self.frame.screen_rows = rows;\n        self.frame.screen_cols = cols;\n    }\n\n    fn render(\n        &mut self,\n        mode_name: &str,\n        layout: &Layout,\n        n_running: usize,\n        pending_keys: &[Input],\n        held_click: Option<&Click>,\n        mb: Option<MiniBufferState<'_>>,\n    ) {\n        let conf = config_handle!(self);\n        let (cs, status_timeout, tabstop, max_mb_lines) = (\n            &conf.colorscheme,\n            conf.status_timeout,\n            conf.tabstop,\n            conf.minibuffer_lines,\n        );\n\n        // If we have a minibuffer open then that takes priority over an open scratch buffer\n        let w_minibuffer = mb.is_some();\n        let mb = mb.unwrap_or_default();\n        let active_buffer = layout.active_buffer();\n\n        let mb_has_lines = mb.b.map(|b| !b.is_empty()).unwrap_or_default();\n        let offset = if mb_has_lines {\n            mb.bottom - mb.top + 1\n        } else if !w_minibuffer && layout.scratch.is_visible {\n            max_mb_lines\n        } else {\n            0\n        };\n\n        // This is the screen size that we have to work with for the buffer content we currently want to\n        // display. If the minibuffer is active then it take priority over anything else and we always\n        // show the status bar as the final two lines of the UI.\n        let effective_screen_rows = self.frame.screen_rows.saturating_sub(offset);\n\n        let load_exec_range = match held_click {\n            Some(Click::Text { btn, selection, .. })\n                if *btn == MouseButton::Right || *btn == MouseButton::Middle =>\n            {\n                Some((*btn == MouseButton::Right, *selection))\n            }\n            _ => None,\n        };\n\n        let (load_exec_range, scratch_load_exec_range) = if layout.scratch.is_focused {\n            (None, load_exec_range)\n        } else {\n            (load_exec_range, None)\n        };\n\n        self.frame\n            .render_windows(layout, load_exec_range, effective_screen_rows, tabstop, cs);\n        self.frame\n            .render_status_bar(cs, mode_name, n_running, active_buffer);\n\n        self.frame.show_mb = w_minibuffer || layout.scratch.is_visible;\n        self.frame.show_msg_bar = !w_minibuffer;\n\n        if w_minibuffer {\n            self.frame.render_minibuffer_state(&mb, tabstop, cs);\n        } else if layout.scratch.is_visible {\n            self.frame\n                .render_scratch(&layout.scratch, scratch_load_exec_range, tabstop, cs);\n        };\n\n        if self.frame.show_msg_bar {\n            self.frame.render_message_bar(\n                cs,\n                pending_keys,\n                status_timeout,\n                self.status_message.clone(),\n                self.last_status,\n            );\n        };\n\n        let (cur_x, cur_y) = if w_minibuffer {\n            (mb.cx, self.frame.screen_rows + mb.n_visible_lines + 1)\n        } else {\n            layout.ui_xy()\n        };\n\n        self.frame.cur_x = cur_x;\n        self.frame.cur_y = cur_y;\n    }\n}\n\nimpl<W: Write> UserInterface for GenericTui<W> {\n    fn init(&mut self, tx: Sender<Event>) -> (usize, usize) {\n        let original_termios = get_termios();\n        enable_raw_mode(original_termios);\n        _ = ORIGINAL_TERMIOS.set(original_termios);\n\n        panic::set_hook(Box::new(|panic_info| {\n            let mut stdout = stdout();\n            restore_terminal_state(&mut stdout);\n            _ = stdout.flush();\n\n            // Force capturing a backtrace for easier debugging\n            let bt = std::backtrace::Backtrace::force_capture();\n\n            // Restoring the terminal state to move us off of the alternate screen\n            // can race with our attempt to print the panic info so given that we\n            // are already in a fatal situation, sleeping briefly to ensure that\n            // the cause of the panic is visible before we exit isn't _too_ bad.\n            std::thread::sleep(std::time::Duration::from_millis(300));\n            eprintln!(\"Fatal error:\\n{panic_info}\\n{bt}\");\n            _ = std::fs::write(\"/tmp/ad.panic\", format!(\"{panic_info}\\n{bt}\"));\n        }));\n\n        enable_mouse_support(&mut self.stdout);\n        enable_alternate_screen(&mut self.stdout);\n        enable_bracketed_paste(&mut self.stdout);\n\n        // SAFETY: we only register our signal handler once\n        unsafe { register_signal_handler() };\n\n        let (screen_rows, screen_cols) = get_termsize();\n        self.frame.screen_rows = screen_rows;\n        self.frame.screen_cols = screen_cols;\n\n        spawn_input_thread(tx);\n\n        (screen_rows, screen_cols)\n    }\n\n    fn shutdown(&mut self) {\n        clear_screen(&mut self.stdout);\n    }\n\n    fn state_change(&mut self, change: StateChange) {\n        match change {\n            StateChange::ConfigUpdated => self.frame.style_cache.clear(),\n            StateChange::StatusMessage { msg } => {\n                self.status_message = msg;\n                self.last_status = Instant::now();\n            }\n        }\n    }\n\n    fn refresh(\n        &mut self,\n        mode_name: &str,\n        layout: &mut Layout,\n        n_running: usize,\n        pending_keys: &[Input],\n        held_click: Option<&Click>,\n        mb: Option<MiniBufferState<'_>>,\n    ) {\n        self.frame.screen_rows = layout.screen_rows;\n        self.frame.screen_cols = layout.screen_cols;\n        self.frame.show_msg_bar = mb.is_none();\n        let mb_this_frame = mb.is_some();\n\n        if self.frame.screen_cols < MIN_COLS || self.frame.screen_rows < MIN_ROWS {\n            return;\n        }\n\n        // If the UI changed or we have an active minibuffer then we need to rerender the UI.\n        // We also need to re-render on the frame after a minibuffer is closed in order to\n        // get rid of it, as none of the other buffers in the layout will be marked as changed\n        // since the last render.\n        let need_render = layout.changed_since_last_render()\n            || mb_this_frame\n            || self.mb_last_frame | held_click.is_some();\n\n        if need_render {\n            layout.update_visible_ts_state();\n            self.render(mode_name, layout, n_running, pending_keys, held_click, mb);\n            if let Err(e) = self.frame.write(&mut self.stdout) {\n                die!(\"Unable to refresh screen: {e}\");\n            }\n        } else if self.frame.show_msg_bar {\n            // match self.render in not showing the message bar if the minibuffer is open\n            let conf = config_handle!(self);\n            let (cs, status_timeout) = (&conf.colorscheme, conf.status_timeout);\n            self.frame.render_message_bar(\n                cs,\n                pending_keys,\n                status_timeout,\n                self.status_message.clone(),\n                self.last_status,\n            );\n            if let Err(e) = self.frame.write_msg_bar(&mut self.stdout) {\n                die!(\"Unable to refresh screen: {e}\");\n            }\n        }\n\n        if let Err(e) = self.stdout.flush() {\n            die!(\"Unable to refresh screen: {e}\");\n        }\n\n        self.mb_last_frame = mb_this_frame;\n    }\n\n    fn set_cursor_shape(&mut self, cur_shape: CurShape) {\n        if let Err(e) = self.stdout.write_all(cur_shape.to_string().as_bytes()) {\n            // In this situation we're probably not going to be able to do all that much\n            // but we might as well try\n            die!(\"Unable to write to stdout: {e}\");\n        };\n    }\n}\n\n#[derive(Debug, Default)]\npub struct Frame {\n    win_lines: String,\n    status_bar: String,\n    mb_lines: String,\n    show_mb: bool,\n    msg_bar: String,\n    show_msg_bar: bool,\n    screen_rows: usize,\n    screen_cols: usize,\n    cur_x: usize,\n    cur_y: usize,\n    // Cache of the ANSI escape code strings required for each fully qualified tree-sitter\n    // highlighting tag. See render_line for details on how the cache is used.\n    style_cache: HashMap<String, String>,\n}\n\nimpl Frame {\n    fn new() -> Self {\n        let win_lines_cap = 128 * 1024;\n        let bar_cap = 8 * 1024;\n\n        Self {\n            win_lines: String::with_capacity(win_lines_cap),\n            mb_lines: String::with_capacity(bar_cap),\n            status_bar: String::with_capacity(bar_cap),\n            msg_bar: String::with_capacity(bar_cap),\n            ..Default::default()\n        }\n    }\n\n    fn write(&self, w: &mut impl Write) -> io::Result<()> {\n        write!(w, \"{}{}\", Cursor::Hide, Cursor::ToStart)?;\n        w.write_all(self.win_lines.as_bytes())?;\n        w.write_all(self.status_bar.as_bytes())?;\n        if self.show_mb {\n            w.write_all(self.mb_lines.as_bytes())?;\n        }\n        if self.show_msg_bar {\n            w.write_all(self.msg_bar.as_bytes())?;\n        }\n\n        write!(\n            w,\n            \"{}{}\",\n            Cursor::To(self.cur_x + 1, self.cur_y + 1),\n            Cursor::Show\n        )\n    }\n\n    fn write_msg_bar(&self, w: &mut impl Write) -> io::Result<()> {\n        write!(w, \"{}{}\", Cursor::Hide, Cursor::To(1, self.screen_rows + 2))?;\n        w.write_all(self.msg_bar.as_bytes())?;\n        write!(\n            w,\n            \"{}{}\",\n            Cursor::To(self.cur_x + 1, self.cur_y + 1),\n            Cursor::Show\n        )\n    }\n\n    fn render_windows(\n        &mut self,\n        layout: &Layout,\n        load_exec_range: Option<(bool, Range)>,\n        screen_rows: usize,\n        tabstop: usize,\n        cs: &ColorScheme,\n    ) {\n        self.win_lines.clear();\n\n        let mut col_renderers: Vec<_> = layout\n            .cols\n            .iter()\n            .map(|(is_focus, col)| {\n                let rng = if is_focus { load_exec_range } else { None };\n                ColRenderer::new(col, layout, rng, screen_rows, tabstop, cs)\n            })\n            .collect();\n\n        let n_cols = col_renderers.len();\n        'outer: loop {\n            let mut remaining;\n            let mut prev_col = None;\n\n            for (i, cr) in col_renderers.iter_mut().enumerate() {\n                (remaining, prev_col) =\n                    cr.render_next_line(&mut self.win_lines, prev_col, &mut self.style_cache);\n                if i == n_cols - 1 && !remaining {\n                    _ = write!(&mut self.win_lines, \"{}\\r\\n\", Cursor::ClearRight);\n                    break 'outer;\n                }\n            }\n\n            _ = write!(&mut self.win_lines, \"{}\\r\\n\", Cursor::ClearRight);\n        }\n    }\n\n    fn render_status_bar(\n        &mut self,\n        cs: &ColorScheme,\n        mode_name: &str,\n        n_running: usize,\n        b: &Buffer,\n    ) {\n        self.status_bar.clear();\n\n        let lstatus = format!(\n            \"{} {} - {} lines {}{}\",\n            mode_name,\n            b.display_name(),\n            b.len_lines(),\n            if b.dirty { \"[+]\" } else { \"\" },\n            if !b.has_trailing_newline() {\n                \"[noeol]\"\n            } else {\n                \"\"\n            }\n        );\n        let rstatus = format!(\n            \"{}{}\",\n            if n_running == 0 {\n                String::new()\n            } else {\n                format!(\"[{n_running} running] \")\n            },\n            b.dot.addr(b)\n        );\n        let width = self\n            .screen_cols\n            .saturating_sub(UnicodeWidthStr::width(lstatus.as_str()));\n\n        _ = write!(\n            &mut self.status_bar,\n            \"{}{}{lstatus}{rstatus:>width$}{}\\r\\n\",\n            Style::Bg(cs.bar_bg),\n            Style::Fg(cs.fg),\n            Style::Reset\n        );\n    }\n\n    // current prompt and pending chars\n    fn render_message_bar(\n        &mut self,\n        cs: &ColorScheme,\n        pending_keys: &[Input],\n        status_timeout: u64,\n        mut msg: String,\n        last_status: Instant,\n    ) {\n        self.msg_bar.clear();\n        self.msg_bar.push_str(&Cursor::ClearRight.to_string());\n        msg.truncate(self.screen_cols.saturating_sub(10));\n\n        let pending = render_pending(pending_keys);\n        let delta = (Instant::now() - last_status).as_secs();\n\n        if !msg.is_empty() && delta < status_timeout {\n            let width = self\n                .screen_cols\n                .saturating_sub(msg.len())\n                .saturating_sub(10);\n            _ = write!(\n                &mut self.msg_bar,\n                \"{}{}{msg}{pending:>width$}          \",\n                Style::Fg(cs.fg),\n                Style::Bg(cs.bg)\n            );\n        } else {\n            let width = self.screen_cols.saturating_sub(10);\n            _ = write!(\n                &mut self.msg_bar,\n                \"{}{}{pending:>width$}          \",\n                Style::Fg(cs.fg),\n                Style::Bg(cs.bg)\n            );\n        }\n    }\n\n    fn render_minibuffer_state(\n        &mut self,\n        mb: &MiniBufferState<'_>,\n        tabstop: usize,\n        cs: &ColorScheme,\n    ) {\n        self.mb_lines.clear();\n\n        if let Some(b) = mb.b {\n            for i in mb.top..=mb.bottom {\n                let slice = b.line(i).unwrap();\n                let bg = if i == mb.selected_line_idx {\n                    cs.minibuffer_hl\n                } else {\n                    cs.bg\n                };\n\n                let mut cols = 0;\n                let mut chars = slice.chars().peekable();\n                _ = write!(\n                    &mut self.mb_lines,\n                    \"{}\",\n                    Styles {\n                        fg: Some(cs.fg),\n                        bg: Some(bg),\n                        ..Default::default()\n                    }\n                );\n\n                render_chars(\n                    &mut chars,\n                    None,\n                    self.screen_cols,\n                    tabstop,\n                    &mut cols,\n                    &mut self.mb_lines,\n                );\n\n                if cols < self.screen_cols {\n                    self.mb_lines.push_str(&Style::Bg(bg).to_string());\n                }\n\n                let width = self.screen_cols;\n                _ = write!(&mut self.mb_lines, \"{:>width$}\\r\\n\", Cursor::ClearRight);\n            }\n        }\n\n        _ = write!(\n            &mut self.mb_lines,\n            \"{}{}{}{}{}\",\n            Style::Fg(cs.fg),\n            Style::Bg(cs.bg),\n            mb.prompt,\n            mb.input,\n            Cursor::ClearRight\n        );\n    }\n\n    fn render_scratch(\n        &mut self,\n        scratch: &Scratch,\n        load_exec_range: Option<(bool, Range)>,\n        tabstop: usize,\n        cs: &ColorScheme,\n    ) {\n        self.mb_lines.clear();\n        let b = scratch.b.buffer();\n        let (w_lnum, _) = b.sign_col_dims();\n        let rng = if scratch.is_focused {\n            load_exec_range\n        } else {\n            None\n        };\n\n        let mut wr = WinRenderer {\n            y: 0,\n            w_lnum,\n            n_cols: self.screen_cols,\n            tabstop,\n            it: b.iter_tokenized_lines_from(scratch.w.view.row_off, rng),\n            gb: &b.txt,\n            w: &scratch.w,\n            cs,\n        };\n\n        while wr.render_next_line(&mut self.mb_lines, None, &mut self.style_cache) {}\n    }\n}\n\n#[derive(Clone, Copy)]\nenum PrevCol {\n    Buffer,\n    Hline,\n}\n\nstruct ColRenderer<'a> {\n    inner: ziplist::Iter<'a, Window>,\n    current: Option<WinRenderer<'a>>,\n    layout: &'a Layout,\n    cs: &'a ColorScheme,\n    load_exec_range: Option<(bool, Range)>,\n    screen_rows: usize,\n    tabstop: usize,\n    n_cols: usize,\n    row: usize,\n}\n\nimpl<'a> ColRenderer<'a> {\n    fn new(\n        col: &'a Column,\n        layout: &'a Layout,\n        load_exec_range: Option<(bool, Range)>,\n        screen_rows: usize,\n        tabstop: usize,\n        cs: &'a ColorScheme,\n    ) -> Self {\n        ColRenderer {\n            inner: col.wins.iter(),\n            current: None,\n            layout,\n            cs,\n            load_exec_range,\n            screen_rows,\n            tabstop,\n            n_cols: col.n_cols,\n            row: 0,\n        }\n    }\n\n    fn next_window(&mut self) -> Option<WinRenderer<'a>> {\n        let (is_focus, w) = self.inner.next()?;\n        let b = self\n            .layout\n            .buffer_with_id(w.view.bufid)\n            .expect(\"valid buffer id\");\n\n        let (w_lnum, _) = b.sign_col_dims();\n        let rng = if is_focus { self.load_exec_range } else { None };\n        let it = b.iter_tokenized_lines_from(w.view.row_off, rng);\n\n        Some(WinRenderer {\n            y: 0,\n            w_lnum,\n            n_cols: self.n_cols,\n            tabstop: self.tabstop,\n            it,\n            gb: &b.txt,\n            w,\n            cs: self.cs,\n        })\n    }\n\n    /// Render the next available line into the provided buffer.\n    ///\n    /// Returns false if there are no more lines to render.\n    fn render_next_line(\n        &mut self,\n        buf: &mut String,\n        prev_col: Option<PrevCol>,\n        style_cache: &mut HashMap<String, String>,\n    ) -> (bool, Option<PrevCol>) {\n        if self.current.is_none() {\n            self.current = match self.next_window() {\n                Some(w) => Some(w),\n                None => return (false, None),\n            }\n        }\n\n        let lines_remaining =\n            self.current\n                .as_mut()\n                .unwrap()\n                .render_next_line(buf, prev_col, style_cache);\n        self.row += 1;\n\n        let this_col = if lines_remaining {\n            Some(PrevCol::Buffer)\n        } else {\n            self.current = None;\n            let left_edge = match prev_col {\n                Some(PrevCol::Buffer) => TR_STR,\n                Some(PrevCol::Hline) => X_STR,\n                None => \"\",\n            };\n\n            _ = write!(\n                buf,\n                \"{}{}{left_edge}{}\",\n                Style::Fg(self.cs.minibuffer_hl),\n                Style::Bg(self.cs.bg),\n                H_STR.repeat(self.n_cols)\n            );\n            Some(PrevCol::Hline)\n        };\n\n        (self.row < self.screen_rows, this_col)\n    }\n}\n\nstruct WinRenderer<'a> {\n    y: usize,\n    w_lnum: usize,\n    n_cols: usize,\n    tabstop: usize,\n    it: LineIter<'a>,\n    gb: &'a GapBuffer,\n    w: &'a Window,\n    cs: &'a ColorScheme,\n}\n\nimpl<'a> WinRenderer<'a> {\n    fn render_next_line(\n        &mut self,\n        buf: &mut String,\n        prev_col: Option<PrevCol>,\n        style_cache: &mut HashMap<String, String>,\n    ) -> bool {\n        if self.y >= self.w.n_rows {\n            return false;\n        }\n\n        let file_row = self.y + self.w.view.row_off;\n        self.y += 1;\n\n        if let Some(pc) = prev_col {\n            let left_edge = match pc {\n                PrevCol::Buffer => V_STR,\n                PrevCol::Hline => TL_STR,\n            };\n\n            _ = write!(\n                buf,\n                \"{}{}{left_edge}\",\n                Style::Fg(self.cs.minibuffer_hl),\n                Style::Bg(self.cs.bg)\n            );\n        }\n\n        match self.it.next() {\n            None => {\n                _ = write!(\n                    buf,\n                    \"{}{}~ {V_STR:>width$}{}\",\n                    Style::Fg(self.cs.signcol_fg),\n                    Style::Bg(self.cs.bg),\n                    Style::Fg(self.cs.fg),\n                    width = self.w_lnum\n                );\n                let padding = self.n_cols.saturating_sub(self.w_lnum).saturating_sub(2);\n                buf.push_str(&\" \".repeat(padding));\n            }\n\n            Some(it) => {\n                // +2 for the leading space and vline chars\n                let padding = self.w_lnum + 2;\n\n                _ = write!(\n                    buf,\n                    \"{}{} {:>width$}{V_STR}\",\n                    Style::Fg(self.cs.signcol_fg),\n                    Style::Bg(self.cs.bg),\n                    file_row + 1,\n                    width = self.w_lnum\n                );\n\n                render_line(\n                    self.gb,\n                    it,\n                    self.w.view.col_off,\n                    self.n_cols.saturating_sub(padding),\n                    self.tabstop,\n                    self.cs,\n                    style_cache,\n                    buf,\n                );\n            }\n        };\n\n        true\n    }\n}\n\nfn render_pending(keys: &[Input]) -> String {\n    let mut s = String::new();\n    for k in keys {\n        match k {\n            Input::Char(c) if c.is_ascii_whitespace() => s.push_str(&format!(\"<{:x}>\", *c as u8)),\n            Input::Char(c) => s.push(*c),\n            Input::Ctrl(c) => {\n                s.push('^');\n                s.push(*c);\n            }\n            Input::Alt(c) => {\n                s.push('^');\n                s.push('[');\n                s.push(*c);\n            }\n            Input::CtrlAlt(c) => {\n                s.push('^');\n                s.push('[');\n                s.push('^');\n                s.push(*c);\n            }\n\n            _ => (),\n        }\n    }\n\n    if s.len() > 10 {\n        s = s.split_off(s.len() - 10);\n    }\n\n    s\n}\n\n#[inline]\nfn skip_token_chars(\n    chars: &mut Peekable<Chars<'_>>,\n    tabstop: usize,\n    to_skip: &mut usize,\n) -> Option<usize> {\n    for ch in chars.by_ref() {\n        let w = if ch == '\\t' {\n            tabstop\n        } else {\n            UnicodeWidthChar::width(ch).unwrap_or(1)\n        };\n\n        match (*to_skip).cmp(&w) {\n            Ordering::Less => {\n                let spaces = Some(w - *to_skip);\n                *to_skip = 0;\n                return spaces;\n            }\n\n            Ordering::Equal => {\n                *to_skip = 0;\n                break;\n            }\n\n            Ordering::Greater => *to_skip -= w,\n        }\n    }\n\n    None\n}\n\nfn render_chars(\n    chars: &mut Peekable<Chars<'_>>,\n    spaces: Option<usize>,\n    max_cols: usize,\n    tabstop: usize,\n    cols: &mut usize,\n    buf: &mut String,\n) {\n    if let Some(n) = spaces {\n        buf.extend(repeat_n(' ', n));\n        *cols = n;\n    }\n\n    for ch in chars {\n        if ch == '\\n' {\n            break;\n        }\n\n        let (w, ch) = if ch == '\\t' {\n            (tabstop, ch)\n        } else {\n            match UnicodeWidthChar::width(ch) {\n                Some(0) | None => (1, char::REPLACEMENT_CHARACTER),\n                Some(n) => (n, ch),\n            }\n        };\n\n        if *cols + w <= max_cols {\n            if ch == '\\t' {\n                // Tab is just a control character that moves the cursor rather than\n                // replacing the previous buffer content so we need to explicitly\n                // insert spaces instead.\n                buf.extend(repeat_n(' ', tabstop));\n            } else {\n                buf.push(ch);\n            }\n            *cols += w;\n        } else {\n            break;\n        }\n    }\n\n    buf.push_str(RESET_STYLE);\n}\n\n#[allow(clippy::too_many_arguments)]\nfn render_line<'a>(\n    gb: &'a GapBuffer,\n    it: impl Iterator<Item = RangeToken<'a>>,\n    col_off: usize,\n    max_cols: usize,\n    tabstop: usize,\n    cs: &ColorScheme,\n    style_cache: &mut HashMap<String, String>,\n    buf: &mut String,\n) {\n    let mut to_skip = col_off;\n    let mut cols = 0;\n\n    for tk in it {\n        let slice = tk.as_slice(gb);\n        let mut chars = slice.chars().peekable();\n        let spaces = if to_skip > 0 {\n            let spaces = skip_token_chars(&mut chars, tabstop, &mut to_skip);\n            if to_skip > 0 || (chars.peek().is_none() && spaces.is_none()) {\n                continue;\n            }\n            spaces\n        } else {\n            None\n        };\n\n        // In the common case we have the styles for each tag already cached, so we take the hit on\n        // allocating the cache key and looking it up a second time when we insert into the cache.\n        // This allows us to avoid having to allocate the key on every lookup in order to make use\n        // of the entry API.\n        //\n        // The cache styles are also stored against the original tag rather so they can be looked\n        // up directly each time they are used, rather than need to to traverse the fallback path\n        // as done in ColorScheme::styles_for.\n        let style_str = match style_cache.get(tk.tag) {\n            Some(s) => s,\n            None => {\n                let s = cs.styles_for(tk.tag).to_string();\n                style_cache.insert(tk.tag.to_string(), s);\n                style_cache.get(tk.tag).unwrap()\n            }\n        };\n\n        buf.push_str(style_str);\n        render_chars(&mut chars, spaces, max_cols, tabstop, &mut cols, buf);\n\n        if cols == max_cols {\n            break;\n        }\n    }\n\n    if cols < max_cols {\n        buf.push_str(&Style::Bg(cs.bg).to_string());\n        buf.extend(repeat_n(' ', max_cols - cols));\n    }\n}\n\n#[derive(Debug)]\nenum RawInput {\n    Input(Input),\n    // Control sequences\n    // https://invisible-island.net/xterm/ctlseqs/ctlseqs.html#h2-Bracketed-Paste-Mode\n    // https://invisible-island.net/xterm/xterm-paste64.html\n    BPasteStart,\n}\n\nimpl From<Input> for RawInput {\n    fn from(value: Input) -> Self {\n        Self::Input(value)\n    }\n}\n\n/// Spawn a thread to read from stdin and process user input to send Events to\n/// the main editor event loop.\nfn spawn_input_thread(tx: Sender<Event>) -> JoinHandle<()> {\n    spawn(move || {\n        let mut stdin = stdin().lock();\n\n        loop {\n            match try_read_input(&mut stdin) {\n                Some(RawInput::Input(i)) => {\n                    _ = tx.send(Event::Input(i));\n                    continue;\n                }\n\n                Some(RawInput::BPasteStart) => {\n                    let mut s = String::new();\n                    let mut buf = Vec::with_capacity(6);\n\n                    while let Some(c) = try_read_char(&mut stdin) {\n                        match (c, buf.as_slice()) {\n                            ('\\x1b', [])\n                            | ('[', ['\\x1b'])\n                            | ('2', ['\\x1b', '['])\n                            | ('0', ['\\x1b', '[', '2'])\n                            | ('1', ['\\x1b', '[', '2', '0']) => buf.push(c),\n\n                            ('~', ['\\x1b', '[', '2', '0', '1']) => {\n                                _ = tx.send(Event::BracketedPaste(s));\n                                break;\n                            }\n\n                            (c, _) => {\n                                s.extend(buf.drain(..));\n                                s.push(c);\n                            }\n                        }\n                    }\n                }\n\n                None => (),\n            }\n\n            // Always check for the window size changing after processing multiple inputs or if we\n            // failed to read anything.\n            if win_size_changed() {\n                let (rows, cols) = get_termsize();\n                _ = tx.send(Event::WinsizeChanged { rows, cols });\n            }\n        }\n    })\n}\n\nfn try_read_char(stdin: &mut impl Read) -> Option<char> {\n    let mut buf: [u8; 4] = [0; 4];\n\n    for i in 0..4 {\n        if stdin.read_exact(&mut buf[i..i + 1]).is_err() {\n            return if i == 0 {\n                None\n            } else {\n                Some(char::REPLACEMENT_CHARACTER)\n            };\n        }\n\n        match std::str::from_utf8(&buf[0..i + 1]) {\n            Ok(s) => return s.chars().next(),\n            Err(e) if e.error_len().is_some() => return Some(char::REPLACEMENT_CHARACTER),\n            Err(_) => (),\n        }\n    }\n\n    // utf8 requires at most 4 bytes so at this point we have invalid data\n    Some(char::REPLACEMENT_CHARACTER)\n}\n\nfn try_read_input(stdin: &mut impl Read) -> Option<RawInput> {\n    let c = try_read_char(stdin)?;\n\n    // Normal key press\n    match Input::from_char(c) {\n        Input::Esc => (),\n        i => return Some(i.into()),\n    }\n\n    let c2 = match try_read_char(stdin) {\n        Some(c2) => c2,\n        None => return Some(Input::Esc.into()),\n    };\n    let c3 = match try_read_char(stdin) {\n        Some(c3) => c3,\n        None => return Some(Input::try_from_seq2(c, c2).unwrap_or(Input::Esc).into()),\n    };\n\n    if let Some(i) = Input::try_from_seq2(c2, c3) {\n        return Some(i.into());\n    }\n\n    // https://en.wikipedia.org/wiki/ANSI_escape_code#Control_Sequence_Introducer_commands\n    if c2 == '[' && c3.is_ascii_digit() {\n        let mut digits = vec![c3];\n        loop {\n            match try_read_char(stdin)? {\n                c if c.is_ascii_digit() => digits.push(c),\n                '~' => break,\n                c => {\n                    debug!(\"unknown CSIC sequence: ^[[{}{c}\", String::from_iter(digits));\n                    return None;\n                }\n            }\n        }\n\n        // https://en.wikipedia.org/wiki/ANSI_escape_code#Control_Sequence_Introducer_commands\n        return match digits.as_slice() {\n            ['1' | '7'] => Some(Input::Home.into()),\n            ['4' | '8'] => Some(Input::End.into()),\n            ['3'] => Some(Input::Del.into()),\n            ['5'] => Some(Input::PageUp.into()),\n            ['6'] => Some(Input::PageDown.into()),\n            ['2', '0', '0'] => Some(RawInput::BPasteStart),\n            // 201 == bracketed paste end\n            _ => None,\n        };\n    }\n\n    // xterm SGR (1006) mouse encoding: \"^[< Cb;Cx;Cy(;) (M or m) \"\n    //   https://invisible-island.net/xterm/ctlseqs/ctlseqs.html#h3-Extended-coordinates\n    if c2 == '[' && c3 == '<' {\n        let mut buf = Vec::new();\n        let m;\n\n        loop {\n            match try_read_char(stdin) {\n                Some(c @ 'm' | c @ 'M') => {\n                    m = c;\n                    break;\n                }\n                Some(c) => buf.push(c as u8),\n                None => return None,\n            };\n        }\n        let s = String::from_utf8(buf).unwrap();\n        let nums: Vec<usize> = s.split(';').map(|s| s.parse::<usize>().unwrap()).collect();\n        let (b, x, y) = (nums[0], nums[1], nums[2]);\n\n        return MouseEvent::try_from_raw(b, x, y, m).map(|i| RawInput::Input(Input::Mouse(i)));\n    }\n\n    Some(Input::Esc.into())\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::syntax::{ByteRange, TK_DEFAULT};\n    use simple_test_case::test_case;\n    use std::{char::REPLACEMENT_CHARACTER, io};\n\n    #[test_case(\"a\".as_bytes(), &['a']; \"single ascii character\")]\n    #[test_case(&[240, 159, 146, 150], &['\ud83d\udc96']; \"single utf8 character\")]\n    #[test_case(&[165, 159, 146, 150], &[REPLACEMENT_CHARACTER; 4]; \"invalid utf8 with non-ascii prefix\")]\n    #[test_case(&[65, 159, 146, 150], &['A', REPLACEMENT_CHARACTER, REPLACEMENT_CHARACTER, REPLACEMENT_CHARACTER]; \"invalid utf8 with ascii prefix\")]\n    #[test]\n    fn try_read_char_works(bytes: &[u8], expected: &[char]) {\n        let mut r = io::Cursor::new(bytes);\n        let mut chars = Vec::new();\n\n        while let Some(ch) = try_read_char(&mut r) {\n            chars.push(ch);\n        }\n\n        assert_eq!(&chars, expected);\n    }\n\n    fn rt(tag: &'static str, from: usize, to: usize) -> RangeToken<'static> {\n        RangeToken {\n            tag,\n            r: ByteRange { from, to },\n        }\n    }\n\n    // https://en.wikipedia.org/wiki/Bidirectional_text#Table_of_possible_BiDi_character_types\n    // https://i18n-puzzles.com/puzzle/18/\n    #[test]\n    fn render_chars_correctly_handles_bidi_markers() {\n        let line = GapBuffer::from(\"\u2067foo\u2066bar\u2069baz\u2069\");\n        let expected = format!(\"\ufffdfoo\ufffdbar\ufffdbaz\ufffd{RESET_STYLE}\");\n\n        let max_cols = line.chars().count();\n        let mut chars = line.chars().peekable();\n        let mut buf = String::with_capacity(line.len());\n        let mut cols = 0;\n\n        render_chars(&mut chars, None, max_cols, 4, &mut cols, &mut buf);\n\n        assert_eq!(buf, expected);\n    }\n\n    // The !| characters here are the dummy style strings in the style_cache\n    // The $# characters are replaced with RESET_STYLE and bg color respectively\n    #[test_case(0, 14, \"foo\\tbar baz\", \"!foo$|  $!bar$| $!baz$#  \"; \"full line padded to max cols\")]\n    #[test_case(0, 12, \"foo\\tbar baz\", \"!foo$|  $!bar$| $!baz$\"; \"full line\")]\n    #[test_case(1, 11, \"foo\\tbar baz\", \"!oo$|  $!bar$| $!baz$\"; \"skipping first character\")]\n    #[test_case(3, 9, \"foo\\tbar baz\", \"|  $!bar$| $!baz$\"; \"skipping first token\")]\n    #[test_case(4, 8, \"foo\\tbar baz\", \"| $!bar$| $!baz$\"; \"skipping part way through a tab\")]\n    #[test_case(0, 10, \"\u4e16\\t\u754c foo\", \"!\u4e16$|  $!\u754c$| $!foo$\"; \"unicode full line\")]\n    #[test_case(0, 12, \"\u4e16\\t\u754c foo\", \"!\u4e16$|  $!\u754c$| $!foo$#  \"; \"unicode full line padded to max cols\")]\n    // In the case where we skip part way through a unicode character we still apply the tag\n    // styling to the spaces we insert to pad to the correct offset rather than replacing it\n    // with default styling instead\n    #[test_case(1, 9, \"\u4e16\\t\u754c foo\", \"! $|  $!\u754c$| $!foo$\"; \"unicode skipping first column of multibyte char\")]\n    #[test]\n    fn render_line_correctly_skips_tokens(\n        col_off: usize,\n        max_cols: usize,\n        s: &str,\n        expected_template: &str,\n    ) {\n        let gb = GapBuffer::from(s);\n        let range_tokens = vec![\n            rt(\"a\", 0, 3),\n            rt(TK_DEFAULT, 3, 4),\n            rt(\"a\", 4, 7),\n            rt(TK_DEFAULT, 7, 8),\n            rt(\"a\", 8, 11),\n        ];\n\n        let cs = ColorScheme::default();\n        let mut style_cache: HashMap<String, String> = [\n            (\"a\".to_owned(), \"!\".to_owned()),\n            (TK_DEFAULT.to_owned(), \"|\".to_owned()),\n        ]\n        .into_iter()\n        .collect();\n\n        let mut s = String::new();\n        render_line(\n            &gb,\n            range_tokens.into_iter(),\n            col_off,\n            max_cols,\n            2,\n            &cs,\n            &mut style_cache,\n            &mut s,\n        );\n\n        let expected = expected_template\n            .replace(\"$\", RESET_STYLE)\n            .replace(\"#\", &Style::Bg(cs.bg).to_string());\n\n        assert_eq!(s, expected);\n    }\n\n    // Reproduction and regression test for https://github.com/sminez/ad/issues/137\n    #[test]\n    fn minibuffer_lines_with_multibyte_chars_dont_panic() {\n        let s = \"  56 | Fastst\u00e4lla att under samtliga \u00f6ppetdagar den h\u00e4r veckan s\u00e5 finns det alltid minst en\";\n        let b = Buffer::new_virtual(0, \"test\", s, Default::default());\n\n        let mb = MiniBufferState {\n            cx: 0,\n            n_visible_lines: 10,\n            selected_line_idx: 0,\n            prompt: \"> \",\n            input: Default::default(),\n            b: Some(&b),\n            top: 0,\n            bottom: 0,\n        };\n\n        let mut frame = Frame::new();\n        frame.screen_cols = 91;\n\n        // In 137 this was panicking due to indexing into the rendered line using self.screen_cols\n        // as a raw byte offset. The fix is simply not to truncate in that way as render_chars is\n        // already ensuring that the buffer it is building up is staying within the available\n        // screen space.\n        frame.render_minibuffer_state(&mb, 4, &Default::default());\n    }\n}\n", "source": "ad/src/ui/tui.rs", "file_type": "rc"}
{"text": "//! Layout of UI windows\nuse crate::{\n    buffer::{Buffer, BufferId, Buffers},\n    config::Config,\n    config_handle, die,\n    dot::{Cur, Dot},\n    editor::ViewPort,\n    fsys::InputFilter,\n    lsp::LspManagerHandle,\n    ziplist,\n    ziplist::{Position, ZipList},\n};\nuse std::{\n    cmp::min,\n    io,\n    mem::swap,\n    path::Path,\n    sync::{Arc, RwLock, mpsc::channel},\n};\nuse tracing::{debug, warn};\nuse unicode_width::UnicodeWidthChar;\n\n/// The reserved ID for the scratch buffer.\n/// If we ever collide with this when creating a normal buffer then the user is\n/// doing something _very_ strange...\npub const SCRATCH_ID: usize = usize::MAX;\n\n/// Similar to in ../buffer/internal.rs:/assert_line_endings/ this is used to hunt for exactly\n/// _where_ state becomes invalid between the actual buffer state in Buffers and the layout\n/// state referencing what should always be known IDs in Layout. This macro should be called\n/// at all points where the buffers & views are created / destroyed, as well as any time that\n/// views change their IDs. It should always be wrapped with #[cfg(test)] so that it doesn't\n/// affect the performance of the editor when it is actually in use.\n#[cfg(test)]\nmacro_rules! assert_invariants {\n    ($self:expr) => {{\n        for (i, (_, col)) in $self.cols.iter().enumerate() {\n            for (j, (_, win)) in col.wins.iter().enumerate() {\n                assert!(\n                    $self.buffers.contains_bufid(win.view.bufid),\n                    \"col {i} window {j} held unknown bufid ({})\",\n                    win.view.bufid\n                );\n                let b = $self.buffers.with_id(win.view.bufid).unwrap();\n                assert!(\n                    win.view.row_off < b.len_lines(),\n                    \"col {i} window {j} has an OOB row_off ({} vs {})\",\n                    win.view.row_off,\n                    b.len_lines()\n                );\n            }\n        }\n        for view in $self.views.iter() {\n            assert!(\n                $self.buffers.contains_bufid(view.bufid),\n                \"stored view held unknown bufid ({})\",\n                view.bufid\n            );\n            let b = $self.buffers.with_id(view.bufid).unwrap();\n            assert!(\n                view.row_off < b.len_lines(),\n                \"stored view for bufid {} has an OOB row_off ({} vs {})\",\n                view.bufid,\n                view.row_off,\n                b.len_lines()\n            );\n        }\n    }};\n}\n\n/// Layout is a screen layout of the windows available for displaying buffer\n/// content to the user. The available screen space is split into a number of\n/// columns each containing a vertical stack of windows.\n#[derive(Debug)]\npub struct Layout {\n    /// The managed buffer state\n    buffers: Buffers,\n    /// Global editor config\n    config: Arc<RwLock<Config>>,\n    /// An anonymous buffer that sits outside of the main buffer state and acts as though it is the\n    /// active buffer for the purposes of Load/Execute.\n    pub(crate) scratch: Scratch,\n    /// Available screen width in terms of characters\n    pub(crate) screen_rows: usize,\n    /// Available screen height in terms of characters\n    pub(crate) screen_cols: usize,\n    /// Left to right Columns of windows\n    pub(super) cols: ZipList<Column>,\n    /// Known Buffer views that are not currently active\n    pub(super) views: Vec<View>,\n    /// Whether or not the on-screen state changed since the last render of the UI.\n    /// Per-buffer state changes are tracked on each [Buffer], this flag is only for\n    /// changes to the UI layout itself.\n    changed_since_last_render: bool,\n}\n\nimpl Layout {\n    pub fn new_with_stub_lsp_handle(\n        screen_rows: usize,\n        screen_cols: usize,\n        config: Arc<RwLock<Config>>,\n    ) -> Self {\n        let (tx, _rx) = channel();\n        let lsp_handle = LspManagerHandle::new_stubbed(tx);\n\n        Self::new(screen_rows, screen_cols, Arc::new(lsp_handle), config)\n    }\n\n    pub(crate) fn new(\n        screen_rows: usize,\n        screen_cols: usize,\n        lsp_handle: Arc<LspManagerHandle>,\n        config: Arc<RwLock<Config>>,\n    ) -> Self {\n        let scratch = Scratch::new(config.clone());\n        let buffers = Buffers::new(lsp_handle, config.clone());\n        let id = buffers.active().id;\n\n        let l = Self {\n            buffers,\n            config,\n            scratch,\n            screen_rows,\n            screen_cols,\n            cols: ziplist![Column::new(screen_rows, screen_cols, &[id])],\n            views: vec![],\n            changed_since_last_render: false,\n        };\n\n        #[cfg(test)]\n        assert_invariants!(l);\n\n        l\n    }\n\n    /// Check to see if any actions taken since the last time this method was called resulted\n    /// in changes to the visible UI state.\n    ///\n    /// Calling this method will reset the internal flags used for checking these state changes.\n    pub(crate) fn changed_since_last_render(&mut self) -> bool {\n        let had_change = self.changed_since_last_render\n            || self.buffers.iter().any(|b| b.changed_since_last_render)\n            || self.scratch.b.buffer().changed_since_last_render;\n        self.changed_since_last_render = false;\n        self.buffers\n            .iter_mut()\n            .for_each(|b| b.changed_since_last_render = false);\n        self.scratch.b.buffer_mut().changed_since_last_render = false;\n\n        had_change\n    }\n\n    pub(crate) fn buffers(&self) -> &Buffers {\n        &self.buffers\n    }\n\n    pub(crate) fn ids(&self) -> Vec<Vec<BufferId>> {\n        self.cols\n            .iter()\n            .map(|(_, col)| col.wins.iter().map(|(_, win)| win.view.bufid).collect())\n            .collect()\n    }\n\n    /// The number of currently visible windows\n    pub(crate) fn n_open_windows(&self) -> usize {\n        self.cols.iter().map(|(_, c)| c.wins.len()).sum()\n    }\n\n    pub(crate) fn ensure_file_is_open(&mut self, path: &str) {\n        self.buffers.ensure_file_is_open(path);\n\n        #[cfg(test)]\n        assert_invariants!(self);\n    }\n\n    pub(crate) fn is_empty_squirrel(&self) -> bool {\n        self.buffers.is_empty_squirrel()\n    }\n\n    fn buffer_is_visible(&self, id: BufferId) -> bool {\n        self.cols\n            .iter()\n            .any(|(_, c)| c.wins.iter().any(|(_, w)| w.view.bufid == id))\n    }\n\n    /// Returns the active buffer, ignoring whether or not the scratch buffer is focused\n    pub(crate) fn active_buffer_ignoring_scratch(&self) -> &Buffer {\n        self.buffers.active()\n    }\n\n    /// Returns the active buffer, ignoring whether or not the scratch buffer is focused\n    pub(crate) fn active_buffer_mut_ignoring_scratch(&mut self) -> &mut Buffer {\n        self.buffers.active_mut()\n    }\n\n    /// Returns the active buffer or the scratch buffer if it is focused\n    pub fn active_buffer(&self) -> &Buffer {\n        if self.scratch.is_focused {\n            self.scratch.b.buffer()\n        } else {\n            self.buffers.active()\n        }\n    }\n\n    /// Returns the active buffer or the scratch buffer if it is focused\n    pub(crate) fn active_buffer_mut(&mut self) -> &mut Buffer {\n        if self.scratch.is_focused {\n            self.scratch.b.buffer_mut()\n        } else {\n            self.buffers.active_mut()\n        }\n    }\n\n    pub(crate) fn buffer_with_id(&self, id: BufferId) -> Option<&Buffer> {\n        self.buffers.with_id(id)\n    }\n\n    pub(crate) fn buffer_with_id_mut(&mut self, id: BufferId) -> Option<&mut Buffer> {\n        self.buffers.with_id_mut(id)\n    }\n\n    fn focus_first_window_with_buffer(&mut self, id: BufferId) {\n        self.scratch.is_focused = false;\n        self.cols\n            .focus_element_by_mut(|c| c.wins.focus_element_by_mut(|w| w.view.bufid == id));\n    }\n\n    pub(crate) fn toggle_scratch(&mut self) {\n        self.scratch.toggle();\n        self.changed_since_last_render = true;\n    }\n\n    pub fn open_or_focus<P: AsRef<Path>>(\n        &mut self,\n        path: P,\n        mut new_window: bool,\n    ) -> io::Result<Option<BufferId>> {\n        self.scratch.is_focused = false;\n        self.changed_since_last_render = true;\n\n        if self.buffers.is_empty_squirrel() {\n            // in the case where we only have an empty squirrel buffer present, we always replace\n            // the current buffer with the one that is newly opened.\n            new_window = false;\n        }\n\n        let retain_empty_unnamed = new_window || self.n_open_windows() > 1;\n        let opt = self.buffers.open_or_focus(path, retain_empty_unnamed)?;\n        let id = self.active_buffer_ignoring_scratch().id;\n\n        if self.buffer_is_visible(id) {\n            self.focus_first_window_with_buffer(id);\n        } else if new_window {\n            self.show_buffer_in_new_window(id);\n        } else {\n            self.show_buffer_in_active_window(id);\n        }\n\n        #[cfg(test)]\n        assert_invariants!(self);\n\n        Ok(opt)\n    }\n\n    /// Open a new virtual buffer that is not backed by a file on disk\n    ///\n    /// Opening the same virtual buffer a second time will replace the contents.\n    pub(crate) fn open_virtual(\n        &mut self,\n        name: impl Into<String>,\n        content: impl Into<String>,\n        new_window: bool,\n    ) {\n        self.scratch.is_focused = false;\n        self.changed_since_last_render = true;\n\n        let id = self.buffers.open_virtual(name.into(), content.into());\n\n        if self.buffer_is_visible(id) {\n            self.focus_first_window_with_buffer(id);\n        } else if new_window {\n            self.show_buffer_in_new_window(id);\n        } else {\n            self.show_buffer_in_active_window(id);\n        }\n\n        #[cfg(test)]\n        assert_invariants!(self);\n    }\n\n    /// Open a new transient scratch buffer.\n    ///\n    /// This will replace the layout position of the main scratch buffer without altering it's\n    /// contents. When the transient buffer is closed, the main scratch buffer will be put back.\n    /// See [Scratch::toggle].\n    pub(crate) fn open_transient_scratch(\n        &mut self,\n        name: impl Into<String>,\n        content: impl Into<String>,\n    ) {\n        self.changed_since_last_render = true;\n\n        self.scratch\n            .set_transient(name.into(), content.into(), self.config.clone());\n    }\n\n    /// Returns true if this was the last buffer otherwise false.\n    ///\n    /// Closing a buffer also updates the UI:\n    ///   - any cached views for the buffer are cleared\n    ///   - any open windows containing the buffer are closed\n    ///   - if a buffer was the only window in a given column, the column is removed\n    ///   - if the active column is removed then focus moves to the next column\n    ///   - if there are no other columns then the \"next buffer\" is placed in the\n    ///     first column\n    pub(crate) fn close_buffer(&mut self, id: BufferId) -> bool {\n        self.scratch.is_focused = false;\n        self.changed_since_last_render = true;\n\n        if id == self.scratch.b.buffer().id {\n            self.scratch.is_visible = false;\n            return false;\n        }\n\n        if self.buffers.len() == 1 {\n            // We could have been asked to close a non-existent buffer.\n            // If this was the last buffer then Editor::delete_buffer will exit\n            return self.active_buffer_ignoring_scratch().id == id;\n        }\n\n        debug_assert!(self.buffers.len() > 1, \"we have at least two buffers\");\n        self.views.retain(|v| v.bufid != id);\n        self.buffers.close_buffer(id);\n        let focused_id = self.active_buffer_ignoring_scratch().id;\n        let ix = self.views.iter().position(|v| v.bufid == id);\n        let existing_view = ix.map(|ix| self.views.remove(ix));\n\n        let only_closing_buffer = self\n            .cols\n            .iter()\n            .flat_map(|(_, c)| c.wins.iter().map(|(_, w)| w.view.bufid))\n            .all(|bufid| bufid == id);\n\n        if only_closing_buffer {\n            self.cols = ziplist![Column::new(\n                self.screen_rows,\n                self.screen_cols,\n                &[focused_id]\n            )];\n            if let Some(view) = existing_view {\n                self.cols.focus.wins.focus.view = view;\n            }\n\n            #[cfg(test)]\n            assert_invariants!(self);\n\n            return false;\n        }\n\n        // Remove columns where there are only views of the closing buffer\n        let cols_before = self.cols.len();\n        self.cols\n            .filter_unchecked(|c| c.wins.iter().any(|(_, w)| w.view.bufid != id));\n\n        if self.cols.len() < cols_before {\n            self.balance_columns();\n        }\n\n        // Remove remaining windows which were showing the closing buffer\n        for (_, c) in self.cols.iter_mut() {\n            let wins_before = c.wins.len();\n            c.wins.filter_unchecked(|w| w.view.bufid != id);\n            if c.wins.len() < wins_before {\n                c.balance_windows(self.screen_rows);\n            }\n        }\n\n        #[cfg(test)]\n        assert_invariants!(self);\n\n        false\n    }\n\n    pub(crate) fn focus_id(&mut self, id: BufferId, force_active: bool) {\n        if id == self.scratch.b.buffer().id {\n            self.scratch.is_focused = true;\n            self.scratch.is_visible = true;\n            return;\n        }\n\n        self.scratch.is_focused = false;\n        self.changed_since_last_render = true;\n\n        if let Some(id) = self.buffers.focus_id(id) {\n            if !force_active && self.buffer_is_visible(id) {\n                self.focus_first_window_with_buffer(id);\n            } else {\n                self.show_buffer_in_active_window(id);\n            }\n        }\n    }\n\n    /// Focus the given buffer ID without touching the jump list\n    pub(crate) fn focus_id_silent(&mut self, id: BufferId) {\n        self.buffers.focus_id_silent(id);\n    }\n\n    /// Focus the column at the given index without recording a jump.\n    ///\n    /// # Panics\n    /// Panics if col_idx is out of bounds.\n    pub fn focus_column_for_resize(&mut self, col_idx: usize) {\n        assert!(col_idx < self.cols.len(), \"col_idx out of bounds\");\n\n        self.scratch.is_focused = false;\n        self.changed_since_last_render = true;\n\n        self.cols.focus_head();\n        for _ in 0..col_idx {\n            self.cols.focus_down();\n        }\n\n        self.buffers.focus_id_silent(self.focused_view().bufid);\n    }\n\n    /// Focus the window at the given index within the currently focused column,\n    /// without recording a jump.\n    ///\n    /// # Panics\n    /// Panics if win_idx is out of bounds.\n    pub fn focus_window_for_resize(&mut self, win_idx: usize) {\n        let wins = &mut self.cols.focus.wins;\n        assert!(win_idx < wins.len(), \"win_idx out of bounds\");\n\n        self.scratch.is_focused = false;\n        self.changed_since_last_render = true;\n\n        wins.focus_head();\n        for _ in 0..win_idx {\n            wins.focus_down();\n        }\n\n        self.buffers.focus_id_silent(self.focused_view().bufid);\n    }\n\n    /// Focus the column and window at the given indices without recording a jump.\n    ///\n    /// # Panics\n    /// Panics if either index is out of bounds.\n    pub fn focus_column_and_window_for_resize(&mut self, col_idx: usize, win_idx: usize) {\n        self.focus_column_for_resize(col_idx);\n        self.focus_window_for_resize(win_idx);\n    }\n\n    pub(crate) fn focus_next_buffer(&mut self) -> BufferId {\n        self.scratch.is_focused = false;\n        self.changed_since_last_render = true;\n\n        self.buffers.next();\n        let id = self.active_buffer().id;\n        self.show_buffer_in_active_window(id);\n\n        id\n    }\n\n    pub(crate) fn focus_previous_buffer(&mut self) -> BufferId {\n        self.scratch.is_focused = false;\n        self.changed_since_last_render = true;\n\n        self.buffers.previous();\n        let id = self.active_buffer().id;\n        self.show_buffer_in_active_window(id);\n\n        id\n    }\n\n    /// Close the active window, if this was the last remaining window then\n    /// Editor::delete_active_window will exit.\n    pub(crate) fn close_active_window(&mut self) -> bool {\n        self.changed_since_last_render = true;\n\n        if self.scratch.is_focused {\n            self.scratch.toggle();\n            return false;\n        }\n\n        if self.cols.len() == 1 && self.cols.focus.wins.len() == 1 {\n            return true;\n        }\n\n        if self.cols.focus.wins.len() == 1 {\n            self.cols.remove_focused_unchecked();\n            self.balance_columns();\n        } else {\n            self.cols.focus.wins.remove_focused_unchecked();\n            self.balance_active_column();\n        }\n\n        let id = self.cols.focus.wins.focus.view.bufid;\n        self.buffers.focus_id(id);\n\n        #[cfg(test)]\n        assert_invariants!(self);\n\n        false\n    }\n\n    /// Close the active column, if this was the last remaining column then\n    /// Editor::delete_active_column will exit.\n    pub(crate) fn close_active_column(&mut self) -> bool {\n        self.changed_since_last_render = true;\n\n        if self.scratch.is_focused {\n            self.scratch.toggle();\n            return false;\n        }\n\n        if self.cols.len() == 1 {\n            return true;\n        }\n\n        self.cols.remove_focused_unchecked();\n        self.balance_columns();\n\n        let id = self.cols.focus.wins.focus.view.bufid;\n        self.buffers.focus_id(id);\n\n        #[cfg(test)]\n        assert_invariants!(self);\n\n        false\n    }\n\n    pub(crate) fn record_jump_position(&mut self) {\n        self.buffers.record_jump_position();\n    }\n\n    pub(crate) fn dirty_buffers(&self) -> Vec<String> {\n        self.buffers.dirty_buffers()\n    }\n\n    pub(crate) fn as_buffer_list(&self) -> Vec<String> {\n        self.buffers.as_buffer_list()\n    }\n\n    pub(crate) fn jump_forward(&mut self) -> Option<BufferId> {\n        let maybe_ids = self.buffers.jump_list_forward();\n        if let Some((prev_id, new_id)) = maybe_ids {\n            self.show_buffer_in_active_window(self.active_buffer_ignoring_scratch().id);\n            self.set_viewport(ViewPort::Center);\n            if new_id != prev_id {\n                return Some(new_id);\n            }\n        }\n\n        None\n    }\n\n    pub(crate) fn jump_backward(&mut self) -> Option<BufferId> {\n        let maybe_ids = self.buffers.jump_list_backward();\n        if let Some((prev_id, new_id)) = maybe_ids {\n            self.show_buffer_in_active_window(self.active_buffer_ignoring_scratch().id);\n            self.set_viewport(ViewPort::Center);\n            if new_id != prev_id {\n                return Some(new_id);\n            }\n        }\n\n        None\n    }\n\n    pub(crate) fn write_output_for_buffer(&mut self, id: usize, s: String, cwd: &Path) {\n        let id = self.buffers.write_output_for_buffer(id, s, cwd);\n        if !self.buffer_is_visible(id) {\n            self.show_buffer_in_new_window(id);\n        }\n\n        #[cfg(test)]\n        assert_invariants!(self);\n    }\n\n    /// Move focus to the column to the right of current focus (wrapping)\n    pub(crate) fn next_column(&mut self) {\n        self.scratch.is_focused = false;\n        self.changed_since_last_render = true;\n\n        self.cols.focus_down();\n        self.buffers.focus_id(self.focused_view().bufid);\n        self.force_cursor_to_be_in_view();\n\n        #[cfg(test)]\n        assert_invariants!(self);\n    }\n\n    /// Move focus to the column to the left of current focus (wrapping)\n    pub(crate) fn prev_column(&mut self) {\n        self.scratch.is_focused = false;\n        self.changed_since_last_render = true;\n\n        self.cols.focus_up();\n        self.buffers.focus_id(self.focused_view().bufid);\n        self.force_cursor_to_be_in_view();\n\n        #[cfg(test)]\n        assert_invariants!(self);\n    }\n\n    /// Move focus to the window below in the current column (wrapping)\n    pub(crate) fn next_window_in_column(&mut self) {\n        self.scratch.is_focused = false;\n        self.changed_since_last_render = true;\n\n        self.cols.focus.wins.focus_down();\n        self.buffers.focus_id(self.focused_view().bufid);\n        self.force_cursor_to_be_in_view();\n\n        #[cfg(test)]\n        assert_invariants!(self);\n    }\n\n    /// Move focus to the window above in the current column (wrapping)\n    pub(crate) fn prev_window_in_column(&mut self) {\n        self.scratch.is_focused = false;\n        self.changed_since_last_render = true;\n\n        self.cols.focus.wins.focus_up();\n        self.buffers.focus_id(self.focused_view().bufid);\n        self.force_cursor_to_be_in_view();\n\n        #[cfg(test)]\n        assert_invariants!(self);\n    }\n\n    /// Drag the focused window up through the column containing it (wrapping)\n    pub(crate) fn drag_up(&mut self) {\n        self.scratch.is_focused = false;\n        self.changed_since_last_render = true;\n\n        self.cols.focus.wins.swap_up();\n\n        #[cfg(test)]\n        assert_invariants!(self);\n    }\n\n    /// Drag the focused window down through the column containing it (wrapping)\n    pub(crate) fn drag_down(&mut self) {\n        self.scratch.is_focused = false;\n        self.changed_since_last_render = true;\n\n        self.cols.focus.wins.swap_down();\n\n        #[cfg(test)]\n        assert_invariants!(self);\n    }\n\n    /// Drag the focused window to the column on the left.\n    ///\n    /// # Semantics\n    /// - If the current columns contains multiple windows and the target exists\n    ///   then the current focus is moved to the focus position of the target column\n    /// - We anchor if the current column is the extreme left or right and this is\n    ///   the only window, otherwise a new column is created and the window is moved\n    ///   into it as the focus.\n    /// - If the focused window is the only window in and extremal column and the\n    ///   direction is towards other columns then the window is moved to that column\n    ///   and the previous column is removed.\n    pub(crate) fn drag_left(&mut self) {\n        self.scratch.is_focused = false;\n        self.changed_since_last_render = true;\n\n        // Strictly speaking, self.cols.up.is_empty() == true implies self.cols.len() == 1 but\n        // we keep the explicit check for clarity.\n        if self.cols.up.is_empty() || self.cols.len() == 1 {\n            // Single column or far left column\n\n            // If we only have a single window in this column then we're done...\n            if self.cols.focus.wins.len() == 1 {\n                return;\n            }\n\n            // Otherwise we need to create a new column containing only this window\n            let win = self.cols.focus.wins.remove_focused_unchecked();\n            self.balance_active_column(); // tidy up the column we've just popped from\n            let mut col = Column::new(self.screen_rows, self.screen_cols, &[win.view.bufid]);\n            col.wins.focus = win;\n            self.cols.insert_at(Position::Head, col);\n            self.cols.focus_up();\n            self.balance_columns();\n        } else if self.cols.focus.wins.len() == 1 {\n            // Column that is not on the far left containing only a single window\n\n            // If this column only has a single window then remove it an place the window in\n            // the column to the left\n            let on_left = self.cols.up.is_empty();\n            let win = self.cols.remove_focused_unchecked().wins.focus;\n            self.balance_columns();\n            self.balance_active_column();\n            if !on_left {\n                self.cols.focus_up();\n            }\n            self.cols.focus.wins.insert(win);\n            self.balance_active_column();\n        } else {\n            // Column that is not on the far left containing more than one window\n\n            let win = self.cols.focus.wins.remove_focused_unchecked();\n            self.balance_active_column();\n            self.cols.focus_up();\n            self.cols.focus.wins.insert(win);\n            self.balance_active_column();\n        }\n\n        #[cfg(test)]\n        assert_invariants!(self);\n    }\n\n    /// Drag the focused window to the column on the right.\n    ///\n    /// See [Layout::drag_left] for semantics.\n    pub(crate) fn drag_right(&mut self) {\n        self.scratch.is_focused = false;\n        self.changed_since_last_render = true;\n\n        // Strictly speaking, self.cols.up.is_empty() == true implies self.cols.len() == 1 but\n        // we keep the explicit check for clarity.\n        if self.cols.len() == 1 || self.cols.down.is_empty() {\n            // Single column or far right column\n\n            // If we only have a single window in this column then we're done...\n            if self.cols.focus.wins.len() == 1 {\n                return;\n            }\n\n            // Otherwise we need to create a new column containing only this window\n            let win = self.cols.focus.wins.remove_focused_unchecked();\n            self.balance_active_column(); // tidy up the column we've just popped from\n\n            let mut col = Column::new(self.screen_rows, self.screen_cols, &[0]);\n            col.wins.focus = win;\n            self.cols.insert_at(Position::Tail, col);\n            self.cols.focus_down();\n            self.balance_columns();\n        } else if self.cols.focus.wins.len() == 1 {\n            // Column that is not on the far right containing only a single window\n\n            let win = self.cols.remove_focused_unchecked().wins.focus;\n            self.cols.focus.wins.insert(win);\n            self.balance_active_column();\n            self.balance_columns();\n        } else {\n            // Column that is not on the far right containing more than one window\n\n            let win = self.cols.focus.wins.remove_focused_unchecked();\n            self.balance_active_column();\n            self.cols.focus_down();\n            self.cols.focus.wins.insert(win);\n            self.balance_active_column();\n        }\n\n        #[cfg(test)]\n        assert_invariants!(self);\n    }\n\n    /// Adjust the size of the active [Column] by increasing or decreasing the number of\n    /// character columns it takes up.\n    ///\n    /// The adjustment is always applied from the left of the Column unless the active column\n    /// is the first in the [Layout], in which case the adjustment is made from the right.\n    pub(crate) fn resize_active_column(&mut self, delta_cols: i16) {\n        self.changed_since_last_render = true;\n        self.cols.grow_focus(delta_cols);\n    }\n\n    /// Adjust the size of the active [Window] by increasing or decreasing the number of rows\n    /// it takes up.\n    ///\n    /// The adjustment is always applied from the top of the window unless the active window\n    /// is the first window in its [Column], in which case the adjustment is made from the\n    /// bottom of the window instead.\n    pub(crate) fn resize_active_window(&mut self, delta_rows: i16) {\n        self.changed_since_last_render = true;\n        self.cols.focus.wins.grow_focus(delta_rows);\n    }\n\n    /// Resize the active column against the column to its right.\n    pub fn resize_active_column_against_next(&mut self, delta: i16) {\n        self.changed_since_last_render = true;\n        self.cols.grow_focus_against_next(delta);\n    }\n\n    /// Resize the active window against the window below it.\n    pub fn resize_active_window_against_next(&mut self, delta: i16) {\n        self.changed_since_last_render = true;\n        self.cols.focus.wins.grow_focus_against_next(delta);\n    }\n\n    /// Update the current layout state to reflect a new physical screen size given in terms\n    /// of the number of character rows and columns.\n    ///\n    /// Any existing layout customisation will be preserved as far as possible by converting\n    /// dimensions to be relative to the size of the full screen.\n    pub(crate) fn update_screen_size(&mut self, rows: usize, cols: usize) {\n        self.changed_since_last_render = true;\n\n        let col_ratio = (cols as f32) / (self.screen_cols as f32);\n        let row_ratio = (rows as f32) / (self.screen_rows as f32);\n\n        self.screen_rows = rows;\n        self.screen_cols = cols;\n\n        self.cols.scale_sizes(col_ratio, cols);\n        for (_, c) in self.cols.iter_mut() {\n            c.wins.scale_sizes(row_ratio, rows);\n        }\n\n        self.clamp_scroll();\n    }\n\n    /// Force the columns within the layout to be equally sized.\n    pub(crate) fn balance_columns(&mut self) {\n        self.changed_since_last_render = true;\n\n        let (n_cols, slop) = calculate_dims(self.screen_cols, self.cols.len());\n        for (i, (_, col)) in self.cols.iter_mut().enumerate() {\n            col.n_cols = n_cols;\n            if i < slop {\n                col.n_cols += 1;\n            }\n        }\n    }\n\n    /// Force the windows within the active column to be balanced.\n    pub(crate) fn balance_active_column(&mut self) {\n        self.changed_since_last_render = true;\n        self.cols.focus.balance_windows(self.screen_rows);\n    }\n\n    /// Force the all windows within the layout to be equally sized within their respective\n    /// columns.\n    pub(crate) fn balance_windows(&mut self) {\n        self.changed_since_last_render = true;\n        for (_, col) in self.cols.iter_mut() {\n            col.balance_windows(self.screen_rows);\n        }\n    }\n\n    /// Force all columns and windows to be equally sized.\n    pub(crate) fn balance_all(&mut self) {\n        self.balance_columns();\n        self.balance_windows();\n    }\n\n    #[inline]\n    pub(crate) fn focused_view(&self) -> &View {\n        &self.cols.focus.wins.focus.view\n    }\n\n    #[inline]\n    pub(crate) fn focused_view_mut(&mut self) -> &mut View {\n        &mut self.cols.focus.wins.focus.view\n    }\n\n    pub(crate) fn active_window_rows(&self) -> usize {\n        if self.scratch.is_focused {\n            self.scratch.w.n_rows\n        } else {\n            self.cols.focus.wins.focus.n_rows\n        }\n    }\n\n    /// Set the currently focused window to contain the given buffer\n    pub(crate) fn show_buffer_in_active_window(&mut self, id: BufferId) {\n        self.scratch.is_focused = false;\n        self.changed_since_last_render = true;\n\n        if self.focused_view().bufid == id {\n            return;\n        }\n\n        let mut view = match self.views.iter().position(|v| v.bufid == id) {\n            Some(idx) => self.views.remove(idx),\n            None => View::new(id),\n        };\n\n        swap(self.focused_view_mut(), &mut view);\n        if self.buffers.contains_bufid(view.bufid) {\n            self.views.push(view);\n        }\n\n        #[cfg(test)]\n        assert_invariants!(self);\n    }\n\n    /// Create a new column containing a single window showing the same view found in the\n    /// current active window.\n    pub(crate) fn new_column(&mut self) {\n        self.scratch.is_focused = false;\n        self.changed_since_last_render = true;\n\n        let view = self.focused_view().clone();\n        let mut col = Column::new(self.screen_rows, self.screen_cols, &[view.bufid]);\n        col.wins.last_mut().view = view;\n        self.cols.insert_at(Position::Tail, col);\n        self.cols.focus_tail();\n        self.balance_columns();\n\n        #[cfg(test)]\n        assert_invariants!(self);\n    }\n\n    /// Create a new window at the end of the current column showing the same view\n    /// found in the current active window.\n    pub(crate) fn new_window(&mut self) {\n        self.scratch.is_focused = false;\n        self.changed_since_last_render = true;\n\n        let view = self.focused_view().clone();\n        let wins = &mut self.cols.focus.wins;\n        wins.insert_at(Position::Tail, Window { n_rows: 0, view });\n        wins.focus_tail();\n        self.balance_active_column();\n\n        #[cfg(test)]\n        assert_invariants!(self);\n    }\n\n    /// Set the currently focused window to contain the given buffer\n    pub(crate) fn show_buffer_in_new_window(&mut self, id: BufferId) {\n        self.scratch.is_focused = false;\n        self.changed_since_last_render = true;\n\n        let view = if self.focused_view().bufid == id {\n            self.focused_view().clone()\n        } else {\n            match self.views.iter().position(|v| v.bufid == id) {\n                Some(idx) => self.views.remove(idx),\n                None => View::new(id),\n            }\n        };\n\n        if self.cols.len() == 1 {\n            let mut col = Column::new(self.screen_rows, self.screen_cols, &[id]);\n            col.wins.last_mut().view = view;\n            self.cols.insert_at(Position::Tail, col);\n            self.cols.focus_tail();\n            self.balance_columns();\n        } else {\n            self.cols.focus_tail();\n            let wins = &mut self.cols.focus.wins;\n            wins.insert_at(Position::Tail, Window { n_rows: 0, view });\n            wins.focus_tail();\n            self.balance_active_column();\n        }\n\n        self.buffers.focus_id(id);\n\n        #[cfg(test)]\n        assert_invariants!(self);\n    }\n\n    pub(crate) fn force_cursor_to_be_in_view(&mut self) {\n        self.changed_since_last_render = true;\n        let tabstop = config_handle!(self).tabstop;\n\n        if self.scratch.is_focused {\n            self.scratch.w.view.force_cursor_to_be_in_view(\n                self.scratch.b.buffer_mut(),\n                self.scratch.w.n_rows,\n                self.screen_cols,\n                tabstop,\n            );\n        } else {\n            let b = self.buffers.active_mut();\n            let cols = self.cols.focus.n_cols;\n            let rows = self.cols.focus.wins.focus.n_rows;\n\n            self.cols\n                .focus\n                .focused_view_mut()\n                .force_cursor_to_be_in_view(b, rows, cols, tabstop);\n        }\n\n        #[cfg(test)]\n        assert_invariants!(self);\n    }\n\n    /// Clamp the active view to the current dot of the Buffer it is displaying and ensure that all\n    /// other views are within bounds for the end of the buffer.\n    ///\n    /// We need to do this for every visible view, not just the active one as external\n    /// inputs from systems such as the 9p filesystem and LSP servers can manipulate\n    /// state for non-active buffers.\n    pub(crate) fn clamp_scroll(&mut self) {\n        let tabstop = config_handle!(self).tabstop;\n\n        // Clamp the scratch buffer if it is visible unconditionally as we can't have multiple\n        // views of it.\n        if self.scratch.is_visible {\n            self.scratch.w.view.clamp_scroll(\n                self.scratch.b.buffer_mut(),\n                self.scratch.w.n_rows,\n                self.screen_cols,\n                tabstop,\n            );\n        }\n\n        // Clamp the active buffer fully to ensure that Dot is remaining within bounds\n        let b = self.buffers.active_mut();\n        let cols = self.cols.focus.n_cols;\n        let rows = self.cols.focus.wins.focus.n_rows;\n\n        self.cols\n            .focus\n            .focused_view_mut()\n            .clamp_scroll(b, rows, cols, tabstop);\n\n        // For all other visible Views, ensure that row_off is clamped to the end of the buffer but\n        // don't _fully_ clamp to force the current Dot to be visible. This allows us to present\n        // multiple Views of the same Buffer while only scrolling one of them.\n        for (col_focused, col) in self.cols.iter_mut() {\n            for (win_focused, win) in col.wins.iter_mut() {\n                if col_focused && win_focused {\n                    continue; // handled above\n                }\n\n                let b = self.buffers.with_id_mut(win.view.bufid).unwrap();\n                let y_max = b.txt.len_lines() - 1;\n                win.view.row_off = min(win.view.row_off, y_max);\n            }\n        }\n\n        #[cfg(test)]\n        assert_invariants!(self);\n    }\n\n    pub(crate) fn set_viewport(&mut self, vp: ViewPort) {\n        self.changed_since_last_render = true;\n        let tabstop = config_handle!(self).tabstop;\n\n        if self.scratch.is_focused {\n            self.scratch.w.view.set_viewport(\n                self.scratch.b.buffer_mut(),\n                vp,\n                self.scratch.w.n_rows,\n                self.screen_cols,\n                tabstop,\n            );\n        } else {\n            let b = self.buffers.active_mut();\n            let cols = self.cols.focus.n_cols;\n            let rows = self.cols.focus.wins.focus.n_rows;\n\n            self.cols\n                .focus\n                .focused_view_mut()\n                .set_viewport(b, vp, rows, cols, tabstop);\n        }\n\n        #[cfg(test)]\n        assert_invariants!(self);\n    }\n\n    /// Coordinate offsets from the top left of the window layout to the top left of the active window.\n    fn xy_offsets(&self) -> (usize, usize) {\n        if self.scratch.is_focused {\n            let y_offset = self.screen_rows - self.scratch.w.n_rows + 1; // +1 for status line\n            return (0, y_offset);\n        }\n\n        let cols_before = &self.cols.up;\n        let wins_above = &self.cols.focus.wins.up;\n        let x_offset = cols_before.iter().map(|c| c.n_cols).sum::<usize>() + cols_before.len();\n        let y_offset = wins_above.iter().map(|w| w.n_rows).sum::<usize>() + wins_above.len();\n\n        (x_offset, y_offset)\n    }\n\n    /// Locate the absolute cursor position based on the current window layout\n    pub(crate) fn ui_xy(&self) -> (usize, usize) {\n        let (x_offset, y_offset) = self.xy_offsets();\n        let (x, y) = if self.scratch.is_focused {\n            self.scratch.w.view.ui_xy(self.scratch.b.buffer())\n        } else {\n            self.focused_view().ui_xy(self.active_buffer())\n        };\n\n        (x + x_offset, y + y_offset)\n    }\n\n    /// Whether or not the given screen row is within a visible scratch buffer\n    fn row_is_scratch(&self, y: usize) -> bool {\n        if !self.scratch.is_visible {\n            return false;\n        }\n\n        y > (self.screen_rows - self.scratch.w.n_rows + 1)\n    }\n\n    pub fn border_at_coords(&self, x: usize, y: usize) -> Option<Border> {\n        if self.row_is_scratch(y) {\n            return None;\n        }\n\n        let n_cols = self.cols.len();\n        let mut x_offset = 0;\n\n        for (col_idx, (_, col)) in self.cols.iter().enumerate() {\n            let border_x = x_offset + col.n_cols + 1;\n\n            if x == border_x && col_idx < n_cols - 1 {\n                return Some(Border::Vertical { col_idx });\n            } else if x > border_x {\n                x_offset = border_x;\n                continue;\n            }\n\n            let n_wins = col.wins.len();\n            let mut y_offset = 0;\n\n            for (win_idx, (_, win)) in col.wins.iter().enumerate() {\n                let border_y = y_offset + win.n_rows + 1;\n\n                if y == border_y && win_idx < n_wins - 1 {\n                    return Some(Border::Horizontal { col_idx, win_idx });\n                } else if y > border_y {\n                    y_offset = border_y;\n                    continue;\n                }\n\n                return None; // Click was inside a window\n            }\n\n            return None;\n        }\n\n        None\n    }\n\n    /// If the given coordinates lie within the scratch buffer return None, otherwise return the ID\n    /// of the buffer containing the point.\n    fn buffer_for_screen_coords(&self, x: usize, y: usize) -> BufferId {\n        let mut x_offset = 0;\n        let mut y_offset = 0;\n\n        if self.row_is_scratch(y) {\n            return SCRATCH_ID;\n        }\n\n        for (_, col) in self.cols.iter() {\n            if x > x_offset + col.n_cols {\n                x_offset += col.n_cols + 1;\n                continue;\n            }\n            for (_, win) in col.wins.iter() {\n                if y > y_offset + win.n_rows {\n                    y_offset += win.n_rows + 1;\n                    continue;\n                }\n                return win.view.bufid;\n            }\n        }\n\n        debug!(\"click out of bounds (x, y)=({x}, {y})\");\n        self.active_buffer().id\n    }\n\n    fn focus_buffer_for_screen_coords(&mut self, x: usize, y: usize) -> BufferId {\n        self.changed_since_last_render = true;\n        let mut x_offset = 0;\n        let mut y_offset = 0;\n\n        if self.row_is_scratch(y) {\n            self.scratch.is_focused = true;\n            return SCRATCH_ID;\n        }\n\n        self.scratch.is_focused = false;\n\n        self.cols.focus_head();\n        for _ in 0..self.cols.len() {\n            let col = &self.cols.focus;\n            if x > x_offset + col.n_cols {\n                x_offset += col.n_cols + 1;\n                self.cols.focus_down();\n                continue;\n            }\n\n            self.cols.focus.wins.focus_head();\n            for _ in 0..self.cols.focus.wins.len() {\n                let win = &self.cols.focus.wins.focus;\n                if y > y_offset + win.n_rows {\n                    y_offset += win.n_rows + 1;\n                    self.cols.focus.wins.focus_down();\n                    continue;\n                }\n                self.buffers.focus_id(win.view.bufid);\n                return win.view.bufid;\n            }\n        }\n\n        debug!(\"click out of bounds (x, y)=({x}, {y})\");\n        self.active_buffer().id\n    }\n\n    /// Map a given (x, y) point into a Cur for the active buffer or tag\n    fn cur_from_screen_coords(&mut self, x: usize, y: usize) -> Cur {\n        let (x_offset, y_offset) = self.xy_offsets();\n        let (b, win) = if self.scratch.is_focused {\n            (self.scratch.b.buffer_mut(), &mut self.scratch.w)\n        } else {\n            (self.buffers.active_mut(), &mut self.cols.focus.wins.focus)\n        };\n\n        let row_off = win.view.row_off;\n\n        let (_, w_sgncol) = b.sign_col_dims();\n        let rx = x\n            .saturating_sub(1)\n            .saturating_sub(x_offset)\n            .saturating_sub(w_sgncol);\n        let y = min(\n            y.saturating_sub(y_offset).saturating_add(row_off),\n            b.len_lines(),\n        )\n        .saturating_sub(1);\n\n        win.view.rx = rx;\n        b.cached_rx = rx;\n\n        let mut cur = Cur::from_yx(y, b.x_from_provided_rx(y, rx), b);\n        cur.clamp_idx(b.len_chars());\n\n        cur\n    }\n\n    /// Determine the cursor position for a given set of coordinates and report whether or not\n    /// these coordinates are inside of the currently active buffer (or tag).\n    pub(crate) fn try_active_cur_from_screen_coords(&mut self, x: usize, y: usize) -> Option<Cur> {\n        let id = self.buffer_for_screen_coords(x, y);\n        if id == self.active_buffer().id {\n            Some(self.cur_from_screen_coords(x, y))\n        } else {\n            None\n        }\n    }\n\n    /// Focus the buffer (or tag) containing the given screen coordinates and return the current\n    /// cursor position for updating held mouse state.\n    pub(crate) fn focus_cur_from_screen_coords(&mut self, x: usize, y: usize) -> (BufferId, Cur) {\n        let bufid = self.focus_buffer_for_screen_coords(x, y);\n        let cur = self.cur_from_screen_coords(x, y);\n\n        (bufid, cur)\n    }\n\n    /// Set the active buffer and dot based on a mouse click.\n    ///\n    /// Returns true if the click was in the currently active buffer and false if this click has\n    /// changed the active buffer.\n    pub(crate) fn set_dot_from_screen_coords(&mut self, x: usize, y: usize) -> bool {\n        self.changed_since_last_render = true;\n        let current_bufid = self.active_buffer().id;\n        let bufid = self.focus_buffer_for_screen_coords(x, y);\n        let c = self.cur_from_screen_coords(x, y);\n        self.active_buffer_mut().dot = Dot::Cur { c };\n\n        #[cfg(test)]\n        assert_invariants!(self);\n\n        bufid == current_bufid\n    }\n\n    /// Scroll the `View` under the given cursor coordinates up or down by `scroll_rows`\n    pub fn scroll_view(&mut self, x: usize, y: usize, up: bool, scroll_rows: usize) {\n        self.changed_since_last_render = true;\n        let tabstop = config_handle!(self).tabstop;\n        let mut x_offset = 0;\n        let mut y_offset = 0;\n\n        if self.row_is_scratch(y) {\n            apply_scroll(\n                self.scratch.b.buffer_mut(),\n                &mut self.scratch.w,\n                self.screen_cols,\n                tabstop,\n                self.scratch.is_focused,\n                up,\n                scroll_rows,\n            );\n\n            #[cfg(test)]\n            assert_invariants!(self);\n\n            return;\n        }\n\n        for (focused_col, col) in self.cols.iter_mut() {\n            if x > x_offset + col.n_cols {\n                x_offset += col.n_cols + 1;\n                continue;\n            }\n            for (focused_win, win) in col.wins.iter_mut() {\n                if y > y_offset + win.n_rows {\n                    y_offset += win.n_rows + 1;\n                    continue;\n                }\n\n                let b = self.buffers.with_id_mut(win.view.bufid).unwrap_or_else(|| {\n                    die!(\"invalid buffer ID {}\", win.view.bufid);\n                });\n                let focused = focused_col && focused_win;\n                apply_scroll(b, win, col.n_cols, tabstop, focused, up, scroll_rows);\n\n                #[cfg(test)]\n                assert_invariants!(self);\n\n                return;\n            }\n        }\n\n        // Default to scrolling the active window\n        let n_cols = self.cols.focus.n_cols;\n        let win = &mut self.cols.focus.wins.focus;\n        let b = self.buffers.with_id_mut(win.view.bufid).unwrap();\n        apply_scroll(b, win, n_cols, tabstop, true, up, scroll_rows);\n\n        #[cfg(test)]\n        assert_invariants!(self);\n    }\n\n    pub(crate) fn update_visible_ts_state(&mut self) {\n        let it = self.cols.iter().flat_map(|(_, c)| {\n            c.wins\n                .iter()\n                .map(|(_, w)| (w.view.bufid, w.view.row_off, w.n_rows))\n        });\n\n        for (bufid, from, n_rows) in it {\n            let b = self.buffers.with_id_mut(bufid).unwrap_or_else(|| {\n                die!(\"invalid buffer ID {bufid}\");\n            });\n\n            b.update_ts_state(from, n_rows);\n        }\n\n        #[cfg(test)]\n        assert_invariants!(self);\n    }\n\n    /// Returns `true` if the filter was successfully set, false if there was already one in place.\n    pub(crate) fn try_set_input_filter(&mut self, bufid: BufferId, filter: InputFilter) -> bool {\n        let b = match self.buffer_with_id_mut(bufid) {\n            Some(b) => b,\n            None => return false,\n        };\n\n        if b.input_filter.is_some() {\n            warn!(\"attempt to set an input filter when one is already in place. id={bufid:?}\");\n            return false;\n        }\n\n        let scratch_filter = filter.paired_tag_filter();\n        b.input_filter = Some(filter);\n        // Deliberately self.scratch.b.main rather than self.scratch.b.buffer_mut() as we don't\n        // support attaching an input filter to transient scratch buffers\n        self.scratch.b.main.input_filter = Some(scratch_filter);\n\n        true\n    }\n\n    /// Remove the input filter for the given buffer if one exists.\n    pub(crate) fn clear_input_filter(&mut self, bufid: usize) {\n        if let Some(b) = self.buffer_with_id_mut(bufid) {\n            b.input_filter = None;\n        }\n\n        // Deliberately self.scratch.b.main rather than self.scratch.b.buffer_mut() as we don't\n        // support attaching an input filter to transient scratch buffers\n        self.scratch.b.main.input_filter = None;\n    }\n}\n\n#[derive(Debug, Clone)]\npub(crate) struct Column {\n    /// Number of character columns wide\n    pub(crate) n_cols: usize,\n    /// Windows within this column\n    pub(crate) wins: ZipList<Window>,\n}\n\nimpl Column {\n    pub(crate) fn new(n_rows: usize, n_cols: usize, buf_ids: &[BufferId]) -> Self {\n        let (win_rows, slop) = calculate_dims(n_rows, buf_ids.len());\n        let mut wins = ZipList::try_from_iter(buf_ids.iter().map(|id| Window::new(win_rows, *id)))\n            .expect(\"can't have an empty column\");\n\n        for (i, (_, w)) in wins.iter_mut().enumerate() {\n            if i < slop {\n                w.n_rows += 1;\n            }\n        }\n\n        Self { n_cols, wins }\n    }\n\n    /// Needed to avoid borrowing all of Layout when calling [Layout::focused_view_mut].\n    #[inline]\n    fn focused_view_mut(&mut self) -> &mut View {\n        &mut self.wins.focus.view\n    }\n\n    /// Force the windows within this column to be balanced regardless of their current sizes\n    fn balance_windows(&mut self, screen_rows: usize) {\n        let (n_rows, slop) = calculate_dims(screen_rows, self.wins.len());\n        for (i, (_, win)) in self.wins.iter_mut().enumerate() {\n            win.n_rows = n_rows;\n            if i < slop {\n                win.n_rows += 1;\n            }\n        }\n    }\n}\n\n/// State for the scratch buffer\n#[derive(Debug)]\npub(crate) struct Scratch {\n    pub(crate) b: ScratchBuf,\n    pub(super) w: Window,\n    pub(super) is_visible: bool,\n    pub(super) is_focused: bool,\n}\n\n#[derive(Debug)]\npub(crate) struct ScratchBuf {\n    main: Buffer,\n    transient: Option<Buffer>,\n}\n\nimpl ScratchBuf {\n    pub(crate) fn buffer(&self) -> &Buffer {\n        self.transient.as_ref().unwrap_or(&self.main)\n    }\n\n    pub(crate) fn buffer_mut(&mut self) -> &mut Buffer {\n        self.transient.as_mut().unwrap_or(&mut self.main)\n    }\n\n    pub(crate) fn clear(&mut self) {\n        self.main.clear();\n    }\n}\n\nimpl Scratch {\n    // n_rows is read from config on startup but then not modified after that\n    fn new(config: Arc<RwLock<Config>>) -> Self {\n        let n_rows = config.read().unwrap().minibuffer_lines;\n\n        Self {\n            b: ScratchBuf {\n                main: Buffer::new_virtual(SCRATCH_ID, \"*scratch*\", \"\", config),\n                transient: None,\n            },\n            w: Window::new(n_rows, SCRATCH_ID),\n            is_visible: false,\n            is_focused: false,\n        }\n    }\n\n    fn set_transient(&mut self, name: String, content: String, config: Arc<RwLock<Config>>) {\n        self.b.transient = Some(Buffer::new_virtual(SCRATCH_ID, name, content, config));\n        self.is_visible = true;\n        self.is_focused = true;\n    }\n\n    /// Toggle the visibility of the scratch buffer and focus it if opening.\n    ///\n    /// If the scratch buffer was visible and contained a transient buffer, remove it.\n    fn toggle(&mut self) {\n        if self.is_visible && self.b.transient.is_some() {\n            self.b.transient = None;\n        }\n\n        self.is_visible = !self.is_visible;\n        self.is_focused = self.is_visible;\n    }\n}\n\n#[derive(Debug, Clone)]\npub(crate) struct Window {\n    /// Number of character rows high\n    pub(crate) n_rows: usize,\n    /// Buffer view details currently shown in this window\n    pub(crate) view: View,\n}\n\nimpl Window {\n    pub(crate) fn new(n_rows: usize, bufid: BufferId) -> Self {\n        Self {\n            n_rows,\n            view: View::new(bufid),\n        }\n    }\n}\n\n#[derive(Debug, Clone)]\npub(crate) struct View {\n    pub(crate) bufid: BufferId,\n    pub(crate) col_off: usize,\n    pub(crate) row_off: usize,\n    pub(crate) rx: usize,\n    cur: Cur,\n}\n\nimpl View {\n    pub(crate) fn new(bufid: BufferId) -> Self {\n        Self {\n            bufid,\n            col_off: 0,\n            row_off: 0,\n            rx: 0,\n            cur: Cur::default(),\n        }\n    }\n\n    /// provides an (x, y) coordinate assuming that this window is in the top left\n    fn ui_xy(&self, b: &Buffer) -> (usize, usize) {\n        let (_, w_sgncol) = b.sign_col_dims();\n        let (y, _) = b.dot.active_cur().as_yx(b);\n        let x = self.rx - self.col_off + w_sgncol;\n        let y = y - self.row_off;\n\n        (x, y)\n    }\n\n    pub(crate) fn rx_from_x(&self, b: &Buffer, y: usize, x: usize, tabstop: usize) -> usize {\n        if y >= b.len_lines() {\n            return 0;\n        }\n\n        let mut rx = 0;\n        for c in b.txt.line(y).chars().take(x) {\n            if c == '\\t' {\n                rx += (tabstop - 1) - (rx % tabstop);\n            }\n            rx += UnicodeWidthChar::width(c).unwrap_or(1);\n        }\n\n        rx\n    }\n\n    /// Force the contained Buffer cursor to be visible if it currently isn't\n    fn force_cursor_to_be_in_view(\n        &mut self,\n        b: &mut Buffer,\n        rows: usize,\n        cols: usize,\n        tabstop: usize,\n    ) {\n        b.dot = self.cur.into();\n        self.clamp_scroll(b, rows, cols, tabstop);\n    }\n\n    /// Clamp the current viewport to include the [Dot].\n    pub(crate) fn clamp_scroll(\n        &mut self,\n        b: &mut Buffer,\n        rows: usize,\n        cols: usize,\n        tabstop: usize,\n    ) {\n        self.cur = b.dot.active_cur();\n        let (y, x) = self.cur.as_yx(b);\n        let (_, w_sgncol) = b.sign_col_dims();\n        self.rx = self.rx_from_x(b, y, x, tabstop);\n        b.cached_rx = self.rx;\n\n        if y < self.row_off {\n            self.row_off = y;\n        }\n\n        if y >= self.row_off + rows {\n            self.row_off = y + 1 - rows;\n        }\n\n        if self.rx < self.col_off {\n            self.col_off = self.rx;\n        }\n\n        if self.rx >= self.col_off + cols - w_sgncol {\n            self.col_off = self.rx + w_sgncol + 1 - cols;\n        }\n    }\n\n    /// Set the current [ViewPort] while accounting for screen size.\n    pub(crate) fn set_viewport(\n        &mut self,\n        b: &mut Buffer,\n        vp: ViewPort,\n        screen_rows: usize,\n        screen_cols: usize,\n        tabstop: usize,\n    ) {\n        let (y, _) = b.dot.active_cur().as_yx(b);\n\n        self.row_off = match vp {\n            ViewPort::Top => y,\n            ViewPort::Center => y.saturating_sub(screen_rows / 2),\n            ViewPort::Bottom => y.saturating_sub(screen_rows),\n        };\n\n        self.clamp_scroll(b, screen_rows, screen_cols, tabstop);\n    }\n}\n\n/// Min window size is 5x5\nconst MIN_DIM: usize = 5;\n\npub trait Growable {\n    fn size(&mut self) -> &mut usize;\n\n    fn clamped_sub(&mut self, delta: usize, min_val: usize) -> usize {\n        let clamped = (*self.size()).saturating_sub(delta);\n        if clamped >= min_val {\n            *self.size() = clamped;\n            delta\n        } else {\n            let actual = *self.size() - min_val;\n            *self.size() = min_val;\n            actual\n        }\n    }\n}\n\nimpl Growable for Column {\n    fn size(&mut self) -> &mut usize {\n        &mut self.n_cols\n    }\n}\n\nimpl Growable for Window {\n    fn size(&mut self) -> &mut usize {\n        &mut self.n_rows\n    }\n}\n\nimpl<T> ZipList<T>\nwhere\n    T: Growable,\n{\n    /// Attempt to adjust the size of the focused element by a given delta.\n    ///\n    /// Clamp to [MIN_DIM] for both the focused element and the adjacent element\n    /// that is being modified along with it.\n    fn grow_focus(&mut self, delta: i16) {\n        if self.len() == 1 || delta == 0 {\n            return; // nothing to grow\n        }\n\n        let other = if self.up.is_empty() {\n            &mut self.down[0]\n        } else {\n            &mut self.up[0]\n        };\n\n        if delta < 0 {\n            let actual = self.focus.clamped_sub((-delta) as usize, MIN_DIM);\n            *other.size() += actual;\n        } else {\n            let actual = other.clamped_sub(delta as usize, MIN_DIM);\n            *self.focus.size() += actual;\n        }\n    }\n\n    /// Resize the focused element against the next element (down[0]).\n    ///\n    /// No-op if there's no next element to resize against.\n    fn grow_focus_against_next(&mut self, delta: i16) {\n        if self.down.is_empty() || delta == 0 {\n            return;\n        }\n\n        let other = &mut self.down[0];\n        if delta < 0 {\n            let actual = self.focus.clamped_sub((-delta) as usize, MIN_DIM);\n            *other.size() += actual;\n        } else {\n            let actual = other.clamped_sub(delta as usize, MIN_DIM);\n            *self.focus.size() += actual;\n        }\n    }\n\n    /// Attempt to preserve the current relative size of each element when the\n    /// overall available space changes.\n    fn scale_sizes(&mut self, ratio: f32, new_total: usize) {\n        let mut total = 0;\n        for (_, elem) in self.iter_mut() {\n            let new_size = (*elem.size() as f32 * ratio) as usize;\n            *elem.size() = new_size;\n            total += new_size;\n        }\n\n        total += self.len() - 1;\n        let slop = new_total - total;\n\n        for (i, (_, elem)) in self.iter_mut().enumerate() {\n            if i < slop {\n                *elem.size() += 1;\n            }\n        }\n    }\n}\n\n/// A border that can be dragged to resize\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum Border {\n    /// Vertical border after column at index `col_idx`\n    Vertical { col_idx: usize },\n    /// Horizontal border after window at index `win_idx` within column at index `col_idx`\n    Horizontal { col_idx: usize, win_idx: usize },\n}\n\n/// Calculate the size (rows/cols) for n blocks within an available space of t\n/// while accounting for \"slop\" that will be added to some elements to make up\n/// the correct total.\n///\n/// This calculation is derived from:  t = n(size) + (n - 1) + slop\n///\n/// where the (n - 1) is spacer rows/columns between each region. The use of\n/// truncating division in computing \"size\" gets us an approximate answer for\n/// an integer value that solve the equation above without \"slop\", which is then\n/// calculated to get the correct total\nfn calculate_dims(t: usize, n: usize) -> (usize, usize) {\n    let size = (t + 1) / n - 1;\n    let slop = t + 1 - n * (size + 1);\n\n    (size, slop)\n}\n\n/// When we apply scrolling to a [View] we need to keep track of a preferred cursor position so\n/// that when the user bounces between windows they don't get reset to a default position based on\n/// the viewport alone.\nfn apply_scroll(\n    b: &mut Buffer,\n    win: &mut Window,\n    n_cols: usize,\n    tabstop: usize,\n    focused: bool,\n    up: bool,\n    scroll_rows: usize,\n) {\n    let n_rows = win.n_rows;\n    let view = &mut win.view;\n    let mut cur = if focused {\n        b.dot.active_cur()\n    } else {\n        view.cur\n    };\n    let (y, x) = cur.as_yx(b);\n    let y_max = b.txt.len_lines() - 1;\n    let mut need_clamp = false;\n\n    if up && view.row_off > 0 && y == view.row_off + n_rows - 1 {\n        cur = Cur::from_yx(y.saturating_sub(scroll_rows), x, b);\n    } else if !up && y == view.row_off && view.row_off < y_max {\n        cur = Cur::from_yx(min(y + scroll_rows, y_max), x, b);\n        need_clamp = true;\n    };\n\n    if focused {\n        b.dot.set_active_cur(cur);\n        if need_clamp {\n            b.dot.clamp_idx(b.txt.len_chars());\n            b.xdot.clamp_idx(b.txt.len_chars());\n        }\n    } else {\n        view.cur = cur;\n    }\n\n    view.row_off = if up {\n        view.row_off.saturating_sub(scroll_rows)\n    } else {\n        min(view.row_off + scroll_rows, y_max)\n    };\n\n    if focused {\n        view.clamp_scroll(b, n_rows, n_cols, tabstop);\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::{\n        dot::{Dot, TextObject},\n        key::Arrow,\n    };\n    use simple_test_case::test_case;\n    use std::{path::PathBuf, sync::mpsc::channel};\n\n    impl Layout {\n        pub fn column_widths(&self) -> Vec<usize> {\n            self.cols.iter().map(|(_, c)| c.n_cols).collect()\n        }\n\n        pub fn window_heights(&self) -> Vec<usize> {\n            self.cols.focus.wins.iter().map(|(_, w)| w.n_rows).collect()\n        }\n\n        pub fn cols_before_focus(&self) -> usize {\n            self.cols.up.len()\n        }\n    }\n\n    fn test_layout(col_wins: &[usize], n_rows: usize, n_cols: usize) -> Layout {\n        let mut cols = Vec::with_capacity(col_wins.len());\n        let mut n = 0;\n        let mut all_ids = Vec::new();\n        let (col_size, slop) = calculate_dims(n_cols, col_wins.len());\n\n        for (i, m) in col_wins.iter().enumerate() {\n            let ids: Vec<usize> = (n..(n + m)).collect();\n            n += m;\n            let col_n_cols = if i < slop { col_size + 1 } else { col_size };\n            cols.push(Column::new(n_rows, col_n_cols, &ids));\n            all_ids.extend(ids);\n        }\n\n        let (tx, _) = channel();\n        let config = Arc::new(RwLock::new(Config::default()));\n        let scratch = Scratch::new(config.clone());\n\n        let mut l = Layout {\n            buffers: Buffers::new_stubbed(&all_ids, tx, config.clone()),\n            config,\n            scratch,\n            screen_rows: n_rows,\n            screen_cols: n_cols,\n            cols: ZipList::try_from_iter(cols).unwrap(),\n            views: vec![],\n            changed_since_last_render: false,\n        };\n        l.update_screen_size(n_rows, n_cols);\n\n        l\n    }\n\n    fn ordered_window_ids(l: &Layout) -> Vec<usize> {\n        l.cols\n            .iter()\n            .flat_map(|(_, c)| c.wins.iter().map(|(_, w)| w.view.bufid))\n            .collect::<Vec<_>>()\n    }\n\n    #[test]\n    fn opening_file_with_unnamed_split_works() {\n        let (tx, _) = channel();\n        let config = Arc::new(RwLock::new(Config::default()));\n        let scratch = Scratch::new(config.clone());\n\n        let buffers = Buffers::new_with_raw_sender(tx, config.clone());\n        let id = buffers.active().id;\n\n        let mut l = Layout {\n            buffers,\n            config,\n            scratch,\n            screen_rows: 80,\n            screen_cols: 100,\n            cols: ziplist![Column::new(80, 100, &[id])],\n            views: vec![],\n            changed_since_last_render: false,\n        };\n\n        l.new_column();\n\n        // This will panic if we've ended removing the original unnamed buffer from\n        // self.buffers as part of opening the virtual buffer as the Layout state\n        // will now contain references to an unknown buffer ID (via assert_invariants)\n        let _ = l.open_or_focus(\"test-buffer.txt\", false);\n    }\n\n    #[test]\n    fn drag_left_works() {\n        let mut l = test_layout(&[1, 1, 2], 80, 100);\n        l.next_column();\n        assert_eq!(l.active_buffer().id, 1);\n        l.drag_left();\n\n        assert_eq!(l.cols.len(), 2);\n        let first_col: Vec<usize> = l\n            .cols\n            .head()\n            .wins\n            .iter()\n            .map(|(_, w)| w.view.bufid)\n            .collect();\n        let second_col: Vec<usize> = l\n            .cols\n            .last()\n            .wins\n            .iter()\n            .map(|(_, w)| w.view.bufid)\n            .collect();\n\n        assert_eq!(&first_col, &[1, 0]);\n        assert_eq!(&second_col, &[2, 3]);\n    }\n\n    #[test]\n    fn drag_right_works() {\n        let mut l = test_layout(&[1, 1, 2], 80, 100);\n        assert_eq!(l.active_buffer().id, 0);\n        l.drag_right();\n\n        assert_eq!(l.cols.len(), 2);\n        let first_col: Vec<usize> = l\n            .cols\n            .head()\n            .wins\n            .iter()\n            .map(|(_, w)| w.view.bufid)\n            .collect();\n        let second_col: Vec<usize> = l\n            .cols\n            .last()\n            .wins\n            .iter()\n            .map(|(_, w)| w.view.bufid)\n            .collect();\n\n        assert_eq!(&first_col, &[0, 1]);\n        assert_eq!(&second_col, &[2, 3]);\n    }\n\n    #[test]\n    fn next_prev_column_methods_work() {\n        let mut l = test_layout(&[1, 1, 2], 80, 100);\n        assert_eq!(l.focused_view().bufid, 0);\n\n        // next wrapping\n        l.next_column();\n        assert_eq!(l.focused_view().bufid, 1);\n        l.next_column();\n        assert_eq!(l.focused_view().bufid, 2);\n        l.next_column();\n        assert_eq!(l.focused_view().bufid, 0);\n\n        // prev wrapping\n        l.prev_column();\n        assert_eq!(l.focused_view().bufid, 2);\n        l.prev_column();\n        assert_eq!(l.focused_view().bufid, 1);\n        l.prev_column();\n        assert_eq!(l.focused_view().bufid, 0);\n    }\n\n    #[test]\n    fn next_prev_window_methods_work() {\n        let mut l = test_layout(&[3, 1], 80, 100);\n        assert_eq!(l.focused_view().bufid, 0);\n\n        // next wrapping\n        l.next_window_in_column();\n        assert_eq!(l.focused_view().bufid, 1);\n        l.next_window_in_column();\n        assert_eq!(l.focused_view().bufid, 2);\n        l.next_window_in_column();\n        assert_eq!(l.focused_view().bufid, 0);\n\n        // prev wrapping\n        l.prev_window_in_column();\n        assert_eq!(l.focused_view().bufid, 2);\n        l.prev_window_in_column();\n        assert_eq!(l.focused_view().bufid, 1);\n        l.prev_window_in_column();\n        assert_eq!(l.focused_view().bufid, 0);\n    }\n\n    #[test_case(&[1], 30, 40, 0; \"one col one win\")]\n    #[test_case(&[1, 1], 30, 40, 0; \"two cols one win each click in first\")]\n    #[test_case(&[1, 1], 60, 40, 1; \"two cols one win each click in second\")]\n    #[test_case(&[1, 2], 60, 40, 1; \"two cols second with two click in second window\")]\n    #[test_case(&[1, 2], 60, 60, 2; \"two cols second with two click in third window\")]\n    #[test_case(&[1, 3], 60, 15, 1; \"two cols second with three click in first window\")]\n    #[test_case(&[1, 3], 60, 35, 2; \"two cols second with three click in second window\")]\n    #[test_case(&[1, 3], 60, 60, 3; \"two cols second with three click in third window\")]\n    #[test_case(&[1, 4], 60, 70, 4; \"two cols second with four click in fourth window\")]\n    #[test]\n    fn buffer_for_screen_coords_works(col_wins: &[usize], x: usize, y: usize, expected: BufferId) {\n        let mut l = test_layout(col_wins, 80, 100);\n\n        assert_eq!(\n            l.buffer_for_screen_coords(x, y),\n            expected,\n            \"bufid without mutation\"\n        );\n        assert_eq!(\n            l.cols.focus.wins.focus.view.bufid, 0,\n            \"focused id before mutation\"\n        );\n        assert_eq!(\n            l.focus_buffer_for_screen_coords(x, y),\n            expected,\n            \"bufid with mutation\"\n        );\n        assert_eq!(\n            l.cols.focus.wins.focus.view.bufid, expected,\n            \"focused id after mutation\"\n        );\n    }\n\n    #[test_case(1, 1, \"f\"; \"before wide char SOB\")]\n    #[test_case(4, 1, \" \"; \"immediately before wide char\")]\n    #[test_case(5, 1, \"\u4e16\"; \"on first wide char\")]\n    #[test_case(7, 1, \"\u754c\"; \"on second wide char\")]\n    #[test_case(9, 1, \" \"; \"after second wide char\")]\n    #[test_case(1, 2, \"\ud83e\udd8a\"; \"second line first wide char\")]\n    #[test_case(3, 2, \"\u2316\"; \"second line multibyte single cell char\")]\n    #[test_case(6, 2, \"a\"; \"second line ascii after wide and multibyte\")]\n    #[test]\n    fn cur_from_screen_coords_handles_wide_utf8_chars(x: usize, y: usize, s: &str) {\n        let mut l = test_layout(&[1], 80, 100);\n        // This is a mix of ascii and utf-8 multi-byte characters where some (but not all) of the\n        // multi-byte characters have width > 1. Our handling of the raw x position given to us\n        // from terminal input needs to be based on _character width_ rather than the number of\n        // bytes in the character.\n        let content = \"foo \u4e16\u754c \u2320\\n\ud83e\udd8a\u2316 bar\".to_string();\n        l.active_buffer_mut().insert_xdot(content);\n\n        // cur_from_screen_coords has to account for the additional UI elements we have in place\n        // for the sign column so this gets added on here to allow the test case parameters to\n        // represent the logical position within the buffer.\n        let (_, w_sgncol) = l.active_buffer().sign_col_dims();\n        let c = l.cur_from_screen_coords(x + w_sgncol, y);\n        l.active_buffer_mut().dot = Dot::Cur { c };\n\n        assert_eq!(l.active_buffer().dot_contents(), s, \"click=({x}, {y})\");\n    }\n\n    #[test_case(0, &[1, 2, 3, 4]; \"0\")]\n    #[test_case(1, &[0, 2, 3, 4]; \"1\")]\n    #[test_case(2, &[0, 1, 3, 4]; \"2\")]\n    #[test_case(3, &[0, 1, 2, 4]; \"3\")]\n    #[test_case(4, &[0, 1, 2, 3]; \"4\")]\n    #[test]\n    fn close_buffer_works(id: usize, expected: &[usize]) {\n        let mut l = test_layout(&[1, 4], 80, 100);\n        assert_eq!(&ordered_window_ids(&l), &[0, 1, 2, 3, 4], \"initial ids\");\n\n        l.close_buffer(id);\n        assert!(!l.buffers.contains_bufid(id), \"buffer id should be removed\");\n\n        for bufid in expected.iter() {\n            assert!(\n                l.buffers.contains_bufid(*bufid),\n                \"other buffers should still be there\"\n            );\n        }\n\n        assert_eq!(\n            &ordered_window_ids(&l),\n            expected,\n            \"ids for each window should be correct\"\n        );\n    }\n\n    #[test]\n    fn focus_buffer_for_screen_coords_doesnt_reorder_windows() {\n        let (x, y) = (60, 70);\n        let expected = 4;\n        let mut l = test_layout(&[1, 4], 80, 100);\n\n        assert_eq!(\n            &ordered_window_ids(&l),\n            &[0, 1, 2, 3, 4],\n            \"before first click\"\n        );\n\n        assert_eq!(\n            l.focus_buffer_for_screen_coords(x, y),\n            expected,\n            \"bufid with mutation\"\n        );\n\n        assert_eq!(\n            &ordered_window_ids(&l),\n            &[0, 1, 2, 3, 4],\n            \"after first click\"\n        );\n\n        assert_eq!(\n            l.focus_buffer_for_screen_coords(x, y),\n            expected,\n            \"bufid with mutation\"\n        );\n\n        assert_eq!(\n            &ordered_window_ids(&l),\n            &[0, 1, 2, 3, 4],\n            \"after second click\"\n        );\n    }\n\n    // NOTE: there was a bug around misunderstanding terminal \"cells\" in relation to\n    //       wide unicode characters\n    //       - https://github.com/crossterm-rs/crossterm/issues/458\n    //       - https://github.com/unicode-rs/unicode-width\n    #[test]\n    fn ui_xy_correctly_handles_multibyte_characters() {\n        let s = \"abc \u4e16\u754c \ud83e\udd8a\";\n        // unicode display width for each character\n        let widths = &[1, 1, 1, 1, 2, 2, 1, 2];\n        let mut b = Buffer::new_virtual(0, \"test\", s, Default::default());\n        let mut view = View::new(0);\n        let mut offset = 0;\n\n        // sign column offset is 3\n        for (idx, ch) in s.chars().enumerate() {\n            assert_eq!(b.dot_contents(), ch.to_string());\n            assert_eq!(b.dot, Dot::Cur { c: Cur { idx } });\n            assert_eq!(\n                view.ui_xy(&b),\n                (3 + offset, 0),\n                \"idx={idx} content={:?}\",\n                b.dot_contents()\n            );\n\n            b.set_dot(TextObject::Arr(Arrow::Right), 1);\n            view.clamp_scroll(&mut b, 80, 80, 4);\n            offset += widths[idx];\n        }\n    }\n\n    #[test_case(1, 0, 10, &[100]; \"one col inc\")]\n    #[test_case(1, 0, -10, &[100]; \"one col dec\")]\n    #[test_case(2, 0, 10, &[60, 39]; \"two cols inc one\")]\n    #[test_case(2, 0, -10, &[40, 59]; \"two cols dec one\")]\n    #[test_case(2, 1, 10, &[40, 59]; \"two cols inc two\")]\n    #[test_case(2, 1, -10, &[60, 39]; \"two cols dec two\")]\n    #[test_case(3, 1, 10, &[23, 43, 32]; \"three cols inc two\")]\n    #[test_case(3, 1, -10, &[43, 23, 32]; \"three cols dec two\")]\n    #[test_case(2, 0, -200, &[MIN_DIM, 100 - MIN_DIM - 1]; \"two cols dec one clamping\")]\n    #[test_case(2, 0, 200, &[100 - MIN_DIM - 1, MIN_DIM]; \"two cols inc one clamping\")]\n    #[test]\n    fn resize_active_column_works(n_cols: usize, ix: usize, delta: i16, expected_cols: &[usize]) {\n        assert_eq!(expected_cols.len(), n_cols, \"malformed test case\");\n        let mut l = test_layout(&vec![1; n_cols], 80, 100);\n        // set focus to the target column\n        l.cols.focus_head();\n        for _ in 0..ix {\n            l.cols.focus_down();\n        }\n\n        l.resize_active_column(delta);\n\n        for (i, (_, c)) in l.cols.iter().enumerate() {\n            assert_eq!(c.n_cols, expected_cols[i], \"column {i}\");\n        }\n    }\n\n    #[test_case(1, 0, 10, &[80]; \"one win inc\")]\n    #[test_case(1, 0, -10, &[80]; \"one win dec\")]\n    #[test_case(2, 0, 10, &[50, 29]; \"two wins inc one\")]\n    #[test_case(2, 0, -10, &[30, 49]; \"two wins dec one\")]\n    #[test_case(2, 1, 10, &[30, 49]; \"two wins inc two\")]\n    #[test_case(2, 1, -10, &[50, 29]; \"two wins dec two\")]\n    #[test_case(3, 1, 10, &[16, 36, 26]; \"three wins inc two\")]\n    #[test_case(3, 1, -10, &[36, 16, 26]; \"three wins dec two\")]\n    #[test_case(2, 0, -200, &[MIN_DIM, 80 - MIN_DIM - 1]; \"two wins dec one clamping\")]\n    #[test_case(2, 0, 200, &[80 - MIN_DIM - 1, MIN_DIM]; \"two wins inc one clamping\")]\n    #[test]\n    fn resize_active_window_works(n_wins: usize, ix: usize, delta: i16, expected_rows: &[usize]) {\n        assert_eq!(expected_rows.len(), n_wins, \"malformed test case\");\n        let mut l = test_layout(&[n_wins], 80, 100);\n        // set focus to the target window\n        l.cols.focus.wins.focus_head();\n        for _ in 0..ix {\n            l.cols.focus.wins.focus_down();\n        }\n\n        l.resize_active_window(delta);\n\n        for (i, (_, w)) in l.cols.focus.wins.iter().enumerate() {\n            assert_eq!(w.n_rows, expected_rows[i], \"window {i}\");\n        }\n    }\n\n    #[test_case(100, 120, (73, 46), (100, 63, 36); \"increase width and height\")]\n    #[test_case(60, 80, (48, 31), (60, 38, 21); \"decrease width and height\")]\n    #[test]\n    fn update_screen_size_preserves_relative_sizes(\n        w: usize,\n        h: usize,\n        expected_cols: (usize, usize),\n        expected_wins: (usize, usize, usize),\n    ) {\n        let mut l = test_layout(&[1, 2], 80, 100);\n\n        l.cols.focus_head();\n        l.resize_active_column(10);\n        l.cols.focus_down();\n        l.cols.focus.wins.focus_head();\n        l.resize_active_window(10); // now focused on 1st window of 2nd column\n\n        let cols = |l: &Layout| (l.cols.up[0].n_cols, l.cols.focus.n_cols);\n        let wins = |l: &Layout| {\n            (\n                l.cols.up[0].wins.focus.n_rows,\n                l.cols.focus.wins.focus.n_rows,\n                l.cols.focus.wins.down[0].n_rows,\n            )\n        };\n\n        // check that the initial column and window sizes are correct\n        assert_eq!(cols(&l), (60, 39), \"initial column widths\");\n        assert_eq!(wins(&l), (80, 50, 29), \"initial window heights\");\n\n        l.update_screen_size(w, h);\n\n        assert_eq!(cols(&l), expected_cols, \"updated column widths\");\n        assert_eq!(wins(&l), expected_wins, \"updated window heights\");\n    }\n\n    #[test]\n    fn writing_to_a_non_visible_output_buffer_creates_a_window() {\n        let mut l = test_layout(&[1, 1], 80, 100);\n        assert_eq!(l.n_open_windows(), 2);\n        assert_eq!(l.cols[0].wins[0].n_rows, 80);\n        assert_eq!(l.cols[1].wins[0].n_rows, 80);\n\n        l.write_output_for_buffer(0, \"some output\".into(), &PathBuf::from(\"/tmp\"));\n        assert_eq!(l.n_open_windows(), 3);\n        assert_eq!(l.cols[0].wins[0].n_rows, 80);\n        assert_eq!(l.cols[1].wins[0].n_rows, 40);\n        assert_eq!(l.cols[1].wins[1].n_rows, 39);\n    }\n\n    #[test]\n    fn single_column_single_window_has_no_borders() {\n        let l = test_layout(&[1], 80, 100);\n\n        for x in 1..=100 {\n            for y in 1..=80 {\n                assert_eq!(\n                    l.border_at_coords(x, y),\n                    None,\n                    \"unexpected hit @ ({x}, {y})\"\n                );\n            }\n        }\n    }\n\n    #[test]\n    fn single_column_multiple_windows_has_horizontal_borders() {\n        let l = test_layout(&[3], 80, 100);\n\n        assert_eq!(l.cols[0].wins[0].n_rows, 26);\n        assert_eq!(l.cols[0].wins[1].n_rows, 26);\n        assert_eq!(l.cols[0].wins[2].n_rows, 26);\n\n        assert_eq!(\n            l.border_at_coords(50, 27),\n            Some(Border::Horizontal {\n                col_idx: 0,\n                win_idx: 0\n            })\n        );\n\n        assert_eq!(\n            l.border_at_coords(50, 54),\n            Some(Border::Horizontal {\n                col_idx: 0,\n                win_idx: 1\n            })\n        );\n\n        assert_eq!(l.border_at_coords(50, 81), None); // past last window\n        assert_eq!(l.border_at_coords(50, 1), None); // inside first window\n        assert_eq!(l.border_at_coords(50, 26), None); // last row of first window\n        assert_eq!(l.border_at_coords(50, 28), None); // first row of second window\n    }\n\n    #[test]\n    fn multiple_columns_single_window_each_has_vertical_borders() {\n        let l = test_layout(&[1, 1, 1], 80, 100);\n\n        assert_eq!(l.cols[0].n_cols, 33);\n        assert_eq!(l.cols[1].n_cols, 33);\n        assert_eq!(l.cols[2].n_cols, 32);\n\n        assert_eq!(\n            l.border_at_coords(34, 40),\n            Some(Border::Vertical { col_idx: 0 })\n        );\n\n        assert_eq!(\n            l.border_at_coords(68, 40),\n            Some(Border::Vertical { col_idx: 1 })\n        );\n\n        assert_eq!(l.border_at_coords(101, 40), None); // past last column\n        assert_eq!(l.border_at_coords(1, 40), None); // inside first column\n        assert_eq!(l.border_at_coords(33, 40), None); // last char of first column\n        assert_eq!(l.border_at_coords(35, 40), None); // first char of second column\n    }\n\n    #[test]\n    fn multiple_columns_multiple_windows_has_both_border_types() {\n        let l = test_layout(&[2, 2], 80, 100);\n\n        let col0_width = l.cols[0].n_cols;\n        let win0_height = l.cols[0].wins[0].n_rows;\n\n        assert_eq!(\n            l.border_at_coords(col0_width + 1, 20),\n            Some(Border::Vertical { col_idx: 0 })\n        );\n\n        assert_eq!(\n            l.border_at_coords(10, win0_height + 1),\n            Some(Border::Horizontal {\n                col_idx: 0,\n                win_idx: 0\n            })\n        );\n\n        let col1_x = col0_width + 1 + 10; // inside col1\n        assert_eq!(\n            l.border_at_coords(col1_x, win0_height + 1),\n            Some(Border::Horizontal {\n                col_idx: 1,\n                win_idx: 0\n            })\n        );\n\n        assert_eq!(l.border_at_coords(10, 10), None); // inside window\n        assert_eq!(l.border_at_coords(col1_x, 10), None); // inside window in col1\n    }\n\n    #[test]\n    fn border_coords_at_screen_edges() {\n        let l = test_layout(&[1, 1], 80, 100);\n\n        assert_eq!(l.border_at_coords(1, 1), None); // top-left corner, inside first window\n        assert_eq!(l.border_at_coords(101, 40), None); // past right edge\n        assert_eq!(l.border_at_coords(10, 81), None); // past bottom edge\n    }\n\n    #[test]\n    fn focus_column_for_resize_works() {\n        let mut l = test_layout(&[1, 1, 1], 80, 100);\n        assert_eq!(l.cols.up.len(), 0);\n\n        l.focus_column_for_resize(1);\n        assert_eq!(l.cols.up.len(), 1);\n        assert_eq!(l.cols.down.len(), 1);\n\n        l.focus_column_for_resize(2);\n        assert_eq!(l.cols.up.len(), 2);\n        assert_eq!(l.cols.down.len(), 0);\n\n        l.focus_column_for_resize(0);\n        assert_eq!(l.cols.up.len(), 0);\n        assert_eq!(l.cols.down.len(), 2);\n    }\n\n    #[test]\n    #[should_panic(expected = \"col_idx out of bounds\")]\n    fn focus_column_for_resize_panics_on_out_of_bounds() {\n        let mut l = test_layout(&[1, 1, 1], 80, 100);\n        l.focus_column_for_resize(99);\n    }\n\n    #[test]\n    fn focus_window_for_resize_works() {\n        let mut l = test_layout(&[3], 80, 100);\n        assert_eq!(l.cols.focus.wins.up.len(), 0);\n\n        l.focus_window_for_resize(1);\n        assert_eq!(l.cols.focus.wins.up.len(), 1);\n        assert_eq!(l.cols.focus.wins.down.len(), 1);\n\n        l.focus_window_for_resize(2);\n        assert_eq!(l.cols.focus.wins.up.len(), 2);\n        assert_eq!(l.cols.focus.wins.down.len(), 0);\n\n        l.focus_window_for_resize(0);\n        assert_eq!(l.cols.focus.wins.up.len(), 0);\n        assert_eq!(l.cols.focus.wins.down.len(), 2);\n    }\n\n    #[test]\n    #[should_panic(expected = \"win_idx out of bounds\")]\n    fn focus_window_for_resize_panics_on_out_of_bounds() {\n        let mut l = test_layout(&[3], 80, 100);\n        l.focus_window_for_resize(99);\n    }\n\n    #[test]\n    fn focus_column_and_window_for_resize_works() {\n        let mut l = test_layout(&[2, 2], 80, 100);\n\n        l.focus_column_and_window_for_resize(1, 1);\n        assert_eq!(l.cols.up.len(), 1);\n        assert_eq!(l.cols.focus.wins.up.len(), 1);\n    }\n\n    #[test]\n    #[should_panic(expected = \"col_idx out of bounds\")]\n    fn focus_column_and_window_for_resize_panics_on_bad_col() {\n        let mut l = test_layout(&[2, 2], 80, 100);\n        l.focus_column_and_window_for_resize(99, 0);\n    }\n\n    #[test]\n    #[should_panic(expected = \"win_idx out of bounds\")]\n    fn focus_column_and_window_for_resize_panics_on_bad_win() {\n        let mut l = test_layout(&[2, 2], 80, 100);\n        l.focus_column_and_window_for_resize(0, 99);\n    }\n\n    #[test_case(2, 0, 10, &[60, 39]; \"two cols grow first against second\")]\n    #[test_case(2, 0, -10, &[40, 59]; \"two cols shrink first against second\")]\n    #[test_case(3, 1, 10, &[33, 43, 22]; \"three cols grow middle against last\")]\n    #[test_case(3, 1, -10, &[33, 23, 42]; \"three cols shrink middle against last\")]\n    #[test_case(2, 0, -200, &[MIN_DIM, 100 - MIN_DIM - 1]; \"clamps to MIN_DIM\")]\n    #[test_case(2, 1, 10, &[50, 49]; \"last column has no next so noop\")]\n    #[test]\n    fn resize_column_against_next(n_cols: usize, focus_idx: usize, delta: i16, expected: &[usize]) {\n        let mut l = test_layout(&vec![1; n_cols], 80, 100);\n        l.focus_column_for_resize(focus_idx);\n        l.resize_active_column_against_next(delta);\n\n        for (i, (_, c)) in l.cols.iter().enumerate() {\n            assert_eq!(c.n_cols, expected[i], \"column {i}\");\n        }\n    }\n\n    #[test_case(2, 0, 10, &[50, 29]; \"two wins grow first against second\")]\n    #[test_case(2, 0, -10, &[30, 49]; \"two wins shrink first against second\")]\n    #[test_case(3, 1, 10, &[26, 36, 16]; \"three wins grow middle against last\")]\n    #[test_case(3, 1, -10, &[26, 16, 36]; \"three wins shrink middle against last\")]\n    #[test_case(2, 0, -200, &[MIN_DIM, 80 - MIN_DIM - 1]; \"clamps to MIN_DIM\")]\n    #[test_case(2, 1, 10, &[40, 39]; \"last window has no next so noop\")]\n    #[test]\n    fn resize_window_against_next(n_wins: usize, focus_idx: usize, delta: i16, expected: &[usize]) {\n        let mut l = test_layout(&[n_wins], 80, 100);\n        l.focus_window_for_resize(focus_idx);\n        l.resize_active_window_against_next(delta);\n\n        for (i, (_, w)) in l.cols.focus.wins.iter().enumerate() {\n            assert_eq!(w.n_rows, expected[i], \"window {i}\");\n        }\n    }\n\n    #[test]\n    fn clamp_scroll_clamps_all_visible_views() {\n        let mut l = test_layout(&[2, 3], 80, 100);\n\n        for (_, col) in l.cols.iter_mut() {\n            for (_, win) in col.wins.iter_mut() {\n                let b = l.buffers.with_id_mut(win.view.bufid).unwrap();\n                b.insert_xdot(\"line1\\nline2\\nline3\".to_string());\n                win.view.row_off = 100;\n            }\n        }\n\n        l.clamp_scroll();\n\n        for (_, col) in l.cols.iter() {\n            for (_, win) in col.wins.iter() {\n                assert_eq!(\n                    win.view.row_off, 2,\n                    \"bufid {} had row_off={}\",\n                    win.view.bufid, win.view.row_off\n                );\n            }\n        }\n    }\n\n    #[test]\n    fn apply_scroll_for_unfocused_window_clamps_row_off() {\n        let config = Arc::new(RwLock::new(Config::default()));\n        let mut b = Buffer::new_unnamed(0, \"line1\\nline2\\nline3\\nline4\\nline5\", config);\n        let y_max = b.txt.len_lines() - 1;\n        assert_eq!(y_max, 4);\n\n        let mut win = Window::new(0, 3);\n        win.view.row_off = 3;\n\n        let focused = false;\n        let up = false;\n        let n_cols = 80;\n        let tabstop = 4;\n        let scroll_rows = 5;\n\n        apply_scroll(&mut b, &mut win, n_cols, tabstop, focused, up, scroll_rows);\n\n        assert_eq!(win.view.row_off, y_max);\n    }\n}\n", "source": "ad/src/ui/layout.rs", "file_type": "rc"}
{"text": "//! A simple AST for parsing and manipulating regex strings\nuse super::{CharClass, Error, next_char};\nuse std::{collections::HashSet, iter::Peekable, mem::swap, str::Chars};\n\n/// Complex regex patterns can cause the generation of leading literal patterns to take\n/// exponentially longer to compute. We impose a hard limit on the number of patterns we collect in\n/// order to keep this under control at the expense of not being able to always find leading\n/// literals for complex patterns.\n/// When combining leading literals we check using this constant to see if we are exceeding this\n/// limit and cancel the calculation (returning no leading literals at all) if the correct set\n/// would need to be truncated. This prevents us running an invalid fast path optimisation that can\n/// end up advancing us too far through the input.\nconst MAX_LEADING_LITERALS: usize = 50;\n\n#[derive(Debug, Clone, PartialEq, Eq)]\npub(super) enum Ast {\n    Comp(Comp),\n    Assertion(Assertion),\n    Alt(Vec<Ast>),\n    Rep(Rep, Box<Ast>),\n    Concat(Vec<Ast>),\n    SubMatch(SmKind, Box<Ast>),\n}\n\n#[derive(Debug, Clone, PartialEq, Eq)]\npub(super) enum SmKind {\n    Normal,\n    Named(String),\n    NonCapturing,\n}\n\nimpl Ast {\n    /// Extract leading literal string fragments from this [Ast].\n    ///\n    /// This is used for determining if we can make use of a fast literal search to determine the\n    /// start of a potential match before dropping into running the regex engine. Doing so can\n    /// result in a significant speedup.\n    pub fn leading_literals(&self) -> HashSet<String> {\n        let (mut lits, _) = self.leading_literals_inner();\n        lits.remove(\"\");\n        lits\n    }\n\n    fn leading_literals_inner(&self) -> (HashSet<String>, bool) {\n        match self {\n            // Actual literals that we need to collect\n            Self::Comp(Comp::Char(c)) => (std::iter::once(c.to_string()).collect(), true),\n            Self::Comp(Comp::Numeric) => (('0'..='9').map(String::from).collect(), true),\n\n            Self::Comp(Comp::Class(cls)) if !cls.negated && cls.size() <= MAX_LEADING_LITERALS => (\n                cls.chars\n                    .iter()\n                    .map(|ch| ch.to_string())\n                    .chain(\n                        cls.ranges\n                            .iter()\n                            .flat_map(|(start, end)| (*start..=*end).map(String::from)),\n                    )\n                    .collect(),\n                true,\n            ),\n\n            // Other comparisons are too broad for us to lift out into leading literals and\n            // assertions are not literals.\n            Self::Comp(_) | Self::Assertion(_) => (HashSet::new(), false),\n\n            Self::SubMatch(_, node) => node.leading_literals_inner(),\n\n            // Nested structure we need to combine\n            Self::Concat(nodes) => leading_literals_for_concat(nodes.iter()),\n\n            Self::Alt(nodes) => {\n                let mut lits = HashSet::new();\n                for node in nodes {\n                    lits.extend(node.leading_literals());\n                    if lits.len() > MAX_LEADING_LITERALS {\n                        lits.clear();\n                        return (lits, false);\n                    }\n                }\n\n                (lits, true)\n            }\n\n            Self::Rep(r, node) => {\n                let mut lits = node.leading_literals();\n                if r.is_nullable() && !lits.is_empty() {\n                    lits.insert(String::new());\n                }\n\n                (lits, false)\n            }\n        }\n    }\n\n    fn concat_or_node(mut nodes: Vec<Ast>) -> Ast {\n        match nodes.len() {\n            1 => nodes.remove(0),\n            _ => Ast::Concat(nodes),\n        }\n    }\n\n    pub fn op_len(&self) -> usize {\n        match self {\n            Ast::Comp(_) | Ast::Assertion(_) => 1,\n            Ast::Alt(nodes) => {\n                nodes.iter().map(|n| n.op_len()).sum::<usize>() + (nodes.len() - 1) * 2\n            }\n            Ast::Rep(r, node) => r.op_len(node.op_len()),\n            Ast::Concat(nodes) => nodes.iter().map(|n| n.op_len()).sum(),\n            Ast::SubMatch(SmKind::NonCapturing, node) => node.op_len(), // save start and end\n            Ast::SubMatch(_, node) => node.op_len() + 2,                // save start and end\n        }\n    }\n\n    pub fn reverse(&mut self) {\n        match self {\n            Self::Assertion(Assertion::LineStart) => *self = Self::Assertion(Assertion::LineEnd),\n            Self::Assertion(Assertion::LineEnd) => *self = Self::Assertion(Assertion::LineStart),\n\n            Self::Alt(nodes) => {\n                nodes.reverse();\n                nodes.iter_mut().for_each(|n| n.reverse());\n            }\n            Self::Rep(_, node) => node.reverse(),\n            Self::Concat(nodes) => {\n                nodes.reverse();\n                nodes.iter_mut().for_each(|n| n.reverse());\n            }\n            Self::SubMatch(_, node) => node.reverse(),\n            _ => (),\n        }\n    }\n\n    pub fn optimise(&mut self) {\n        let mut optimising = true;\n\n        while optimising {\n            optimising = match self {\n                Ast::Comp(cmp) => cmp.replace_common_classes(),\n                Ast::Concat(nodes) => compress_cats(nodes),\n                // TODO: extract common alt prefixes & dedup cases\n                _ => false,\n            };\n        }\n    }\n\n    fn contains_named_submatch(&self) -> bool {\n        match self {\n            Ast::SubMatch(SmKind::Named(_), _) => true,\n            Ast::SubMatch(_, node) => node.contains_named_submatch(),\n            Ast::Rep(_, node) => node.contains_named_submatch(),\n            Ast::Alt(nodes) => nodes.iter().any(|n| n.contains_named_submatch()),\n            Ast::Concat(nodes) => nodes.iter().any(|n| n.contains_named_submatch()),\n            _ => false,\n        }\n    }\n\n    fn named_submatch_only(&mut self) {\n        let apply = |nodes: &mut Vec<Ast>| {\n            for node in nodes.iter_mut() {\n                node.named_submatch_only()\n            }\n        };\n\n        match self {\n            Ast::SubMatch(SmKind::Named(_) | SmKind::NonCapturing, node) => {\n                node.named_submatch_only()\n            }\n\n            Ast::SubMatch(k @ SmKind::Normal, node) => {\n                node.named_submatch_only();\n                *k = SmKind::NonCapturing;\n            }\n\n            Ast::Alt(nodes) => apply(nodes),\n            Ast::Concat(nodes) => apply(nodes),\n            Ast::Rep(_, node) => node.named_submatch_only(),\n            _ => (),\n        }\n    }\n}\n\nfn leading_literals_for_concat(mut it: std::slice::Iter<'_, Ast>) -> (HashSet<String>, bool) {\n    let mut lits = HashSet::new();\n    lits.insert(String::new());\n    let mut ongoing = true;\n\n    while let Some(node) = it.next()\n        && ongoing\n    {\n        // We stop at assertions and repetitions alter how we proceed\n        let rep = match node {\n            Ast::Assertion(_) => {\n                ongoing = false;\n                break;\n            }\n            Ast::Rep(r, _) => Some(r),\n            _ => None,\n        };\n\n        let node_lits;\n        (node_lits, ongoing) = node.leading_literals_inner();\n\n        match rep {\n            // + and * both act as a break condition as we have an unbounded number of characters\n            // to consume. In the case of * we need to account for the case where we didn't match\n            // and include all of the literals that come afterwards directly.\n            Some(Rep::Plus(_)) => {\n                lits = combine(&lits, &node_lits);\n                if lits.len() > MAX_LEADING_LITERALS {\n                    lits.clear();\n                    return (lits, false);\n                }\n\n                break;\n            }\n\n            Some(Rep::Star(_)) => {\n                if !node_lits.is_empty() {\n                    let remaining = it.clone();\n                    let mut star_lits = combine(&lits, &node_lits);\n                    let (without_star_lits, _) = leading_literals_for_concat(remaining);\n                    star_lits.extend(combine(&lits, &without_star_lits));\n                    lits = star_lits;\n                }\n                if lits.len() > MAX_LEADING_LITERALS {\n                    lits.clear();\n                    return (lits, false);\n                }\n\n                lits.remove(\"\");\n                break;\n            }\n\n            _ => {\n                lits = combine(&lits, &node_lits);\n                if lits.len() > MAX_LEADING_LITERALS {\n                    lits.clear();\n                    return (lits, false);\n                }\n            }\n        };\n    }\n\n    (lits, ongoing)\n}\n\nfn combine(lits: &HashSet<String>, node_lits: &HashSet<String>) -> HashSet<String> {\n    lits.iter()\n        .flat_map(|l| {\n            node_lits.iter().map(|nl| {\n                let mut s = l.clone();\n                s.push_str(nl);\n                s\n            })\n        })\n        .collect()\n}\n\nfn compress_cats(nodes: &mut Vec<Ast>) -> bool {\n    let mut buf = Vec::new();\n    swap(&mut buf, nodes);\n\n    let mut buf2 = Vec::with_capacity(buf.len());\n    let mut compressing = true;\n    let mut compressed = false;\n\n    while compressing {\n        compressing = false;\n        for node in buf.drain(..) {\n            if let Ast::Concat(children) = node {\n                buf2.extend(children);\n                compressing = true;\n            } else {\n                buf2.push(node);\n            }\n        }\n        swap(&mut buf, &mut buf2);\n        compressed |= compressing;\n    }\n\n    swap(&mut buf, nodes);\n\n    compressed\n}\n\n#[derive(Debug, Clone, PartialEq, Eq)]\npub(super) enum Comp {\n    Char(char),\n    Class(CharClass),\n    Any,\n    TrueAny,\n    // Common classes\n    Numeric,\n    NonNumeric,\n    AlphaNumeric,\n    NonAlphaNumeric,\n    WhiteSpace,\n    NonWhiteSpace,\n}\n\nimpl Comp {\n    /// Whether or not this Comp matches the current VM state.\n    #[inline]\n    pub(super) fn matches(&self, ch: char) -> bool {\n        match self {\n            Comp::Char(c) => *c == ch,\n            Comp::Class(cls) => cls.matches(ch),\n            Comp::Any => ch != '\\n',\n            Comp::TrueAny => true,\n            Comp::Numeric => ch.is_ascii_digit(),\n            Comp::NonNumeric => !ch.is_ascii_digit(),\n            Comp::AlphaNumeric => ch.is_ascii_alphanumeric() || ch == '_',\n            Comp::NonAlphaNumeric => !(ch.is_ascii_alphanumeric() || ch == '_'),\n            Comp::WhiteSpace => ch.is_whitespace(),\n            Comp::NonWhiteSpace => !ch.is_whitespace(),\n        }\n    }\n\n    fn replace_common_classes(&mut self) -> bool {\n        match self {\n            Comp::Class(CharClass {\n                negated: false,\n                chars,\n                ranges,\n            }) if chars.is_empty() && ranges == &[('0', '9')] => {\n                *self = Comp::Numeric;\n                true\n            }\n\n            Comp::Class(CharClass {\n                negated: true,\n                chars,\n                ranges,\n            }) if chars.is_empty() && ranges == &[('0', '9')] => {\n                *self = Comp::NonNumeric;\n                true\n            }\n\n            Comp::Class(CharClass {\n                negated: false,\n                chars,\n                ranges,\n            }) if chars == &['_']\n                && ranges.contains(&('0', '9'))\n                && ranges.contains(&('a', 'z'))\n                && ranges.contains(&('A', 'Z')) =>\n            {\n                *self = Comp::AlphaNumeric;\n                true\n            }\n\n            Comp::Class(CharClass {\n                negated: true,\n                chars,\n                ranges,\n            }) if chars == &['_']\n                && ranges.contains(&('0', '9'))\n                && ranges.contains(&('a', 'z'))\n                && ranges.contains(&('A', 'Z')) =>\n            {\n                *self = Comp::NonAlphaNumeric;\n                true\n            }\n\n            _ => false,\n        }\n    }\n}\n\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub(super) enum Assertion {\n    LineStart,\n    LineEnd,\n    WordBoundary,\n    NonWordBoundary,\n}\n\nimpl Assertion {\n    #[inline]\n    pub(super) fn holds_for(&self, prev: Option<char>, ch: char, next: Option<char>) -> bool {\n        match self {\n            Assertion::LineStart => matches!(prev, Some('\\n') | None),\n            Assertion::LineEnd => matches!(next, Some('\\n') | None),\n\n            Assertion::WordBoundary => match (prev, next) {\n                (_, None) | (None, _) => true,\n                (Some(p), Some(n)) => is_word_boundary(p, ch) || is_word_boundary(ch, n),\n            },\n\n            Assertion::NonWordBoundary => match (prev, next) {\n                (_, None) | (None, _) => false,\n                (Some(p), Some(n)) => !is_word_boundary(p, ch) && !is_word_boundary(ch, n),\n            },\n        }\n    }\n}\n\nfn is_word_boundary(prev: char, ch: char) -> bool {\n    use CharKind::*;\n\n    matches!(\n        (CharKind::from(prev), CharKind::from(ch)),\n        (Word, Punctuation)\n            | (Punctuation, Word)\n            | (Word | Punctuation, Whitespace)\n            | (Whitespace, Word | Punctuation)\n    )\n}\n\n#[derive(Clone, Copy)]\nenum CharKind {\n    Word,\n    Punctuation,\n    Whitespace,\n}\n\nimpl From<char> for CharKind {\n    fn from(ch: char) -> Self {\n        if ch.is_alphanumeric() || ch == '_' {\n            CharKind::Word\n        } else if ch.is_whitespace() {\n            CharKind::Whitespace\n        } else {\n            CharKind::Punctuation\n        }\n    }\n}\n\n#[derive(Debug, Clone, PartialEq, Eq)]\npub(super) enum Greed {\n    Greedy,\n    Lazy,\n}\n\n#[derive(Debug, Clone, PartialEq, Eq)]\npub(super) enum Rep {\n    Quest(Greed),\n    Star(Greed),\n    Plus(Greed),\n}\n\nimpl Rep {\n    fn is_nullable(&self) -> bool {\n        matches!(self, Self::Quest(_) | Self::Star(_))\n    }\n\n    fn make_lazy(&mut self) {\n        match self {\n            Rep::Quest(g) => *g = Greed::Lazy,\n            Rep::Star(g) => *g = Greed::Lazy,\n            Rep::Plus(g) => *g = Greed::Lazy,\n        }\n    }\n\n    fn apply(self, nodes: &mut Vec<Ast>) -> Result<(), Error> {\n        let last = nodes.pop().ok_or(Error::InvalidRepetition)?;\n\n        match (self, last) {\n            (Rep::Quest(_), Ast::Rep(mut r, node)) => {\n                r.make_lazy();\n                nodes.push(Ast::Rep(r, node));\n            }\n            (r, last) => nodes.push(Ast::Rep(r, Box::new(last))),\n        }\n\n        Ok(())\n    }\n\n    fn op_len(&self, child_len: usize) -> usize {\n        match self {\n            // sp(n+1, n+2), op\n            Rep::Quest(_) => child_len + 1,\n            // sp(n+1, n+3), op, jmp(m-2)\n            Rep::Star(_) => child_len + 2,\n            // op, sp(n-1, n+1)\n            Rep::Plus(_) => child_len + 1,\n        }\n    }\n}\n\n#[derive(Debug, Clone, PartialEq, Eq)]\nenum Counted {\n    Rep(usize),               // {n}\n    RepAtLeast(usize),        // {n,}\n    RepBetween(usize, usize), // {n,m}\n}\n\nimpl Counted {\n    fn apply(self, nodes: &mut Vec<Ast>) -> Result<(), Error> {\n        let last = nodes.pop().ok_or(Error::InvalidRepetition)?;\n\n        match self {\n            Counted::Rep(n) => nodes.extend(vec![last; n]),\n            Counted::RepAtLeast(n) => {\n                nodes.extend(vec![last.clone(); n - 1]);\n                nodes.push(Ast::Rep(Rep::Plus(Greed::Greedy), Box::new(last)));\n            }\n            Counted::RepBetween(n, m) => {\n                nodes.extend(vec![last.clone(); n]);\n                nodes.extend(vec![\n                    Ast::Rep(Rep::Quest(Greed::Greedy), Box::new(last));\n                    m - n\n                ]);\n            }\n        }\n\n        Ok(())\n    }\n}\n\npub(super) fn parse(re: &str) -> Result<Ast, Error> {\n    let mut nodes = Vec::new();\n    let mut it = re.chars().peekable();\n\n    parse_many(&mut it, &mut nodes)?;\n\n    let mut root = match nodes.len() {\n        0 => return Err(Error::EmptyRegex),\n        _ => Ast::concat_or_node(nodes),\n    };\n\n    if root.contains_named_submatch() {\n        root.named_submatch_only()\n    }\n\n    Ok(root)\n}\n\nenum ParseEnd {\n    Rparen,\n    Eof,\n}\n\nfn parse1(it: &mut Peekable<Chars<'_>>, root: &mut Vec<Ast>) -> Result<Option<ParseEnd>, Error> {\n    match next_char(it)? {\n        Some((ch, true)) => handle_escaped(ch, root).map(|_| None),\n        Some((ch, false)) => handle_char(ch, it, root),\n        None => Ok(Some(ParseEnd::Eof)),\n    }\n}\n\nfn parse_many(it: &mut Peekable<Chars<'_>>, root: &mut Vec<Ast>) -> Result<ParseEnd, Error> {\n    loop {\n        match parse1(it, root)? {\n            Some(p) => return Ok(p),\n            None => continue,\n        }\n    }\n}\n\nfn handle_char(\n    ch: char,\n    it: &mut Peekable<Chars<'_>>,\n    root: &mut Vec<Ast>,\n) -> Result<Option<ParseEnd>, Error> {\n    match ch {\n        '|' => handle_alt(it, root)?,\n        '(' => handle_subexp(it, root)?,\n        ')' => return Ok(Some(ParseEnd::Rparen)),\n\n        '?' => Rep::Quest(Greed::Greedy).apply(root)?,\n        '*' => Rep::Star(Greed::Greedy).apply(root)?,\n        '+' => Rep::Plus(Greed::Greedy).apply(root)?,\n        '{' => try_parse_counted_repetition(it)?.apply(root)?,\n\n        '^' => root.push(Ast::Assertion(Assertion::LineStart)),\n        '$' => root.push(Ast::Assertion(Assertion::LineEnd)),\n\n        '[' => root.push(Ast::Comp(Comp::Class(CharClass::try_parse(it)?))),\n        '.' => root.push(Ast::Comp(Comp::Any)),\n        '@' => root.push(Ast::Comp(Comp::TrueAny)),\n        ch => root.push(Ast::Comp(Comp::Char(ch))),\n    }\n\n    Ok(None)\n}\n\n/// Three variants of submatch / group are supported by this engine:\n///   1) \"(...)\"\n///      Capturing: the position of this sub-expression will be extracted as submatch\n///      and made available through a numeric index based on it's position within the\n///      regular expression.\n///   2) \"(?<name>...)\"\n///      Named capturing: the position of this subexpression will be extracted as a submatch\n///      and made available through the provided name rather than an index. To avoid confusion\n///      with mixing and matching named capture groups and positional ones, the presence of a\n///      named capture group will mark all unnamed capture groups within that regex to be\n///      treated as non-capturing. If they are required, they will also need to be named.\n///   3) \"(?:...)\"\n///      Non-capturing: allows for grouping and application of repetition / alternation\n///      of compound expressions without contributing to the captured sub-expressions.\nfn handle_subexp(it: &mut Peekable<Chars<'_>>, root: &mut Vec<Ast>) -> Result<(), Error> {\n    let mut sub = Vec::new();\n    let kind = match it.peek() {\n        Some('?') => {\n            it.next();\n            match it.next() {\n                Some(':') => SmKind::NonCapturing,\n                Some('<') => {\n                    let mut name = String::new();\n                    for ch in it.by_ref() {\n                        if ch == '>' {\n                            break;\n                        }\n                        name.push(ch);\n                    }\n                    if it.peek().is_none() {\n                        return Err(Error::UnclosedGroupName(name));\n                    }\n                    SmKind::Named(name)\n                }\n                Some(ch) => return Err(Error::UnknownGroupQualifier(ch)),\n                None => return Err(Error::UnbalancedParens),\n            }\n        }\n        _ => SmKind::Normal,\n    };\n\n    let node = match parse_many(it, &mut sub)? {\n        ParseEnd::Eof => return Err(Error::UnbalancedParens),\n        ParseEnd::Rparen => match sub.len() {\n            0 => return Err(Error::EmptyParens),\n            1 => sub.remove(0),\n            _ => Ast::Concat(sub),\n        },\n    };\n\n    root.push(Ast::SubMatch(kind, Box::new(node)));\n\n    Ok(())\n}\n\nfn handle_alt(it: &mut Peekable<Chars<'_>>, root: &mut Vec<Ast>) -> Result<(), Error> {\n    if root.is_empty() {\n        return Err(Error::UnbalancedAlt);\n    }\n    let mut first = Vec::new();\n    swap(&mut first, root);\n    let mut alt = vec![Ast::concat_or_node(first)];\n    let mut buf = Vec::new();\n\n    loop {\n        if parse1(it, &mut buf)?.is_some() {\n            if buf.is_empty() {\n                return Err(Error::UnbalancedAlt);\n            }\n            alt.push(Ast::concat_or_node(buf));\n            break;\n        }\n\n        match it.peek() {\n            Some('|') => {\n                it.next();\n                alt.push(Ast::concat_or_node(buf.clone()));\n                buf.clear();\n            }\n            Some(')') => {\n                alt.push(Ast::concat_or_node(buf.clone()));\n                break;\n            }\n            _ => (),\n        }\n    }\n\n    root.push(Ast::Alt(alt));\n    Ok(())\n}\n\nfn handle_escaped(ch: char, root: &mut Vec<Ast>) -> Result<(), Error> {\n    match ch {\n        'b' => root.push(Ast::Assertion(Assertion::WordBoundary)),\n        'B' => root.push(Ast::Assertion(Assertion::NonWordBoundary)),\n\n        'd' => root.push(Ast::Comp(Comp::Numeric)),\n        'D' => root.push(Ast::Comp(Comp::NonNumeric)),\n        'w' => root.push(Ast::Comp(Comp::AlphaNumeric)),\n        'W' => root.push(Ast::Comp(Comp::NonAlphaNumeric)),\n        's' => root.push(Ast::Comp(Comp::WhiteSpace)),\n        'S' => root.push(Ast::Comp(Comp::NonWhiteSpace)),\n\n        ch => root.push(Ast::Comp(Comp::Char(ch))),\n    }\n\n    Ok(())\n}\n\nfn try_parse_counted_repetition(it: &mut Peekable<Chars<'_>>) -> Result<Counted, Error> {\n    let (mut ch, _) = next_char(it)?.ok_or(Error::InvalidRepetition)?;\n\n    if !ch.is_ascii_digit() {\n        return Err(Error::InvalidRepetition);\n    }\n    let n = parse_num(ch, it).ok_or(Error::InvalidRepetition)?;\n    if n == 0 {\n        return Err(Error::InvalidRepetition);\n    }\n\n    (ch, _) = next_char(it)?.ok_or(Error::InvalidRepetition)?;\n    if ch == '}' {\n        return Ok(Counted::Rep(n));\n    } else if ch != ',' {\n        return Err(Error::InvalidRepetition);\n    }\n\n    (ch, _) = next_char(it)?.ok_or(Error::InvalidRepetition)?;\n    if ch == '}' {\n        return Ok(Counted::RepAtLeast(n));\n    }\n\n    if !ch.is_ascii_digit() {\n        return Err(Error::InvalidRepetition);\n    }\n    let m = parse_num(ch, it).ok_or(Error::InvalidRepetition)?;\n    if m == 0 {\n        return Err(Error::InvalidRepetition);\n    }\n\n    (ch, _) = next_char(it)?.ok_or(Error::InvalidRepetition)?;\n    if ch == '}' {\n        Ok(Counted::RepBetween(n, m))\n    } else {\n        Err(Error::InvalidRepetition)\n    }\n}\n\n/// Attempt to parse a number from a sequence of digits.\n///\n/// `initial` must be an ASCII digit (enforced with an assert).\n/// This function will return `None` if the parsed sequence of digits is too large\n/// to fit within a `usize`.\nfn parse_num(initial: char, it: &mut Peekable<Chars<'_>>) -> Option<usize> {\n    assert!(initial.is_ascii_digit());\n    let mut s = String::from(initial);\n    loop {\n        match it.peek() {\n            Some(ch) if ch.is_ascii_digit() => {\n                s.push(it.next().unwrap());\n            }\n            _ => return s.parse().ok(),\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::Rep::*;\n    use super::*;\n    use Assertion::*;\n    use Greed::*;\n    use simple_test_case::test_case;\n\n    fn cat(nodes: Vec<Ast>) -> Ast {\n        Ast::Concat(nodes)\n    }\n\n    fn alt(nodes: Vec<Ast>) -> Ast {\n        Ast::Alt(nodes)\n    }\n\n    fn sub(s: Ast) -> Ast {\n        Ast::SubMatch(SmKind::Normal, Box::new(s))\n    }\n\n    fn ncsub(s: Ast) -> Ast {\n        Ast::SubMatch(SmKind::NonCapturing, Box::new(s))\n    }\n\n    fn nsub(name: &str, s: Ast) -> Ast {\n        Ast::SubMatch(SmKind::Named(name.to_string()), Box::new(s))\n    }\n\n    fn ch(c: char) -> Ast {\n        Ast::Comp(Comp::Char(c))\n    }\n\n    fn asr(a: Assertion) -> Ast {\n        Ast::Assertion(a)\n    }\n\n    fn rep(r: super::Rep, c: char) -> Ast {\n        Ast::Rep(r, Box::new(ch(c)))\n    }\n\n    #[test_case(\"a\", ch('a'); \"single char\")]\n    #[test_case(\"abc\", cat(vec![ch('a'), ch('b'), ch('c')]); \"chars only\")]\n    #[test_case(\"^a\", cat(vec![asr(LineStart), ch('a')]); \"line start\")]\n    #[test_case(\"a$\", cat(vec![ch('a'), asr(LineEnd)]); \"line end\")]\n    #[test_case(\"ab+\", cat(vec![ch('a'), rep(Plus(Greedy), 'b')]); \"plus\")]\n    #[test_case(\"ab*\", cat(vec![ch('a'), rep(Star(Greedy), 'b')]); \"star\")]\n    #[test_case(\"ab?\", cat(vec![ch('a'), rep(Quest(Greedy), 'b')]); \"question mark\")]\n    #[test_case(\"ab+?\", cat(vec![ch('a'), rep(Plus(Lazy), 'b')]); \"lazy plus\")]\n    #[test_case(\"ab*?\", cat(vec![ch('a'), rep(Star(Lazy), 'b')]); \"lazy star\")]\n    #[test_case(\"ab??\", cat(vec![ch('a'), rep(Quest(Lazy), 'b')]); \"lazy question mark\")]\n    #[test_case(\"a|b\", alt(vec![ch('a'), ch('b')]); \"single char alt\")]\n    #[test_case(\n        \"ab(c|d)\",\n        cat(vec![ch('a'), ch('b'), sub(alt(vec![ch('c'), ch('d')]))]);\n        \"alt in sub\"\n    )]\n    #[test_case(\"(foo)\", sub(cat(vec![ch('f'), ch('o'), ch('o')])); \"sub expression\")]\n    #[test_case(\"(?:foo)\", ncsub(cat(vec![ch('f'), ch('o'), ch('o')])); \"non capturing sub expression\")]\n    #[test_case(\"(?<bar>foo)\", nsub(\"bar\", cat(vec![ch('f'), ch('o'), ch('o')])); \"named sub expression\")]\n    #[test_case(\n        \"(?<bar>foo)(a|b)\",\n        cat(vec![nsub(\"bar\", cat(vec![ch('f'), ch('o'), ch('o')])), ncsub(alt(vec![ch('a'), ch('b')]))]);\n        \"named sub expression should demote non named to non capturing\"\n    )]\n    #[test]\n    fn parse_works(re: &str, expected: Ast) {\n        let res = parse(re).unwrap();\n        assert_eq!(res, expected);\n    }\n\n    #[test_case(\"abc\", \"cba\"; \"literals only\")]\n    #[test_case(\"ab+c\", \"cb+a\"; \"literals with plus\")]\n    #[test_case(\"a*bc\", \"cba*\"; \"literals with star\")]\n    #[test_case(\"abc?\", \"c?ba\"; \"literals with quest\")] // typos:ignore\n    #[test_case(\"a(bc)+\", \"(cb)+a\"; \"repeated capture group\")]\n    #[test_case(\"a|b\", \"b|a\"; \"alts\")]\n    #[test_case(\"[Gg]oo+gle\", \"elgo+o[Gg]\"; \"with class and rep\")]\n    #[test]\n    fn ast_reverse_works(re_forward: &str, re_back: &str) {\n        let mut forward_ast = parse(re_forward).unwrap();\n        forward_ast.reverse();\n        let back_ast = parse(re_back).unwrap();\n\n        assert_eq!(forward_ast, back_ast);\n    }\n\n    #[test_case(\"abc\", &[\"abc\"]; \"literals only\")]\n    #[test_case(\"ab+c\", &[\"ab\"]; \"literals with plus\")]\n    #[test_case(\"a+bc\", &[\"a\"]; \"leading plus\")]\n    #[test_case(\"a*bc\", &[\"a\", \"bc\"]; \"leading star\")]\n    #[test_case(\"ba*\", &[\"b\", \"ba\"]; \"star after lit\")] // typos:ignore\n    #[test_case(\"ab*c\", &[\"a\", \"ab\", \"ac\"]; \"star between lits\")]\n    #[test_case(\"abcd*e\", &[\"abc\", \"abcd\", \"abce\"]; \"star between lits long\")]\n    #[test_case(\"a?bc\", &[\"a\"]; \"leading question mark\")]\n    #[test_case(\"abc?\", &[\"ab\", \"abc\"]; \"literals with question mark\")]\n    #[test_case(\"a(bc)+\", &[\"abc\"]; \"repeated capture group\")]\n    #[test_case(\"ac|bd\", &[\"ac\", \"bd\"]; \"alts\")]\n    #[test_case(\"ac*x|bd\", &[\"a\", \"ac\", \"ax\", \"bd\"]; \"alts with star\")]\n    #[test_case(\"[Gg]oo+gle\", &[\"Goo\", \"goo\"]; \"with class and rep\")]\n    #[test_case(\".*\", &[]; \"dot star\")]\n    #[test_case(\".+\", &[]; \"dot plus\")]\n    #[test_case(\".?\", &[]; \"dot question mark\")]\n    #[test_case(\".*a\", &[]; \"leading dot star\")]\n    #[test_case(\".+a\", &[]; \"leading dot plus\")]\n    #[test_case(\".?a\", &[]; \"leading dot question mark\")]\n    #[test_case(\"([0-2]+)-more\", &[\"0\", \"1\", \"2\"]; \"leading submatch\")]\n    // Cases where we exceed MAX_LEADING_LITERALS and therefor return nothing\n    #[test_case(\"[a-zA-Z]+foo\", &[]; \"char class exceeds limit\")]\n    #[test_case(\"[a-z]|[A-Z]|[0-9]\", &[]; \"alt branches exceed limit\")]\n    #[test_case(\"[a-z][a-c]foo\", &[]; \"concat product exceeds limit\")]\n    #[test]\n    fn ast_leading_literal_patterns_works(re: &str, expected: &[&str]) {\n        let ast = parse(re).unwrap();\n        println!(\"AST {ast:?}\");\n        let pats = ast.leading_literals();\n        let expected: HashSet<String> = expected.iter().map(|s| s.to_string()).collect();\n\n        assert_eq!(pats, expected);\n    }\n\n    #[test_case(\"a{99999999999999999999}\"; \"single count\")]\n    #[test_case(\"a{99999999999999999999,5}\"; \"lower bound\")]\n    #[test_case(\"a{2,99999999999999999999}\"; \"upper bound\")]\n    #[test_case(\"a{99999999999999999999,99999999999999999999}\"; \"both bounds\")]\n    #[test]\n    fn giant_counted_repetitions_error(re: &str) {\n        assert!(parse(re).is_err());\n    }\n}\n", "source": "ad/src/regex/ast.rs", "file_type": "rc"}
{"text": "//! The op-code compiler and optimised for the regex VM\nuse super::ast::{Assertion, Ast, Comp, Greed, Rep, SmKind};\nuse std::collections::BTreeSet;\n\n#[derive(Debug, Clone, PartialEq, Eq)]\npub(super) struct Inst {\n    pub(super) op: Op,\n    pub(super) generation: usize,\n}\n\npub(super) type Prog = Vec<Inst>;\n\n#[derive(Debug, Clone, PartialEq, Eq)]\npub(super) enum Op {\n    Comp(Comp),\n    Assertion(Assertion),\n    Split(usize, usize),\n    Jump(usize),\n    Save(usize),\n    RSave(usize),\n    Match,\n}\n\nimpl Op {\n    fn is_control(&self) -> bool {\n        matches!(self, Op::Jump(_) | Op::Split(_, _) | Op::Match)\n    }\n}\n\nenum Ops {\n    One(Op),\n    Many(Vec<Op>),\n}\n\nimpl Ops {\n    #[inline]\n    fn len(&self) -> usize {\n        match self {\n            Ops::One(_) => 1,\n            Ops::Many(ops) => ops.len(),\n        }\n    }\n\n    #[inline]\n    fn add_to(self, buf: &mut Vec<Op>) {\n        match self {\n            Ops::One(op) => buf.push(op),\n            Ops::Many(ops) => buf.extend(ops),\n        }\n    }\n\n    #[inline]\n    fn into_vec(self) -> Vec<Op> {\n        match self {\n            Ops::One(op) => vec![op],\n            Ops::Many(ops) => ops,\n        }\n    }\n}\n\nfn alt_ops(mut nodes: Vec<Ast>, offset: usize, saves: &mut SmDetails, reverse: bool) -> Vec<Op> {\n    // Each node other than the last has an additional split and jump op\n    let alt_len = nodes.iter().map(|n| n.op_len()).sum::<usize>() + (nodes.len() - 1) * 2;\n    let mut buf = Vec::with_capacity(alt_len);\n    let last = nodes.pop().unwrap();\n    let it = nodes.into_iter();\n\n    for node in it {\n        let base = offset + buf.len();\n        buf.push(Op::Split(base + 1, base + 2 + node.op_len()));\n        node.into_ops(base + 1, saves, reverse).add_to(&mut buf);\n        buf.push(Op::Jump(offset + alt_len));\n    }\n\n    last.into_ops(offset + buf.len(), saves, reverse)\n        .add_to(&mut buf);\n\n    buf\n}\n\nfn concat_ops(nodes: Vec<Ast>, offset: usize, saves: &mut SmDetails, reverse: bool) -> Vec<Op> {\n    let concat_len = nodes.iter().map(|n| n.op_len()).sum();\n    let mut buf = Vec::with_capacity(concat_len);\n    for node in nodes.into_iter() {\n        node.into_ops(offset + buf.len(), saves, reverse)\n            .add_to(&mut buf);\n    }\n\n    buf\n}\n\nfn submatch_ops(\n    kind: SmKind,\n    node: Ast,\n    offset: usize,\n    saves: &mut SmDetails,\n    reverse: bool,\n) -> Vec<Op> {\n    match kind {\n        SmKind::NonCapturing => return node.into_ops(offset, saves, reverse).into_vec(),\n        SmKind::Named(name) => saves.names.push(name),\n        SmKind::Normal => (),\n    }\n\n    saves.n += 1;\n    let s = saves.n * 2;\n    let ops = node.into_ops(offset + 1, saves, reverse);\n    let mut buf = Vec::with_capacity(ops.len() + 2);\n\n    buf.push(if reverse {\n        Op::RSave(s + 1)\n    } else {\n        Op::Save(s)\n    });\n\n    ops.add_to(&mut buf);\n\n    buf.push(if reverse {\n        Op::RSave(s)\n    } else {\n        Op::Save(s + 1)\n    });\n\n    buf\n}\n\nfn rep_ops(r: Rep, node: Ast, offset: usize, saves: &mut SmDetails, reverse: bool) -> Vec<Op> {\n    match r {\n        Rep::Quest(greed) => {\n            let (mut l1, mut l2) = (offset + 1, offset + 1 + node.op_len());\n            if greed == Greed::Lazy {\n                (l1, l2) = (l2, l1);\n            };\n            let ops = node.into_ops(offset + 1, saves, reverse);\n            let mut buf = vec![Op::Split(l1, l2)];\n            ops.add_to(&mut buf);\n            buf\n        }\n\n        Rep::Star(greed) => {\n            let (mut l1, mut l2) = (offset + 1, offset + 2 + node.op_len());\n            if greed == Greed::Lazy {\n                (l1, l2) = (l2, l1);\n            };\n            let ops = node.into_ops(offset + 1, saves, reverse);\n            let mut buf = vec![Op::Split(l1, l2)];\n            ops.add_to(&mut buf);\n            buf.push(Op::Jump(offset));\n            buf\n        }\n\n        Rep::Plus(greed) => {\n            let (mut l1, mut l2) = (offset, offset + 1 + node.op_len());\n            if greed == Greed::Lazy {\n                (l1, l2) = (l2, l1);\n            };\n            let ops = node.into_ops(offset, saves, reverse);\n            let mut buf = Vec::new();\n            ops.add_to(&mut buf);\n            buf.push(Op::Split(l1, l2));\n            buf\n        }\n    }\n}\n\nimpl Ast {\n    /// Each AST node returns split and jump offsets as if it were zero indexed.\n    /// Wrapper nodes (alts, reps, cats, subexprs) update those offsets as needed\n    fn into_ops(self, offset: usize, saves: &mut SmDetails, reverse: bool) -> Ops {\n        match self {\n            Ast::Comp(comp) => Ops::One(Op::Comp(comp)),\n            Ast::Assertion(a) => Ops::One(Op::Assertion(a)),\n            Ast::Alt(nodes) => Ops::Many(alt_ops(nodes, offset, saves, reverse)),\n            Ast::Concat(nodes) => Ops::Many(concat_ops(nodes, offset, saves, reverse)),\n            Ast::Rep(r, node) => Ops::Many(rep_ops(r, *node, offset, saves, reverse)),\n            Ast::SubMatch(kind, node) => {\n                Ops::Many(submatch_ops(kind, *node, offset, saves, reverse))\n            }\n        }\n    }\n}\n\n/// While we compile the AST into our VM opcodes we need to track how many saves we have\n/// encountered so far so that we can insert the correct save instructions around sub-matches.\n///\n/// Assumptions:\n/// In the case of named sub-matches we do not support mixing and matching the named/unnamed\n/// so position with the names vector is sufficient for tracking the names of each match.\nstruct SmDetails {\n    n: usize,\n    names: Vec<String>,\n}\n\n#[derive(Debug, Clone, PartialEq, Eq)]\npub(super) struct CompiledOps {\n    pub(super) ops: Vec<Op>,\n    pub(super) n_submatches: usize,\n    pub(super) submatch_names: Vec<String>,\n}\n\npub(super) fn compile_ast(mut ast: Ast, reverse: bool) -> CompiledOps {\n    if reverse {\n        ast.reverse();\n    }\n\n    let mut saves = SmDetails {\n        n: 0,\n        names: Vec::new(),\n    };\n    let prog = match ast.into_ops(0, &mut saves, reverse) {\n        Ops::One(op) => vec![op],\n        Ops::Many(prog) => prog,\n    };\n\n    let (first_save, second_save) = if reverse {\n        (Op::RSave(1), Op::RSave(0))\n    } else {\n        (Op::Save(0), Op::Save(1))\n    };\n\n    // Compiled code for \"@*?\" to allow for unanchored matching.\n    // Save(0) marks the beginning of the regex in the input\n    // Save(1) marks the end of the regex in the input\n    let mut full = vec![\n        Op::Split(3, 1),\n        Op::Comp(Comp::TrueAny),\n        Op::Split(3, 1),\n        first_save,\n    ];\n    // Unconditionally increment all jumps and splits in the compiled program\n    // to account for the prefix we just added.\n    full.extend(prog.into_iter().map(|op| match op {\n        Op::Jump(j) => Op::Jump(j + 4),\n        Op::Split(l1, l2) => Op::Split(l1 + 4, l2 + 4),\n        op => op,\n    }));\n    full.extend([second_save, Op::Match]);\n\n    CompiledOps {\n        ops: full,\n        n_submatches: saves.n,\n        submatch_names: saves.names,\n    }\n}\n\npub(super) fn optimise(mut ops: Vec<Op>) -> Vec<Op> {\n    let mut optimising = true;\n\n    while optimising {\n        optimising = false;\n        for i in 0..ops.len() {\n            optimising |= inline_jumps(&mut ops, i);\n        }\n    }\n\n    strip_unreachable_instructions(&mut ops);\n\n    ops\n}\n\n// - Chained jumps or jumps to splits can be inlined\n// - Split to jump can be inlined\n// - Jump to Match is just Match\n// - Split to Match is Match if both branches are Match,\n//   otherwise there could be a longer match available\n//   on the non-Match branch so we keep the split\n#[inline]\nfn inline_jumps(ops: &mut [Op], i: usize) -> bool {\n    if let Op::Jump(j) = ops[i] {\n        if let Op::Jump(l1) = ops[j] {\n            ops[i] = Op::Jump(l1);\n        } else if let Op::Split(l1, l2) = ops[j] {\n            ops[i] = Op::Split(l1, l2);\n        } else if let Op::Match = ops[j] {\n            ops[i] = Op::Match;\n        } else {\n            return false;\n        }\n        return true;\n    } else if let Op::Split(s1, s2) = ops[i] {\n        if ops[s1] == Op::Match && ops[s2] == Op::Match {\n            ops[i] = Op::Match;\n            return true;\n        }\n\n        let new_s1 = if let Op::Jump(j1) = ops[s1] { j1 } else { s1 };\n        let new_s2 = if let Op::Jump(j2) = ops[s2] { j2 } else { s2 };\n        if new_s1 != s1 || new_s2 != s2 {\n            ops[i] = Op::Split(new_s1, new_s2);\n            return true;\n        }\n    }\n\n    false\n}\n\n// An instruction is unreachable if:\n// - it doesn't follow a comparison instruction (pc wouldn't advance to it)\n// - nothing now jumps or splits to it\nfn strip_unreachable_instructions(ops: &mut Vec<Op>) {\n    let mut to_from: Vec<(usize, usize)> = Vec::with_capacity(ops.len());\n    let mut jumps = BTreeSet::new();\n\n    for (i, op) in ops.iter().enumerate() {\n        match op {\n            Op::Jump(j) => {\n                jumps.insert(*j);\n                to_from.push((*j, i));\n            }\n            Op::Split(l1, l2) => {\n                jumps.extend([*l1, *l2]);\n                to_from.push((*l1, i));\n                to_from.push((*l2, i));\n            }\n            _ => (),\n        }\n    }\n\n    for i in (1..ops.len() - 1).rev() {\n        if !ops[i - 1].is_control() || jumps.contains(&i) {\n            continue;\n        }\n\n        for (to, from) in to_from.iter_mut() {\n            if *to > i {\n                match &mut ops[*from] {\n                    Op::Jump(x) => *x -= 1,\n                    Op::Split(x, _) if *x > i => *x -= 1,\n                    Op::Split(_, x) if *x > i => *x -= 1,\n                    _ => (),\n                }\n            }\n\n            if *from > i {\n                *from -= 1;\n            }\n        }\n\n        ops.remove(i);\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::regex::ast::parse;\n    use simple_test_case::test_case;\n\n    const BOL: Op = Op::Assertion(Assertion::LineStart);\n    const EOL: Op = Op::Assertion(Assertion::LineEnd);\n\n    fn sp(l1: usize, l2: usize) -> Op {\n        Op::Split(l1, l2)\n    }\n\n    fn jmp(l1: usize) -> Op {\n        Op::Jump(l1)\n    }\n\n    fn c(ch: char) -> Op {\n        Op::Comp(Comp::Char(ch))\n    }\n\n    fn sv(s: usize) -> Op {\n        Op::Save(s)\n    }\n\n    #[test_case(\"abc\", vec![c('a'), c('b'), c('c')]; \"lit only\")]\n    #[test_case(\"a|b\", vec![sp(5, 7), c('a'), jmp(8), c('b')]; \"single char alt\")]\n    #[test_case(\"a|b|c\", vec![sp(5, 7), c('a'), jmp(11), sp(8, 10), c('b'), jmp(11), c('c')]; \"chained alternation\")]\n    #[test_case(\"(a|b)\", vec![sv(2), sp(6, 8), c('a'), jmp(9), c('b'), sv(3)]; \"single char alt submatch\")]\n    #[test_case(\"ab(c|d)\", vec![c('a'), c('b'), sv(2), sp(8, 10), c('c'), jmp(11), c('d'), sv(3)]; \"literals then alt\")]\n    #[test_case(\"ab+a\", vec![c('a'), c('b'), sp(5, 7), c('a')]; \"plus for single lit\")]\n    #[test_case(\"ab?a\", vec![c('a'), sp(6, 7), c('b'), c('a')]; \"quest for single lit\")]\n    #[test_case(\"ab*a\", vec![c('a'), sp(6, 8), c('b'), jmp(5), c('a')]; \"star for single lit\")]\n    #[test_case(\"a(bb)+a\", vec![c('a'), sv(2), c('b'), c('b'), sv(3), sp(5, 10), c('a')]; \"rep of cat\")]\n    #[test_case(\"ba*\", vec![c('b'), sp(6, 8), c('a'), jmp(5)]; \"trailing star\")] // typos:ignore\n    #[test_case(\"b?a\", vec![sp(5, 6), c('b'), c('a')]; \"first lit is optional\")]\n    #[test_case(\"(a*)\", vec![sv(2), sp(6, 8), c('a'), jmp(5), sv(3)]; \"star\")]\n    #[test_case(\"(a*)*\", vec![sp(5, 11), sv(2), sp(7, 9), c('a'), jmp(6), sv(3), jmp(4)]; \"star star\")]\n    #[test_case(\"^foo\", vec![BOL, c('f'), c('o'), c('o')]; \"BOL then literals\")]\n    #[test_case(\"foo$\", vec![c('f'), c('o'), c('o'), EOL]; \"literals then EOL\")]\n    #[test_case(\"(?<xy>X|Y)(a|b)\", vec![sv(2), sp(6, 8), c('X'), jmp(9), c('Y'), sv(3), sp(11, 13), c('a'), jmp(14), c('b')]; \"named submatch demoting unnamed\")]\n    #[test]\n    fn ast_compile_works(re: &str, expected: Vec<Op>) {\n        let ast = parse(re).unwrap();\n        let prog = compile_ast(ast, false).ops;\n\n        let mut full = vec![sp(3, 1), Op::Comp(Comp::TrueAny), sp(3, 1), sv(0)];\n        full.extend(expected);\n        full.extend([sv(1), Op::Match]);\n\n        assert_eq!(prog, full);\n    }\n\n    #[test_case(\"a|b\", vec![sp(5, 7), c('a'), jmp(8), c('b')]; \"single char alt\")]\n    #[test_case(\"ab(c|d)\", vec![c('a'), c('b'), sv(2), sp(8, 10), c('c'), jmp(11), c('d'), sv(3)]; \"lits then alt\")] // typos:ignore\n    #[test_case(\"ab*a\", vec![c('a'), sp(6, 8), c('b'), sp(6, 8), c('a')]; \"star for single lit\")]\n    #[test_case(\"ba*\", vec![c('b'), sp(6, 8), c('a'), sp(6, 8)]; \"trailing star\")] // typos:ignore\n    #[test_case(\"(a*)*\", vec![sp(5, 11), sv(2), sp(7, 9), c('a'), sp(7, 9), sv(3), sp(5, 11)]; \"star star\")]\n    #[test_case(\"(?<xy>X|Y)(a|b)\", vec![sv(2), sp(6, 8), c('X'), jmp(9), c('Y'), sv(3), sp(11, 13), c('a'), jmp(14), c('b')]; \"named submatch demoting unnamed\")]\n    #[test]\n    fn opcode_optimise_works(re: &str, expected: Vec<Op>) {\n        let ast = parse(re).unwrap();\n        let prog = optimise(compile_ast(ast, false).ops);\n        let mut full = vec![sp(3, 1), Op::Comp(Comp::TrueAny), sp(3, 1), sv(0)];\n        full.extend(expected);\n        full.extend([sv(1), Op::Match]);\n\n        assert_eq!(prog, full);\n    }\n\n    #[test_case(\"(a*)*b\"; \"nested star\")]\n    #[test_case(\"((a|b)*)*c\"; \"nested alternation star\")]\n    #[test_case(\"(a+|b+)*c\"; \"alternation of plus star\")]\n    #[test_case(\"((a*b*)*c*)*d\"; \"deeply nested stars\")]\n    #[test_case(\"(((x|y)*z*)*w*)*v\"; \"complex nested pattern\")]\n    #[test]\n    fn stripping_nested_ops_doesnt_panic(re: &str) {\n        let ast = parse(re).unwrap();\n        let compiled = compile_ast(ast, false);\n        // This used to panic when tracking the removed op indices was incorrect\n        let _optimized = optimise(compiled.ops);\n    }\n}\n", "source": "ad/src/regex/compile.rs", "file_type": "rc"}
{"text": "//! Virtual machine based implementation based on the instruction set described\n//! in Russ Cox's second article in the series and the source of plan9 Sam:\n//!   <https://swtch.com/~rsc/regexp/regexp2.html>\n//!   <https://github.com/sminez/plan9port/blob/master/src/cmd/sam/regexp.c>\n//!\n//! The compilation step used is custom (rather than using a YACC parser).\n//!\n//! We make use of pre-allocated buffers for the Thread lists and track the\n//! index we are up to per-iteration as this results in roughly a 100x speed\n//! up from not having to allocate and free inside of the main loop.\nuse crate::regex::{\n    Error, Haystack,\n    ast::{Assertion, parse},\n    compile::{CompiledOps, Inst, Op, Prog, compile_ast, optimise},\n    matches::{Match, MatchIter},\n};\nuse aho_corasick::AhoCorasick;\nuse std::{\n    collections::HashSet,\n    fmt,\n    mem::swap,\n    sync::{Arc, Mutex},\n};\n\npub(super) const N_SLOTS: usize = 30;\n\n/// A regular expression engine designed for use within the ad text editor.\n///\n/// This is a relatively naive implementation though it does have some\n/// optimisations and runs reasonably quickly. It is not at all designed to\n/// be robust against malicious input and it does not attempt to support\n/// full PCRE syntax or functionality.\npub struct Regex {\n    re: Arc<str>,\n    inner: Mutex<RegexInner>,\n}\n\nimpl Clone for Regex {\n    fn clone(&self) -> Self {\n        let inner = self.inner.lock().unwrap().clone();\n\n        Self {\n            re: self.re.clone(),\n            inner: Mutex::new(inner),\n        }\n    }\n}\n\nimpl PartialEq for Regex {\n    fn eq(&self, other: &Self) -> bool {\n        self.re == other.re\n    }\n}\n\nimpl Eq for Regex {}\n\nimpl fmt::Debug for Regex {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_tuple(\"Regex\").field(&self.re).finish()\n    }\n}\n\nimpl fmt::Display for Regex {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"{}\", self.re)\n    }\n}\n\nimpl Regex {\n    /// Attempt to compile the given regular expression into its optimised VM opcode form.\n    ///\n    /// This method handles pre-allocation of the memory required for running the VM so\n    /// that the allocation cost is paid once up front rather than on each use of the Regex.\n    pub fn compile(re: impl AsRef<str>) -> Result<Self, Error> {\n        let mut ast = parse(re.as_ref())?;\n        ast.optimise();\n        let lits = ast.leading_literals();\n        let CompiledOps {\n            ops,\n            n_submatches,\n            submatch_names,\n        } = compile_ast(ast, false);\n\n        Ok(Self::new(\n            re.as_ref(),\n            ops,\n            n_submatches,\n            submatch_names,\n            lits,\n        ))\n    }\n\n    fn new(\n        re: &str,\n        ops: Vec<Op>,\n        n_submatches: usize,\n        submatch_names: Vec<String>,\n        leading_lits: HashSet<String>,\n    ) -> Self {\n        let prog: Prog = optimise(ops)\n            .into_iter()\n            .map(|op| Inst { op, generation: 0 })\n            .collect();\n\n        let clist = vec![Thread::default(); prog.len()].into_boxed_slice();\n        let nlist = vec![Thread::default(); prog.len()].into_boxed_slice();\n        let sms = vec![SubMatches::default(); prog.len()].into_boxed_slice();\n        let free_sms = (1..prog.len()).collect();\n\n        let fast_start = if leading_lits.is_empty() {\n            None\n        } else {\n            Some(Box::new(\n                AhoCorasick::new(leading_lits).expect(\"using auto builder so no errors possible\"),\n            ))\n        };\n\n        Self {\n            re: Arc::from(re),\n            inner: Mutex::new(RegexInner {\n                prog,\n                fast_start,\n                n_submatches,\n                submatch_names: Arc::from(submatch_names.into_boxed_slice()),\n                clist,\n                nlist,\n                generation: 0,\n                p: 0,\n                prev: None,\n                next: None,\n                sms,\n                free_sms,\n                track_submatches: true,\n            }),\n        }\n    }\n\n    /// Determine whether or not this Regex matches the [Haystack] without searching for the\n    /// leftmost-longest match and associated submatch boundaries.\n    pub fn matches<H>(&self, haystack: &H) -> bool\n    where\n        H: Haystack,\n    {\n        let mut inner = self.inner.lock().unwrap();\n        inner.track_submatches = false;\n        inner.match_from_byte_offset(haystack, 0).is_some()\n    }\n\n    /// Determine whether or not this Regex matches the [Haystack] from the given offset without\n    /// searching for the leftmost-longest match and associated submatch boundaries.\n    pub fn matches_from<H>(&self, haystack: &H, offset: usize) -> bool\n    where\n        H: Haystack,\n    {\n        let mut inner = self.inner.lock().unwrap();\n        inner.track_submatches = false;\n        inner.match_from_byte_offset(haystack, offset).is_some()\n    }\n\n    /// Determine whether or not this Regex matches the [Haystack] between the given offsets\n    /// without searching for the leftmost-longest match and associated submatch boundaries.\n    pub fn matches_between<H>(&self, haystack: &H, from: usize, to: usize) -> bool\n    where\n        H: Haystack,\n    {\n        let mut inner = self.inner.lock().unwrap();\n        inner.track_submatches = false;\n        inner\n            .match_between_byte_offsets(haystack, from, to)\n            .is_some()\n    }\n\n    /// Search the given [Haystack] for the leftmost longest match of this [Regex] and return the\n    /// match position along with all submatches.\n    ///\n    /// It is recommended that you call [Haystack::try_make_contiguous] before calling this method\n    /// in order to speed up searching whenever this is possible.\n    pub fn find<H>(&self, haystack: &H) -> Option<Match>\n    where\n        H: Haystack,\n    {\n        let mut inner = self.inner.lock().unwrap();\n        inner.track_submatches = true;\n        inner.match_from_byte_offset(haystack, 0)\n    }\n\n    /// Search the given [Haystack] for the leftmost longest match of this [Regex] starting from\n    /// the provided byte offset rather than the beginning of the haystack, returning\n    /// the match position along with all submatches.\n    ///\n    /// It is recommended that you call [Haystack::try_make_contiguous] before calling this method\n    /// in order to speed up searching whenever this is possible.\n    pub fn find_from<H>(&self, haystack: &H, offset: usize) -> Option<Match>\n    where\n        H: Haystack,\n    {\n        let mut inner = self.inner.lock().unwrap();\n        inner.track_submatches = true;\n        inner.match_from_byte_offset(haystack, offset)\n    }\n\n    /// Search the given [Haystack] for the leftmost longest match of this [Regex] starting from\n    /// the provided byte offset rather than the beginning of the haystack, and ending before\n    /// the provided `char_to`, returning the match position along with all submatches.\n    ///\n    /// It is recommended that you call [Haystack::try_make_contiguous] before calling this method\n    /// in order to speed up searching whenever this is possible.\n    pub fn find_between<H>(&self, haystack: &H, from: usize, to: usize) -> Option<Match>\n    where\n        H: Haystack,\n    {\n        let mut inner = self.inner.lock().unwrap();\n        inner.track_submatches = true;\n        inner.match_between_byte_offsets(haystack, from, to)\n    }\n\n    /// It is recommended that you call [Haystack::try_make_contiguous] before calling this method\n    /// in order to speed up searching whenever this is possible.\n    pub fn find_iter<'a, H>(&'a mut self, haystack: &'a H) -> MatchIter<'a, H>\n    where\n        H: Haystack,\n    {\n        self.inner.lock().unwrap().track_submatches = true;\n\n        MatchIter {\n            haystack,\n            r: self,\n            from: 0,\n        }\n    }\n}\n\n#[derive(Debug, Clone, PartialEq, Eq)]\npub struct RevRegex(Regex);\n\nimpl RevRegex {\n    /// Attempt to compile the given regular expression into its reversed optimised VM opcode form.\n    /// This is used for searching backwards through an input stream.\n    ///\n    /// This method handles pre-allocation of the memory required for running the VM so\n    /// that the allocation cost is paid once up front rather than on each use of the Regex.\n    pub fn compile(re: impl AsRef<str>) -> Result<Self, Error> {\n        let mut ast = parse(re.as_ref())?;\n        ast.optimise();\n        let CompiledOps {\n            ops,\n            n_submatches,\n            submatch_names,\n        } = compile_ast(ast, true);\n\n        Ok(Self(Regex::new(\n            re.as_ref(),\n            ops,\n            n_submatches,\n            submatch_names,\n            HashSet::new(),\n        )))\n    }\n\n    /// Search the given [Haystack] for the leftmost longest match of this [Regex] starting from\n    /// the provided `from` bytes offset rather than the beginning of the haystack, returning the\n    /// match position along with all submatches.\n    pub fn find_rev_from<H>(&self, haystack: &H, offset: usize) -> Option<Match>\n    where\n        H: Haystack,\n    {\n        let mut inner = self.0.inner.lock().unwrap();\n        inner.track_submatches = true;\n        inner.run_vm(&mut haystack.rev_iter_between(0, offset), offset)\n    }\n}\n\n#[derive(Clone)]\nstruct RegexInner {\n    /// The compiled instructions for running the VM\n    prog: Prog,\n    /// Fast searcher for the first potential match site\n    fast_start: Option<Box<AhoCorasick>>,\n    /// The number of submatches present in the pattern\n    n_submatches: usize,\n    /// Names to be used for extracting named submatches\n    submatch_names: Arc<[String]>,\n    /// Pre-allocated Thread list in priority order to handle leftmost-longest semantics\n    clist: Box<[Thread]>,\n    /// Pre-allocated Thread list in priority order to handle leftmost-longest semantics\n    nlist: Box<[Thread]>,\n    /// Pre-allocated SubMatch positions referenced by threads\n    sms: Box<[SubMatches]>,\n    /// Available indices into self.sms for storing SubMatch positions for new threads\n    free_sms: Vec<usize>,\n    track_submatches: bool,\n    /// Monotonically increasing index used to dedup Threads\n    /// Will overflow at some point if a given regex is used a VERY large number of times\n    generation: usize,\n    /// Index into the current Thread list\n    p: usize,\n    /// Previous character from the input\n    prev: Option<char>,\n    /// Next character in the input after the one currently being processed\n    next: Option<char>,\n}\n\nimpl RegexInner {\n    /// If we have leading literals then it is possible to try to find the start of a potential\n    /// match more quickly using aho-corasick.\n    ///\n    /// This is only valid to use when the haystack is contiguous.\n    fn fast_update_byte_offset<H>(&self, haystack: &H, mut byte_offset: usize) -> Option<usize>\n    where\n        H: Haystack,\n    {\n        assert!(\n            haystack.is_contiguous(),\n            \"fast_update_byte_offset called for discontiguous haystack\"\n        );\n\n        let ac = self.fast_start.as_ref()?;\n        // If aho-corasick cant find a match for our literal prefixes then we fall back to running\n        // the full search as we need to place an upper bound on the number of leading literal\n        // patterns we check for in order to constrain the search space. Otherwise we know that any\n        // potential match cant start before the start of the prefix that was found so we update\n        // our byte_offset to there before running the VM.\n        if let Some(m) = ac.find(haystack.substr_from(byte_offset)?.as_ref()) {\n            // m.start is based on the substr not the full haystack so we need to add the original\n            // offset to get the correct value.\n            byte_offset += m.start();\n        }\n\n        Some(byte_offset)\n    }\n\n    /// If the given [Haystack] supports accelerated searching then it is handled here before\n    /// passing off to [Regex::run_vm].\n    ///\n    /// Callers need to set `self.track_submatches` prior to calling this method.\n    fn match_from_byte_offset<H>(&mut self, haystack: &H, mut offset: usize) -> Option<Match>\n    where\n        H: Haystack,\n    {\n        if haystack.is_contiguous() {\n            offset = self\n                .fast_update_byte_offset(haystack, offset)\n                .unwrap_or(offset);\n        }\n\n        self.run_vm(&mut haystack.iter_from(offset)?, offset)\n    }\n\n    fn match_between_byte_offsets<H>(\n        &mut self,\n        haystack: &H,\n        mut from: usize,\n        to: usize,\n    ) -> Option<Match>\n    where\n        H: Haystack,\n    {\n        if haystack.is_contiguous()\n            && let Some(new_from) = self.fast_update_byte_offset(haystack, from)\n        {\n            if new_from > to {\n                return None; // no match within offsets\n            }\n            from = new_from;\n        }\n\n        self.run_vm(&mut haystack.iter_between(from, to), from)\n    }\n\n    /// This is the main VM implementation that is used by all other matching methods on Regex.\n    ///\n    /// The `track_submatches` flag is used to early return a dummy Match as soon as we\n    /// can tell that the given regular expression matches the input (rather than looking for\n    /// the leftmost-longest match).\n    ///  - The Match returned in this case will always point to the null string at the start\n    ///    of the string and should only be used for conversion to a bool in `matches_*`\n    ///    methods.\n    fn run_vm<I>(&mut self, input: &mut I, mut sp: usize) -> Option<Match>\n    where\n        I: Iterator<Item = (usize, char)>,\n    {\n        let mut sub_matches = [0; N_SLOTS];\n        self.free_sms = (1..self.prog.len()).collect();\n        self.sms[0] = SubMatches {\n            refs: 1,\n            inner: [0; N_SLOTS],\n        };\n\n        // We bump the generation to ensure we don't collide with anything from\n        // a previous run while initialising the VM.\n        self.generation += 1;\n        // When setting up the initial threads we have our prelude which uses \"@\" so we provide a\n        // null byte for the initial character as it is not needed and it avoids us having to make\n        // the \"ch\" param of add_thread optional.\n        self.add_thread(Thread::default(), sp, '\\0', true);\n        swap(&mut self.clist, &mut self.nlist);\n        self.generation += 1;\n\n        // Same as at the end of the outer for-loop, we need to reset self.p to 0\n        // so that we are correctly tracking the length of the new nlist.\n        let mut n = self.p;\n        self.p = 0;\n        let mut matched = false;\n\n        let mut it = input.peekable();\n        self.prev = None;\n        self.next = None;\n\n        while let Some((i, ch)) = it.next() {\n            sp = i;\n            self.next = it.peek().map(|(_, c)| *c);\n\n            for i in 0..n {\n                if let Some(sm) = self.step_thread(i, sp, ch) {\n                    if !self.track_submatches {\n                        return Some(Match::synthetic(0, 0));\n                    }\n\n                    matched = true;\n                    sub_matches = self.sms[sm].inner;\n\n                    // We're ending this thread and all others that have lower priority\n                    // so decrement the references they have to their submatches\n                    for j in i..n {\n                        self.sm_dec_ref(self.clist[j].sm);\n                    }\n\n                    break;\n                }\n            }\n\n            swap(&mut self.clist, &mut self.nlist);\n            self.prev = Some(ch);\n            self.generation += 1;\n            n = self.p;\n\n            if self.p == 0 {\n                break;\n            }\n\n            self.p = 0;\n        }\n\n        self.prev = None;\n        self.next = None;\n\n        // Check to see if the final pass had a match which would be better than any\n        // that we have so far.\n        for t in self.clist.iter_mut().take(n) {\n            if self.prog[t.pc].op == Op::Match && self.sms[t.sm].inner[1] >= sub_matches[1] {\n                matched = true;\n                sub_matches = self.sms[t.sm].inner;\n                break;\n            }\n        }\n\n        if !matched {\n            return None;\n        }\n\n        Some(Match {\n            n_submatches: self.n_submatches,\n            sub_matches,\n            submatch_names: self.submatch_names.clone(),\n        })\n    }\n\n    #[inline]\n    fn step_thread(&mut self, i: usize, sp: usize, ch: char) -> Option<usize> {\n        let t = &self.clist[i];\n        match &self.prog[t.pc].op {\n            // If comparisons and their assertions hold then queue the resulting threads\n            Op::Comp(comp) if comp.matches(ch) => match t.assertion {\n                Some(a) if !a.holds_for(self.prev, ch, self.next) => {\n                    self.sm_dec_ref(t.sm);\n                    return None;\n                }\n                _ => self.add_thread(thread(t.pc + 1, t.sm), sp, ch, false),\n            },\n\n            Op::Match => return Some(t.sm),\n\n            // Save, Jump & Split are handled in add_thread.\n            // Non-matching comparison ops result in that thread dying.\n            _ => self.sm_dec_ref(t.sm),\n        }\n\n        None\n    }\n\n    #[inline]\n    fn add_thread(&mut self, t: Thread, sp: usize, ch: char, initial: bool) {\n        if self.prog[t.pc].generation == self.generation {\n            self.sm_dec_ref(t.sm);\n            return; // already on the list we are currently building\n        }\n        self.prog[t.pc].generation = self.generation;\n\n        // We do this as chained if-let as we need to recursively call add_thread with data\n        // from self.prog but add_thread required &mut self, so matching would mean we had\n        // to Clone as Op::Class does not implement Copy.\n        // > This is faster than cloning the op and matching\n        if let Op::Jump(l1) = self.prog[t.pc].op {\n            let th = match t.assertion {\n                Some(a) => assert_thread(l1, t.sm, a),\n                None => thread(l1, t.sm),\n            };\n            self.add_thread(th, sp, ch, initial);\n        } else if let Op::Split(l1, l2) = self.prog[t.pc].op {\n            self.sms[t.sm].refs += 1;\n            let (t1, t2) = match t.assertion {\n                Some(a) => (assert_thread(l1, t.sm, a), assert_thread(l2, t.sm, a)),\n                None => (thread(l1, t.sm), thread(l2, t.sm)),\n            };\n            self.add_thread(t1, sp, ch, initial);\n            self.add_thread(t2, sp, ch, initial);\n        } else if let Op::Assertion(a) = self.prog[t.pc].op {\n            self.add_thread(assert_thread(t.pc + 1, t.sm, a), sp, ch, initial);\n        } else if let Op::Save(s) = self.prog[t.pc].op {\n            self.handle_save(t, s, sp, ch, initial, false)\n        } else if let Op::RSave(s) = self.prog[t.pc].op {\n            self.handle_save(t, s, sp, ch, initial, true)\n        } else {\n            self.nlist[self.p] = t;\n            self.p += 1;\n        }\n    }\n\n    #[inline]\n    fn handle_save(&mut self, t: Thread, s: usize, sp: usize, ch: char, initial: bool, rev: bool) {\n        // If we are saving our initial position from a forward match then we are looking at the\n        // correct character, otherwise the Save op is being processed at the character before the\n        // one we need to save.\n        let inc_bytes = if !initial && !rev { ch.len_utf8() } else { 0 };\n\n        if (!rev && s.is_multiple_of(2)) || (rev && !s.is_multiple_of(2)) {\n            let sm = self.sm_update(t.sm, s, sp + inc_bytes);\n            let th = match t.assertion {\n                Some(a) => assert_thread(t.pc + 1, sm, a),\n                None => thread(t.pc + 1, sm),\n            };\n            self.add_thread(th, sp, ch, initial);\n        } else {\n            match t.assertion {\n                Some(a) if !a.holds_for(self.prev, ch, self.next) => self.sm_dec_ref(t.sm),\n                _ => {\n                    let sm = self.sm_update(t.sm, s, sp + inc_bytes);\n                    self.add_thread(thread(t.pc + 1, sm), sp, ch, initial);\n                }\n            }\n        }\n    }\n\n    #[inline]\n    fn sm_dec_ref(&mut self, i: usize) {\n        if !self.track_submatches {\n            return;\n        }\n\n        self.sms[i].refs -= 1;\n        if self.sms[i].refs == 0 {\n            self.free_sms.push(i);\n        }\n    }\n\n    #[inline]\n    fn sm_update(&mut self, i: usize, s: usize, sp: usize) -> usize {\n        // We don't hard error on compiling a regex with more than out max submatches\n        // but we don't track anything past the last one\n        if !self.track_submatches || s >= N_SLOTS {\n            return i;\n        }\n\n        let i = if self.sms[i].refs == 1 {\n            i\n        } else {\n            self.sm_dec_ref(i);\n            let j = self.free_sms.swap_remove(0);\n            self.sms[j].inner = self.sms[i].inner;\n            self.sms[j].refs = 1;\n            j\n        };\n\n        self.sms[i].inner[s] = sp;\n\n        i\n    }\n}\n\n#[derive(Debug, Default, Clone, Copy, PartialEq, Eq)]\nstruct SubMatches {\n    /// How many threads are currently pointing at this SubMatches\n    refs: usize,\n    /// $0 -> $n submatches with $0 being the full match\n    /// for submatch $k the start index is 2$k and the end is 2$k+1\n    inner: [usize; N_SLOTS],\n}\n\n#[derive(Debug, Default, Clone, Copy, PartialEq, Eq)]\nstruct Thread {\n    /// VM program counter for this thread\n    pc: usize,\n    /// An assertion that must hold for this instruction to be runnable\n    assertion: Option<Assertion>,\n    /// Index into the Regex sms field\n    sm: usize,\n}\n\n#[inline]\nfn thread(pc: usize, sm: usize) -> Thread {\n    Thread {\n        pc,\n        sm,\n        assertion: None,\n    }\n}\n\n#[inline]\nfn assert_thread(pc: usize, sm: usize, a: Assertion) -> Thread {\n    Thread {\n        pc,\n        sm,\n        assertion: Some(a),\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::buffer::Buffer;\n    use simple_test_case::test_case;\n\n    // typos:off\n    #[test_case(\"foo\", \"foo\", Some(\"foo\"); \"literal full string\")]\n    #[test_case(\"ba*\", \"baaaaa\", Some(\"baaaaa\"); \"zero or more present\")]\n    #[test_case(\"ba*\", \"b\", Some(\"b\"); \"zero or more not present\")]\n    #[test_case(\"ba+\", \"baaaaa\", Some(\"baaaaa\"); \"one or more present\")]\n    #[test_case(\"ba+\", \"b\", None; \"one or more not present\")]\n    #[test_case(\"b?a\", \"ba\", Some(\"ba\"); \"optional present\")]\n    #[test_case(\"b?a\", \"a\", Some(\"a\"); \"optional not present\")]\n    #[test_case(\"a(bb)+a\", \"abbbba\", Some(\"abbbba\"); \"article example matching\")]\n    #[test_case(\"a(bb)+a\", \"abbba\", None; \"article example non matching\")]\n    #[test_case(\".*b\", \"123b\", Some(\"123b\"); \"dot star prefix\")]\n    #[test_case(\"1.*\", \"123b\", Some(\"123b\"); \"dot star suffix\")]\n    #[test_case(\"1.*b\", \"123b\", Some(\"123b\"); \"dot star inner\")]\n    #[test_case(\"(c|C)ase matters\", \"case matters\", Some(\"case matters\"); \"alternation first\")]\n    #[test_case(\"(c|C)ase matters\", \"Case matters\", Some(\"Case matters\"); \"alternation second\")]\n    #[test_case(\"(aa|bbb|c|dd)\", \"c\", Some(\"c\"); \"chained alternation\")]\n    #[test_case(\"this@*works\", \"this contains\\nbut still works\", Some(\"this contains\\nbut still works\"); \"true any\")]\n    #[test_case(r\"literal\\?\", \"literal?\", Some(\"literal?\"); \"escape special char\")]\n    #[test_case(r\"literal\\t\", \"literal\\t\", Some(\"literal\\t\"); \"escape sequence\")]\n    #[test_case(\"[abc] happy cow\", \"a happy cow\", Some(\"a happy cow\"); \"character class\")]\n    #[test_case(\"[^abc] happy cow\", \"a happy cow\", None; \"negated character class\")]\n    #[test_case(\"[a-zA-Z]*\", \"camelCaseFtw\", Some(\"camelCaseFtw\"); \"char class ranges matching\")]\n    #[test_case(\"[a-zA-Z]*1\", \"kebab-case-not-so-much\", None; \"char class ranges non matching\")]\n    #[test_case(\"[a-zA-Z ]*\", \"this should work\", Some(\"this should work\"); \"char class mixed\")]\n    #[test_case(\"[\\\\]5]*\", \"5]]5555]]\", Some(\"5]]5555]]\"); \"char class escaped bracket\")]\n    #[test_case(\"[0-9]+\", \"0123\", Some(\"0123\"); \"digit range\")]\n    #[test_case(\"[0-9]+\", \"0\", Some(\"0\"); \"digit range range start only\")]\n    #[test_case(\"25[0-5]\", \"255\", Some(\"255\"); \"ipv4 element one\")]\n    #[test_case(\"2[0-4][0-9]\", \"231\", Some(\"231\"); \"ipv4 element two\")]\n    #[test_case(\"1?[0-9]?[0-9]\", \"155\", Some(\"155\"); \"ipv4 element three three digit\")]\n    #[test_case(\"1?[0-9]?[0-9]\", \"72\", Some(\"72\"); \"ipv4 element three two digit\")]\n    #[test_case(\"1?[0-9]?[0-9]\", \"8\", Some(\"8\"); \"ipv4 element three one digit\")]\n    #[test_case(\"1?[0-9]?[0-9]\", \"0\", Some(\"0\"); \"ipv4 element three zero\")]\n    #[test_case(\"(25[0-5]|2[0-4][0-9])\", \"255\", Some(\"255\"); \"ipv4 elements one and two matching one\")]\n    #[test_case(\"(25[0-5]|2[0-4][0-9])\", \"219\", Some(\"219\"); \"ipv4 elements one and two matching two\")]\n    #[test_case(\"(25[0-5]|2[0-4][0-9])\", \"42\", None; \"ipv4 elements one and two not matching\")]\n    #[test_case(\"(2[0-4][0-9]|1?[0-9]?[0-9])\", \"237\", Some(\"237\"); \"ipv4 elements two and three matching two\")]\n    #[test_case(\"(2[0-4][0-9]|1?[0-9]?[0-9])\", \"142\", Some(\"142\"); \"ipv4 elements two and three matching three\")]\n    #[test_case(\"(25[0-5]|2[0-4][0-9]|1?[0-9]?[0-9])\", \"251\", Some(\"251\"); \"ipv4 all elements matching one\")]\n    #[test_case(\"(25[0-5]|2[0-4][0-9]|1?[0-9]?[0-9])\", \"237\", Some(\"237\"); \"ipv4 all elements matching two\")]\n    #[test_case(\"(25[0-5]|2[0-4][0-9]|1?[0-9]?[0-9])\", \"142\", Some(\"142\"); \"ipv4 all elements matching three\")]\n    #[test_case(\n        r\"(25[0-5]|2[0-4][0-9]|1?[0-9]?[0-9])\\.(25[0-5]|2[0-4][0-9]|1?[0-9]?[0-9])\\.(25[0-5]|2[0-4][0-9]|1?[0-9]?[0-9])\\.(25[0-5]|2[0-4][0-9]|1?[0-9]?[0-9])\",\n        \"127.0.0.1 \",\n        Some(\"127.0.0.1\");\n        \"ipv4 full\"\n    )]\n    #[test_case(\"^foo\", \"foo at the start\", Some(\"foo\"); \"SOL holding\")]\n    #[test_case(\"^foo\", \"bar\\nfoo at the start\", Some(\"foo\"); \"SOL holding after newline\")]\n    #[test_case(\"^foo\", \"we have foo but not at the start\", None; \"SOL not holding\")]\n    #[test_case(\"foo$\", \"a line that ends with foo\", Some(\"foo\"); \"BOL holding\")]\n    #[test_case(\"foo$\", \"a line that ends with foo\\nnow bar\", Some(\"foo\"); \"BOL holding before newline\")]\n    #[test_case(\"foo$\", \"a line with foo in the middle\", None; \"BOL not holding\")]\n    #[test_case(\"foo\", \"\u2502foo\", Some(\"foo\"); \"after a multibyte char\")]\n    #[test_case(\"a{3}\", \"aaa\", Some(\"aaa\"); \"counted repetition\")]\n    #[test_case(\"a{3}\", \"aa\", None; \"counted repetition non matching\")]\n    #[test_case(\"a{3,}\", \"aaaaaa\", Some(\"aaaaaa\"); \"counted repetition at least\")]\n    #[test_case(\"a{3,}\", \"aa\", None; \"counted repetition at least non matching\")]\n    #[test_case(\"a{3,5}\", \"aaa\", Some(\"aaa\"); \"counted repetition between lower\")]\n    #[test_case(\"a{3,5}\", \"aaaaa\", Some(\"aaaaa\"); \"counted repetition between upper\")]\n    #[test_case(\"a{3,5}\", \"aaaa\", Some(\"aaaa\"); \"counted repetition in range\")]\n    #[test_case(\"a{3,5}\", \"aa\", None; \"counted repetition less\")]\n    #[test_case(\"^a{3,5}$\", \"aaaaaa\", None; \"counted repetition more\")]\n    #[test_case(\"\\\\b\\\\w+\\\\b\", \"foo\", Some(\"foo\"); \"word boundary at end of input\")]\n    #[test_case(\"\\\\bfor\\\\b\", \"forward\", None; \"word boundary for match at start of word\")]\n    #[test_case(\"\\\\bfor\\\\b\", \"for ward\", Some(\"for\"); \"word boundary for match not inside word\")]\n    #[test_case(\"\\\\bfor\\\\b\", \"bob for\", Some(\"for\"); \"word boundary match not at BOF\")]\n    #[test_case(\"\\\\bfor\\\\b\", \"bob for bob\", Some(\"for\"); \"word boundary match not at BOF or EOF\")]\n    #[test_case(\"\\\\bin\\\\b\", \"min\", None; \"word boundary for match at end of word\")]\n    #[test_case(\"\\\\b(in)\\\\b\", \"min\", None; \"word boundary for sub expression match at end of word\")]\n    #[test_case(\"\\\\b(in|for)\\\\b\", \"min\", None; \"word boundary for alt match at end of word\")]\n    #[test_case(\"\\\\b(in|for)\\\\b\", \"bob for\", Some(\"for\"); \"word boundary for alt match not at BOF\")]\n    #[test_case(\"[a-zA-Z0-9_\\\\-./@]+\\\\.jpe?g\", \"glenda_space_medium.jpg\", Some(\"glenda_space_medium.jpg\"); \"complex group\")]\n    #[test_case(\"[a-zA-Z\u00a1-\uffff0-9_\\\\-./@]+\", \"foo-bar_99.pdf\", Some(\"foo-bar_99.pdf\"); \"multibyte group\")]\n    // typos:on\n    #[test]\n    fn find_works(re: &str, s: &str, expected: Option<&str>) {\n        let r = Regex::compile(re).unwrap();\n        let m = r.find(&s).map(|m| m.match_text(&s));\n        assert_eq!(m.as_deref(), expected);\n    }\n\n    #[test_case(\"foo\", \"foo\", Some(\"foo\"); \"literal full string\")]\n    #[test_case(\"ba*\", \" baaaaa foo\", Some(\"baaaaa\"); \"zero or more present\")] // typos:ignore\n    #[test_case(\"ba*\", \"b foo\", Some(\"b\"); \"zero or more not present\")] // typos:ignore\n    #[test_case(\"foo$\", \"a line that ends with foo\\nnow bar\", Some(\"foo\"); \"BOL holding before newline\")]\n    #[test_case(\"\\\\b\\\\w+\\\\b\", \"foo\", Some(\"foo\"); \"word boundary at end of input\")]\n    #[test_case(\n        r\"(25[0-5]|2[0-4][0-9]|1?[0-9]?[0-9])\\.(25[0-5]|2[0-4][0-9]|1?[0-9]?[0-9])\\.(25[0-5]|2[0-4][0-9]|1?[0-9]?[0-9])\\.(25[0-5]|2[0-4][0-9]|1?[0-9]?[0-9])\",\n        \"127.0.0.1 \",\n        Some(\"127.0.0.1\");\n        \"ipv4 full\"\n    )]\n    #[test_case(\n        \"his\",\n        \"this is a line\\nand another\\n- [ ] something to do\\n\",\n        Some(\"his\");\n        \"multiline input\"\n    )]\n    #[test]\n    fn find_rev_works(re: &str, s: &str, expected: Option<&str>) {\n        let r = RevRegex::compile(re).unwrap();\n        let b = Buffer::new_unnamed(0, s, Default::default());\n        let m = r.find_rev_from(&b, s.len()).map(|m| m.match_text(&b));\n\n        assert_eq!(m.as_deref(), expected);\n    }\n\n    #[test_case(\"[0-9]+\", \" 42 3 127 9991 \", &[\"42\", \"3\", \"127\", \"9991\"]; \"integers\")]\n    #[test_case(\"[0-9]+\", \" 42 3 127 9991\", &[\"42\", \"3\", \"127\", \"9991\"]; \"integers to EOF\")]\n    #[test_case(\"[0-9]+\", \"42 3 127 9991 \", &[\"42\", \"3\", \"127\", \"9991\"]; \"integers from BOF\")]\n    #[test_case(\"[0-9]+\", \"42 3 127 9991\", &[\"42\", \"3\", \"127\", \"9991\"]; \"integers full input\")]\n    #[test_case(\"foo|bar|baz\", \"baz bar foo bar\", &[\"baz\", \"bar\", \"foo\", \"bar\"]; \"alts spaced in s\")]\n    #[test_case(\"foo|bar|baz\", \"bazbarfoobar\", &[\"baz\", \"bar\", \"foo\", \"bar\"]; \"alts back to back in s\")]\n    #[test_case(\"(foo|bar|baz)\", \"foo foobar barfoo baz\", &[\"foo\", \"foo\", \"bar\", \"bar\", \"foo\", \"baz\"]; \"alts in parens\")]\n    #[test_case(\"\\\\b(foo|bar|baz)\\\\b\", \"foo foobar barfoo baz\", &[\"foo\", \"baz\"]; \"alts with word boundaries\")]\n    #[test]\n    fn find_iter_works(re: &str, s: &str, expected: &[&str]) {\n        let mut r = Regex::compile(re).unwrap();\n        let matches: Vec<String> = r\n            .find_iter(&s)\n            .map(|m| m.match_text(&s).into_owned())\n            .collect();\n\n        assert_eq!(&matches, expected);\n    }\n\n    #[test]\n    fn dot_star_works() {\n        let r = Regex::compile(\".*\").unwrap();\n        let s = \"\\nthis is\\na multiline\\nfile\";\n        let m1 = r.find(&s).unwrap();\n        assert_eq!(m1.match_text(&s), \"\");\n\n        // Skipping the leading newline should cause us to match all of the following line\n        let m2 = r.find(&&s[1..]).unwrap();\n        assert_eq!(m2.match_text(&&s[1..]), \"this is\");\n    }\n\n    #[test]\n    fn match_extraction_works() {\n        let re = \"([0-9]+)-([0-9]+)-([0-9]+)\";\n        let r = Regex::compile(re).unwrap();\n        let s = \"this should work 123-456-789 other stuff\";\n        let m = r.find(&s).unwrap();\n\n        assert_eq!(m.match_text(&s), \"123-456-789\");\n        assert_eq!(m.submatch_text(1, &s).as_deref(), Some(\"123\"));\n        assert_eq!(m.submatch_text(2, &s).as_deref(), Some(\"456\"));\n        assert_eq!(m.submatch_text(3, &s).as_deref(), Some(\"789\"));\n    }\n\n    #[test_case(\"(?<xy>X|Y)\", \"xy\", \"X\"; \"named match on its own\")]\n    #[test_case(\"(?<xy>X|Y)(a|b)\", \"xy\", \"X\"; \"named match before unnamed\")]\n    #[test_case(\"(e| )(?<xy>X|Y)\", \"xy\", \"X\"; \"named match after unnamed\")]\n    #[test_case(\"(e| )(?<xy>X|Y)(a|b)\", \"xy\", \"X\"; \"named match inbetween unnamed\")]\n    #[test]\n    fn named_submatch_works(re: &str, name: &str, expected: &str) {\n        let r = Regex::compile(re).unwrap();\n        let s = \"text before Xanadu\";\n        let m = r.find(&s).unwrap();\n\n        assert_eq!(m.named_matches(), vec![name]);\n        assert_eq!(m.submatch_text_by_name(name, &s).as_deref(), Some(expected));\n    }\n\n    #[test]\n    fn multiline_input_match_dot_star_works() {\n        let r = Regex::compile(\".*\").unwrap();\n        let s = \"this is\\na multiline\\nfile\";\n\n        let m = r.find(&s).unwrap();\n        assert_eq!(m.match_text(&s), \"this is\");\n    }\n\n    #[test]\n    fn multiline_input_find_from_dot_star_works_with_non_zero_initial_sp() {\n        let r = Regex::compile(\".*\").unwrap();\n        let s = \"this is\\na multiline\\nfile\";\n\n        // Just to convince me that the offsets here are exactly as I am expecting\n        assert_eq!(s.chars().skip(7).collect::<String>(), \"\\na multiline\\nfile\");\n\n        let m1 = r.find_from(&s, 7).unwrap();\n        assert_eq!(m1.match_text(&s), \"\");\n\n        let m2 = r.find_from(&s, 8).unwrap();\n        assert_eq!(m2.match_text(&s), \"a multiline\");\n    }\n\n    #[test]\n    fn multiline_input_find_iter_dot_star_works() {\n        let mut r = Regex::compile(\".*\").unwrap();\n        let s = \"this is\\na multiline\\nfile\";\n\n        let mut it = r.find_iter(&s);\n\n        // written this way rather than using collect as if we introduce a bug in the MatchIter\n        // impl we can end up with an iterator that gets stuck and never terminates.\n        let m1 = it.next().unwrap();\n        assert_eq!(m1.match_text(&s), \"this is\");\n\n        let m2 = it.next().unwrap();\n        assert_eq!(m2.match_text(&s), \"\");\n\n        let m3 = it.next().unwrap();\n        assert_eq!(m3.match_text(&s), \"a multiline\");\n\n        let m4 = it.next().unwrap();\n        assert_eq!(m4.match_text(&s), \"\");\n\n        let m5 = it.next().unwrap();\n        assert_eq!(m5.match_text(&s), \"file\");\n        assert_eq!(it.next(), None);\n    }\n\n    #[test]\n    fn match_extraction_works_when_multibyte_characters_are_present() {\n        let s: &str = \"const VLINE: char = '\u2502';\n\nimpl Editor {\n\";\n\n        let re = r\"impl (\\w+) \\{\";\n        let r = Regex::compile(re).unwrap();\n        let m = r.find(&s).unwrap();\n\n        assert_eq!(m.submatch_text(1, &s).as_deref(), Some(\"Editor\"));\n        assert_eq!(m.match_text(&s), \"impl Editor {\");\n    }\n\n    // This is the pathological case that Cox covers in his article which leads\n    // to exponential behaviour in backtracking based implementations.\n    #[test]\n    fn pathological_match_doesnt_explode() {\n        let s = \"a\".repeat(100);\n        let mut re = \"a?\".repeat(100);\n        re.push_str(&s);\n\n        let r = Regex::compile(&re).unwrap();\n        assert!(r.find(&s.as_str()).is_some());\n    }\n\n    // Make sure that the previous cached state for a given Regex doesn't cause\n    // any strange behaviour for future matches\n    #[test]\n    fn repeated_match_works() {\n        let re = \"a(bb)+a\";\n\n        let r = Regex::compile(re).unwrap();\n        for _ in 0..10 {\n            assert!(r.find(&\"abbbba\").is_some());\n            assert!(r.find(&\"foo\").is_none());\n        }\n    }\n\n    // Regression case for https://github.com/sminez/ad/issues/165\n    #[test_case(\"Tracing_Summit_2025_Perfet_RYQoyoF.pdf\"; \"tracing\")]\n    #[test_case(\"Bracing_Summit_2025_Perfet_RYQoyoF.pdf\"; \"bracing\")]\n    #[test]\n    fn leading_literal_truncation_doesnt_affect_matching(s: &str) {\n        let re = \"([a-zA-Z\u00a1-\ufffd0-9_\\\\-./@]+).[Pp][Dd][Ff]\";\n        let r = Regex::compile(re).unwrap();\n        let m = r.find(&s).unwrap();\n\n        assert_eq!(m.match_text(&s), s);\n    }\n}\n", "source": "ad/src/regex/vm.rs", "file_type": "rc"}
{"text": "//! A simple regex engine for operating on character streams and supporting\n//! the Sam text editor's structural regular expressions.\n//!\n//! Thompson's original paper on writing a regex engine can be found here:\n//!   <https://dl.acm.org/doi/pdf/10.1145/363347.363387>\nuse std::{fmt, iter::Peekable, str::Chars};\n\nmod ast;\nmod compile;\nmod haystack;\nmod matches;\nmod stream;\nmod vm;\n\npub use haystack::Haystack;\npub use matches::Match;\npub use stream::{CachingStream, CachingStreamIter};\npub use vm::{Regex, RevRegex};\n\n/// Errors that can be returned by the regex engine\n#[derive(Debug, Clone, PartialEq, Eq)]\npub enum Error {\n    /// Empty parens\n    EmptyParens,\n    /// Empty string used when creating a [Regex]\n    EmptyRegex,\n    /// Invalid regex class\n    InvalidClass,\n    /// Invalid escape sequence\n    InvalidEscape(char),\n    /// Invalid repetition pattern\n    InvalidRepetition,\n    /// The provided regex is too long\n    ReTooLong,\n    /// Alternation without a right hand side\n    UnbalancedAlt,\n    /// Unbalanced parens\n    UnbalancedParens,\n    /// Group name without a closing '<'\n    UnclosedGroupName(String),\n    /// Invalid group qualifier following (?...)\n    UnknownGroupQualifier(char),\n}\n\nimpl std::error::Error for Error {}\n\nimpl fmt::Display for Error {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match self {\n            Self::EmptyParens => write!(f, \"empty parens\"),\n            Self::EmptyRegex => write!(f, \"empty regular expression\"),\n            Self::InvalidClass => write!(f, \"invalid class\"),\n            Self::InvalidEscape(c) => write!(f, \"invalid escaped character {c:?}\"),\n            Self::InvalidRepetition => write!(f, \"invalid repetition\"),\n            Self::ReTooLong => write!(f, \"regex too long\"),\n            Self::UnbalancedAlt => write!(f, \"alternation had no right hand side\"),\n            Self::UnbalancedParens => write!(f, \"unbalanced parens\"),\n            Self::UnclosedGroupName(s) => write!(f, \"unclosed group name {s:?}\"),\n            Self::UnknownGroupQualifier(c) => write!(f, \"unknown group qualifier {c:?}\"),\n        }\n    }\n}\n\n/// Helper for converting characters to 0 based inicies for looking things up in caches.\nconst fn char_ix(ch: char) -> usize {\n    ((ch as u16) & 0xFF) as usize\n}\n\nconst fn init_escapes() -> [Option<char>; 256] {\n    macro_rules! escape {\n        ($escapes:expr, $($ch:expr),+) => {\n            $($escapes[char_ix($ch)] = Some($ch);)+\n        };\n        ($escapes:expr, $($ch:expr => $esc:expr),+) => {\n            $($escapes[char_ix($ch)] = Some($esc);)+\n        };\n    }\n\n    let mut escapes = [None; 256];\n    escape!(\n        escapes, '*', '+', '?', '.', '@', '(', ')', '[', ']', '{', '}', '|'\n    );\n    escape!(escapes, '\\\\', '\\'', '\"', '^', '$', '-');\n    escape!(escapes, 'b', 'B', 'd', 'D', 'w', 'W', 's', 'S');\n    escape!(escapes, 'n'=>'\\n', 'r'=>'\\r', 't'=>'\\t');\n\n    escapes\n}\n\n/// Supported escape sequences\nconst ESCAPES: [Option<char>; 256] = init_escapes();\n\n#[derive(Debug, Clone, PartialEq, Eq)]\nstruct CharClass {\n    pub(crate) negated: bool,\n    pub(crate) chars: Vec<char>,\n    pub(crate) ranges: Vec<(char, char)>,\n}\n\nimpl CharClass {\n    fn try_parse(it: &mut Peekable<Chars<'_>>) -> Result<Self, Error> {\n        let mut next = || next_char(it)?.ok_or(Error::InvalidClass);\n        let (mut ch, _) = next()?;\n\n        let negated = ch == '^';\n        if negated {\n            (ch, _) = next()?\n        };\n        let mut chars = vec![ch];\n        let mut ranges = vec![];\n\n        loop {\n            let (ch, escaped) = next()?;\n            match ch {\n                ']' if !escaped => break,\n\n                '-' if !escaped => {\n                    let start = chars.pop().ok_or(Error::InvalidClass)?;\n                    let (end, _) = next()?;\n                    if start as u32 >= end as u32 {\n                        return Err(Error::InvalidClass);\n                    }\n\n                    ranges.push((start, end));\n                }\n\n                ch => chars.push(ch),\n            }\n        }\n\n        Ok(Self {\n            negated,\n            chars,\n            ranges,\n        })\n    }\n\n    // Negated classes still don't match a newline\n    #[inline]\n    fn matches(&self, ch: char) -> bool {\n        if self.negated && ch == '\\n' {\n            return false;\n        }\n\n        let res = self.chars.contains(&ch)\n            || self\n                .ranges\n                .iter()\n                .any(|&(start, end)| ch >= start && ch <= end);\n\n        if self.negated { !res } else { res }\n    }\n\n    fn size(&self) -> usize {\n        self.chars.len()\n            + self\n                .ranges\n                .iter()\n                .map(|(s, e)| (*e as u32 - *s as u32 + 1) as usize)\n                .sum::<usize>()\n    }\n}\n\nfn next_char(it: &mut Peekable<Chars<'_>>) -> Result<Option<(char, bool)>, Error> {\n    match it.next() {\n        Some('\\\\') => (),\n        Some(ch) => return Ok(Some((ch, false))),\n        None => return Ok(None),\n    }\n\n    let ch = match it.next() {\n        Some(ch) => ch,\n        None => return Err(Error::InvalidEscape('\\0')),\n    };\n\n    match ESCAPES[char_ix(ch)] {\n        Some(ch) => Ok(Some((ch, true))),\n        None => Err(Error::InvalidEscape(ch)),\n    }\n}\n\nmod impl_structex {\n    use super::*;\n    use crate::buffer::{Buffer, GapBuffer, Slice};\n    use std::{io, ops::Range};\n    use structex::re::{Haystack, RawCaptures, RegexEngine, Sliceable, Writable};\n\n    impl RegexEngine for Regex {\n        type CompileError = Error;\n\n        fn compile(re: &str) -> Result<Self, Self::CompileError> {\n            Regex::compile(re)\n        }\n    }\n\n    impl Haystack<Regex> for str {\n        fn is_match_between(&self, re: &Regex, from: usize, to: usize) -> bool {\n            re.matches_between(&self, from, to)\n        }\n\n        fn captures_between(&self, re: &Regex, from: usize, to: usize) -> Option<RawCaptures> {\n            let m = re.find_between(&self, from, to)?;\n\n            Some(RawCaptures::new(m.iter_locs()))\n        }\n    }\n\n    impl Haystack<Regex> for GapBuffer {\n        fn is_match_between(&self, re: &Regex, from: usize, to: usize) -> bool {\n            re.matches_between(self, from, to)\n        }\n\n        fn captures_between(&self, re: &Regex, from: usize, to: usize) -> Option<RawCaptures> {\n            let m = re.find_between(self, from, to)?;\n\n            Some(RawCaptures::new(m.iter_locs()))\n        }\n    }\n\n    impl Sliceable for GapBuffer {\n        type Slice<'h>\n            = Slice<'h>\n        where\n            Self: 'h;\n\n        fn char_at(&self, byte_offset: usize) -> Option<char> {\n            self.get_char_at(byte_offset)\n        }\n\n        fn slice(&self, range: Range<usize>) -> Self::Slice<'_> {\n            self.slice_from_byte_offsets(range.start, range.end)\n        }\n\n        fn max_len(&self) -> usize {\n            self.len()\n        }\n    }\n\n    impl Writable for GapBuffer {\n        fn write_to<W>(&self, w: &mut W) -> io::Result<usize>\n        where\n            W: io::Write,\n        {\n            let (l, r) = self.as_byte_slices();\n            w.write_all(l)?;\n            w.write_all(r)?;\n\n            Ok(self.len())\n        }\n    }\n\n    impl<'a> Writable for Slice<'a> {\n        fn write_to<W>(&self, w: &mut W) -> io::Result<usize>\n        where\n            W: std::io::Write,\n        {\n            let (l, r) = self.as_slices();\n            w.write_all(l)?;\n            w.write_all(r)?;\n\n            Ok(l.len() + r.len())\n        }\n    }\n\n    impl Haystack<Regex> for Buffer {\n        fn is_match_between(&self, re: &Regex, from: usize, to: usize) -> bool {\n            re.matches_between(self, from, to)\n        }\n\n        fn captures_between(&self, re: &Regex, from: usize, to: usize) -> Option<RawCaptures> {\n            let m = re.find_between(self, from, to)?;\n\n            Some(RawCaptures::new(m.iter_locs()))\n        }\n    }\n\n    impl Sliceable for Buffer {\n        type Slice<'h>\n            = Slice<'h>\n        where\n            Self: 'h;\n\n        fn char_at(&self, byte_offset: usize) -> Option<char> {\n            self.txt.get_char_at(byte_offset)\n        }\n\n        fn slice(&self, range: Range<usize>) -> Self::Slice<'_> {\n            self.txt.slice_from_byte_offsets(range.start, range.end)\n        }\n\n        fn max_len(&self) -> usize {\n            self.txt.len()\n        }\n    }\n\n    impl Writable for Buffer {\n        fn write_to<W>(&self, w: &mut W) -> io::Result<usize>\n        where\n            W: io::Write,\n        {\n            let (l, r) = self.txt.as_byte_slices();\n            w.write_all(l)?;\n            w.write_all(r)?;\n\n            Ok(self.txt.len())\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use simple_test_case::test_case;\n\n    #[test_case(\"_\", &['_'], &[]; \"single underscore\")]\n    #[test_case(\"abc_\", &['a', 'b', 'c', '_'], &[]; \"chars\")]\n    #[test_case(\"a-z\", &[], &[('a', 'z')]; \"single range\")]\n    #[test_case(\"a-zA-Z\", &[], &[('a', 'z'), ('A', 'Z')]; \"multi range\")]\n    #[test_case(\"a-z_./]\", &['_', '.', '/'], &[('a', 'z')]; \"compound\")]\n    #[test_case(\"a-zA-Z_\\\\-.]\", &['_', '-', '.'], &[('a', 'z'), ('A', 'Z')]; \"compound escaped dash\")]\n    #[test]\n    fn parsing_classes_works(raw: &str, chars: &[char], ranges: &[(char, char)]) {\n        // The outer regex parser consumes the initial '[' before passing through so test cases\n        // look a little lopsided due to missing this.\n        for (s, negated) in [(format!(\"{raw}]\"), false), (format!(\"^{raw}]\"), true)] {\n            let cls = CharClass::try_parse(&mut s.chars().peekable()).unwrap();\n            let expected = CharClass {\n                negated,\n                chars: chars.to_vec(),\n                ranges: ranges.to_vec(),\n            };\n\n            assert_eq!(cls, expected, \"negated={negated}\");\n        }\n    }\n\n    // Each of the inputs here is missing the opening '[' as that is consumed prior to calling\n    // `CharClass::try_parse`\n    #[test_case(\"z-a]\"; \"backwards alpha\")]\n    #[test_case(\"Z-A]\"; \"backwards upper alpha\")]\n    #[test_case(\"9-0]\"; \"backwards numeric\")]\n    #[test_case(\"a-a]\"; \"equal alpha endpoints\")]\n    #[test_case(\"5-5]\"; \"equal numeric endpoints\")]\n    #[test_case(\"a-z9-0]\"; \"valid then invalid range\")]\n    #[test_case(\"\\u{00FF}-\\u{0000}]\"; \"backwards unicode\")]\n    #[test]\n    fn invalid_character_ranges_error(s: &str) {\n        assert!(CharClass::try_parse(&mut s.chars().peekable()).is_err());\n    }\n}\n", "source": "ad/src/regex/mod.rs", "file_type": "rc"}
{"text": "//! Searching through the contents of a buffer for simple target patterns\n//!\n//! For more complex patterns, Regex should be used instead\nuse crate::{\n    buffer::Buffer,\n    dot::{Cur, Dot, Range},\n};\n\n/// A Find is able to locate its next occurrence within an indexed character stream and return\n/// an optional pair of start/end indices denoting the location of the next match.\n///\n/// For more complex patterns, Regex should be used instead\npub trait Find {\n    /// The type of the Find being used when running backwards through a buffer\n    type Reversed: Find;\n\n    /// Construct the reversed version of this matcher for searching backwards through a buffer\n    fn reversed(&self) -> Self::Reversed;\n\n    /// Attempt to locate the start/end indices of the next match of this Matcher within a\n    /// character stream. Single character matches should be returned with start==end.\n    fn try_find<I>(&self, it: I) -> Option<(usize, usize)>\n    where\n        I: Iterator<Item = (usize, char)>;\n\n    fn expand(&self, dot: Dot, b: &Buffer) -> Dot\n    where\n        Self: Sized,\n    {\n        let Range {\n            mut start,\n            mut end,\n            start_active,\n        } = dot.as_range();\n\n        start = find_backward_start(self, start, b);\n        end = find_forward_end(self, end, b);\n\n        Dot::from(Range::from_cursors(start, end, start_active)).collapse_null_range()\n    }\n}\n\npub fn find_forward<F: Find>(f: &F, cur: Cur, b: &Buffer) -> Option<Dot> {\n    find_between(f, cur.idx, b.txt.len_chars(), b)\n}\n\npub fn find_forward_end<F: Find>(f: &F, cur: Cur, b: &Buffer) -> Cur {\n    find_forward(f, cur, b)\n        .unwrap_or_else(|| Cur::buffer_end(b).into())\n        .last_cur()\n}\n\npub fn find_forward_wrapping<F: Find>(f: &F, b: &Buffer) -> Option<Dot> {\n    find_between(f, b.dot.last_cur().idx, b.txt.len_chars(), b)\n        .or_else(|| find_between(f, 0, b.dot.last_cur().idx, b))\n}\n\npub fn find_backward<F: Find>(f: &F, cur: Cur, b: &Buffer) -> Option<Dot> {\n    rev_find_between(f, cur.idx, 0, b)\n}\n\npub fn find_backward_start<F: Find>(f: &F, cur: Cur, b: &Buffer) -> Cur {\n    find_backward(f, cur, b).unwrap_or_default().first_cur()\n}\n\n// pub fn find_backward_wrapping<F: Find>(f: &F, b: &Buffer) -> Option<Dot> {\n//     rev_find_between(f, b.dot.first_cur().idx, 0, b)\n//         .or_else(|| rev_find_between(f, b.txt.len_chars(), b.dot.first_cur().idx, b))\n// }\n\nfn match_to_dot(m: Option<(usize, usize)>) -> Option<Dot> {\n    match m {\n        Some((start, end)) if start == end => Some(Cur { idx: start }.into()),\n        Some((start, end)) => Some(Dot::from_char_indices(start, end)),\n        None => None,\n    }\n}\n\nfn find_between<F: Find>(f: &F, from: usize, to: usize, b: &Buffer) -> Option<Dot> {\n    match_to_dot(f.try_find(b.iter_between_chars(from, to)))\n}\n\nfn rev_find_between<F: Find>(f: &F, from: usize, to: usize, b: &Buffer) -> Option<Dot> {\n    let ch_from = b.txt.byte_to_char(from);\n    let ch_to = b.txt.byte_to_char(to);\n\n    match_to_dot(\n        f.reversed()\n            .try_find(b.rev_iter_between_chars(ch_from, ch_to)),\n    )\n}\n\n// Functions that check a single character\nimpl<F> Find for F\nwhere\n    F: Fn(char) -> bool + Copy,\n{\n    type Reversed = F;\n\n    fn try_find<I>(&self, it: I) -> Option<(usize, usize)>\n    where\n        I: Iterator<Item = (usize, char)>,\n    {\n        for (i, ch) in it {\n            if (self)(ch) {\n                return Some((i, i));\n            }\n        }\n\n        None\n    }\n\n    fn reversed(&self) -> Self::Reversed {\n        *self\n    }\n}\n\n// Chars just need to locate themselves.\nimpl Find for char {\n    type Reversed = char;\n\n    fn try_find<I>(&self, it: I) -> Option<(usize, usize)>\n    where\n        I: Iterator<Item = (usize, char)>,\n    {\n        for (i, ch) in it {\n            if ch == *self {\n                return Some((i, i));\n            }\n        }\n\n        None\n    }\n\n    fn reversed(&self) -> Self::Reversed {\n        *self\n    }\n}\n\n// Strings need to locate themselves character by character.\nimpl Find for &str {\n    type Reversed = String;\n\n    fn try_find<I>(&self, it: I) -> Option<(usize, usize)>\n    where\n        I: Iterator<Item = (usize, char)>,\n    {\n        let chars: Vec<char> = self.chars().collect();\n        let last = chars.len().saturating_sub(1);\n        let mut cix = 0;\n        let mut start = 0;\n\n        for (i, ch) in it {\n            if ch != chars[cix] {\n                start = 0;\n                cix = 0;\n                continue;\n            }\n\n            if cix == 0 {\n                start = i;\n            }\n\n            if cix == last {\n                return Some((start, i));\n            }\n\n            cix += 1;\n        }\n\n        None\n    }\n\n    fn reversed(&self) -> Self::Reversed {\n        self.chars().rev().collect()\n    }\n}\n\n// Deferring to &str for the impl\nimpl Find for String {\n    type Reversed = String;\n\n    fn try_find<I>(&self, it: I) -> Option<(usize, usize)>\n    where\n        I: Iterator<Item = (usize, char)>,\n    {\n        self.as_str().try_find(it)\n    }\n\n    fn reversed(&self) -> Self::Reversed {\n        self.chars().rev().collect()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use simple_test_case::test_case;\n\n    #[test_case(\"this\"; \"first word\")]\n    #[test_case(\"is\"; \"inner word two chars\")]\n    #[test_case(\"a\"; \"inner word single char\")]\n    #[test_case(\"find\"; \"inner word multiple chars\")]\n    #[test_case(\"test\"; \"last word\")]\n    #[test]\n    fn find_forward_str(s: &str) {\n        let b = Buffer::new_virtual(0, \"test\", \"this is a find test\", Default::default());\n        let dot = find_forward_wrapping(&s, &b).expect(\"to find string\");\n        let matched_text = dot.content(&b);\n\n        assert_eq!(matched_text, s);\n    }\n}\n", "source": "ad/src/dot/find.rs", "file_type": "rc"}
{"text": "//! Internal data structures and helpers for maintaining buffer state.\n//!\n//! When working at the implementation of this datastructure it is important to keep in mind that\n//! there are several related, but distinct, pairs of concepts:\n//! - The \"logical\" buffer state as presented to users of the API, vs the \"raw\" buffer state that\n//!   is actually stored. The logical buffer is guaranteed to be valid utf-8 while the raw buffer\n//!   is allowed to contain arbitrary byte sequences within the current \"gap\" region.\n//! - Character offsets vs byte offsets. Character offsets only ever apply to the logical buffer\n//!   state while byte offsets can be both logical and raw.\n//!\n//! ### References\n//! - <https://www.cs.unm.edu/~crowley/papers/sds.pdf>\n//! - <http://doc.cat-v.org/plan_9/4th_edition/papers/sam/>\n//! - <https://www.averylaird.com/programming/piece-table/2018/05/10/insertions-piece-table>\n//! - <https://www.staff.city.ac.uk/~ross/papers/FingerTree.pdf>\n//! - <https://nullprogram.com/blog/2017/09/07/>\n//! - <https://coredumped.dev/2023/08/09/text-showdown-gap-buffers-vs-ropes/>\n//! - <https://code.visualstudio.com/blogs/2018/03/23/text-buffer-reimplementation>\nuse std::{\n    borrow::Cow,\n    cell::UnsafeCell,\n    cmp::{Ordering, max, min},\n    collections::HashMap,\n    fmt,\n};\n\n// The internal data is `[u8]` so the values here are in terms of bytes\n\nconst MIN_GAP: usize = 32;\nconst MIN_GAP_GROW: usize = 64;\nconst MAX_GAP_GROW: usize = 1024 * 8;\n\n/// For a given buffer length, calculate the new size of the gap we need when reallocating.\n/// This is set to 5% of the length of our data buffer but bounded by MIN_GAP and MAX_GAP.\n#[inline]\nfn clamp_gap_size(len: usize, min_gap: usize) -> usize {\n    min(max(len / 20, min_gap), MAX_GAP_GROW)\n}\n\n#[inline]\nfn count_chars(bytes: &[u8]) -> usize {\n    if bytes.is_empty() {\n        return 0;\n    }\n\n    let mut n_chars = 0;\n    let mut cur = 0;\n\n    while cur < bytes.len() {\n        // SAFETY: we know we are in bounds and that we contain valid utf-8 data\n        let ch = unsafe { decode_char_at(cur, bytes) };\n        cur += ch.len_utf8();\n        n_chars += 1;\n    }\n\n    n_chars\n}\n\ntype ByteOffset = usize;\ntype CharOffset = usize;\n\n/// A simple [HashMap] based cache of mappings from character positions to byte positions within\n/// the buffer since the last time it was modified (either by altering the logical buffer content,\n/// moving the gap or resizing the buffer).\n#[derive(Debug)]\nstruct CharToByteCache(UnsafeCell<HashMap<CharOffset, ByteOffset>>);\n\nimpl CharToByteCache {\n    fn clear(&self) {\n        // SAFETY: Only called internally as part of methods that have mutable access to the buffer\n        unsafe { (&mut *self.0.get()).clear() }\n    }\n\n    fn get(&self, char_idx: CharOffset) -> Option<ByteOffset> {\n        // SAFETY: Only called in offset_char_to_raw_byte when used to return cached values\n        unsafe { (&*self.0.get()).get(&char_idx).copied() }\n    }\n\n    fn insert(&self, char_idx: CharOffset, byte_idx: ByteOffset) {\n        // SAFETY: Only called in offset_char_to_raw_byte when used to cache values\n        unsafe {\n            (&mut *self.0.get()).insert(char_idx, byte_idx);\n        }\n    }\n}\n\nimpl Clone for CharToByteCache {\n    fn clone(&self) -> Self {\n        // SAFETY: We only reach in to the inner map to clone it and wrap in a new UnsafeCell\n        unsafe { Self(UnsafeCell::new((&*self.0.get()).clone())) }\n    }\n}\nimpl PartialEq for CharToByteCache {\n    fn eq(&self, _: &Self) -> bool {\n        true // we don't care about the cache for GapBuffer equality\n    }\n}\nimpl Eq for CharToByteCache {}\n\n/// An implementation of a gap buffer that tracks internal meta-data to help with accessing\n/// sub-regions of the text such as character ranges and lines.\n#[derive(Debug, Clone, PartialEq, Eq)]\npub struct GapBuffer {\n    /// the raw data being stored (both buffer content and the gap)\n    data: Box<[u8]>,\n    /// current size of the allocation for data\n    cap: usize,\n    /// raw byte offset to the first character in the gap\n    gap_start: usize,\n    /// raw byte offset to the last character in the gap\n    gap_end: usize,\n    /// size in bytes for the next gap when re-allocating\n    next_gap: usize,\n    /// total number of characters in the buffer\n    /// this is != line_endings.last() if there is no trailing newline\n    n_chars: usize,\n    /// line ending raw byte offset -> char offset\n    line_endings: Vec<(ByteOffset, CharOffset)>,\n    /// Simple cache of computed char->byte mappings since the last time the buffer was modified\n    char_to_byte_cache: CharToByteCache,\n}\n\nimpl Default for GapBuffer {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\nfn compute_line_endings(s: &str) -> (usize, Vec<(ByteOffset, CharOffset)>) {\n    let mut n_chars = 0;\n    let mut line_endings = Vec::new();\n\n    for (line_chars, (idx, ch)) in s.char_indices().enumerate() {\n        n_chars += 1;\n        if ch == '\\n' {\n            line_endings.push((idx, line_chars));\n        }\n    }\n\n    (n_chars, line_endings)\n}\n\nimpl From<String> for GapBuffer {\n    fn from(s: String) -> Self {\n        let gap_start = s.len();\n        let next_gap = clamp_gap_size(gap_start, MIN_GAP_GROW);\n        let cap = gap_start + next_gap;\n        let (n_chars, line_endings) = compute_line_endings(&s);\n        let mut v = s.into_bytes();\n        v.resize(cap, 0);\n\n        let mut gb = Self {\n            data: v.into_boxed_slice(),\n            cap,\n            gap_start,\n            gap_end: cap,\n            next_gap,\n            n_chars,\n            line_endings,\n            char_to_byte_cache: CharToByteCache(UnsafeCell::new(HashMap::new())),\n        };\n\n        gb.move_gap_to(0);\n        gb\n    }\n}\n\nimpl From<&str> for GapBuffer {\n    fn from(s: &str) -> Self {\n        let gap_start = s.len();\n        let next_gap = clamp_gap_size(gap_start, MIN_GAP_GROW);\n        let cap = gap_start + next_gap;\n        let (n_chars, line_endings) = compute_line_endings(s);\n        let mut v = Vec::with_capacity(cap);\n        v.extend_from_slice(s.as_bytes());\n        v.resize(cap, 0);\n\n        let mut gb = Self {\n            data: v.into_boxed_slice(),\n            cap,\n            gap_start,\n            gap_end: cap,\n            next_gap,\n            n_chars,\n            line_endings,\n            char_to_byte_cache: CharToByteCache(UnsafeCell::new(HashMap::new())),\n        };\n\n        gb.move_gap_to(0);\n        gb\n    }\n}\n\nimpl fmt::Display for GapBuffer {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        let (s1, s2) = self.as_strs();\n        write!(f, \"{s1}{s2}\")\n    }\n}\n\nimpl<'a> PartialEq<&'a str> for GapBuffer {\n    fn eq(&self, other: &&'a str) -> bool {\n        let b = other.as_bytes();\n        if b.len() != self.len() {\n            return false;\n        }\n\n        b[..self.gap_start] == self.data[..self.gap_start]\n            && b[self.gap_start..] == self.data[self.gap_end..]\n    }\n}\n\nimpl PartialEq<String> for GapBuffer {\n    fn eq(&self, other: &String) -> bool {\n        *self == other.as_str()\n    }\n}\n\n/// One of the most common \"hard to find\" bugs I encounter around the GapBuffer is detecting\n/// when and where the tracking of line endings becomes corrupted. This macro is called at\n/// points where the line_endings map is modified guarded by #[cfg(test)] so that it does not\n/// affect the performance of the editor when it is in use. It is also called in situations\n/// where we are already panicking in order to check to see if the reason for the panic was\n/// because there is a bug around line endings that the current test suite didn't catch.\nmacro_rules! assert_line_endings {\n    ($self:expr) => {{\n        let true_endings: Vec<usize> = $self\n            .data\n            .iter()\n            .enumerate()\n            .filter(|&(i, &b)| b == b'\\n' && (i < $self.gap_start || i >= $self.gap_end))\n            .map(|(i, _)| i)\n            .collect();\n        let tracked_line_endings: Vec<usize> = $self.line_endings.iter().map(|(n, _)| *n).collect();\n\n        assert_eq!(\n            tracked_line_endings, true_endings,\n            \"incorrect byte positions for line endings with gap_start={} gap_end={}\",\n            $self.gap_start, $self.gap_end\n        );\n\n        let true_endings: Vec<usize> = $self\n            .to_string()\n            .chars()\n            .enumerate()\n            .filter(|&(_, c)| c == '\\n')\n            .map(|(i, _)| i)\n            .collect();\n        let tracked_line_endings: Vec<usize> = $self.line_endings.iter().map(|(_, n)| *n).collect();\n\n        assert_eq!(\n            tracked_line_endings, true_endings,\n            \"incorrect character positions for line endings with gap_start={} gap_end={}\",\n            $self.gap_start, $self.gap_end\n        );\n    }};\n}\n\nimpl GapBuffer {\n    /// Construct a new empty GapBuffer\n    pub fn new() -> Self {\n        Self::from(\"\")\n    }\n\n    /// Number of bytes in the gap\n    #[inline]\n    fn gap(&self) -> usize {\n        self.gap_end - self.gap_start\n    }\n\n    /// The current length of \"active\" data in the buffer (i.e. not including the gap)\n    #[inline]\n    pub fn len(&self) -> usize {\n        self.cap - self.gap()\n    }\n\n    /// Whether or not the visible buffer contents are empty or not.\n    /// This can return true while there is \"deleted\" data in the gap.\n    #[inline]\n    pub fn is_empty(&self) -> bool {\n        self.cap == self.gap()\n    }\n\n    /// Rearrange the internal storage of this buffer so that the active data is in a single\n    /// contiguous slice which is then returned.\n    pub fn make_contiguous(&mut self) -> &[u8] {\n        self.move_gap_to(0);\n        &self.data[self.gap_end..]\n    }\n\n    /// Whether or not the full data within the buffer is contiguous (all on one side of the gap).\n    pub fn is_contiguous(&self) -> bool {\n        self.gap_start == 0 || self.gap_end == self.cap\n    }\n\n    /// The contents of the buffer as a single `&str`.\n    ///\n    /// This method requires a mutable reference as we need to move the gap in order to ensure that\n    /// all of the active data within the buffer is contiguous.\n    pub fn as_str(&mut self) -> &str {\n        let raw = self.make_contiguous();\n\n        // SAFETY: we know we have valid utf-8 data internally and make_contiguous moves the gap so\n        // that `raw` contains all of the live data within the buffer.\n        unsafe { std::str::from_utf8_unchecked(raw) }\n    }\n\n    /// A contiguous substring of the buffer from the give byte offset.\n    ///\n    /// # Safety\n    /// You must call [GapBuffer::make_contiguous] before calling this method.\n    pub unsafe fn substr_from(&self, byte_offset: usize) -> &str {\n        // SAFETY: See above\n        let (start, end) = if self.gap_start == 0 {\n            (self.gap_end + byte_offset, self.cap)\n        } else {\n            (byte_offset, self.gap_start)\n        };\n        // SAFETY: We know that buffer is contiguous and that indices are within bounds\n        unsafe { std::str::from_utf8_unchecked(&self.data[start..end]) }\n    }\n\n    /// Assume that the gap is at 0 and return the full contents of the inner buffer as a slice of\n    /// bytes.\n    ///\n    /// # Safety\n    /// You must call [GapBuffer::make_contiguous] before calling this method.\n    pub unsafe fn assume_contiguous_bytes(&self) -> &[u8] {\n        &self.data[self.gap_end..]\n    }\n\n    /// Assume that the gap is at 0 and return the full contents of the inner buffer as a &str\n    ///\n    /// # Safety\n    /// You must call [GapBuffer::make_contiguous] before calling this method.\n    pub unsafe fn assume_contiguous_str(&self) -> &str {\n        // SAFETY: See above\n        unsafe { std::str::from_utf8_unchecked(&self.data[self.gap_end..]) }\n    }\n\n    /// The contents of the buffer either side of the current gap as &str slices.\n    ///\n    /// If [make_contiguous][GapBuffer::make_contiguous] was previously called, the first `&str`\n    /// will be empty and the full content of the buffer will be in the second `&str`.\n    pub fn as_strs(&self) -> (&str, &str) {\n        let (left, right) = self.as_byte_slices();\n\n        // SAFETY: we know that we have valid utf8 data internally and that the position of the gap\n        // does not split any utf-8 codepoints.\n        unsafe {\n            (\n                std::str::from_utf8_unchecked(left),\n                std::str::from_utf8_unchecked(right),\n            )\n        }\n    }\n\n    /// The contents of the buffer either side of the current gap as byte slices.\n    ///\n    /// If [make_contiguous][GapBuffer::make_contiguous] was previously called, the first slice\n    /// will be empty and the full content of the buffer will be in the second slice.\n    pub fn as_byte_slices(&self) -> (&[u8], &[u8]) {\n        (&self.data[0..self.gap_start], &self.data[self.gap_end..])\n    }\n\n    /// Whether or not the contents of the buffer end with a final newline character.\n    ///\n    /// POSIX semantics define a line as \"A sequence of zero or more non-newline characters plus\n    /// a terminating newline character.\"\n    ///\n    /// See: <https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap03.html#tag_03_206>\n    pub fn has_trailing_newline(&self) -> bool {\n        let (l, r) = self.as_byte_slices();\n\n        if r.is_empty() {\n            l.ends_with(b\"\\n\")\n        } else {\n            r.ends_with(b\"\\n\")\n        }\n    }\n\n    /// Iterate over the characters of the buffer\n    pub fn chars(&self) -> Chars<'_> {\n        self.as_slice().chars()\n    }\n\n    /// Iterate over the lines of the buffer\n    pub fn iter_lines(&self) -> impl Iterator<Item = Slice<'_>> {\n        let mut line_idx = 0;\n\n        std::iter::from_fn(move || {\n            if line_idx == self.len_lines() {\n                return None;\n            }\n            let slice = self.line(line_idx);\n            line_idx += 1;\n\n            Some(slice)\n        })\n    }\n\n    /// The number of lines within the buffer\n    #[inline]\n    pub fn len_lines(&self) -> usize {\n        match self.line_endings.last() {\n            Some(&(raw_idx, _)) => {\n                let n = self.line_endings.len();\n                let byte_idx = if raw_idx > self.gap_start {\n                    raw_idx - self.gap_end\n                } else {\n                    raw_idx\n                };\n\n                if byte_idx < self.len() { n + 1 } else { n }\n            }\n\n            None => 1,\n        }\n    }\n\n    /// The number of characters in the buffer\n    #[inline]\n    pub fn len_chars(&self) -> usize {\n        self.n_chars\n    }\n\n    /// The byte offset of the end of the given line.\n    ///\n    /// For lines with a trailing newline this is the position of the newline character,\n    /// for the final line (if there is no trailing newline) this is the end of the buffer.\n    #[inline]\n    pub fn line_end_byte(&self, line_idx: usize) -> usize {\n        if line_idx < self.line_endings.len() {\n            self.raw_byte_to_byte(self.line_endings[line_idx].0)\n        } else {\n            self.len()\n        }\n    }\n\n    pub fn lines_before_byte_offset(&self, byte_offset: usize) -> usize {\n        let raw_offset = self.byte_to_raw_byte(byte_offset);\n        self.line_endings.partition_point(|(b, _)| *b < raw_offset)\n    }\n\n    /// Clear the contents of the buffer.\n    ///\n    /// # Note\n    /// This does not actually zero out the data currently within the buffer or truncate the\n    /// allocation in any way. It simply resets internal state so that it behaves like an empty\n    /// initial buffer.\n    pub fn clear(&mut self) {\n        self.move_gap_to(0);\n        self.gap_end = self.cap;\n        self.line_endings.clear();\n        self.n_chars = 0;\n\n        #[cfg(test)]\n        assert_line_endings!(self);\n    }\n\n    /// The character at the specified character index.\n    ///\n    /// # Panics\n    /// This method will panic if the given character index is out of bounds\n    #[inline]\n    pub fn char(&self, char_idx: usize) -> char {\n        let byte_idx = self.char_to_raw_byte(char_idx);\n\n        // SAFETY: we know that we have valid utf8 data internally\n        unsafe { decode_char_at(byte_idx, &self.data) }\n    }\n\n    /// The character at the specified character index.\n    #[inline]\n    pub fn get_char(&self, char_idx: usize) -> Option<char> {\n        if char_idx < self.n_chars {\n            Some(self.char(char_idx))\n        } else {\n            None\n        }\n    }\n\n    /// The character at the specified byte index.\n    ///\n    /// # Panics\n    /// This method will panic if the given byte index is out of bounds\n    #[inline]\n    pub fn char_at(&self, byte_idx: usize) -> char {\n        let byte_idx = self.byte_to_raw_byte(byte_idx);\n\n        // SAFETY: we know that we have valid utf8 data internally\n        unsafe { decode_char_at(byte_idx, &self.data) }\n    }\n\n    /// The character at the specified byte index.\n    #[inline]\n    pub fn get_char_at(&self, byte_idx: usize) -> Option<char> {\n        if byte_idx < self.len() {\n            Some(self.char_at(byte_idx))\n        } else {\n            None\n        }\n    }\n\n    #[inline]\n    fn char_len(&self, byte_idx: usize) -> usize {\n        // SAFETY: we know that we have valid utf8 data internally\n        unsafe { decode_char_at(byte_idx, &self.data) }.len_utf8()\n    }\n\n    /// The requested line as a [Slice].\n    ///\n    /// # Panics\n    /// This method will panic if the given line index is out of bounds\n    #[inline]\n    pub fn line(&self, line_idx: usize) -> Slice<'_> {\n        if line_idx >= self.len_lines() {\n            assert_line_endings!(self);\n            panic!(\n                \"line index was {line_idx} but buffer has {} lines\",\n                self.len_lines()\n            )\n        }\n\n        let to = if line_idx < self.line_endings.len() {\n            let idx = self.line_endings[line_idx].0;\n            idx + self.char_len(idx)\n        } else {\n            self.cap\n        };\n\n        let from = if line_idx == 0 {\n            0\n        } else {\n            let idx = self.line_endings[line_idx - 1].0;\n            idx + 1\n        };\n\n        if from == to {\n            Slice::NULL\n        } else {\n            Slice::from_raw_offsets(from, to, self)\n        }\n    }\n\n    /// Returns true if the requested line is empty or only contains a single trailing newline.\n    ///\n    /// See [line][Self::line] for panic details.\n    pub fn line_is_blank(&self, line_idx: usize) -> bool {\n        matches!(\n            self.line(line_idx).as_strs(),\n            (\"\", \"\") | (\"\", \"\\n\") | (\"\\n\", \"\")\n        )\n    }\n\n    /// The number of characters in the requested line.\n    ///\n    /// # Panics\n    /// This method will panic if the given line index is out of bounds\n    #[inline]\n    pub fn line_len_chars(&self, line_idx: usize) -> usize {\n        if line_idx >= self.len_lines() {\n            assert_line_endings!(self);\n            panic!(\n                \"line index was {line_idx} but buffer has {} lines\",\n                self.len_lines()\n            )\n        }\n\n        let chars_to = if self.line_endings.is_empty() {\n            return self.n_chars;\n        } else if line_idx < self.line_endings.len() {\n            self.line_endings[line_idx].1 + 1\n        } else {\n            self.n_chars\n        };\n\n        let chars_from = if line_idx == 0 {\n            0\n        } else {\n            self.line_endings[line_idx - 1].1 + 1\n        };\n\n        chars_to - chars_from\n    }\n\n    /// Primarily intended for supplying contiguous ranges of bytes to tree-sitter when\n    /// parsing. Returns a byte slice from the underlying data buffer without entering\n    /// the gap.\n    pub fn maximal_slice_from_offset(&self, byte_offset: usize) -> &[u8] {\n        if byte_offset > self.len() {\n            &[]\n        } else {\n            let i = self.byte_to_raw_byte(byte_offset);\n            match i.cmp(&self.gap_start) {\n                Ordering::Less => &self.data[i..self.gap_start],\n                Ordering::Equal => &self.data[self.gap_end..],\n                Ordering::Greater => &self.data[i..],\n            }\n        }\n    }\n\n    /// An exclusive range of characters from the buffer\n    pub fn slice_from_byte_offsets(&self, byte_from: usize, byte_to: usize) -> Slice<'_> {\n        if byte_from == byte_to {\n            return Slice::NULL;\n        }\n\n        let from = self.byte_to_raw_byte(byte_from);\n        let to = self.byte_to_raw_byte(byte_to);\n\n        Slice::from_raw_offsets(from, to, self)\n    }\n\n    /// An exclusive range of characters from the buffer\n    pub fn slice(&self, char_from: usize, char_to: usize) -> Slice<'_> {\n        if char_from == char_to {\n            return Slice::NULL;\n        }\n\n        let byte_from = self.char_to_raw_byte(char_from);\n        let byte_to = self.offset_char_to_raw_byte(char_to, byte_from, char_from);\n\n        Slice::from_raw_offsets(byte_from, byte_to, self)\n    }\n\n    pub fn as_slice(&self) -> Slice<'_> {\n        self.slice(0, self.len_chars())\n    }\n\n    pub fn chars_in_raw_range(&self, raw_from: usize, raw_to: usize) -> usize {\n        if raw_to <= self.gap_start || raw_from >= self.gap_end {\n            count_chars(&self.data[raw_from..raw_to])\n        } else {\n            count_chars(&self.data[raw_from..self.gap_start])\n                + count_chars(&self.data[self.gap_end..raw_to])\n        }\n    }\n\n    /// Convert a character index to the index of the line containing it\n    ///\n    /// # Panics\n    /// This method will panic if the given char index is out of bounds\n    pub fn char_to_line(&self, char_idx: usize) -> usize {\n        match self.try_char_to_line(char_idx) {\n            Some(line_idx) => line_idx,\n            None => {\n                assert_line_endings!(self);\n                panic!(\n                    \"char index was {char_idx} but the buffer char length is {}\",\n                    self.len_chars()\n                );\n            }\n        }\n    }\n\n    /// Convert a character index to the index of the line containing it\n    pub fn try_char_to_line(&self, char_idx: usize) -> Option<usize> {\n        match char_idx.cmp(&self.n_chars) {\n            Ordering::Less => {\n                if char_idx < self.n_chars {\n                    Some(self.line_endings.partition_point(|(_, i)| *i < char_idx))\n                } else {\n                    Some(self.len_lines() - 1)\n                }\n            }\n\n            // We allow setting the cursor to the end of the buffer for inserts\n            Ordering::Equal => Some(self.len_lines() - 1),\n\n            Ordering::Greater => None,\n        }\n    }\n\n    /// Convert a line index to the character index of its first character\n    ///\n    /// # Panics\n    /// This method will panic if the given char index is out of bounds\n    pub fn line_to_char(&self, line_idx: usize) -> usize {\n        match self.try_line_to_char(line_idx) {\n            Some(char_idx) => char_idx,\n            None => {\n                assert_line_endings!(self);\n                panic!(\n                    \"line index was {line_idx} but the buffer has {} lines\",\n                    self.len_lines()\n                );\n            }\n        }\n    }\n\n    /// Convert a line index to the character index of its first character\n    pub fn try_line_to_char(&self, line_idx: usize) -> Option<usize> {\n        if line_idx > self.len_lines() - 1 {\n            return None;\n        }\n\n        if line_idx == 0 {\n            Some(0)\n        } else {\n            let k = self.line_endings[line_idx - 1].1;\n            Some(k + 1)\n        }\n    }\n\n    /// Convert a line index to the byte index of its first character\n    ///\n    /// # Panics\n    /// This method will panic if the given byte index is out of bounds\n    pub fn line_to_byte(&self, line_idx: usize) -> usize {\n        let raw = if line_idx == 0 {\n            0\n        } else {\n            self.line_endings[line_idx - 1].0 + 1\n        };\n\n        self.raw_byte_to_byte(raw)\n    }\n\n    /// Insert a single character at the specifified character index.\n    ///\n    /// This is O(1) if idx is at the current gap start and the gap is large enough to accommodate\n    /// the new text, otherwise data will need to be copied in order to relocate the gap.\n    pub fn insert_char(&mut self, char_idx: usize, ch: char) {\n        let len = ch.len_utf8();\n        if self.gap().saturating_sub(len) < MIN_GAP {\n            self.grow_gap(len);\n        }\n\n        let idx = self.char_to_byte(char_idx);\n        self.move_gap_to(idx);\n\n        ch.encode_utf8(&mut self.data[self.gap_start..]);\n        self.gap_start += len;\n        self.n_chars += 1;\n\n        let endings: &[(ByteOffset, CharOffset)] =\n            if ch == '\\n' { &[(idx, char_idx)] } else { &[] };\n\n        self.add_line_endings(idx, 1, endings);\n        self.char_to_byte_cache.clear();\n\n        #[cfg(test)]\n        assert_line_endings!(self);\n    }\n\n    /// Insert a string at the specifified character index.\n    ///\n    /// This is O(1) if idx is at the current gap start and the gap is large enough to accommodate\n    /// the new text, otherwise data will need to be copied in order to relocate the gap.\n    pub fn insert_str(&mut self, char_idx: usize, s: &str) {\n        let len = s.len();\n        let len_chars = s.chars().count();\n        if self.gap().saturating_sub(len) < MIN_GAP {\n            self.grow_gap(len);\n        }\n\n        let idx = self.char_to_byte(char_idx);\n        self.move_gap_to(idx);\n\n        self.data[self.gap_start..self.gap_start + len].copy_from_slice(s.as_bytes());\n        self.gap_start += len;\n        self.n_chars += len_chars;\n\n        let endings: Vec<_> = s\n            .char_indices()\n            .enumerate()\n            .filter(|(_, (_, ch))| *ch == '\\n')\n            .map(|(i, (offset, _))| (idx + offset, char_idx + i))\n            .collect();\n\n        self.add_line_endings(idx, len_chars, &endings);\n        self.char_to_byte_cache.clear();\n\n        #[cfg(test)]\n        assert_line_endings!(self);\n    }\n\n    /// Remove the requested character index from the visible region of the buffer\n    pub fn remove_char(&mut self, char_idx: usize) {\n        let raw_idx = self.char_to_raw_byte(char_idx);\n        let idx = self.raw_byte_to_byte(raw_idx);\n        let len = self.char_len(raw_idx);\n\n        if idx != self.gap_start {\n            self.move_gap_to(idx);\n        } else {\n            self.char_to_byte_cache.clear();\n        }\n\n        self.gap_end += len;\n        self.n_chars -= 1;\n\n        self.remove_line_endings(idx, idx + len, 1);\n        self.char_to_byte_cache.clear();\n\n        #[cfg(test)]\n        assert_line_endings!(self);\n    }\n\n    /// Remove the requested range (from..to) from the visible region of the buffer.\n    ///\n    /// # Panics\n    /// This method will panic if `char_from > char_to` or if the requested range is out of bounds.\n    pub fn remove_range(&mut self, char_from: usize, char_to: usize) {\n        if char_from == char_to {\n            return;\n        }\n\n        assert!(\n            char_from < char_to,\n            \"invalid range: from={char_from} > to={char_to}\"\n        );\n\n        let raw_from = self.char_to_raw_byte(char_from);\n        let from = self.raw_byte_to_byte(raw_from);\n        let to = self.offset_char_to_byte(char_to, raw_from, char_from);\n        debug_assert!(from < to, \"invalid byte range: from={from} > to={to}\");\n        self.move_gap_to(from);\n\n        let n_bytes = to - from;\n        let n_chars = char_to - char_from;\n\n        self.remove_line_endings(from, self.byte_to_raw_byte(to), n_chars);\n\n        self.gap_end += n_bytes;\n        self.n_chars -= n_chars;\n        self.char_to_byte_cache.clear();\n\n        #[cfg(test)]\n        assert_line_endings!(self);\n    }\n\n    fn add_line_endings(\n        &mut self,\n        byte_from: usize,\n        n_chars: usize,\n        new_endings: &[(ByteOffset, CharOffset)],\n    ) {\n        let idx = self.line_endings.partition_point(|(b, _)| *b < byte_from);\n        for (_, c) in &mut self.line_endings[idx..] {\n            *c += n_chars;\n        }\n\n        self.line_endings\n            .splice(idx..idx, new_endings.iter().copied());\n    }\n\n    fn remove_line_endings(&mut self, byte_from: usize, byte_to: usize, n_chars: usize) {\n        self.line_endings\n            .retain(|(b, _)| *b < self.gap_start || *b >= self.gap_end);\n\n        // If we have no line endings at all, or the removal occurred past the end of the last line\n        // endings we have tracked then there's nothing to do.\n        // > In the second case, _not_ early returning here results in the calls to partition_point\n        //   below being invalid.\n        if self.line_endings.is_empty()\n            || self\n                .line_endings\n                .last()\n                .map(|(b, _)| *b < byte_from)\n                .unwrap_or(false)\n        {\n            return;\n        }\n\n        let line_from = self.line_endings.partition_point(|(b, _)| *b < byte_from);\n        let line_to = self.line_endings.partition_point(|(b, _)| *b < byte_to);\n\n        if line_from == line_to {\n            let (b, _) = self.line_endings[line_from];\n            if b >= byte_from && b < byte_to {\n                self.line_endings.remove(line_from);\n            }\n        } else {\n            self.line_endings.drain(line_from..line_to);\n        }\n\n        for (_, c) in &mut self.line_endings[line_from..] {\n            *c -= n_chars;\n        }\n    }\n\n    fn grow_gap(&mut self, n: usize) {\n        if n >= self.next_gap {\n            self.next_gap = clamp_gap_size(self.len() + n, n.next_power_of_two());\n        }\n\n        let gap_increase = self.next_gap + n;\n        let cap = self.cap + self.next_gap + n;\n        let mut buf = Vec::with_capacity(cap);\n\n        buf.extend_from_slice(&self.data[..self.gap_start]); // data to gap\n        buf.resize(buf.len() + self.next_gap + self.gap() + n, 0); // the new gap (zeroed)\n        buf.extend_from_slice(&self.data[self.gap_end..]); // data after gap\n\n        let start = self.gap_start;\n        let from = self.line_endings.partition_point(|(b, _)| *b <= start);\n        for (b, _) in &mut self.line_endings[from..] {\n            *b += gap_increase;\n        }\n\n        self.next_gap = clamp_gap_size(self.len(), self.next_gap * 2);\n        self.data = buf.into_boxed_slice();\n        self.gap_end += gap_increase;\n        self.cap = cap;\n        self.char_to_byte_cache.clear();\n\n        #[cfg(test)]\n        assert_line_endings!(self);\n    }\n\n    /// The byte_idx argument here is an absolute position within the \"live\" buffer which will mark\n    /// the first byte of the gap region following the move.\n    ///\n    /// We do not require that the data within the gap region is valid utf-8 so it is fine for this\n    /// offset to land in the middle of existing multi-byte characters so long as the regions\n    /// outside of the gap stay valid utf-8.\n    ///\n    /// # Panics\n    /// This method will panic if the given index is out of bounds\n    fn move_gap_to(&mut self, byte_idx: usize) {\n        // we need space to fit the current gap size\n        assert!(\n            byte_idx <= self.len(),\n            \"index out of bounds: {byte_idx} > {}\",\n            self.len()\n        );\n\n        let gap = self.gap();\n\n        let (src, dest) = match byte_idx.cmp(&self.gap_start) {\n            Ordering::Equal => return,\n\n            // Gap moving left\n            Ordering::Less => {\n                let start = self.gap_start;\n                let from = self.line_endings.partition_point(|(b, _)| *b < byte_idx);\n                let to = self.line_endings.partition_point(|(b, _)| *b <= start);\n                for (b, _) in &mut self.line_endings[from..to] {\n                    *b += gap;\n                }\n\n                (byte_idx..self.gap_start, byte_idx + gap)\n            }\n\n            // Gap moving right\n            Ordering::Greater => {\n                let end = self.gap_end;\n                let from = self.line_endings.partition_point(|(b, _)| *b < end);\n                let to = self\n                    .line_endings\n                    .partition_point(|(b, _)| *b < byte_idx + gap);\n                for (b, _) in &mut self.line_endings[from..to] {\n                    *b -= gap;\n                }\n\n                (self.gap_end..byte_idx + gap, self.gap_start)\n            }\n        };\n\n        self.data.copy_within(src, dest);\n        self.gap_end = byte_idx + gap;\n        self.gap_start = byte_idx;\n        self.char_to_byte_cache.clear();\n\n        #[cfg(test)]\n        assert_line_endings!(self);\n    }\n\n    /// Convert a logical byte offset into a character offset within the buffer.\n    ///\n    /// This is primarily used to create substrings via the [GapBuffer::substr_from] method when\n    /// running regular expressions over a gap buffer.\n    ///\n    /// This is a simplified version of the equivalent logic in offset_char_to_raw_byte without the\n    /// cache and fast search on single line buffers. This is not typically in the hot path for\n    /// general editor functionality so we don't mind being a little slower in order to keep the\n    /// logic easier to reason about\n    pub fn byte_to_char(&self, byte_idx: usize) -> usize {\n        let mut to = usize::MAX;\n        let raw_byte_idx = self.byte_to_raw_byte(byte_idx);\n        let (mut raw_byte_offset, mut char_offset) = (0, 0);\n\n        // Determine which line the character lies in based on the byte index, skipping all\n        // lines that are before the byte offset we were given.\n        for &(b, c) in self.line_endings.iter() {\n            match b.cmp(&raw_byte_idx) {\n                Ordering::Less => (raw_byte_offset, char_offset) = (b, c),\n                Ordering::Equal => {\n                    return c;\n                }\n                Ordering::Greater => {\n                    to = b;\n                    break;\n                }\n            }\n        }\n\n        let slice = Slice::from_raw_offsets(raw_byte_offset, to, self);\n        let mut byte_cur = self.raw_byte_to_byte(raw_byte_offset);\n        let mut cur = char_offset;\n\n        for ch in slice.chars() {\n            if byte_cur == byte_idx {\n                break;\n            }\n            byte_cur += ch.len_utf8();\n            cur += 1;\n        }\n\n        cur\n    }\n\n    /// Convert a character offset within the logical buffer to a byte offset\n    /// within the logical buffer. This is used to account for multi-byte characters\n    /// within the buffer and is treated as a String-like index but it does not\n    /// account for the position of the gap.\n    #[inline]\n    pub fn char_to_byte(&self, char_idx: usize) -> usize {\n        self.offset_char_to_byte(char_idx, 0, 0)\n    }\n\n    /// Convert a character range to a byte range\n    pub fn char_range_to_byte_range(&self, ch_from: usize, ch_to: usize) -> (usize, usize) {\n        let raw_byte_from = self.char_to_raw_byte(ch_from);\n        let byte_from = self.raw_byte_to_byte(raw_byte_from);\n        let byte_to = self.offset_char_to_byte(ch_to, raw_byte_from, ch_from);\n\n        (byte_from, byte_to)\n    }\n\n    #[inline]\n    fn raw_byte_to_byte(&self, raw: usize) -> usize {\n        if raw > self.gap_start {\n            raw - self.gap()\n        } else {\n            raw\n        }\n    }\n\n    #[inline]\n    pub fn byte_to_raw_byte(&self, byte: usize) -> usize {\n        if byte > self.gap_start {\n            byte + self.gap()\n        } else {\n            byte\n        }\n    }\n\n    #[inline]\n    pub(crate) fn offset_char_to_byte(\n        &self,\n        char_idx: usize,\n        byte_offset: usize,\n        char_offset: usize,\n    ) -> usize {\n        let raw = self.offset_char_to_raw_byte(char_idx, byte_offset, char_offset);\n\n        self.raw_byte_to_byte(raw)\n    }\n\n    /// Convert a character offset within the logical buffer to a raw byte offset\n    /// within the underlying allocation we maintain. This is an absolute index\n    /// into our allocated array that accounts for the position of the gap.\n    #[inline]\n    fn char_to_raw_byte(&self, char_idx: usize) -> usize {\n        self.offset_char_to_raw_byte(char_idx, 0, 0)\n    }\n\n    /// Allow for skipping to a given byte index before starting the search as an optimisation when we\n    /// are searching for multiple positions in sequence (e.g. the start and end of a range).\n    fn offset_char_to_raw_byte(\n        &self,\n        char_idx: usize,\n        mut byte_offset: usize,\n        mut char_offset: usize,\n    ) -> usize {\n        if let Some(i) = self.char_to_byte_cache.get(char_idx) {\n            return i;\n        }\n\n        // Empty buffer is a special case: the only valid char indices are 0 or 1 which maps to gap_start/EOF\n        if self.n_chars == 0 {\n            assert!(\n                char_idx == 0 || char_idx == 1,\n                \"char index should be 0 or 1 for an empty buffer\"\n            );\n            return self.gap_start;\n        }\n\n        // When looking for the last character of a buffer containing a single line we can decode\n        // backwards from either the start of the gap or the end of the raw buffer depending on\n        // where the gap currently lies.\n        if self.line_endings.is_empty() && char_idx == self.len_chars().saturating_sub(1) {\n            if self.gap_end == self.cap && self.gap_start > 0 {\n                let ch_end = self.gap_start - 1;\n                // SAFETY: we know that we have valid utf-8 data immediately before the gap\n                let ch = unsafe { decode_char_ending_at(ch_end, &self.data) };\n\n                let i = self.gap_start.saturating_sub(ch.len_utf8());\n                self.char_to_byte_cache.insert(char_idx, i);\n                return i;\n            } else {\n                // SAFETY: we know that we have valid data at the end of the buffer as\n                // self.gap_end != self.cap, so decoding the final character is valid\n                let ch = unsafe { decode_char_ending_at(self.cap - 1, &self.data) };\n\n                let i = self.cap.saturating_sub(ch.len_utf8());\n                self.char_to_byte_cache.insert(char_idx, i);\n                return i;\n            };\n        }\n\n        let mut to = usize::MAX;\n\n        // Determine which line the character lies in based on the character index, skipping all\n        // lines that are before the byte offset we were given.\n        let line_from = self.line_endings.partition_point(|(b, _)| *b < byte_offset);\n        let line_endings = &self.line_endings[line_from..];\n\n        match line_endings.binary_search_by_key(&char_idx, |&(_, c)| c) {\n            Ok(i) => {\n                let b = line_endings[i].0;\n                self.char_to_byte_cache.insert(char_idx, b);\n                return b;\n            }\n            Err(i) => {\n                if i > 0 {\n                    let (b, c) = line_endings[i - 1];\n                    byte_offset = b;\n                    char_offset = c;\n                }\n                if i < line_endings.len() {\n                    to = line_endings[i].0;\n                }\n            }\n        }\n\n        let slice = Slice::from_raw_offsets(byte_offset, to, self);\n        let mut chars = slice.chars();\n        let mut cur = byte_offset;\n        for _ in 0..(char_idx - char_offset) {\n            chars.next();\n            cur = chars.cur + byte_offset;\n        }\n\n        let slice_enclosed_gap = self.gap_start >= byte_offset && self.gap_end <= to;\n        // Cur landed inside the gap or we counted over the gap while iterating the slice above\n        if cur >= self.gap_start && (cur < self.gap_end || slice_enclosed_gap) {\n            cur += self.gap();\n        }\n\n        self.char_to_byte_cache.insert(char_idx, cur);\n        cur\n    }\n\n    /// Used in tests to ensure that the data inside of the gap can't accidentally be read into as\n    /// valid buffer content due to there not making sufficient edits to the buffer state during the\n    /// test.\n    #[cfg(test)]\n    fn shred_gap(&mut self) {\n        for b in self.data[self.gap_start..self.gap_end].iter_mut() {\n            *b = b'\\0';\n        }\n    }\n}\n\n/// A view on a region of the GapBuffer.\n///\n/// Slices will become invalidated if the gap is moved from the position they were created with\n#[derive(Default, Debug, Copy, Clone, PartialEq, Eq)]\npub struct Slice<'a> {\n    /// The logical byte offset that this slice was taken from\n    from: usize,\n    left: &'a [u8],\n    right: &'a [u8],\n}\n\nimpl<'a> From<Slice<'a>> for Cow<'a, str> {\n    fn from(s: Slice<'a>) -> Self {\n        if s.left.is_empty() {\n            // SAFETY: we know that we have valid utf8 data internally\n            Cow::Borrowed(unsafe { std::str::from_utf8_unchecked(s.right) })\n        } else if s.right.is_empty() {\n            // SAFETY: we know that we have valid utf8 data internally\n            Cow::Borrowed(unsafe { std::str::from_utf8_unchecked(s.left) })\n        } else {\n            Cow::Owned(s.to_string())\n        }\n    }\n}\n\nimpl<'a> Slice<'a> {\n    const NULL: Slice<'a> = Slice {\n        from: 0,\n        left: &[],\n        right: &[],\n    };\n\n    pub fn is_contiguous(&self) -> bool {\n        self.left.is_empty() || self.right.is_empty()\n    }\n\n    /// The logical byte offset that this slice was taken from.\n    pub fn from(&self) -> usize {\n        self.from\n    }\n\n    #[inline]\n    fn from_raw_offsets(from: usize, to: usize, gb: &'a GapBuffer) -> Slice<'a> {\n        let to = min(to, gb.data.len());\n        let logical_from = gb.raw_byte_to_byte(from);\n\n        if to <= gb.gap_start || from >= gb.gap_end {\n            return Slice {\n                from: logical_from,\n                left: &gb.data[from..to],\n                right: &[],\n            };\n        }\n\n        debug_assert!(from <= gb.gap_start, \"line offset sits in gap\");\n\n        Slice {\n            from: logical_from,\n            left: &gb.data[from..gb.gap_start],\n            right: &gb.data[gb.gap_end..to],\n        }\n    }\n\n    pub fn subslice_from_byte_offsets(&self, from: usize, to: usize) -> Slice<'_> {\n        if from == to {\n            return Slice::NULL;\n        }\n\n        let to = min(to, self.len());\n        let logical_from = self.from + from;\n\n        if to <= self.left.len() {\n            Slice {\n                from: logical_from,\n                left: &self.left[from..to],\n                right: &[],\n            }\n        } else if from >= self.left.len() {\n            Slice {\n                from: logical_from,\n                left: &[],\n                right: &self.right[from..to],\n            }\n        } else {\n            Slice {\n                from: logical_from,\n                left: &self.left[from..],\n                right: &self.right[..to],\n            }\n        }\n    }\n\n    /// The number of utf-8 characters within this slice.\n    ///\n    /// Calculating involves parsing the entire slice as utf-8.\n    pub fn len_utf8(&self) -> usize {\n        self.chars().count()\n    }\n\n    pub fn len(&self) -> usize {\n        self.left.len() + self.right.len()\n    }\n\n    pub fn is_empty(&self) -> bool {\n        self.len() == 0\n    }\n\n    /// The two sides of this slice as &str references\n    pub fn as_strs(&self) -> (&str, &str) {\n        // SAFETY: we know that we have valid utf8 data internally\n        unsafe {\n            (\n                std::str::from_utf8_unchecked(self.left),\n                std::str::from_utf8_unchecked(self.right),\n            )\n        }\n    }\n\n    /// The two sides of this slice as &[u8] slices\n    pub fn as_slices(&self) -> (&[u8], &[u8]) {\n        (self.left, self.right)\n    }\n\n    /// Iterate over the contiguous &[u8] regions within this slice\n    pub fn slice_iter(self) -> SliceIter<'a> {\n        SliceIter {\n            inner: self,\n            pos: Some(false),\n        }\n    }\n\n    /// Iterate over the characters in this slice\n    pub fn chars(self) -> Chars<'a> {\n        Chars { s: self, cur: 0 }\n    }\n\n    /// Iterate over the characters in this slice in reverse\n    pub fn rev_chars(self) -> RevChars<'a> {\n        RevChars {\n            s: self,\n            cur: self.left.len() + self.right.len(),\n        }\n    }\n\n    /// Iterate over the characters in this slice with their corresponding character indices\n    pub fn indexed_chars(self, from: usize, rev: bool) -> IdxChars<'a> {\n        let (cur, idx) = if rev {\n            (\n                self.left.len() + self.right.len(),\n                from + count_chars(self.left) + count_chars(self.right),\n            )\n        } else {\n            (0, from)\n        };\n\n        IdxChars {\n            s: self,\n            cur,\n            idx,\n            rev,\n        }\n    }\n\n    fn cur_and_data(&self, cur: usize) -> (usize, &[u8]) {\n        if cur < self.left.len() {\n            (cur, self.left)\n        } else {\n            (cur - self.left.len(), self.right)\n        }\n    }\n}\n\nimpl fmt::Display for Slice<'_> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        let mut v = Vec::with_capacity(self.left.len() + self.right.len());\n        v.extend_from_slice(self.left);\n        v.extend_from_slice(self.right);\n\n        match String::from_utf8(v) {\n            Ok(s) => write!(f, \"{s}\"),\n            Err(_) => Err(fmt::Error),\n        }\n    }\n}\n\nimpl<'a> PartialEq<&'a str> for Slice<'_> {\n    fn eq(&self, other: &&'a str) -> bool {\n        let b = other.as_bytes();\n        if b.len() != self.left.len() + self.right.len() {\n            return false;\n        }\n\n        &b[..self.left.len()] == self.left && &b[self.left.len()..] == self.right\n    }\n}\n\nimpl PartialEq<String> for Slice<'_> {\n    fn eq(&self, other: &String) -> bool {\n        *self == other.as_str()\n    }\n}\n\n#[derive(Debug)]\npub struct SliceIter<'a> {\n    inner: Slice<'a>,\n    pos: Option<bool>,\n}\n\nimpl<'a> Iterator for SliceIter<'a> {\n    type Item = &'a [u8];\n\n    fn next(&mut self) -> Option<Self::Item> {\n        match self.pos? {\n            false => {\n                self.pos = Some(true);\n                Some(self.inner.left)\n            }\n\n            true => {\n                self.pos = None;\n                Some(self.inner.right)\n            }\n        }\n    }\n}\n\n/// An iterator of characters from a [Slice]\n#[derive(Default, Debug, Copy, Clone, PartialEq, Eq)]\npub struct Chars<'a> {\n    s: Slice<'a>,\n    cur: usize,\n}\n\nimpl Iterator for Chars<'_> {\n    type Item = char;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        if self.cur >= self.s.left.len() + self.s.right.len() {\n            return None;\n        }\n\n        let (cur, data) = self.s.cur_and_data(self.cur);\n        // SAFETY: we know we are in bounds and that we contain valid utf-8 data\n        let ch = unsafe { decode_char_at(cur, data) };\n        self.cur += ch.len_utf8();\n\n        Some(ch)\n    }\n}\n\n/// An iterator of characters from a [Slice]\n#[derive(Default, Debug, Copy, Clone, PartialEq, Eq)]\npub struct RevChars<'a> {\n    s: Slice<'a>,\n    cur: usize,\n}\n\nimpl Iterator for RevChars<'_> {\n    type Item = char;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        if self.cur == 0 {\n            return None;\n        }\n\n        let (cur, data) = self.s.cur_and_data(self.cur - 1);\n        // SAFETY: we know we are in bounds and that we contain valid utf-8 data\n        let ch = unsafe { decode_char_ending_at(cur, data) };\n        self.cur -= ch.len_utf8();\n\n        Some(ch)\n    }\n}\n\n/// An iterator of characters and their indices from a [Slice]\n#[derive(Default, Debug, Copy, Clone, PartialEq, Eq)]\npub struct IdxChars<'a> {\n    s: Slice<'a>,\n    cur: usize,\n    idx: usize,\n    rev: bool,\n}\n\nimpl Iterator for IdxChars<'_> {\n    type Item = (usize, char);\n\n    fn next(&mut self) -> Option<Self::Item> {\n        if (!self.rev && self.cur >= self.s.left.len() + self.s.right.len())\n            || (self.rev && self.cur == 0)\n        {\n            return None;\n        }\n\n        if self.rev {\n            let (cur, data) = self.s.cur_and_data(self.cur - 1);\n            // SAFETY: we know we are in bounds and that we contain valid utf-8 data\n            let ch = unsafe { decode_char_ending_at(cur, data) };\n            let len = ch.len_utf8();\n            self.idx -= 1;\n            self.cur -= len;\n            Some((self.idx, ch))\n        } else {\n            let (cur, data) = self.s.cur_and_data(self.cur);\n            // SAFETY: we know we are in bounds and that we contain valid utf-8 data\n            let ch = unsafe { decode_char_at(cur, data) };\n            let len = ch.len_utf8();\n            let res = Some((self.idx, ch));\n            self.cur += len;\n            self.idx += 1;\n            res\n        }\n    }\n}\n\n// The following helper functions are adapted from nightly APIs in std::core::str\n// -> https://doc.rust-lang.org/stable/src/core/str/validations.rs.html\n\n/// Mask of the value bits of a continuation byte.\nconst CONT_MASK: u8 = 0b0011_1111;\n\n/// Returns the initial codepoint accumulator for the first byte.\n/// The first byte is special, only want bottom 5 bits for width 2, 4 bits\n/// for width 3, and 3 bits for width 4.\n#[inline]\nconst fn utf8_first_byte(byte: u8, width: u32) -> u32 {\n    (byte & (0x7F >> width)) as u32\n}\n\n/// Returns the value of `ch` updated with continuation byte `byte`.\n#[inline]\nconst fn utf8_acc_cont_byte(ch: u32, byte: u8) -> u32 {\n    (ch << 6) | (byte & CONT_MASK) as u32\n}\n\n/// Checks whether the byte is a UTF-8 continuation byte (i.e., starts with the\n/// bits `10`).\n#[inline]\nconst fn utf8_is_cont_byte(byte: u8) -> bool {\n    (byte as i8) < -64\n}\n\n/// Decode a utf-8 code point from `bytes` starting at `start`.\n/// `bytes` must contain valid utf-8 data beginning at `start`\n#[inline]\nunsafe fn decode_char_at(start: usize, bytes: &[u8]) -> char {\n    // Decode UTF-8\n    // SAFETY: `bytes` contains UTF-8-like string data so we have the next byte,\n    let x = bytes[start];\n    if x < 128 {\n        // SAFETY: x is in the correct range\n        return unsafe { char::from_u32_unchecked(x as u32) };\n    }\n\n    // Multibyte case follows\n    // Decode from a byte combination out of: [[[x y] z] w]\n    // NOTE: Performance is sensitive to the exact formulation here\n    let init = utf8_first_byte(x, 2);\n    // SAFETY: `bytes` contains UTF-8-like string data so we have the next byte,\n    let y = bytes[start + 1];\n    let mut ch = utf8_acc_cont_byte(init, y);\n\n    if x >= 0xE0 {\n        // [[x y z] w] case\n        // 5th bit in 0xE0 .. 0xEF is always clear, so `init` is still valid\n        // SAFETY: `bytes` contains UTF-8-like string data so we have the next byte,\n        let z = bytes[start + 2];\n        let y_z = utf8_acc_cont_byte((y & CONT_MASK) as u32, z);\n        ch = (init << 12) | y_z;\n        if x >= 0xF0 {\n            // [x y z w] case\n            // use only the lower 3 bits of `init`\n            // SAFETY: `bytes` contains UTF-8-like string data so we have the next byte,\n            let w = bytes[start + 3];\n            ch = ((init & 7) << 18) | utf8_acc_cont_byte(y_z, w);\n        }\n    }\n\n    // SAFETY: we know that ch is valid at this point\n    unsafe { char::from_u32_unchecked(ch) }\n}\n\n/// Decode a utf-8 code point from `bytes` ending at `end`.\n/// `bytes` must contain valid utf-8 data ending at `end`\n#[inline]\nunsafe fn decode_char_ending_at(end: usize, bytes: &[u8]) -> char {\n    // Decode UTF-8\n    let w = match bytes[end] {\n        // SAFETY: b is in range\n        b if b < 128 => return unsafe { char::from_u32_unchecked(b as u32) },\n        b => b,\n    };\n\n    // Multibyte case follows\n    // Decode from a byte combination out of: [x [y [z w]]]\n    let mut ch;\n    // SAFETY: `bytes` contains UTF-8-like string data so we have the next byte,\n    let z = bytes[end - 1];\n    ch = utf8_first_byte(z, 2);\n    if utf8_is_cont_byte(z) {\n        // SAFETY: `bytes` contains UTF-8-like string data so we have the next byte,\n        let y = bytes[end - 2];\n        ch = utf8_first_byte(y, 3);\n        if utf8_is_cont_byte(y) {\n            // SAFETY: `bytes` contains UTF-8-like string data so we have the next byte,\n            let x = bytes[end - 3];\n            ch = utf8_first_byte(x, 4);\n            ch = utf8_acc_cont_byte(ch, y);\n        }\n        ch = utf8_acc_cont_byte(ch, z);\n    }\n    ch = utf8_acc_cont_byte(ch, w);\n\n    // SAFETY: we know that ch is valid at this point\n    unsafe { char::from_u32_unchecked(ch) }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use simple_test_case::test_case;\n\n    fn debug_buffer_content(gb: &GapBuffer) -> String {\n        let mut v = gb.data.to_vec();\n        v[gb.gap_start..gb.gap_end].copy_from_slice(\"_\".repeat(gb.gap()).as_bytes());\n        String::from_utf8(v).expect(\"valid utf8\")\n    }\n\n    fn raw_debug_buffer_content(gb: &GapBuffer) -> String {\n        let mut v = gb.data.to_vec();\n        for b in v[gb.gap_start..gb.gap_end].iter_mut() {\n            if *b == b'\\0' {\n                *b = b'_';\n            }\n        }\n        v.insert(gb.gap_end, b']');\n        v.insert(gb.gap_start, b'[');\n\n        String::from_utf8(v).expect(\"valid utf8\")\n    }\n\n    #[test]\n    fn from_string_matches_from_str() {\n        let s = \"this is a test\";\n        let gb1 = GapBuffer::from(s.to_string());\n        let gb2 = GapBuffer::from(s);\n\n        assert_eq!(gb1, gb2);\n    }\n\n    #[test]\n    fn to_string_works() {\n        let s = \"this is a test\";\n        let gb = GapBuffer::from(s.to_string());\n        assert_eq!(gb.to_string(), s);\n    }\n\n    #[test]\n    fn insert_into_empty_string_initial_gb_works() {\n        let mut gb = GapBuffer::from(String::new());\n        gb.insert_char(0, 'a');\n        gb.shred_gap();\n\n        assert_eq!(gb.to_string(), \"a\");\n    }\n\n    #[test_case(\"foo\u2502foo\u2502foo\"; \"interleaved multibyte and ascii\")]\n    #[test_case(\"hello, \u4e16\u754c!\"; \"blocks of multibyte and ascii\")]\n    #[test_case(\"hello, world!\"; \"just ascii\")]\n    #[test]\n    fn len_chars_works(s: &str) {\n        let mut gb = GapBuffer::from(s);\n        let len_s = s.chars().count();\n\n        println!(\"initial:          {:?}\", raw_debug_buffer_content(&gb));\n        assert_eq!(gb.len_chars(), len_s);\n        assert_eq!(\n            gb.len_chars(),\n            gb.to_string().chars().count(),\n            \"char iter len != len_chars\"\n        );\n        assert_eq!(\n            gb.line(0).chars().count(),\n            gb.line_len_chars(0),\n            \"line_len_chars != len_chars\"\n        );\n\n        gb.insert_char(5, 'X');\n        gb.shred_gap();\n\n        println!(\"after insert X:   {:?}\", raw_debug_buffer_content(&gb));\n        assert_eq!(gb.len_chars(), len_s + 1);\n        assert_eq!(\n            gb.len_chars(),\n            gb.to_string().chars().count(),\n            \"char iter len != len_chars\"\n        );\n\n        gb.insert_char(3, '\u754c');\n        gb.shred_gap();\n        println!(\"after insert \u754c:  {:?}\", raw_debug_buffer_content(&gb));\n        assert_eq!(gb.len_chars(), len_s + 2);\n        assert_eq!(\n            gb.len_chars(),\n            gb.to_string().chars().count(),\n            \"char iter len != len_chars\"\n        );\n\n        assert_eq!(gb.char(3), '\u754c');\n        gb.remove_char(3);\n        gb.shred_gap();\n        println!(\"after remove \u754c:  {:?}\", raw_debug_buffer_content(&gb));\n        assert_eq!(gb.len_chars(), len_s + 1);\n        assert_eq!(\n            gb.len_chars(),\n            gb.to_string().chars().count(),\n            \"char iter len != len_chars\"\n        );\n\n        assert_eq!(gb.char(5), 'X');\n        gb.remove_char(5);\n        gb.shred_gap();\n        println!(\"after remove X:   {:?}\", debug_buffer_content(&gb));\n        assert_eq!(gb.len_chars(), len_s);\n        assert_eq!(\n            gb.len_chars(),\n            gb.to_string().chars().count(),\n            \"char iter len != len_chars\"\n        );\n        assert_eq!(gb.to_string(), s);\n    }\n\n    #[test_case(0, 14; \"first line\")]\n    #[test_case(1, 13; \"second line\")]\n    #[test_case(2, 14; \"last line no trailing newline\")]\n    #[test]\n    fn line_len_chars_works(line_idx: usize, expected: usize) {\n        let gb = GapBuffer::from(\"hello, world!\\nhow are you?\\nthis is a test\");\n\n        assert_eq!(gb.line_len_chars(line_idx), expected);\n    }\n\n    #[test_case(\"foo\u2502foo\u2502foo\"; \"interleaved multibyte and ascii\")]\n    #[test_case(\"hello, \u4e16\u754c!\"; \"blocks of multibyte and ascii\")]\n    #[test_case(\"hello, world!\"; \"just ascii\")]\n    #[test]\n    fn move_gap_to_maintains_content(s: &str) {\n        let mut gb = GapBuffer::from(s);\n\n        for i in 0..gb.len_chars() {\n            let idx = gb.char_to_byte(i);\n            gb.move_gap_to(idx);\n            gb.shred_gap();\n\n            // Splitting into the two sections like this allows us to verify that\n            // we have valid utf-8 encoded text on either side of the gap.\n            let (s1, s2) = (\n                std::str::from_utf8(&gb.data[..gb.gap_start]).unwrap(),\n                std::str::from_utf8(&gb.data[gb.gap_end..]).unwrap(),\n            );\n\n            assert_eq!(format!(\"{s1}{s2}\"), s, \"idx={idx}\");\n        }\n    }\n\n    #[test]\n    fn move_gap_to_maintains_line_content() {\n        let s = \"hello, world!\\nhow are you?\\nthis is a test\";\n        let mut gb = GapBuffer::from(s);\n        assert_eq!(gb.len_lines(), 3);\n\n        for i in 0..gb.len_chars() {\n            let idx = gb.char_to_byte(i);\n            gb.move_gap_to(idx);\n            gb.shred_gap();\n            assert_eq!(gb.len_lines(), 3);\n\n            assert_eq!(gb.line(0).to_string(), \"hello, world!\\n\", \"idx={idx}\");\n            assert_eq!(gb.line(1).to_string(), \"how are you?\\n\", \"idx={idx}\");\n            assert_eq!(gb.line(2).to_string(), \"this is a test\", \"idx={idx}\");\n        }\n    }\n\n    #[test_case(0, 0, 0; \"BOF cur at BOF\")]\n    #[test_case(27, 0, 0; \"BOF cur at EOF\")]\n    #[test_case(27, 5, 5; \"in the buffer cur at EOF\")]\n    #[test_case(5, 5, 5; \"in the buffer cur at gap\")]\n    #[test_case(5, 3, 3; \"in the buffer cur before gap\")]\n    #[test_case(5, 11, 15; \"in the buffer cur after gap\")]\n    #[test_case(5, 7, 7; \"multi byte 1\")]\n    #[test_case(5, 8, 10; \"multi byte 2\")]\n    #[test]\n    fn char_to_byte_works(cur: usize, char_idx: usize, expected: usize) {\n        let s = \"hello, \u4e16\u754c!\\nhow are you?\";\n        let mut gb = GapBuffer::from(s);\n        assert_eq!(s.len(), 27, \"EOF case is not 0..s.len()\");\n        assert_eq!(\"\u4e16\".len(), 3);\n        gb.move_gap_to(cur);\n        gb.shred_gap();\n\n        let byte_idx = gb.char_to_byte(char_idx);\n        assert_eq!(byte_idx, expected, \"{:?}\", debug_buffer_content(&gb));\n    }\n\n    // Regression test for (gh#140)\n    #[test_case(\"\u2349\"; \"one multi-byte char\")]\n    #[test_case(\"\u2320\u2316\"; \"two multi-byte chars\")]\n    #[test_case(\"\u060f foo\"; \"one multi-byte char followed by ascii\")]\n    #[test_case(\"\u4e16\u754c abc\"; \"two multi-byte chars followed by ascii\")]\n    #[test]\n    fn char_to_byte_works_with_leading_multibyte_char(s: &str) {\n        let mut gb = GapBuffer::new();\n        gb.insert_str(0, s);\n        gb.shred_gap();\n\n        let byte_idx = gb.char_to_byte(0);\n        assert_eq!(byte_idx, 0, \"{:?}\", debug_buffer_content(&gb));\n    }\n\n    // Regression test for (gh#140)\n    #[test_case(\"\u2349\", 0; \"one multi-byte char\")]\n    #[test_case(\"\u2320\u2316\", 3; \"two multi-byte chars\")]\n    #[test_case(\"foo \u060f\", 4; \"ascii followed by one multi-byte char\")]\n    #[test_case(\"abc \u4e16\u754c\", 7; \"ascii followed by two multi-byte chars\")]\n    #[test_case(\"Hello, world!\u2349\", 13; \"error case from issue 140\")]\n    #[test]\n    fn char_to_byte_works_with_single_line_buffers_ending_in_a_multibyte_char(\n        s: &str,\n        expected: usize,\n    ) {\n        let mut gb = GapBuffer::new();\n        gb.insert_str(0, s);\n        gb.shred_gap();\n        let last_char = s.chars().count() - 1;\n\n        let byte_idx = gb.char_to_byte(last_char);\n        assert_eq!(byte_idx, expected, \"{:?}\", debug_buffer_content(&gb));\n    }\n\n    #[test_case(0, 0, 64, 'h'; \"BOF cur at BOF\")]\n    #[test_case(27, 0, 0, 'h'; \"BOF cur at EOF\")]\n    #[test_case(27, 5, 5, ','; \"in the buffer cur at EOF\")]\n    #[test_case(5, 5, 69, ','; \"in the buffer cur at gap\")]\n    #[test_case(5, 3, 3, 'l'; \"in the buffer cur after gap\")]\n    #[test_case(5, 11, 79, 'h'; \"in the buffer cur before gap\")]\n    #[test_case(5, 7, 71, '\u4e16'; \"multi byte 1\")]\n    #[test_case(5, 8, 74, '\u754c'; \"multi byte 2\")]\n    #[test]\n    fn char_to_raw_byte_works(cur: usize, char_idx: usize, expected: usize, expected_ch: char) {\n        let s = \"hello, \u4e16\u754c!\\nhow are you?\";\n        let mut gb = GapBuffer::from(s);\n        assert_eq!(s.len(), 27, \"EOF case is not 0..s.len()\");\n        assert_eq!(\"\u4e16\".len(), 3);\n        gb.move_gap_to(cur);\n        gb.shred_gap();\n\n        let byte_idx = gb.char_to_raw_byte(char_idx);\n        assert_eq!(byte_idx, expected, \"{:?}\", debug_buffer_content(&gb));\n\n        // SAFETY: safe if the test is passing\n        let ch = unsafe { decode_char_at(byte_idx, &gb.data) };\n        assert_eq!(ch, expected_ch);\n    }\n\n    #[test_case(\"hello, world! this is the last line\"; \"ascii no newline\")]\n    #[test_case(\"hello, world!\\nthis is the last line\"; \"ascii single newline\")]\n    #[test_case(\"foo\u2502foo\u2502foo\"; \"mixed width no newlines\")]\n    #[test_case(\"hello, \u4e16\u754c!\\nhow are you?\"; \"mixed width single newline\")]\n    #[test]\n    fn byte_to_char_works(s: &str) {\n        let mut gb = GapBuffer::from(s);\n\n        for pos in 0..gb.len_chars() - 1 {\n            gb.move_gap_to(gb.char_to_byte(pos));\n            gb.shred_gap();\n\n            for (ch_idx, (byte_idx, _ch)) in s.char_indices().enumerate() {\n                let idx = gb.byte_to_char(byte_idx);\n                assert_eq!(idx, ch_idx, \"gap@{pos}\");\n            }\n        }\n    }\n\n    #[test_case(0, 0, \"hello, world!\\n\"; \"first line cur at BOF\")]\n    #[test_case(0, 1, \"how are you?\"; \"second line cur at BOF\")]\n    #[test_case(26, 0, \"hello, world!\\n\"; \"first line cur at EOF\")]\n    #[test_case(26, 1, \"how are you?\"; \"second line cur at EOF\")]\n    #[test_case(10, 0, \"hello, world!\\n\"; \"first line cur in line\")]\n    #[test_case(10, 1, \"how are you?\"; \"second line cur in line\")]\n    #[test]\n    fn slice_to_string_works(cur: usize, line: usize, expected: &str) {\n        let mut gb = GapBuffer::from(\"hello, world!\\nhow are you?\");\n        gb.move_gap_to(cur);\n        gb.shred_gap();\n\n        assert_eq!(gb.line(line).to_string(), expected);\n    }\n\n    #[test]\n    fn line_to_char_works() {\n        let l1 = \"hello, world!\\n\";\n        let l2 = \"how are you?\\n\";\n        let l3 = \"this is a test\";\n\n        let gb = GapBuffer::from(format!(\"{l1}{l2}{l3}\"));\n\n        assert_eq!(gb.line_to_char(0), 0);\n        assert_eq!(gb.line_to_char(1), l1.chars().count());\n        assert_eq!(gb.line_to_char(2), l1.chars().count() + l2.chars().count());\n    }\n\n    #[test_case(0, 0; \"start of first line\")]\n    #[test_case(5, 0; \"in first line\")]\n    #[test_case(13, 0; \"end of first line\")]\n    #[test_case(14, 1; \"start of second line\")]\n    #[test_case(20, 1; \"in second line\")]\n    #[test_case(26, 1; \"end of second line\")]\n    #[test_case(27, 2; \"start of third line\")]\n    #[test_case(30, 2; \"in third line\")]\n    #[test_case(40, 2; \"end of third line\")]\n    #[test]\n    fn char_to_line_works(char_idx: usize, line_idx: usize) {\n        let l1 = \"hello, world!\\n\";\n        let l2 = \"how are you?\\n\";\n        let l3 = \"this is a test\";\n\n        let gb = GapBuffer::from(format!(\"{l1}{l2}{l3}\"));\n\n        assert_eq!(gb.char_to_line(char_idx), line_idx);\n    }\n\n    #[test_case(&[(0, 'h')], \"hello world\"; \"insert front\")]\n    #[test_case(&[(4, ',')], \"ello, world\"; \"insert inner\")]\n    #[test_case(&[(10, '!')], \"ello world!\"; \"insert back\")]\n    #[test_case(&[(4, ','), (11, '!')], \"ello, world!\"; \"insert inner then back\")]\n    #[test_case(&[(4, ','), (0, 'h')], \"hello, world\"; \"insert inner then front\")]\n    #[test_case(&[(0, 'h'), (5, ','),], \"hello, world\"; \"insert front then inner\")]\n    #[test_case(&[(10, '!'), (0, 'h'), (5, ',')], \"hello, world!\"; \"insert all\")]\n    #[test]\n    fn insert_char(inserts: &[(usize, char)], expected: &str) {\n        let mut gb = GapBuffer::from(\"ello world\");\n\n        for &(idx, ch) in inserts {\n            gb.insert_char(idx, ch);\n            gb.shred_gap();\n        }\n\n        assert_eq!(gb.to_string(), expected, \"{:?}\", debug_buffer_content(&gb))\n    }\n\n    #[test]\n    fn insert_char_with_moving_cur() {\n        let mut gb = GapBuffer::from(\"hello \");\n        gb.insert_char(6, 'w');\n        gb.shred_gap();\n        gb.insert_char(7, 'o');\n        gb.shred_gap();\n        gb.insert_char(8, 'r');\n        gb.shred_gap();\n        gb.insert_char(9, 'l');\n        gb.shred_gap();\n        gb.insert_char(10, 'd');\n        gb.shred_gap();\n        gb.insert_char(11, '!');\n        gb.shred_gap();\n        gb.insert_char(5, ',');\n        gb.shred_gap();\n\n        assert_eq!(\n            gb.to_string(),\n            \"hello, world!\",\n            \"{:?}\",\n            debug_buffer_content(&gb)\n        )\n    }\n\n    #[test]\n    fn insert_newline_char_is_tracked_correctly() {\n        let s = \"hello, world!\\nhow are you?\";\n        let mut gb = GapBuffer::from(s);\n        assert_eq!(gb.len_lines(), 2);\n\n        println!(\"initial: {:?}\", raw_debug_buffer_content(&gb));\n        gb.insert_char(6, '\\n');\n        gb.shred_gap();\n        println!(\"insert:  {:?}\", raw_debug_buffer_content(&gb));\n\n        assert_eq!(gb.len_lines(), 3);\n        assert_eq!(gb.line(0).to_string(), \"hello,\\n\");\n        assert_eq!(gb.line(1).to_string(), \" world!\\n\");\n        assert_eq!(gb.line(2).to_string(), \"how are you?\");\n\n        for idx in 0..=gb.len_chars() {\n            gb.move_gap_to(idx);\n            gb.shred_gap();\n            assert_eq!(gb.len_lines(), 3);\n\n            assert_eq!(gb.line(0).to_string(), \"hello,\\n\", \"idx={idx}\");\n            assert_eq!(gb.line(1).to_string(), \" world!\\n\", \"idx={idx}\");\n            assert_eq!(gb.line(2).to_string(), \"how are you?\", \"idx={idx}\");\n        }\n    }\n\n    #[test_case(&[(0, \"hell\")], \"helloworl\"; \"insert front\")]\n    #[test_case(&[(1, \", \")], \"o, worl\"; \"insert inner\")] // typos:ignore\n    #[test_case(&[(5, \"d!\")], \"oworld!\"; \"insert back\")]\n    #[test_case(&[(5, \"d!\"), (0, \"hell\"), (5, \", \")], \"hello, world!\"; \"insert all\")]\n    #[test_case(&[(5, \"d!\"), (0, \"hell\"), (5, \",\\n\")], \"hello,\\nworld!\"; \"insert all w newline\")]\n    #[test]\n    fn insert_str(inserts: &[(usize, &str)], expected: &str) {\n        let mut gb = GapBuffer::from(\"oworl\");\n        for &(idx, s) in inserts {\n            gb.insert_str(idx, s);\n            gb.shred_gap();\n        }\n\n        assert_eq!(gb.to_string(), expected, \"{:?}\", debug_buffer_content(&gb))\n    }\n\n    #[test]\n    fn insert_newline_in_str_is_tracked_correctly() {\n        let s = \"hello, world!\\nhow are you?\";\n        let mut gb = GapBuffer::from(s);\n        assert_eq!(gb.len_lines(), 2);\n\n        let s2 = \" sailor\\nisn't this fun?\\nwhat a wonderful\\n\";\n        gb.insert_str(6, s2);\n        gb.shred_gap();\n\n        for idx in 0..=gb.len_chars() {\n            gb.move_gap_to(idx);\n            gb.shred_gap();\n            assert_eq!(gb.len_lines(), 5);\n\n            assert_eq!(gb.line(0).to_string(), \"hello, sailor\\n\", \"idx={idx}\");\n            assert_eq!(gb.line(1).to_string(), \"isn't this fun?\\n\", \"idx={idx}\");\n            assert_eq!(gb.line(2).to_string(), \"what a wonderful\\n\", \"idx={idx}\");\n            assert_eq!(gb.line(3).to_string(), \" world!\\n\", \"idx={idx}\");\n            assert_eq!(gb.line(4).to_string(), \"how are you?\", \"idx={idx}\");\n        }\n    }\n\n    #[test_case(6, \"hello,world!\"; \"at gap start\")]\n    #[test_case(7, \"hello, orld!\"; \"at gap end\")]\n    #[test_case(12, \"hello, world\"; \"after gap\")]\n    #[test_case(0, \"ello, world!\"; \"before gap\")]\n    #[test]\n    fn remove_char(idx: usize, expected: &str) {\n        let mut gb = GapBuffer::from(\"hello, world!\");\n        gb.move_gap_to(6); // space before world\n        gb.shred_gap();\n        gb.remove_char(idx);\n        gb.shred_gap();\n\n        assert_eq!(gb.to_string(), expected, \"{:?}\", debug_buffer_content(&gb))\n    }\n\n    #[test]\n    fn remove_newline_char_is_tracked_correctly() {\n        let s = \"hello, world!\\nhow are you?\";\n        let mut gb = GapBuffer::from(s);\n        assert_eq!(gb.len_lines(), 2);\n\n        gb.remove_char(13);\n        gb.shred_gap();\n\n        assert_eq!(gb.len_lines(), 1);\n        assert_eq!(gb.line(0).to_string(), \"hello, world!how are you?\");\n    }\n\n    #[test_case(6, 9, \"hello,rld!\"; \"at gap start\")]\n    #[test_case(7, 10, \"hello, ld!\"; \"at gap end\")]\n    #[test_case(10, 13, \"hello, wor\"; \"after gap\")]\n    #[test_case(0, 5, \", world!\"; \"before gap\")]\n    #[test_case(0, 13, \"\"; \"remove all\")]\n    #[test]\n    fn remove_range_works(from: usize, to: usize, expected: &str) {\n        let s = \"hello, world!\";\n        assert_eq!(s.len(), 13, \"remove all case is not 0..s.len()\");\n\n        let mut gb = GapBuffer::from(s);\n        gb.move_gap_to(6); // space before world\n        gb.shred_gap();\n        gb.remove_range(from, to);\n        gb.shred_gap();\n\n        assert_eq!(gb.to_string(), expected, \"{:?}\", debug_buffer_content(&gb))\n    }\n\n    #[test]\n    fn remove_range_w_multibyte_chars_works() {\n        let s = \"foo\u2502foo\u2502foo\";\n        let mut gb = GapBuffer::from(s);\n\n        gb.remove_range(0, 3);\n        gb.shred_gap();\n        assert_eq!(gb.to_string(), \"\u2502foo\u2502foo\");\n        assert_eq!(gb.len_chars(), 8);\n\n        gb.remove_range(1, 4);\n        gb.shred_gap();\n        assert_eq!(gb.to_string(), \"\u2502\u2502foo\");\n        assert_eq!(gb.len_chars(), 5);\n\n        gb.remove_range(2, 5);\n        gb.shred_gap();\n        assert_eq!(gb.to_string(), \"\u2502\u2502\");\n        assert_eq!(gb.len_chars(), 2);\n    }\n\n    #[test]\n    fn remove_range_for_last_line_works() {\n        let s = \"hello, world!\\nthis is the last line\";\n        let mut gb = GapBuffer::from(s);\n        gb.remove_range(14, s.len());\n        gb.shred_gap();\n        assert_eq!(gb.to_string(), \"hello, world!\\n\");\n        assert_eq!(gb.len_lines(), 2);\n    }\n\n    #[test_case(10, 15, \"hello, worow are you?\"; \"spanning newline\")]\n    #[test_case(7, 14, \"hello, how are you?\"; \"ending on newline\")]\n    #[test_case(13, 26, \"hello, world!\"; \"starting on newline\")]\n    #[test]\n    fn remove_newline_in_str_is_tracked_correctly(from: usize, to: usize, expected: &str) {\n        let s = \"hello, world!\\nhow are you?\";\n        let mut gb = GapBuffer::from(s);\n        assert_eq!(gb.len_lines(), 2);\n\n        gb.remove_range(from, to);\n        gb.shred_gap();\n\n        assert_eq!(gb.len_lines(), 1);\n        assert_eq!(gb.to_string(), expected);\n        assert_eq!(gb.line(0).to_string(), expected);\n    }\n\n    #[test_case('X'; \"ascii\")]\n    #[test_case('\u754c'; \"multi-byte\")]\n    #[test]\n    fn insert_remove_char_is_idempotent(ch: char) {\n        let s = \"hello, world!\";\n        let mut gb = GapBuffer::from(s);\n        gb.insert_char(6, ch);\n        gb.shred_gap();\n        gb.remove_char(6);\n        gb.shred_gap();\n\n        assert_eq!(gb.to_string(), s, \"{:?}\", debug_buffer_content(&gb))\n    }\n\n    #[test_case(\"TEST\", 1; \"without trailing newline\")]\n    #[test_case(\"TEST\\n\", 2; \"with trailing newline\")]\n    #[test_case(\"TEST\\nTEST\", 2; \"with internal newline\")]\n    #[test]\n    fn insert_remove_str_is_idempotent(edit: &str, expected_lines: usize) {\n        let s = \"hello, world!\";\n        let mut gb = GapBuffer::from(s);\n\n        println!(\"initial: {:?}\", raw_debug_buffer_content(&gb));\n        for n in 0..gb.len_lines() {\n            println!(\"{:?}\", gb.line(n).to_string());\n        }\n\n        gb.insert_str(6, edit);\n        gb.shred_gap();\n        assert_eq!(gb.len_lines(), expected_lines);\n        println!(\"insert:  {:?}\", raw_debug_buffer_content(&gb));\n        for n in 0..gb.len_lines() {\n            println!(\"{:?}\", gb.line(n).to_string());\n        }\n\n        gb.remove_range(6, 6 + edit.len());\n        gb.shred_gap();\n        println!(\"remove:  {:?}\", raw_debug_buffer_content(&gb));\n        for n in 0..gb.len_lines() {\n            println!(\"{:?}\", gb.line(n).to_string());\n        }\n\n        assert_eq!(gb.to_string(), s);\n    }\n\n    #[test]\n    fn chars_work() {\n        let s1 = \"hello, world!\\n\";\n        let s2 = \"how are you?\";\n        let gb = GapBuffer::from(format!(\"{s1}{s2}\"));\n\n        let l1_chars: String = gb.line(0).chars().collect();\n        assert_eq!(l1_chars, s1);\n\n        let l2_chars: String = gb.line(1).chars().collect();\n        assert_eq!(l2_chars, s2);\n    }\n\n    #[test_case(\n        \"hello, \u4e16\u754c!\", false,\n        &[(0, 'h'), (1, 'e'), (2, 'l'), (3, 'l'), (4, 'o'),\n          (5, ','), (6, ' '), (7, '\u4e16'), (8, '\u754c'), (9, '!')];\n        \"multi-byte block forward\"\n    )]\n    #[test_case(\n        \"hello, \u4e16\u754c!\", true,\n        &[(9, '!'), (8, '\u754c'), (7, '\u4e16'), (6, ' '), (5, ','),\n          (4, 'o'), (3, 'l'), (2, 'l'), (1, 'e'), (0, 'h')];\n        \"multi-byte block reversed\"\n    )]\n    #[test_case(\n        \"foo\u2502foo\u2502foo\", false,\n        &[(0, 'f'), (1, 'o'), (2, 'o'), (3, '\u2502'), (4, 'f'), (5, 'o'),\n          (6, 'o'), (7, '\u2502'), (8, 'f'), (9, 'o'), (10, 'o')];\n        \"interleaved forward\"\n    )]\n    #[test_case(\n        \"foo\u2502foo\u2502foo\", true,\n        &[(10, 'o'), (9, 'o'), (8, 'f'), (7, '\u2502'), (6, 'o'), (5, 'o'),\n          (4, 'f'), (3, '\u2502'), (2, 'o'), (1, 'o'), (0, 'f')];\n        \"interleaved reversed\"\n    )]\n    #[test]\n    fn indexed_chars_works(s: &str, rev: bool, expected: &[(usize, char)]) {\n        let mut gb = GapBuffer::from(s);\n        let v: Vec<(usize, char)> = gb.line(0).indexed_chars(0, rev).collect();\n        assert_eq!(&v, expected);\n\n        for i in 0..gb.len_chars() {\n            let idx = gb.char_to_byte(i);\n            gb.move_gap_to(idx);\n            gb.shred_gap();\n\n            let v: Vec<(usize, char)> = gb.line(0).indexed_chars(0, rev).collect();\n            assert_eq!(&v, expected, \"idx={idx}\");\n        }\n    }\n\n    #[test_case(\"foo\u2502foo\u2502foo\"; \"interleaved multibyte and ascii\")]\n    #[test_case(\"hello, \u4e16\u754c!\"; \"blocks of multibyte and ascii\")]\n    #[test]\n    fn chars_works(s: &str) {\n        let mut gb = GapBuffer::from(s);\n        let chars: String = gb.line(0).chars().collect();\n        assert_eq!(chars, s);\n\n        for i in 0..gb.len_chars() {\n            let idx = gb.char_to_byte(i);\n            gb.move_gap_to(idx);\n            gb.shred_gap();\n\n            let chars: String = gb.line(0).chars().collect();\n            assert_eq!(chars, s, \"idx={idx}\");\n        }\n    }\n\n    #[test]\n    fn slice_works() {\n        let mut gb = GapBuffer::from(\"hello, world!\\nhow are you?\");\n        let slice = Slice::from_raw_offsets(0, gb.cap, &gb);\n        let (s1, s2) = slice.as_strs();\n        assert_eq!(s1, \"\");\n        assert_eq!(s2, \"hello, world!\\nhow are you?\");\n\n        let slice = gb.slice(6, 17);\n        let (s1, s2) = slice.as_strs();\n        assert_eq!(s1, \" world!\\nhow\");\n        assert_eq!(s2, \"\");\n\n        gb.move_gap_to(12);\n        gb.shred_gap();\n        println!(\"after move:  {:?}\", raw_debug_buffer_content(&gb));\n\n        let slice = gb.slice(6, 17);\n        let (s1, s2) = slice.as_strs();\n        assert_eq!(s1, \" world\");\n        assert_eq!(s2, \"!\\nhow\");\n    }\n\n    #[test]\n    fn null_slice_is_empty() {\n        let mut gb = GapBuffer::from(\"hello, world!\\nhow are you?\");\n\n        for i in 0..gb.len_chars() {\n            let idx = gb.char_to_byte(i);\n            gb.move_gap_to(idx);\n            gb.shred_gap();\n\n            let slice = gb.slice(0, 0);\n\n            assert!(slice.left.is_empty(), \"{i} slice left: {:?}\", slice.left);\n            assert!(slice.right.is_empty(), \"{i} slice right: {:?}\", slice.right);\n        }\n    }\n\n    #[test]\n    fn slice_eq_str_works() {\n        let mut gb = GapBuffer::from(\"hello, world!\\nhow are you?\");\n        gb.move_gap_to(3);\n        gb.shred_gap();\n        let slice = gb.slice(0, 5);\n        assert_eq!(slice, \"hello\");\n    }\n\n    #[test]\n    fn chars_in_raw_range_works() {\n        let mut gb = GapBuffer::from(\"hello, world!\\nhow are you?\");\n        let char_from = 7;\n        let char_to = 12;\n\n        for i in 0..gb.len_chars() {\n            let idx = gb.char_to_byte(i);\n            gb.move_gap_to(idx);\n            gb.shred_gap();\n\n            let byte_from = gb.char_to_raw_byte(char_from);\n            let byte_to = gb.char_to_raw_byte(char_to);\n            let n_chars = gb.chars_in_raw_range(byte_from, byte_to);\n            assert_eq!(n_chars, char_to - char_from, \"gap at {i}\");\n\n            let n_chars = gb.chars_in_raw_range(0, gb.char_to_raw_byte(gb.n_chars));\n            assert_eq!(n_chars, gb.n_chars, \"gap at {i}\");\n        }\n    }\n\n    #[test_case(0, \"\\n\", 2; \"insert newline at start\")]\n    #[test_case(6, \"\\n\", 2; \"insert newline at end of first line\")]\n    #[test_case(3, \"\\n\", 2; \"insert newline in middle of line\")]\n    #[test_case(0, \"new\\n\", 2; \"insert line at start\")]\n    #[test_case(6, \"\\nnew\", 2; \"insert line at end\")]\n    #[test_case(3, \"X\\nY\\n\", 3; \"insert multiple newlines in middle\")]\n    #[test_case(0, \"a\\nb\\nc\\n\", 4; \"insert multiple lines at start\")]\n    #[test_case(6, \"\\na\\nb\\nc\", 4; \"insert multiple lines at end\")]\n    #[test]\n    fn insert_str_tracks_line_endings_correctly(at: usize, insert: &str, expected_lines: usize) {\n        let s = \"line 1\";\n        let mut gb = GapBuffer::from(s);\n        assert_eq!(gb.len_lines(), 1);\n\n        gb.insert_str(at, insert);\n        gb.shred_gap();\n\n        assert_eq!(gb.len_lines(), expected_lines);\n    }\n\n    #[test_case(0, 7, \"line 2\\nline 3\", 2; \"remove first line from start\")]\n    #[test_case(0, 14, \"line 3\", 1; \"remove first two lines from start\")]\n    #[test_case(7, 14, \"line 1\\nline 3\", 2; \"remove middle line\")]\n    #[test_case(14, 20, \"line 1\\nline 2\\n\", 3; \"remove last line\")]\n    #[test_case(6, 14, \"line 1line 3\", 1; \"remove spanning first newline\")]\n    #[test]\n    fn remove_range_tracks_line_endings_correctly(\n        from: usize,\n        to: usize,\n        expected: &str,\n        expected_lines: usize,\n    ) {\n        let s = \"line 1\\nline 2\\nline 3\";\n        let mut gb = GapBuffer::from(s);\n        assert_eq!(gb.len_lines(), 3);\n\n        gb.remove_range(from, to);\n        gb.shred_gap();\n\n        assert_eq!(gb.to_string(), expected);\n        assert_eq!(gb.len_lines(), expected_lines);\n    }\n\n    fn _insert_chars(gb: &mut GapBuffer, s: &str) {\n        for (idx, ch) in s.chars().enumerate() {\n            gb.insert_char(idx + 4, ch);\n            gb.shred_gap();\n        }\n    }\n\n    fn _insert_str(gb: &mut GapBuffer, s: &str) {\n        gb.insert_str(4, s);\n        gb.shred_gap();\n    }\n\n    #[test_case(_insert_chars; \"individual chars\")]\n    #[test_case(_insert_str; \"whole string\")]\n    #[test]\n    fn insert_with_multibyte_chars_preserves_line_endings(insert: fn(&mut GapBuffer, &str)) {\n        let slice_str = |gb: &GapBuffer| gb.slice(0, gb.len_chars()).to_string();\n\n        let mut gb = GapBuffer::from(\"foo\\nbar\\nbaz\\n\");\n        let s = \"\u4e16\\n\u754c \ud83e\udd8a\\n \";\n\n        insert(&mut gb, s);\n\n        assert_eq!(slice_str(&gb), \"foo\\n\u4e16\\n\u754c \ud83e\udd8a\\n bar\\nbaz\\n\");\n\n        assert_eq!(gb.char(8), '\ud83e\udd8a');\n        gb.remove_char(8);\n        gb.shred_gap();\n\n        assert_eq!(slice_str(&gb), \"foo\\n\u4e16\\n\u754c \\n bar\\nbaz\\n\");\n    }\n\n    #[test]\n    fn char_works_with_multibyte_characters() {\n        let s = \"\u4e16\\n\u754c \ud83e\udd8a\\n \";\n        let gb = GapBuffer::from(s);\n\n        for (idx, ch) in s.chars().enumerate() {\n            assert_eq!(gb.char(idx), ch);\n        }\n    }\n\n    #[test]\n    fn char_to_raw_byte_line_end_with_no_newlines() {\n        let mut gb =\n            GapBuffer::from(\"// does it need to be a doc comment? that is a long enough line to\");\n        gb.move_gap_to(0);\n        gb.shred_gap();\n        assert_eq!(gb.char_to_raw_byte(65), 129);\n        gb.move_gap_to(10);\n        gb.shred_gap();\n        assert_eq!(gb.char_to_raw_byte(65), 129);\n        gb.move_gap_to(66);\n        gb.shred_gap();\n        assert_eq!(gb.char_to_raw_byte(65), 65);\n        gb.insert_char(66, '\\n');\n        gb.shred_gap();\n        assert_eq!(\n            gb.to_string(),\n            \"// does it need to be a doc comment? that is a long enough line to\\n\"\n        );\n    }\n\n    #[test_case(0, \"\", \"foo bar\"; \"gap at start\")]\n    #[test_case(3, \"foo\", \" bar\"; \"gap in between\")]\n    #[test]\n    fn as_strs_works(byte_idx: usize, left: &str, right: &str) {\n        let mut gb = GapBuffer::from(\"foo bar\");\n        gb.move_gap_to(byte_idx);\n        gb.shred_gap();\n\n        let (l, r) = gb.as_strs();\n\n        assert_eq!((l, r), (left, right));\n    }\n\n    #[test_case(0; \"gap at start\")]\n    #[test_case(3; \"gap in between\")]\n    #[test]\n    fn as_str_works(byte_idx: usize) {\n        let mut gb = GapBuffer::from(\"foo bar\");\n        gb.move_gap_to(byte_idx);\n        gb.shred_gap();\n\n        let s = gb.as_str();\n\n        assert_eq!(s, \"foo bar\");\n        assert_eq!(gb.gap_start, 0);\n    }\n\n    #[test]\n    fn substr_from_works_when_gap_at_start() {\n        let mut gb = GapBuffer::from(\"hello world\");\n\n        gb.make_contiguous();\n\n        assert!(gb.is_contiguous());\n        assert_eq!(gb.gap_start, 0);\n        assert_ne!(gb.gap_end, gb.cap);\n\n        // SAFETY: buffer is contiguous and offset is valid\n        let result = unsafe { gb.substr_from(6) };\n        assert_eq!(result, \"world\");\n    }\n\n    #[test]\n    fn substr_from_works_when_gap_at_end() {\n        let mut gb = GapBuffer::from(\"hello world\");\n\n        gb.move_gap_to(gb.len());\n\n        assert!(gb.is_contiguous());\n        assert_eq!(gb.gap_end, gb.cap);\n        assert_ne!(gb.gap_start, 0);\n\n        // SAFETY: buffer is contiguous and offset is valid\n        let result = unsafe { gb.substr_from(6) };\n        assert_eq!(result, \"world\");\n    }\n\n    #[test]\n    fn substr_from_matches_expected_after_appending_to_end() {\n        let mut gb = GapBuffer::from(\"hello\");\n\n        gb.insert_char(5, ' ');\n        gb.insert_char(6, 'w');\n        gb.insert_char(7, 'o');\n        gb.insert_char(8, 'r');\n        gb.insert_char(9, 'l');\n        gb.insert_char(10, 'd');\n\n        assert!(gb.is_contiguous());\n        assert_eq!(gb.gap_end, gb.cap);\n        assert_ne!(gb.gap_start, 0);\n\n        // SAFETY: buffer is contiguous and offset is valid\n        let result = unsafe { gb.substr_from(6) };\n        assert_eq!(result, \"world\");\n    }\n}\n", "source": "ad/src/buffer/internal.rs", "file_type": "rc"}
{"text": "//! A [Buffer] represents a single file or in memory text buffer open within the editor.\nuse crate::{\n    Config, MAX_NAME_LEN, UNNAMED_BUFFER,\n    config::ftype_config_for_path_and_first_line,\n    config_handle,\n    dot::{Cur, Dot, Range, TextObject, find::find_forward_wrapping},\n    editor::Action,\n    exec::{Addr, Address},\n    fsys::InputFilter,\n    key::Input,\n    lsp::Coords,\n    syntax::{LineIter, SyntaxState},\n    util::normalize_line_endings,\n};\nuse ad_event::Source;\nuse std::{\n    cmp::min,\n    fs,\n    io::{self, ErrorKind},\n    path::{Path, PathBuf},\n    sync::{\n        Arc, RwLock,\n        atomic::{AtomicUsize, Ordering},\n    },\n    time::SystemTime,\n};\nuse tracing::{debug, error};\n\nmod buffers;\nmod edit;\nmod internal;\n\nuse edit::{Edit, EditLog, Kind, Txt};\n\npub use buffers::BufferId;\npub(crate) use buffers::Buffers;\npub use internal::{Chars, GapBuffer, IdxChars, Slice, SliceIter};\n\n// Welcome splash message for new users to help them get started (rather than just presenting them\n// with a blank buffer.\npub(crate) const WELCOME_SQUIRREL: &str = r#\"+---------------------------------------------------------------------------+\n| > Welcome to the ad text editor!                                          |\n| This is a temporary buffer where you can make notes and execute commands. |\n| You can press the '-' key to open a file from the current directory, or   |\n| type :help to view the in-editor help documentation.                      |\n|                                                                           |\n| To prevent this message being shown at startup, set the 'show_splash'     |\n| property to false in your config file.                                    |\n+---------------------------------------------------------------------------+\n              \\  ,,  __\n                (\"\\ ( (\n                -)>\\ )/\n                ('( )'\n                -'-'\"#;\npub(crate) const DEFAULT_OUTPUT_BUFFER: &str = \"+output\";\nconst HTTPS: &str = \"https://\";\nconst HTTP: &str = \"http://\";\n\n// Used to inform the editor that further action needs to be taken by it after a Buffer has\n// finished processing a given Action.\n#[derive(Debug, Clone, PartialEq, Eq)]\npub enum ActionOutcome {\n    SetClipboard(String),\n    SetStatusMessage(String),\n}\n\n/// Buffer kinds control how each buffer interacts with the rest of the editor functionality\n#[derive(Default, Debug, Clone, PartialEq, Eq)]\npub(crate) enum BufferKind {\n    /// A regular buffer that is backed by a file on disk.\n    File(PathBuf),\n    /// A directory buffer that is modifiable but cannot be saved\n    Directory(PathBuf),\n    /// An in-memory buffer that is not exposed through fsys\n    Virtual(String),\n    /// An in-memory buffer holding output from commands run within a given directory\n    Output(String),\n    /// A currently un-named buffer that can be converted to a File buffer when named\n    #[default]\n    Unnamed,\n    /// State for an active mini-buffer\n    MiniBuffer,\n}\n\nimpl BufferKind {\n    fn display_name(&self) -> String {\n        match self {\n            BufferKind::File(p) => p.display().to_string(),\n            BufferKind::Directory(p) => p.display().to_string(),\n            BufferKind::Virtual(s) => s.clone(),\n            BufferKind::Output(s) => s.clone(),\n            BufferKind::Unnamed => UNNAMED_BUFFER.to_string(),\n            BufferKind::MiniBuffer => \"\".to_string(),\n        }\n    }\n\n    /// The path for the file backing this buffer (if any).\n    fn path(&self) -> Option<&Path> {\n        match &self {\n            BufferKind::File(p) => Some(p.as_ref()),\n            _ => None,\n        }\n    }\n\n    /// The directory containing the file backing this buffer (if any).\n    fn dir(&self) -> Option<&Path> {\n        match &self {\n            BufferKind::File(p) => p.parent(),\n            BufferKind::Directory(p) => Some(p.as_ref()),\n            BufferKind::Output(s) => Path::new(s).parent(),\n            _ => None,\n        }\n    }\n\n    pub(crate) fn is_file(&self) -> bool {\n        matches!(self, Self::File(_))\n    }\n\n    pub(crate) fn is_dir(&self) -> bool {\n        matches!(self, Self::Directory(_))\n    }\n\n    /// The key for the +output buffer that output from command run from this buffer should be\n    /// redirected to\n    pub fn output_file_key(&self, cwd: &Path) -> String {\n        let path = self.dir().unwrap_or(cwd);\n        format!(\"{}/{DEFAULT_OUTPUT_BUFFER}\", path.display())\n    }\n\n    fn try_kind_and_content_from_path(path: PathBuf) -> io::Result<(Self, String)> {\n        match path.metadata() {\n            Ok(m) if m.is_dir() => {\n                let mut raw_entries = Vec::new();\n                for entry in path.read_dir()? {\n                    let p = entry?.path();\n                    let mut s = p.strip_prefix(&path).unwrap_or(&p).display().to_string();\n                    if p.metadata().map(|m| m.is_dir()).unwrap_or_default() {\n                        s.push('/');\n                    }\n                    raw_entries.push(s);\n                }\n                raw_entries.sort_unstable();\n\n                let mut raw = format!(\"{}\\n\\n..\\n\", path.display());\n                raw.push_str(&raw_entries.join(\"\\n\"));\n\n                Ok((Self::Directory(path), raw))\n            }\n\n            _ => {\n                let raw = match fs::read_to_string(&path) {\n                    Ok(contents) => normalize_line_endings(contents),\n                    Err(e) if e.kind() == ErrorKind::NotFound => String::new(),\n                    Err(e) => return Err(e),\n                };\n\n                Ok((Self::File(path), raw))\n            }\n        }\n    }\n}\n\n/// Internal state for a text buffer backed by a file on disk\n#[derive(Debug)]\npub struct Buffer {\n    pub(crate) id: usize,\n    pub(crate) kind: BufferKind,\n    pub(crate) dot: Dot,\n    pub(crate) xdot: Dot,\n    pub(crate) txt: GapBuffer,\n    pub(crate) cached_rx: usize,\n    pub(crate) last_save: SystemTime,\n    pub(crate) dirty: bool,\n    pub(crate) changed_since_last_render: bool,\n    pub(crate) input_filter: Option<InputFilter>,\n    pub(crate) syntax_state: Option<SyntaxState>,\n    config: Arc<RwLock<Config>>,\n    version: AtomicUsize,\n    edit_log: EditLog,\n}\n\nimpl Buffer {\n    /// As the name implies, this method MUST be called with the full canonical file path\n    pub fn new_from_canonical_file_path(\n        id: usize,\n        path: PathBuf,\n        config: Arc<RwLock<Config>>,\n    ) -> io::Result<Self> {\n        let (kind, raw) = BufferKind::try_kind_and_content_from_path(path.clone())?;\n        let mut b = Self {\n            id,\n            kind,\n            dot: Dot::default(),\n            xdot: Dot::default(),\n            txt: GapBuffer::from(raw),\n            cached_rx: 0,\n            last_save: SystemTime::now(),\n            dirty: false,\n            changed_since_last_render: false,\n            input_filter: None,\n            syntax_state: None,\n            config,\n            version: AtomicUsize::new(1),\n            edit_log: EditLog::default(),\n        };\n\n        b.try_set_ts_state();\n\n        Ok(b)\n    }\n\n    /// Create a new unnamed buffer with the given content\n    pub fn new_unnamed(id: usize, content: impl Into<String>, config: Arc<RwLock<Config>>) -> Self {\n        Self {\n            id,\n            kind: BufferKind::Unnamed,\n            dot: Dot::default(),\n            xdot: Dot::default(),\n            txt: GapBuffer::from(normalize_line_endings(content.into())),\n            cached_rx: 0,\n            last_save: SystemTime::now(),\n            dirty: false,\n            changed_since_last_render: false,\n            input_filter: None,\n            syntax_state: None,\n            config,\n            version: AtomicUsize::new(1),\n            edit_log: EditLog::default(),\n        }\n    }\n\n    /// Create a new virtual buffer with the given name and content.\n    ///\n    /// The buffer will not be included in the virtual filesystem and it will be removed when it\n    /// loses focus.\n    pub fn new_virtual(\n        id: usize,\n        name: impl Into<String>,\n        content: impl Into<String>,\n        config: Arc<RwLock<Config>>,\n    ) -> Self {\n        let mut content = normalize_line_endings(content.into());\n        if content.ends_with('\\n') {\n            content.pop();\n        }\n\n        Self {\n            id,\n            kind: BufferKind::Virtual(name.into()),\n            dot: Dot::default(),\n            xdot: Dot::default(),\n            txt: GapBuffer::from(content),\n            cached_rx: 0,\n            last_save: SystemTime::now(),\n            dirty: false,\n            changed_since_last_render: false,\n            input_filter: None,\n            syntax_state: None,\n            config,\n            version: AtomicUsize::new(1),\n            edit_log: EditLog::default(),\n        }\n    }\n\n    /// Construct a new +output buffer with the given name which must be a valid output buffer name\n    /// of the form '$dir/+output'.\n    pub(super) fn new_output(\n        id: usize,\n        name: String,\n        content: String,\n        config: Arc<RwLock<Config>>,\n    ) -> Self {\n        Self {\n            id,\n            kind: BufferKind::Output(name),\n            dot: Dot::default(),\n            xdot: Dot::default(),\n            txt: GapBuffer::from(normalize_line_endings(content)),\n            cached_rx: 0,\n            last_save: SystemTime::now(),\n            dirty: false,\n            changed_since_last_render: false,\n            input_filter: None,\n            syntax_state: None,\n            config,\n            version: AtomicUsize::new(1),\n            edit_log: EditLog::default(),\n        }\n    }\n\n    /// Clear any existing tree-sitter state and then attempt to detect and set the state\n    /// based on this buffer's BufferKind\n    fn try_set_ts_state(&mut self) {\n        self.syntax_state = None;\n        if let Some(lang) = self.configured_filetype() {\n            let cfg = config_handle!(self);\n            match SyntaxState::try_new(&lang, &self.txt, &cfg) {\n                Ok(state) => self.syntax_state = Some(state),\n                Err(msg) => error!(\"unable to initialise syntax state: {msg}\"),\n            }\n        }\n    }\n\n    pub(crate) fn next_edit_version(&self) -> usize {\n        self.version.fetch_add(1, Ordering::Relaxed)\n    }\n\n    pub(crate) fn state_changed_on_disk(&self) -> Result<bool, String> {\n        fn inner(p: &Path, last_save: SystemTime) -> io::Result<bool> {\n            let modified = p.metadata()?.modified()?;\n            Ok(modified > last_save)\n        }\n\n        let path = match &self.kind {\n            BufferKind::File(p) => p,\n            _ => return Ok(false),\n        };\n\n        match inner(path, self.last_save) {\n            Ok(modified) => Ok(modified),\n            Err(e) if e.kind() == ErrorKind::NotFound => Ok(false),\n            Err(e) => Err(format!(\"Error checking file state: {e}\")),\n        }\n    }\n\n    /// Set this buffer's filename (an therefore kind) to the provided path.\n    /// -> This will also re-set / clear any tree-sitter state that is currently held\n    pub(crate) fn set_filename<P: AsRef<Path>>(&mut self, path: P) -> Option<ActionOutcome> {\n        let path = match path.as_ref().canonicalize() {\n            Ok(p) => p,\n            Err(e) if e.kind() == ErrorKind::NotFound => path.as_ref().to_path_buf(),\n            Err(e) => {\n                return Some(ActionOutcome::SetStatusMessage(format!(\n                    \"invalid file path: {e}\"\n                )));\n            }\n        };\n\n        let kind = if path.is_dir() {\n            BufferKind::Directory(path)\n        } else {\n            BufferKind::File(path)\n        };\n\n        self.kind = kind;\n        self.try_set_ts_state();\n        self.changed_since_last_render = true;\n\n        None\n    }\n\n    pub(crate) fn save_to_disk_at(\n        &mut self,\n        path: impl AsRef<Path>,\n        force: bool,\n    ) -> Result<String, String> {\n        if !self.has_trailing_newline() {\n            self.insert_char(TextObject::BufferEnd.as_dot(self), '\\n', None);\n        }\n\n        if !self.dirty {\n            return Err(\"Nothing to save\".to_string());\n        }\n\n        if !force {\n            match self.state_changed_on_disk() {\n                Ok(false) => (),\n                Ok(true) => return Err(\"File modified on disk, use :w! to force\".to_string()),\n                Err(s) => return Err(s),\n            }\n        }\n\n        let path = path.as_ref();\n        let n_lines = self.len_lines();\n        let contents = self.txt.make_contiguous();\n        let display_path = match path.canonicalize() {\n            Ok(cp) => cp.display().to_string(),\n            Err(_) => path.display().to_string(),\n        };\n        let n_bytes = contents.len();\n\n        #[cfg(not(feature = \"fuzz\"))]\n        {\n            match fs::write(path, contents) {\n                Ok(_) => {\n                    self.dirty = false;\n                    self.last_save = SystemTime::now();\n                    Ok(format!(\"\\\"{display_path}\\\" {n_lines}L {n_bytes}B written\"))\n                }\n                Err(e) => Err(format!(\"Unable to save buffer: {e}\")),\n            }\n        }\n\n        #[cfg(feature = \"fuzz\")]\n        {\n            self.dirty = false;\n            self.last_save = SystemTime::now();\n            Ok(format!(\"\\\"{display_path}\\\" {n_lines}L {n_bytes}B written\"))\n        }\n    }\n\n    pub(super) fn reload_from_disk(&mut self) -> String {\n        let path = match &self.kind {\n            BufferKind::File(p) | BufferKind::Directory(p) => p,\n            _ => return \"Buffer is not backed by a file on disk\".to_string(),\n        };\n\n        debug!(id=%self.id, path=%path.as_os_str().to_string_lossy(), \"reloading buffer state from disk\");\n        let raw = match BufferKind::try_kind_and_content_from_path(path.to_path_buf()) {\n            Ok((_, raw)) => raw,\n            Err(e) => return format!(\"Error reloading buffer: {e}\"),\n        };\n\n        let n_chars = raw.len();\n        self.txt = GapBuffer::from(raw);\n        self.dot.clamp_idx(n_chars);\n        self.xdot.clamp_idx(n_chars);\n        self.edit_log.clear();\n        self.dirty = false;\n        self.changed_since_last_render = true;\n        self.last_save = SystemTime::now();\n\n        let n_lines = self.txt.len_lines();\n        let n_bytes = self.txt.len();\n        debug!(%n_bytes, \"reloaded buffer content\");\n\n        let display_path = match path.canonicalize() {\n            Ok(cp) => cp.display().to_string(),\n            Err(_) => path.display().to_string(),\n        };\n\n        format!(\"\\\"{display_path}\\\" {n_lines}L {n_bytes}B loaded\")\n    }\n\n    pub(super) fn new_minibuffer(config: Arc<RwLock<Config>>) -> Self {\n        Self {\n            id: usize::MAX,\n            kind: BufferKind::MiniBuffer,\n            dot: Default::default(),\n            xdot: Default::default(),\n            txt: GapBuffer::from(\"\"),\n            cached_rx: 0,\n            last_save: SystemTime::now(),\n            dirty: false,\n            changed_since_last_render: false,\n            input_filter: None,\n            syntax_state: None,\n            config,\n            version: AtomicUsize::new(1),\n            edit_log: Default::default(),\n        }\n    }\n\n    /// Short name for displaying in the status line\n    pub fn display_name(&self) -> String {\n        let s = self.kind.display_name();\n\n        s[0..min(MAX_NAME_LEN, s.len())].to_string()\n    }\n\n    /// Absolute path of full name of a virtual buffer\n    pub fn full_name(&self) -> &str {\n        match &self.kind {\n            BufferKind::File(p) => p.to_str().expect(\"valid unicode\"),\n            BufferKind::Directory(p) => p.to_str().expect(\"valid unicode\"),\n            BufferKind::Virtual(s) => s,\n            BufferKind::Output(s) => s,\n            BufferKind::Unnamed => UNNAMED_BUFFER,\n            BufferKind::MiniBuffer => \"*mini-buffer*\",\n        }\n    }\n\n    /// The directory containing the file backing this buffer (if any).\n    pub fn dir(&self) -> Option<&Path> {\n        self.kind.dir()\n    }\n\n    /// The path for the file backing this buffer (if any).\n    pub fn path(&self) -> Option<&Path> {\n        self.kind.path()\n    }\n\n    /// The key for the +output buffer that output from command run from this buffer should be\n    /// redirected to\n    pub fn output_file_key(&self, cwd: &Path) -> String {\n        self.kind.output_file_key(cwd)\n    }\n\n    /// Check whether or not this is an unnamed buffer\n    pub fn is_unnamed(&self) -> bool {\n        self.kind == BufferKind::Unnamed\n    }\n\n    /// Whether or not the contents of the buffer end with a final newline character.\n    ///\n    /// POSIX semantics define a line as \"A sequence of zero or more non-newline characters plus\n    /// a terminating newline character.\"\n    ///\n    /// See: <https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap03.html#tag_03_206>\n    pub fn has_trailing_newline(&self) -> bool {\n        self.txt.has_trailing_newline()\n    }\n\n    /// Check the current [Config] to see if this buffer matches a known filetype configuration.\n    pub fn configured_filetype(&self) -> Option<String> {\n        let lang_configs = &config_handle!(self).filetypes;\n        let first_line = self.line(0).map(|l| l.to_string()).unwrap_or_default();\n\n        self.path()\n            .and_then(|path| ftype_config_for_path_and_first_line(path, &first_line, lang_configs))\n            .map(|(lang, _)| lang.clone())\n    }\n\n    /// The utf-8 string contents of this buffer\n    pub fn str_contents(&self) -> String {\n        self.txt.to_string()\n    }\n\n    pub(crate) fn pretty_print_ts_tree(&self) -> Option<String> {\n        self.syntax_state\n            .as_ref()\n            .and_then(|st| st.pretty_print_tree())\n    }\n\n    pub(crate) fn string_lines(&self) -> Vec<String> {\n        self.txt\n            .iter_lines()\n            .map(|l| {\n                let mut s = l.to_string();\n                if s.ends_with('\\n') {\n                    s.pop();\n                }\n                s\n            })\n            .collect()\n    }\n\n    pub fn update_ts_state(&mut self, from: usize, n_rows: usize) {\n        if let Some(ts) = self.syntax_state.as_mut() {\n            ts.update(&self.txt, from, n_rows);\n        }\n    }\n\n    pub fn iter_tokenized_lines_from(\n        &self,\n        line: usize,\n        load_exec_range: Option<(bool, Range)>,\n    ) -> LineIter<'_> {\n        match self.syntax_state.as_ref() {\n            Some(ts) => {\n                ts.iter_tokenized_lines_from(line, &self.txt, self.dot.as_range(), load_exec_range)\n            }\n            None => LineIter::new(\n                line,\n                &self.txt,\n                self.dot.as_range(),\n                load_exec_range,\n                &[],\n                &[],\n            ),\n        }\n    }\n\n    /// The contents of the current [Dot].\n    pub fn dot_contents(&self) -> String {\n        self.dot.content(self)\n    }\n\n    /// The address of the current [Dot].\n    pub fn addr(&self) -> String {\n        self.dot.addr(self)\n    }\n\n    /// The contents of the current xdot.\n    ///\n    /// This is a virtual dot that is only made use of through the filesystem interface.\n    pub fn xdot_contents(&self) -> String {\n        self.xdot.content(self)\n    }\n\n    /// The address of the current xdot.\n    ///\n    /// This is a virtual dot that is only made use of through the filesystem interface.\n    pub fn xaddr(&self) -> String {\n        self.xdot.addr(self)\n    }\n\n    pub(crate) fn tabstop(&self) -> usize {\n        config_handle!(self).tabstop\n    }\n\n    /// The number of lines currently held in the buffer.\n    #[inline]\n    pub fn len_lines(&self) -> usize {\n        self.txt.len_lines()\n    }\n\n    /// The number of utf-8 characters currently held in the buffer.\n    #[inline]\n    pub fn len_chars(&self) -> usize {\n        self.txt.len_chars()\n    }\n\n    /// Whether or not the buffer is empty.\n    ///\n    /// # Note\n    /// This does not always imply that the underlying buffer is zero sized, only that the visible\n    /// contents are empty.\n    #[inline]\n    pub fn is_empty(&self) -> bool {\n        self.txt.len_chars() == 0\n    }\n\n    /// Fully clear the contents of this buffer, notifying fsys of the change\n    pub fn clear(&mut self) {\n        self.handle_action(Action::DotSet(TextObject::BufferStart, 1), Source::Fsys);\n        self.handle_action(\n            Action::DotExtendForward(TextObject::BufferEnd, 1),\n            Source::Fsys,\n        );\n        self.handle_action(Action::Delete, Source::Fsys);\n        self.xdot.clamp_idx(self.txt.len_chars());\n    }\n\n    pub(crate) fn debug_edit_log(&self) -> Vec<String> {\n        self.edit_log.debug_edits(self)\n    }\n\n    pub(crate) fn x_from_rx(&self, y: usize) -> usize {\n        self.x_from_provided_rx(y, self.cached_rx)\n    }\n\n    pub(crate) fn x_from_provided_rx(&self, y: usize, buf_rx: usize) -> usize {\n        let tabstop = config_handle!(self).tabstop;\n        if self.is_empty() {\n            return 0;\n        }\n\n        let mut rx = 0;\n        let mut cx = 0;\n\n        for c in self.txt.line(y).chars() {\n            if c == '\\n' {\n                break;\n            }\n\n            if c == '\\t' {\n                rx += (tabstop - 1) - (rx % tabstop);\n            }\n\n            // FIXME: this method probably needs to be part of the UI trait because of this line.\n            // This is needed because the TUI uses SGR (1006) mouse coordinates which end up\n            // reporting x coordinates in terms of cell widths, so utf8 wide characters need to be\n            // accounted for:\n            //   https://invisible-island.net/xterm/ctlseqs/ctlseqs.html#h3-Extended-coordinates\n            rx += unicode_width::UnicodeWidthChar::width(c).unwrap_or(1);\n\n            if rx > buf_rx {\n                break;\n            }\n            cx += 1;\n        }\n\n        cx\n    }\n\n    /// The line at the requested index returned as a Slice.\n    pub fn line(&self, y: usize) -> Option<Slice<'_>> {\n        if y >= self.len_lines() {\n            None\n        } else {\n            Some(self.txt.line(y))\n        }\n    }\n\n    /// Iterate between two character offsets.\n    ///\n    /// This is distinct from the iter_between method on an Regex haystack which is in terms of\n    /// bytes.\n    pub(crate) fn iter_between_chars(\n        &self,\n        char_from: usize,\n        char_to: usize,\n    ) -> impl Iterator<Item = (usize, char)> {\n        self.txt\n            .slice(char_from, char_to)\n            .indexed_chars(char_from, false)\n    }\n\n    /// Iterate between two character offsets in reverse.\n    ///\n    /// This is distinct from the rev_iter_between method on an Regex haystack which is in terms of\n    /// bytes.\n    pub(crate) fn rev_iter_between_chars(\n        &self,\n        char_from: usize,\n        char_to: usize,\n    ) -> impl Iterator<Item = (usize, char)> {\n        self.txt\n            .slice(char_to, char_from)\n            .indexed_chars(char_to, true)\n    }\n\n    /// Attempt to expand from the given cursor position so long as either the previous or next\n    /// character in the buffer is a known delimiter.\n    pub(crate) fn try_expand_delimited(&mut self) {\n        let current_index = match self.dot {\n            Dot::Cur { c: Cur { idx } } => idx,\n            Dot::Range { .. } => return,\n        };\n\n        let prev = if current_index == 0 {\n            None\n        } else {\n            self.txt.get_char(current_index - 1)\n        };\n        let next = self.txt.get_char(current_index + 1);\n\n        let (l, r) = match (prev, next) {\n            (Some('\\n'), _) | (_, Some('\\n')) => ('\\n', '\\n'),\n            (Some('('), _) | (_, Some(')')) => ('(', ')'),\n            (Some('['), _) | (_, Some(']')) => ('[', ']'),\n            (Some('{'), _) | (_, Some('}')) => ('{', '}'),\n            (Some('<'), _) | (_, Some('>')) => ('<', '>'),\n            (Some('\"'), _) | (_, Some('\"')) => ('\"', '\"'),\n            (Some('\\''), _) | (_, Some('\\'')) => ('\\'', '\\''),\n\n            _ => return self.expand_cur_dot(),\n        };\n\n        self.set_dot(TextObject::Delimited(l, r), 1);\n        self.changed_since_last_render = true;\n    }\n\n    /// If the current dot is a cursor rather than a range, expand it to a sensible range.\n    ///\n    /// This is modeled after (but not identical to) the behaviour in acme's `expand` function\n    /// found in look.c\n    pub(crate) fn expand_cur_dot(&mut self) {\n        let current_index = match self.dot {\n            Dot::Cur { c: Cur { idx } } => idx,\n            Dot::Range { .. } => return,\n        };\n        self.changed_since_last_render = true;\n\n        if let Some(dot) = self.try_expand_known(current_index) {\n            self.dot = dot;\n            return;\n        }\n\n        // Expand until we hit non-alphanumeric characters on each sides\n        let (mut from, mut to) = (current_index, current_index);\n        for (i, ch) in self.iter_between_chars(current_index, self.txt.len_chars()) {\n            if !(ch == '_' || ch == '-' || ch.is_alphanumeric()) {\n                break;\n            }\n            to = i;\n        }\n\n        for (i, ch) in self.rev_iter_between_chars(current_index, 0) {\n            if !(ch == '_' || ch == '-' || ch.is_alphanumeric()) {\n                break;\n            }\n            from = i;\n        }\n\n        self.dot = Dot::from_char_indices(from, to);\n    }\n\n    /// Try to be smart about expanding from the current cursor position to something that we\n    /// understand how to parse:\n    ///   - file path with addr (some/path:addr)\n    ///   - file path\n    ///   - url\n    fn try_expand_known(&self, current_index: usize) -> Option<Dot> {\n        let (mut from, mut to) = (current_index, current_index);\n        let mut colon: Option<usize> = None;\n        let n_chars = self.txt.len_chars();\n\n        let is_file_char = |ch: char| ch.is_alphanumeric() || \"._-+/:@\".contains(ch);\n        let is_addr_char = |ch: char| \"+-/$.#,;?\".contains(ch);\n        let is_url_char = |ch: char| \"?&=\".contains(ch);\n        let has_url_prefix = |i: usize| {\n            let http = i > 4 && i + 3 <= n_chars && self.txt.slice(i - 4, i + 3) == HTTP;\n            let https = i > 5 && i + 3 <= n_chars && self.txt.slice(i - 5, i + 3) == HTTPS;\n\n            http || https\n        };\n\n        // Start by expanding to cover things that are candidates for being file names (optionally\n        // with a following address) or URLs\n        for (i, ch) in self.iter_between_chars(current_index, self.txt.len_chars()) {\n            if !is_file_char(ch) {\n                break;\n            }\n            if ch == ':' && !has_url_prefix(i) {\n                colon = Some(i);\n                break;\n            }\n            to = i;\n        }\n\n        for (i, ch) in self.rev_iter_between_chars(current_index, 0) {\n            if !(is_file_char(ch) || is_url_char(ch) || is_addr_char(ch)) {\n                break;\n            }\n            if colon.is_none() && ch == ':' && !has_url_prefix(i) {\n                colon = Some(i);\n            }\n            from = i;\n        }\n\n        // Now grab the address if we had a trailing colon\n        if let Some(ix) = colon {\n            to = ix;\n            for (_, ch) in self.iter_between_chars(ix + 1, self.txt.len_chars()) {\n                if ch.is_whitespace() || \"()[]{}<>;\".contains(ch) {\n                    break;\n                }\n                to += 1;\n            }\n        }\n\n        let dot_content = self.txt.slice(from, to + 1).to_string();\n\n        // If dot looks like a URL then expand until whitespace and strip trailing punctuation\n        if dot_content.starts_with(HTTP) || dot_content.starts_with(HTTPS) {\n            if to < self.txt.len_chars() {\n                for (_, ch) in self.iter_between_chars(to + 1, self.txt.len_chars()) {\n                    if ch.is_whitespace() || \"()[]{}<>;\".contains(ch) {\n                        break;\n                    }\n                    to += 1;\n                }\n            }\n\n            if dot_content.ends_with('.') {\n                to -= 1;\n            }\n\n            return Some(Dot::from_char_indices(from, to));\n        }\n\n        let dot = Dot::from_char_indices(from, to);\n\n        // If dot up until ':' is a file then return the entire dot\n        let fname = match dot_content.split_once(':') {\n            Some((fname, _)) => fname,\n            None => &dot_content,\n        };\n\n        let path = Path::new(fname);\n        if path.is_absolute() && path.exists() {\n            return Some(dot);\n        } else if let Some(dir) = self.dir()\n            && dir.join(path).exists()\n        {\n            return Some(dot);\n        }\n\n        // Not a file or a URL\n        None\n    }\n\n    pub(crate) fn sign_col_dims(&self) -> (usize, usize) {\n        let w_lnum = n_digits(self.len_lines());\n        let w_sgncol = w_lnum + 2;\n\n        (w_lnum, w_sgncol)\n    }\n\n    pub(crate) fn append(&mut self, s: String, source: Source) {\n        let dot = self.dot;\n        self.set_dot(TextObject::BufferEnd, 1);\n        self.handle_action(Action::InsertString { s }, source);\n        self.dot = dot;\n        self.dot.clamp_idx(self.txt.len_chars());\n        self.xdot.clamp_idx(self.txt.len_chars());\n        self.changed_since_last_render = true;\n    }\n\n    /// The error result of this function is an error string that should be displayed to the user\n    pub fn handle_action(&mut self, a: Action, source: Source) -> Option<ActionOutcome> {\n        match a {\n            Action::Delete => {\n                let (c, deleted) = self.delete_dot(self.dot, Some(source));\n                self.dot = Dot::Cur { c };\n                self.dot.clamp_idx(self.txt.len_chars());\n                self.xdot.clamp_idx(self.txt.len_chars());\n                return deleted.map(ActionOutcome::SetClipboard);\n            }\n            Action::InsertChar { c } => {\n                let (c, _) = self.insert_char(self.dot, c, Some(source));\n                self.dot = Dot::Cur { c };\n                self.dot.clamp_idx(self.txt.len_chars());\n                self.xdot.clamp_idx(self.txt.len_chars());\n                return None;\n            }\n            Action::InsertString { s } => {\n                let (c, _) = self.insert_string(self.dot, s, Some(source));\n                self.dot = Dot::Cur { c };\n                self.dot.clamp_idx(self.txt.len_chars());\n                self.xdot.clamp_idx(self.txt.len_chars());\n                return None;\n            }\n\n            Action::Redo => return self.redo(),\n            Action::Undo => return self.undo(),\n\n            Action::DotCollapseFirst => self.collapse_dot(true),\n            Action::DotCollapseLast => self.collapse_dot(false),\n            Action::DotExtendBackward(tobj, count) => self.extend_dot_backward(tobj, count),\n            Action::DotExtendForward(tobj, count) => self.extend_dot_forward(tobj, count),\n            Action::DotFlip => self.flip_dot(),\n            Action::DotSet(t, count) => self.set_dot(t, count),\n            Action::DotSetFromCoords { coords } => self.set_dot_from_coords(coords),\n\n            Action::XDotSetFromCoords { coords } => self.set_xdot_from_coords(coords),\n            Action::XInsertString { s } => self.insert_xdot(s),\n\n            Action::RenameActiveBuffer { name } => return self.set_filename(name),\n            Action::RawInput { i } => return self.handle_raw_input(i),\n\n            _ => (),\n        }\n\n        None\n    }\n\n    fn handle_raw_input(&mut self, k: Input) -> Option<ActionOutcome> {\n        let (match_indent, expand_tab, tabstop) = {\n            let cfg = config_handle!(self);\n            (cfg.match_indent, cfg.expand_tab, cfg.tabstop)\n        };\n\n        match k {\n            Input::Return => {\n                let mut s = \"\\n\".to_string();\n                if match_indent {\n                    let cur = self.dot.first_cur();\n                    let y = self.txt.char_to_line(cur.idx);\n                    let line = self.txt.line(y).to_string();\n                    s.push_str(\n                        &line\n                            .find(|c: char| !c.is_whitespace())\n                            .map(|ix| line.split_at(ix).0.to_string())\n                            .unwrap_or_default(),\n                    );\n                }\n\n                let c = self.insert_string(self.dot, s, Some(Source::Keyboard)).0;\n\n                self.dot = Dot::Cur { c };\n                return None;\n            }\n\n            Input::Tab => {\n                let (c, _) = if expand_tab {\n                    self.insert_string(self.dot, \" \".repeat(tabstop), Some(Source::Keyboard))\n                } else {\n                    self.insert_char(self.dot, '\\t', Some(Source::Keyboard))\n                };\n\n                self.dot = Dot::Cur { c };\n                return None;\n            }\n\n            Input::Char(ch) => {\n                let (c, _) = self.insert_char(self.dot, ch, Some(Source::Keyboard));\n                self.dot = Dot::Cur { c };\n                return None;\n            }\n\n            Input::Arrow(arr) => self.set_dot(TextObject::Arr(arr), 1),\n\n            _ => return None,\n        }\n\n        self.changed_since_last_render = true;\n        None\n    }\n\n    /// Set dot and clamp to ensure it is within bounds\n    pub(crate) fn set_dot(&mut self, t: TextObject, n: usize) {\n        for _ in 0..n {\n            t.set_dot(self);\n        }\n        self.dot.clamp_idx(self.txt.len_chars());\n        self.xdot.clamp_idx(self.txt.len_chars());\n        self.changed_since_last_render = true;\n    }\n\n    /// Set this Buffer's dot to an explicit cursor position, clamping to EOB.\n    pub fn set_dot_from_cursor(&mut self, idx: usize) {\n        self.dot = Cur::new(idx).into();\n        self.dot.clamp_idx(self.txt.len_chars());\n        self.changed_since_last_render = true;\n    }\n\n    /// Set this Buffer's dot to an explicit [Range], clamping to EOB.\n    pub fn set_dot_from_range(&mut self, from: usize, to: usize) {\n        self.dot = Dot::from(Range::from_cursors(Cur::new(from), Cur::new(to), false))\n            .collapse_null_range();\n        self.dot.clamp_idx(self.txt.len_chars());\n        self.changed_since_last_render = true;\n    }\n\n    fn set_dot_from_coords(&mut self, coords: Coords) {\n        let addr: Addr = coords.as_addr(self);\n        self.dot = self.map_addr(&addr);\n        self.dot.clamp_idx(self.txt.len_chars());\n        self.xdot.clamp_idx(self.txt.len_chars());\n        self.changed_since_last_render = true;\n    }\n\n    fn set_xdot_from_coords(&mut self, coords: Coords) {\n        let addr: Addr = coords.as_addr(self);\n        self.xdot = self.map_addr(&addr);\n        self.xdot.clamp_idx(self.txt.len_chars());\n    }\n\n    /// Extend dot forward and clamp to ensure it is within bounds\n    fn extend_dot_forward(&mut self, t: TextObject, n: usize) {\n        for _ in 0..n {\n            t.extend_dot_forward(self);\n        }\n        self.dot.clamp_idx(self.txt.len_chars());\n        self.xdot.clamp_idx(self.txt.len_chars());\n        self.changed_since_last_render = true;\n    }\n\n    /// Extend dot backward and clamp to ensure it is within bounds\n    fn extend_dot_backward(&mut self, t: TextObject, n: usize) {\n        for _ in 0..n {\n            t.extend_dot_backward(self);\n        }\n        self.dot.clamp_idx(self.txt.len_chars());\n        self.xdot.clamp_idx(self.txt.len_chars());\n        self.changed_since_last_render = true;\n    }\n\n    fn collapse_dot(&mut self, first: bool) {\n        self.dot = if first {\n            self.dot.collapse_to_first_cur()\n        } else {\n            self.dot.collapse_to_last_cur()\n        };\n\n        self.changed_since_last_render = true;\n    }\n\n    fn flip_dot(&mut self) {\n        self.dot.flip();\n        self.changed_since_last_render = true;\n    }\n\n    pub(crate) fn new_edit_log_transaction(&mut self) {\n        self.edit_log.new_transaction()\n    }\n\n    fn undo(&mut self) -> Option<ActionOutcome> {\n        match self.edit_log.undo() {\n            Some(edits) => {\n                self.edit_log.paused = true;\n                for edit in edits.into_iter() {\n                    self.apply_edit(edit);\n                }\n                self.edit_log.paused = false;\n                self.dirty = !self.edit_log.is_empty();\n                self.changed_since_last_render = true;\n                None\n            }\n            None => Some(ActionOutcome::SetStatusMessage(\n                \"Nothing to undo\".to_string(),\n            )),\n        }\n    }\n\n    fn redo(&mut self) -> Option<ActionOutcome> {\n        match self.edit_log.redo() {\n            Some(edits) => {\n                self.edit_log.paused = true;\n                for edit in edits.into_iter() {\n                    self.apply_edit(edit);\n                }\n                self.edit_log.paused = false;\n                self.dirty = true;\n                self.changed_since_last_render = true;\n                None\n            }\n            None => Some(ActionOutcome::SetStatusMessage(\n                \"Nothing to redo\".to_string(),\n            )),\n        }\n    }\n\n    fn apply_edit(&mut self, Edit { kind, cur, txt }: Edit) {\n        let new_cur = match (kind, txt) {\n            (Kind::Insert, Txt::Char(c)) => self.insert_char(Dot::Cur { c: cur }, c, None).0,\n            (Kind::Insert, Txt::String(s)) => self.insert_string(Dot::Cur { c: cur }, s, None).0,\n            (Kind::Delete, Txt::Char(_)) => self.delete_dot(Dot::Cur { c: cur }, None).0,\n            (Kind::Delete, Txt::String(s)) => {\n                let start_idx = cur.idx;\n                let end_idx = (start_idx + s.chars().count()).saturating_sub(1);\n                let end = Cur { idx: end_idx };\n                self.delete_dot(\n                    Dot::Range {\n                        r: Range::from_cursors(cur, end, true),\n                    }\n                    .collapse_null_range(),\n                    None,\n                )\n                .0\n            }\n        };\n\n        self.dot = Dot::Cur { c: new_cur };\n    }\n\n    /// Only files get marked as dirty to ensure that they are prompted for saving before being\n    /// closed.\n    fn mark_dirty(&mut self) {\n        self.dirty = self.kind.is_file();\n    }\n\n    /// Returns true if a filter was present and the notification was sent\n    pub(crate) fn notify_load(&self, source: Source) -> bool {\n        match self.input_filter.as_ref() {\n            Some(f) => {\n                let (ch_from, ch_to) = self.dot.as_char_indices();\n                let txt = self.dot.content(self);\n                f.notify_load(source, ch_from, ch_to, &txt);\n                true\n            }\n            None => false,\n        }\n    }\n\n    /// Returns true if a filter was present and the notification was sent\n    pub(crate) fn notify_execute(&self, source: Source, arg: Option<(Range, String)>) -> bool {\n        match self.input_filter.as_ref() {\n            Some(f) => {\n                let (ch_from, ch_to) = self.dot.as_char_indices();\n                let txt = self.dot.content(self);\n                f.notify_execute(source, ch_from, ch_to, &txt, arg);\n                true\n            }\n            None => false,\n        }\n    }\n\n    fn insert_char(&mut self, dot: Dot, ch: char, source: Option<Source>) -> (Cur, Option<String>) {\n        let ch = if ch == '\\r' { '\\n' } else { ch };\n        let mut have_prepared_edit = false;\n        if let Dot::Range { r } = &dot\n            && r.start.idx != r.end.idx\n            && let Some(s) = self.syntax_state.as_mut()\n        {\n            s.prepare_delete_range(r.start.idx, r.end.idx + 1, &self.txt);\n            have_prepared_edit = true;\n        }\n\n        let (cur, deleted) = match dot {\n            Dot::Cur { c } => (c, None),\n            Dot::Range { r } => self.delete_range(r, source),\n        };\n\n        if have_prepared_edit && let Some(ts) = self.syntax_state.as_mut() {\n            ts.apply_prepared_edit(&self.txt);\n        }\n\n        let idx = cur.idx;\n        if let Some(s) = self.syntax_state.as_mut() {\n            s.prepare_insert_char(idx, ch, &self.txt);\n        }\n\n        self.txt.insert_char(idx, ch);\n\n        if let (Some(source), Some(f)) = (source, self.input_filter.as_ref()) {\n            f.notify_insert(source, idx, idx + 1, &ch.to_string());\n        }\n\n        self.edit_log.insert_char(cur, ch);\n        if let Some(ts) = self.syntax_state.as_mut() {\n            ts.apply_prepared_edit(&self.txt);\n        }\n\n        self.mark_dirty();\n        self.changed_since_last_render = true;\n\n        (Cur { idx: idx + 1 }, deleted)\n    }\n\n    fn insert_string(\n        &mut self,\n        dot: Dot,\n        s: String,\n        source: Option<Source>,\n    ) -> (Cur, Option<String>) {\n        let s = normalize_line_endings(s);\n        let len = s.chars().count();\n        let mut have_prepared_edit = false;\n\n        if let Dot::Range { r } = &dot\n            && r.start.idx != r.end.idx\n            && let Some(ts) = self.syntax_state.as_mut()\n        {\n            ts.prepare_delete_range(r.start.idx, r.end.idx + 1, &self.txt);\n            have_prepared_edit = true;\n        }\n\n        let (mut cur, deleted) = match dot {\n            Dot::Cur { c } => (c, None),\n            Dot::Range { r } => self.delete_range(r, source),\n        };\n\n        if have_prepared_edit && let Some(ts) = self.syntax_state.as_mut() {\n            ts.apply_prepared_edit(&self.txt);\n        }\n\n        let idx = cur.idx;\n        have_prepared_edit = false;\n        if !s.is_empty()\n            && let Some(ts) = self.syntax_state.as_mut()\n        {\n            ts.prepare_insert_string(idx, &s, &self.txt);\n            have_prepared_edit = true;\n        }\n\n        // Inserting an empty string should not be recorded as an edit (and is\n        // a no-op for the content of self.txt) but we support it as inserting\n        // an empty string while dot is a range has the same effect as a delete.\n        if !s.is_empty() {\n            self.txt.insert_str(idx, &s);\n\n            if let (Some(source), Some(f)) = (source, self.input_filter.as_ref()) {\n                f.notify_insert(source, idx, idx + len, &s);\n            }\n\n            self.edit_log.insert_string(cur, s);\n            cur.idx += len;\n        }\n\n        if have_prepared_edit && let Some(ts) = self.syntax_state.as_mut() {\n            ts.apply_prepared_edit(&self.txt);\n        }\n\n        self.mark_dirty();\n        self.changed_since_last_render = true;\n\n        (cur, deleted)\n    }\n\n    fn delete_dot(&mut self, dot: Dot, source: Option<Source>) -> (Cur, Option<String>) {\n        let mut have_prepared_edit = false;\n\n        if let Some(ts) = self.syntax_state.as_mut() {\n            match &dot {\n                Dot::Cur { c } if c.idx < self.txt.len_chars() => {\n                    ts.prepare_delete_char(c.idx, &self.txt);\n                    have_prepared_edit = true;\n                }\n                Dot::Range { r } if r.start.idx != r.end.idx => {\n                    ts.prepare_delete_range(r.start.idx, r.end.idx + 1, &self.txt);\n                    have_prepared_edit = true;\n                }\n                _ => (),\n            }\n        }\n\n        let (cur, deleted) = match dot {\n            Dot::Cur { c } => (self.delete_cur(c, source), None),\n            Dot::Range { r } => self.delete_range(r, source),\n        };\n\n        if have_prepared_edit && let Some(ts) = self.syntax_state.as_mut() {\n            ts.apply_prepared_edit(&self.txt);\n        }\n\n        (cur, deleted)\n    }\n\n    fn delete_cur(&mut self, cur: Cur, source: Option<Source>) -> Cur {\n        let idx = cur.idx;\n        if idx < self.txt.len_chars() {\n            let ch = self.txt.char(idx);\n            self.txt.remove_char(idx);\n\n            if let (Some(source), Some(f)) = (source, self.input_filter.as_ref()) {\n                f.notify_delete(source, idx, idx + 1);\n            }\n\n            self.edit_log.delete_char(cur, ch);\n            self.mark_dirty();\n            self.changed_since_last_render = true;\n        }\n\n        cur\n    }\n\n    fn delete_range(&mut self, r: Range, source: Option<Source>) -> (Cur, Option<String>) {\n        let (from, to) = (r.start.idx, min(r.end.idx + 1, self.txt.len_chars()));\n        let is_single_char = r.start.idx == r.end.idx;\n\n        let s = self.txt.slice(from, to).to_string();\n        self.txt.remove_range(from, to);\n\n        if let (Some(source), Some(f)) = (source, self.input_filter.as_ref()) {\n            f.notify_delete(source, from, to);\n        }\n\n        self.edit_log.delete_string(r.start, s.clone());\n        self.mark_dirty();\n        self.changed_since_last_render = true;\n\n        let deleted = if is_single_char { None } else { Some(s) };\n\n        (r.start, deleted)\n    }\n\n    pub(crate) fn find_forward(&mut self, s: &str) {\n        if let Some(dot) = find_forward_wrapping(&s, self) {\n            self.dot = dot;\n            self.changed_since_last_render = true;\n        }\n    }\n\n    /// Insert a string into the buffer using the current xdot rather than dot,\n    /// preserving the current dot where possible.\n    ///\n    /// If xdot and dot intersect then the user's current selection is being\n    /// modified. Rather than preserve _part_ of the original selection we\n    /// instead collapse to the furthest point in the buffer that was part of\n    /// the original selection. Or, in the case that xdot fully contains dot,\n    /// we place the cursor at the end of the newly inserted text.\n    ///\n    /// DOT    |---X-| ;   |---|   ; |------X| ; |-X---|\n    /// XDOT |----|    ; |-------X ;   |---|   ;   |----|\n    ///\n    /// We determine the final cursor we collapse to based on the start of xdot\n    /// and the offset coming from the text being inserted.\n    pub(crate) fn insert_xdot(&mut self, s: String) {\n        let mut offset = s.chars().count() as isize;\n\n        if self.dot.as_range().intersects_range(&self.xdot.as_range()) {\n            if self.xdot.first_cur() > self.dot.first_cur()\n                && self.xdot.last_cur() >= self.dot.last_cur()\n            {\n                // The final case shown above: we need to back up a character in\n                // order to land on the last character of the existing dot rather\n                // than the first character of the inserted text.\n                offset = -1;\n            }\n\n            self.dot = self.xdot.collapse_to_first_cur();\n        } else if self.xdot.first_cur() > self.dot.last_cur() {\n            // Nothing to update for dot.\n            // DOT   |---|\n            // XDOT         |----|\n            offset = 0;\n        } else {\n            // In this case, the change in buffer length needs to account for\n            // the text being removed as well as what is being inserted.\n            // DOT          |---|\n            // XDOT  |----|\n            offset -= self.xdot.n_chars() as isize;\n            if self.xdot.is_cur() {\n                // Cursors insert directly into the buffer without removing the character\n                // they are on.\n                offset += 1;\n            }\n        };\n\n        let dot_after_edit = self.dot.with_offset_saturating(offset);\n        self.dot = self.xdot;\n        self.handle_action(Action::InsertString { s }, Source::Fsys);\n        (self.xdot, self.dot) = (self.dot, dot_after_edit);\n        self.dot.clamp_idx(self.txt.len_chars()); // xdot clamped as part of handling the insert\n    }\n}\n\nfn n_digits(mut n: usize) -> usize {\n    if n == 0 {\n        return 1;\n    }\n\n    let mut digits = 0;\n    while n != 0 {\n        digits += 1;\n        n /= 10;\n    }\n\n    digits\n}\n\n#[cfg(test)]\npub(crate) mod tests {\n    use super::*;\n    use crate::{key::Arrow, syntax::ts::TsState};\n    use edit::tests::{del_c, del_s, in_c, in_s};\n    use simple_test_case::test_case;\n    use std::env;\n\n    const LINE_1: &str = \"This is a test\";\n    const LINE_2: &str = \"involving multiple lines\";\n\n    fn c(idx: usize) -> Cur {\n        Cur { idx }\n    }\n\n    fn r(from: usize, to: usize, from_active: bool) -> Range {\n        Range::from_cursors(c(from), c(to), from_active)\n    }\n\n    pub fn buffer_from_lines(lines: &[&str]) -> Buffer {\n        let mut b = Buffer::new_unnamed(0, \"\", Default::default());\n        let s = lines.join(\"\\n\");\n\n        for c in s.chars() {\n            b.handle_action(Action::InsertChar { c }, Source::Keyboard);\n        }\n\n        b\n    }\n\n    fn simple_initial_buffer() -> Buffer {\n        buffer_from_lines(&[LINE_1, LINE_2])\n    }\n\n    #[test_case(0, 1; \"n0\")]\n    #[test_case(5, 1; \"n5\")]\n    #[test_case(10, 2; \"n10\")]\n    #[test_case(13, 2; \"n13\")]\n    #[test_case(731, 3; \"n731\")]\n    #[test_case(930, 3; \"n930\")]\n    #[test]\n    fn n_digits_works(n: usize, digits: usize) {\n        assert_eq!(n_digits(n), digits);\n    }\n\n    #[test]\n    fn simple_insert_works() {\n        let b = simple_initial_buffer();\n        let c = Cur::from_yx(1, LINE_2.len(), &b);\n        let lines = b.string_lines();\n\n        assert_eq!(lines.len(), 2);\n        assert_eq!(lines[0], LINE_1);\n        assert_eq!(lines[1], LINE_2);\n        assert_eq!(b.dot, Dot::Cur { c });\n        assert_eq!(\n            b.edit_log.edits,\n            vec![vec![in_s(0, &format!(\"{LINE_1}\\n{LINE_2}\"))]]\n        );\n    }\n\n    #[test]\n    fn insert_with_moving_dot_works() {\n        let mut b = Buffer::new_unnamed(0, \"\", Default::default());\n\n        // Insert from the start of the buffer\n        for c in \"hello w\".chars() {\n            b.handle_action(Action::InsertChar { c }, Source::Keyboard);\n        }\n\n        // move back to insert a character inside of the text we already have\n        b.handle_action(\n            Action::DotSet(TextObject::Arr(Arrow::Left), 2),\n            Source::Keyboard,\n        );\n        b.handle_action(Action::InsertChar { c: ',' }, Source::Keyboard);\n\n        // move forward to the end of the line to finish inserting\n        b.handle_action(Action::DotSet(TextObject::LineEnd, 1), Source::Keyboard);\n        for c in \"orld!\".chars() {\n            b.handle_action(Action::InsertChar { c }, Source::Keyboard);\n        }\n\n        // inserted characters should be in the correct positions\n        assert_eq!(b.txt.to_string(), \"hello, world!\");\n    }\n\n    #[test_case(\n        Action::InsertChar { c: 'x' },\n        in_c(LINE_1.len() + 1, 'x');\n        \"char\"\n    )]\n    #[test_case(\n        Action::InsertString { s: \"x\".to_string() },\n        in_s(LINE_1.len() + 1, \"x\");\n        \"string\"\n    )]\n    #[test]\n    fn insert_w_range_dot_works(a: Action, edit: Edit) {\n        let mut b = simple_initial_buffer();\n        b.handle_action(Action::DotSet(TextObject::Line, 1), Source::Keyboard);\n\n        let outcome = b.handle_action(a, Source::Keyboard);\n        assert_eq!(outcome, None);\n\n        let lines = b.string_lines();\n        assert_eq!(lines.len(), 2);\n\n        let c = Cur::from_yx(1, 1, &b);\n        assert_eq!(b.dot, Dot::Cur { c });\n\n        assert_eq!(lines[0], LINE_1);\n        assert_eq!(lines[1], \"x\");\n        assert_eq!(\n            b.edit_log.edits,\n            vec![vec![\n                in_s(0, &format!(\"{LINE_1}\\n{LINE_2}\")),\n                del_s(LINE_1.len() + 1, LINE_2),\n                edit,\n            ]]\n        );\n    }\n\n    #[test]\n    fn move_forward_at_end_of_buffer_is_fine() {\n        let mut b = Buffer::new_unnamed(0, \"\", Default::default());\n        b.handle_raw_input(Input::Arrow(Arrow::Right));\n\n        let c = Cur { idx: 0 };\n        assert_eq!(b.dot, Dot::Cur { c });\n    }\n\n    #[test]\n    fn delete_in_empty_buffer_is_fine() {\n        let mut b = Buffer::new_unnamed(0, \"\", Default::default());\n        b.handle_action(Action::Delete, Source::Keyboard);\n        let c = Cur { idx: 0 };\n        let lines = b.string_lines();\n\n        assert_eq!(b.dot, Dot::Cur { c });\n        assert_eq!(lines.len(), 1);\n        assert_eq!(lines[0], \"\");\n        assert!(b.edit_log.edits.is_empty());\n    }\n\n    #[test]\n    fn simple_delete_works() {\n        let mut b = simple_initial_buffer();\n        b.handle_action(\n            Action::DotSet(TextObject::Arr(Arrow::Left), 1),\n            Source::Keyboard,\n        );\n        b.handle_action(Action::Delete, Source::Keyboard);\n\n        let c = Cur::from_yx(1, LINE_2.len() - 1, &b);\n        let lines = b.string_lines();\n\n        assert_eq!(b.dot, Dot::Cur { c });\n        assert_eq!(lines.len(), 2);\n        assert_eq!(lines[0], LINE_1);\n        assert_eq!(lines[1], \"involving multiple line\");\n        assert_eq!(\n            b.edit_log.edits,\n            vec![vec![\n                in_s(0, &format!(\"{LINE_1}\\n{LINE_2}\")),\n                del_c(LINE_1.len() + 24, 's')\n            ]]\n        );\n    }\n\n    #[test]\n    fn delete_range_works() {\n        let mut b = simple_initial_buffer();\n        b.handle_action(Action::DotSet(TextObject::Line, 1), Source::Keyboard);\n        b.handle_action(Action::Delete, Source::Keyboard);\n\n        let c = Cur::from_yx(1, 0, &b);\n        let lines = b.string_lines();\n\n        assert_eq!(b.dot, Dot::Cur { c });\n        assert_eq!(lines.len(), 2);\n        assert_eq!(lines[0], LINE_1);\n        assert_eq!(lines[1], \"\");\n        assert_eq!(\n            b.edit_log.edits,\n            vec![vec![\n                in_s(0, &format!(\"{LINE_1}\\n{LINE_2}\")),\n                del_s(LINE_1.len() + 1, \"involving multiple lines\")\n            ]]\n        );\n    }\n\n    #[test]\n    fn delete_range_when_start_equals_end_works() {\n        let mut b = Buffer::new_unnamed(0, \"foo\", Default::default());\n        let (cur, deleted) =\n            b.delete_range(Range::from_cursors(Cur::new(0), Cur::new(0), false), None);\n\n        assert_eq!(b.str_contents(), \"oo\");\n        assert_eq!(cur, Cur::new(0));\n        assert_eq!(deleted, None);\n    }\n\n    #[test]\n    fn delete_undo_works() {\n        let mut b = simple_initial_buffer();\n        let original_lines = b.string_lines();\n        b.new_edit_log_transaction();\n\n        b.handle_action(\n            Action::DotExtendBackward(TextObject::Word, 1),\n            Source::Keyboard,\n        );\n        b.handle_action(Action::Delete, Source::Keyboard);\n\n        b.set_dot(TextObject::BufferStart, 1);\n        b.handle_action(\n            Action::DotExtendForward(TextObject::Word, 1),\n            Source::Keyboard,\n        );\n        b.handle_action(Action::Delete, Source::Keyboard);\n\n        b.handle_action(Action::Undo, Source::Keyboard);\n\n        let lines = b.string_lines();\n\n        assert_eq!(lines, original_lines);\n    }\n\n    #[test]\n    fn undo_string_insert_works() {\n        let initial_content = \"foo foo foo\\n\";\n        let mut b = Buffer::new_unnamed(0, initial_content, Default::default());\n\n        b.insert_string(Dot::Cur { c: c(0) }, \"bar\".to_string(), None);\n        b.handle_action(Action::Undo, Source::Keyboard);\n\n        assert_eq!(b.string_lines(), vec![\"foo foo foo\", \"\"]);\n    }\n\n    #[test]\n    fn undo_string_delete_works() {\n        let initial_content = \"foo foo foo\\n\";\n        let mut b = Buffer::new_unnamed(0, initial_content, Default::default());\n\n        let r = Range::from_cursors(c(0), c(2), true);\n        b.delete_dot(Dot::Range { r }, None);\n        b.handle_action(Action::Undo, Source::Keyboard);\n\n        assert_eq!(b.string_lines(), vec![\"foo foo foo\", \"\"]);\n    }\n\n    #[test]\n    fn undo_string_insert_and_delete_works() {\n        let initial_content = \"foo foo foo\\n\";\n        let mut b = Buffer::new_unnamed(0, initial_content, Default::default());\n\n        let r = Range::from_cursors(c(0), c(2), true);\n        b.delete_dot(Dot::Range { r }, None);\n        b.insert_string(Dot::Cur { c: c(0) }, \"bar\".to_string(), None);\n\n        assert_eq!(b.string_lines(), vec![\"bar foo foo\", \"\"]);\n\n        b.handle_action(Action::Undo, Source::Keyboard);\n        b.handle_action(Action::Undo, Source::Keyboard);\n\n        assert_eq!(b.string_lines(), vec![\"foo foo foo\", \"\"]);\n    }\n\n    #[test_case('(', ')'; \"parens\")]\n    #[test_case('[', ']'; \"brackets\")]\n    #[test_case('{', '}'; \"braces\")]\n    #[test_case('<', '>'; \"angle brackets\")]\n    #[test_case('\"', '\"'; \"double quotes\")]\n    #[test_case('\\'', '\\''; \"single quotes\")]\n    #[test_case('\\n', '\\n'; \"newlines\")]\n    #[test_case(' ', ' '; \"spaces\")]\n    #[test_case('\\t', '\\t'; \"tabs\")]\n    #[test_case(' ', '\\t'; \"space and tab\")]\n    #[test_case('\\t', ' '; \"tab and space\")]\n    #[test]\n    fn try_expand_delimited_works(l: char, r: char) {\n        let mut b = Buffer::new_unnamed(\n            0,\n            format!(\"before...{l}target-text{r}  after\"),\n            Default::default(),\n        );\n\n        for i in [10, 20] {\n            b.dot = c(i).into();\n            b.try_expand_delimited();\n            assert_eq!(\n                b.dot.content(&b),\n                \"target-text\",\n                \"failed at offset={i} with lr=({l:?}, {r:?})\"\n            )\n        }\n    }\n\n    // Tests are executed from the root of the crate so existing file paths are relative to there\n    #[test_case(\"foo\", None; \"unknown format\")]\n    #[test_case(\"someFunc()\", None; \"camel case function call\")]\n    #[test_case(\"some_func()\", None; \"snake case function call\")]\n    #[test_case(\"not_a_real_file.rs\", None; \"file that does not exist\")]\n    #[test_case(\"README.md\", Some(\"README.md\"); \"file that exists\")]\n    #[test_case(\"README.md:12,19\", Some(\"README.md:12,19\"); \"file that exists with addr\")]\n    #[test_case(\"README.md:12:19\", Some(\"README.md:12:19\"); \"file that exists with addr containing colon\")]\n    #[test_case(\"/dev/null\", Some(\"/dev/null\"); \"file that exists abs path\")]\n    #[test_case(\"/dev/null:12-+#\", Some(\"/dev/null:12-+#\"); \"file that exists abs path with addr\")]\n    #[test_case(\"http://example.com\", Some(\"http://example.com\"); \"http url\")]\n    #[test_case(\"http://example.com/some/path\", Some(\"http://example.com/some/path\"); \"http url with path\")]\n    #[test_case(\"http://example.com?foo=1\", Some(\"http://example.com?foo=1\"); \"http url with query string\")]\n    #[test_case(\"http://example.com?foo=1&bar=2\", Some(\"http://example.com?foo=1&bar=2\"); \"http url with multi query string\")]\n    #[test]\n    fn try_expand_known_works(s: &str, expected: Option<&str>) {\n        let cwd = env::current_dir().unwrap().display().to_string();\n        // Check with surrounding whitespace and delimiters\n        for (l, r) in [(\" \", \" \"), (\"(\", \")\"), (\"[\", \"]\"), (\"<\", \">\"), (\"{\", \"}\")] {\n            let b = Buffer::new_output(\n                0,\n                format!(\"{cwd}/+output\"),\n                format!(\"abc_123 {l}{s}{r}\\tmore text\"),\n                Default::default(),\n            );\n\n            // Check with the initial cursor position being at any offset within the target\n            for i in 0..s.len() {\n                let dot = b.try_expand_known(9 + i);\n                let maybe_content = dot.map(|d| d.content(&b));\n                assert_eq!(\n                    maybe_content.as_deref(),\n                    expected,\n                    \"failed at offset={i} with lr=({l:?}, {r:?})\"\n                )\n            }\n        }\n    }\n\n    #[test_case(\"\\r\", \"\\n\"; \"CR\")]\n    #[test_case(\"\\n\", \"\\n\"; \"LF\")]\n    #[test_case(\"\\r\\n\", \"\\n\"; \"CRLF\")]\n    #[test_case(\"foo\\rbar\", \"foo\\nbar\"; \"text either side of CR\")]\n    #[test_case(\"foo\\nbar\", \"foo\\nbar\"; \"text either side of LF\")]\n    #[test_case(\"foo\\r\\nbar\", \"foo\\nbar\"; \"text either side of CRLF\")]\n    #[test_case(\"foo\\rbar\\nbaz\\r\\nquux\", \"foo\\nbar\\nbaz\\nquux\"; \"mixed line endings\")]\n    #[test]\n    fn normalizes_line_endings_insert_string(s: &str, expected: &str) {\n        let mut b = Buffer::new_virtual(0, \"test\", \"\", Default::default());\n        b.insert_string(Dot::Cur { c: c(0) }, s.to_string(), None);\n        assert_eq!(b.str_contents(), expected);\n    }\n\n    #[test_case('\\r', \"\\n\"; \"CR\")]\n    #[test_case('\\n', \"\\n\"; \"LF\")]\n    #[test_case('a', \"a\"; \"ascii\")]\n    #[test]\n    fn normalizes_line_endings_insert_char(ch: char, expected: &str) {\n        let mut b = Buffer::new_virtual(0, \"test\", \"\", Default::default());\n        b.insert_char(Dot::Cur { c: c(0) }, ch, None);\n        assert_eq!(b.str_contents(), expected);\n    }\n\n    // Computing tree-sitter edits involves working with references to the old positions within the\n    // tree which can become invalidated when the buffer is being truncated.\n    #[test]\n    fn insert_string_reducing_buffer_len_works_with_ts_state() {\n        let mut b = Buffer::new_virtual(0, \"test\", \"fn main() {}\", Default::default());\n        b.syntax_state = Some(SyntaxState::ts(\n            TsState::try_new_from_language(\"rust\", tree_sitter_rust::LANGUAGE.into(), \"\", &b.txt)\n                .unwrap(),\n        ));\n\n        b.set_dot(TextObject::BufferStart, 1);\n        b.extend_dot_forward(TextObject::BufferEnd, 1);\n\n        b.handle_action(\n            Action::InsertString {\n                s: \"bar\".to_owned(),\n            },\n            Source::Fsys,\n        );\n\n        assert_eq!(b.txt.to_string(), \"bar\");\n        assert_eq!(b.dot, Dot::Cur { c: Cur { idx: 3 } });\n    }\n\n    #[test]\n    fn insert_char_reducing_buffer_len_works_with_ts_state() {\n        let mut b = Buffer::new_virtual(0, \"test\", \"fn main() {}\", Default::default());\n        b.syntax_state = Some(SyntaxState::ts(\n            TsState::try_new_from_language(\"rust\", tree_sitter_rust::LANGUAGE.into(), \"\", &b.txt)\n                .unwrap(),\n        ));\n\n        b.set_dot(TextObject::BufferStart, 1);\n        b.extend_dot_forward(TextObject::BufferEnd, 1);\n\n        b.handle_action(Action::InsertChar { c: 'a' }, Source::Fsys);\n\n        assert_eq!(b.txt.to_string(), \"a\");\n        assert_eq!(b.dot, Dot::Cur { c: Cur { idx: 1 } });\n    }\n\n    #[test]\n    fn match_indent_works() {\n        let mut b = Buffer::new_virtual(0, \"test\", \"  foo\", Default::default());\n        b.set_dot(TextObject::BufferEnd, 1);\n        b.handle_raw_input(Input::Return);\n        assert_eq!(b.txt.to_string(), \"  foo\\n  \");\n    }\n\n    #[test]\n    fn set_dot_eob_single_line_buffer() {\n        let mut b = Buffer::new_virtual(\n            0,\n            \"test\",\n            \"// does it need to be a doc comment? that is a long enough line to\",\n            Default::default(),\n        );\n        b.set_dot(TextObject::BufferEnd, 1);\n        b.handle_raw_input(Input::Return);\n\n        assert_eq!(\n            b.txt.to_string(),\n            \"// does it need to be a doc comment? that is a long enough line to\\n\"\n        );\n    }\n\n    #[test_case(\n        Dot::from(r(18, 23, false)), \"this is a minimal foo\",\n        r(5, 16, false).into(), \"is a minimal\";\n        \"range after\"\n    )]\n    #[test_case(\n        Dot::from(r(0, 2, false)), \"foos is a minimal buffer\",\n        r(5, 16, false).into(), \"is a minimal\";\n        \"range before equal\"\n    )]\n    #[test_case(\n        Dot::from(r(0, 3, false)), \"foo is a minimal buffer\",\n        r(4, 15, false).into(), \"is a minimal\";\n        \"range before truncate\"\n    )]\n    #[test_case(\n        Dot::from(r(0, 1, false)), \"foois is a minimal buffer\",\n        r(6, 17, false).into(), \"is a minimal\";\n        \"range before expand\"\n    )]\n    #[test_case(\n        Dot::from(r(0, 6, false)), \"foo a minimal buffer\",\n        c(3).into(), \" \";\n        \"range before intersect\"\n    )]\n    #[test_case(\n        Dot::from(r(14, 19, false)), \"this is a minifooffer\",\n        c(13).into(), \"i\";\n        \"range after intersect\"\n    )]\n    #[test_case(\n        Dot::from(r(8, 9, false)), \"this is foominimal buffer\",\n        c(11).into(), \"m\";\n        \"range inside dot\"\n    )]\n    #[test_case(\n        Dot::from(r(4, 18, false)), \"thisfoouffer\",\n        c(7).into(), \"u\";\n        \"range containing dot\"\n    )]\n    #[test_case(\n        Dot::from(c(4)), \"thisfoo is a minimal buffer\",\n        r(8, 19, false).into(), \"is a minimal\";\n        \"cursor before dot\"\n    )]\n    #[test_case(\n        Dot::from(c(18)), \"this is a minimal foobuffer\",\n        r(5, 16, false).into(), \"is a minimal\";\n        \"cursor after dot\"\n    )]\n    #[test_case(\n        Dot::from(c(10)), \"this is a foominimal buffer\",\n        c(13).into(), \"m\";\n        \"cursor inside dot\"\n    )]\n    #[test]\n    fn insert_xdot_sets_correct_dot(\n        xdot: Dot,\n        expected_content: &str,\n        expected_dot: Dot,\n        expected_dot_content: &str,\n    ) {\n        let mut b = Buffer::new_virtual(0, \"test\", \"this is a minimal buffer\", Default::default());\n        b.xdot = xdot;\n        b.dot = r(5, 16, false).into();\n        assert_eq!(b.dot_contents(), \"is a minimal\");\n\n        b.insert_xdot(\"foo\".into());\n\n        assert_eq!(b.str_contents(), expected_content);\n        assert_eq!(b.dot, expected_dot);\n        assert_eq!(b.dot_contents(), expected_dot_content);\n    }\n}\n", "source": "ad/src/buffer/mod.rs", "file_type": "rc"}
{"text": "//! Buffer state for the fuse filesystem\nuse crate::{\n    fsys::{\n        BUFFERS_DIR, BUFFERS_QID, CURRENT_BUFFER, CURRENT_BUFFER_QID, E_UNKNOWN_FILE, INDEX_BUFFER,\n        INDEX_BUFFER_QID, InternalRead, Message, QID_OFFSET, Req, Result, apply_offset,\n        empty_dir_stat, empty_file_stat,\n        event::{InputFilter, InputRequest, run_threaded_input_listener, send_event_to_editor},\n        log::{Log, LogEvent},\n    },\n    input::Event,\n};\nuse ninep::{fs::Stat, sync::server::ReadOutcome};\nuse std::{\n    collections::BTreeMap,\n    sync::mpsc::{Receiver, Sender, channel},\n    time::SystemTime,\n};\nuse tracing::{debug, error, trace};\n\nconst FILENAME: &str = \"filename\";\nconst DOT: &str = \"dot\";\nconst ADDR: &str = \"addr\";\nconst XDOT: &str = \"xdot\";\nconst XADDR: &str = \"xaddr\";\nconst BODY: &str = \"body\";\nconst EVENT: &str = \"event\";\nconst OUTPUT: &str = \"output\";\nconst FILETYPE: &str = \"filetype\";\n\npub(super) const BUFFER_FILES: [(u64, &str); QID_OFFSET as usize - 1] = [\n    (1, FILENAME),\n    (2, DOT),\n    (3, ADDR),\n    (4, XDOT),\n    (5, XADDR),\n    (6, BODY),\n    (7, EVENT),\n    (8, OUTPUT),\n    (9, FILETYPE),\n];\n\nfn parent_and_fname(qid: u64) -> (u64, &'static str) {\n    assert!(qid > CURRENT_BUFFER_QID, \"invalid buffer file qid\");\n\n    let (cur, off) = (CURRENT_BUFFER_QID, QID_OFFSET);\n    let parent = cur + 1 + ((qid - cur - 1) / off) * off;\n    let fname = BUFFER_FILES[((qid - cur - 2) % off) as usize].1;\n\n    (parent, fname)\n}\n\n#[derive(Debug)]\npub(super) enum QidCheck {\n    Unknown,\n    EventFile { buf_qid: u64 },\n    OtherFile,\n}\n\n#[derive(Debug)]\npub(super) struct BufferNodes {\n    pub(super) known: BTreeMap<u64, BufferNode>,\n    pub(super) log: Log,\n    next_qid: u64,\n    current_buffid: usize,\n    stat: Stat,\n    current_buff_stat: Stat,\n    index_stat: Stat,\n    tx: Sender<Event>,\n    brx: Receiver<LogEvent>,\n}\n\nimpl BufferNodes {\n    pub(super) fn new(\n        tx: Sender<Event>,\n        brx: Receiver<LogEvent>,\n        log_tx: Sender<Sender<Vec<u8>>>,\n    ) -> Self {\n        Self {\n            known: BTreeMap::default(),\n            log: Log::new(log_tx),\n            next_qid: CURRENT_BUFFER_QID + 1,\n            current_buffid: 1,\n            stat: empty_dir_stat(BUFFERS_QID, BUFFERS_DIR),\n            current_buff_stat: empty_file_stat(CURRENT_BUFFER_QID, CURRENT_BUFFER),\n            index_stat: empty_file_stat(INDEX_BUFFER_QID, INDEX_BUFFER),\n            tx,\n            brx,\n        }\n    }\n\n    pub(super) fn stat(&self) -> Stat {\n        self.stat.clone()\n    }\n\n    pub(super) fn top_level_stats(&self) -> Vec<Stat> {\n        let mut stats: Vec<Stat> = self.known.values().map(|b| b.stat.clone()).collect();\n        stats.push(self.current_buff_stat.clone());\n        stats.push(self.index_stat.clone());\n\n        stats\n    }\n\n    pub(super) fn buffer_level_stats(&self, qid: u64) -> Option<Vec<Stat>> {\n        self.known.get(&qid).map(|b| b.file_stats())\n    }\n\n    pub(super) fn is_known_buffer_qid(&self, qid: u64) -> bool {\n        self.known.contains_key(&qid) || self.known.values().any(|bn| bn.contains_qid(qid))\n    }\n\n    pub(super) fn check_if_known_qid(&self, qid: u64) -> QidCheck {\n        if self.known.contains_key(&qid) {\n            QidCheck::OtherFile\n        } else {\n            for (&buf_qid, bn) in self.known.iter() {\n                match bn.check_if_known_qid(qid) {\n                    QidCheck::Unknown => (),\n                    QidCheck::EventFile { .. } => return QidCheck::EventFile { buf_qid },\n                    QidCheck::OtherFile => return QidCheck::OtherFile,\n                }\n            }\n\n            QidCheck::Unknown\n        }\n    }\n\n    pub(super) fn attach_input_filter(&mut self, buf_qid: u64) -> Result<()> {\n        match self.known.get_mut(&buf_qid) {\n            Some(bn) => bn.attach_input_filter(&self.tx),\n            None => Err(E_UNKNOWN_FILE.to_string()),\n        }\n    }\n\n    pub(super) fn clear_input_filter(&mut self, buf_qid: u64) {\n        if let Some(bn) = self.known.get_mut(&buf_qid) {\n            bn.clear_input_filter(&self.tx);\n        }\n    }\n\n    pub(super) fn lookup_file_stat(&mut self, parent: u64, name: &str) -> Option<Stat> {\n        match (parent, name) {\n            (BUFFERS_QID, CURRENT_BUFFER) => Some(self.current_buff_stat.clone()),\n            (BUFFERS_QID, INDEX_BUFFER) => Some(self.index_stat.clone()),\n            (BUFFERS_QID, _) => self\n                .known\n                .values()\n                .find(|b| b.str_id == name)\n                .map(|b| b.stat()),\n            _ => self\n                .known\n                .get_mut(&parent)?\n                .refreshed_file_stat(name, &self.tx)\n                .clone(),\n        }\n    }\n\n    pub(super) fn get_stat_for_qid(&mut self, qid: u64) -> Option<Stat> {\n        // If this is a known directory then we return the stat for it\n        if qid == BUFFERS_QID {\n            return Some(self.stat());\n        } else if qid == CURRENT_BUFFER_QID {\n            return Some(self.current_buff_stat.clone());\n        } else if qid == INDEX_BUFFER_QID {\n            return Some(self.index_stat.clone());\n        } else if let Some(b) = self.known.get(&qid) {\n            return Some(b.stat());\n        }\n\n        // Otherwise we see if this is known buffer file\n        let (parent, fname) = parent_and_fname(qid);\n        self.known\n            .get_mut(&parent)?\n            .refreshed_file_stat(fname, &self.tx)\n    }\n\n    pub(super) fn get_file_content(\n        &mut self,\n        qid: u64,\n        offset: usize,\n        count: usize,\n    ) -> InternalRead {\n        if qid == CURRENT_BUFFER_QID {\n            return InternalRead::Immediate(apply_offset(\n                self.current_buffid.to_string().as_bytes(),\n                offset,\n                count,\n            ));\n        } else if qid == INDEX_BUFFER_QID {\n            return InternalRead::Immediate(apply_offset(self.index().as_bytes(), offset, count));\n        }\n\n        let (parent, fname) = parent_and_fname(qid);\n        match self.known.get_mut(&parent) {\n            Some(bn) => bn.current_file_content(fname, offset, count, &self.tx),\n            None => InternalRead::Unknown,\n        }\n    }\n\n    fn index(&mut self) -> String {\n        let mut entries = Vec::with_capacity(self.known.len());\n\n        for b in self.known.values_mut() {\n            let filename = b\n                .current_file_content_as_string(FILENAME, &self.tx)\n                .expect(\"FILENAME to be valid\");\n            let id = &b.str_id;\n\n            // filename already contains a trailing newline\n            entries.push(format!(\"{id}\\t{filename}\"));\n        }\n\n        entries.join(\"\")\n    }\n\n    pub(super) fn truncate(&mut self, qid: u64) {\n        if qid == CURRENT_BUFFER_QID || qid == INDEX_BUFFER_QID {\n            return;\n        }\n\n        let (parent, fname) = parent_and_fname(qid);\n        let b = match self.known.get_mut(&parent) {\n            Some(b) => b,\n            None => return,\n        };\n        b.stat.last_modified = SystemTime::now();\n        b.stat.n_bytes = 0;\n        let id = b.id;\n\n        if fname == BODY {\n            _ = Message::send(Req::ClearBufferBody { id }, &self.tx);\n        }\n    }\n\n    pub(super) fn write(&mut self, qid: u64, s: String, _offset: usize) -> Result<usize> {\n        let (parent, fname) = parent_and_fname(qid);\n        let b = match self.known.get_mut(&parent) {\n            Some(b) => b,\n            None => return Err(E_UNKNOWN_FILE.to_string()),\n        };\n        b.stat.last_modified = SystemTime::now();\n        let id = b.id;\n\n        let n_bytes = s.len();\n        let req = match fname {\n            DOT => Req::SetBufferDot { id, s },\n            ADDR => Req::SetBufferAddr { id, s },\n            BODY => Req::AppendBufferBody { id, s },\n            XDOT => Req::SetBufferXDot { id, s },\n            XADDR => Req::SetBufferXAddr { id, s },\n            OUTPUT => Req::AppendOutput { id, s },\n            EVENT => return send_event_to_editor(id, &s, &self.tx),\n            FILENAME => Req::SetBufferName { id, s },\n            _ => return Err(E_UNKNOWN_FILE.to_string()),\n        };\n\n        match Message::send(req, &self.tx) {\n            Ok(_) => Ok(n_bytes),\n            Err(e) => Err(format!(\n                \"unable to write to {fname} (n_bytes={n_bytes}): {e}\",\n            )),\n        }\n    }\n\n    /// Process any pending updates from the main thread for changes to the buffer set\n    pub(super) fn update(&mut self) {\n        for bid in self.brx.try_iter() {\n            self.log.push(bid);\n            match bid {\n                LogEvent::Open(id) => {\n                    debug!(%id, \"adding buffer to fsys state\");\n                    let qid = self.next_qid;\n                    self.next_qid += QID_OFFSET;\n                    self.known.insert(qid, BufferNode::new(id, qid));\n                }\n\n                // TODO: handle closing deferred reads of files associated with this buffer\n                LogEvent::Close(id) => {\n                    debug!(%id, \"removing buffer from fsys state\");\n                    self.known.retain(|_, v| v.id != id);\n                }\n\n                LogEvent::Focus(id) => {\n                    debug!(%id, \"setting current buffer in fsys state\");\n                    self.current_buffid = id;\n                    self.current_buff_stat.n_bytes = id.to_string().len() as u64;\n                }\n\n                LogEvent::Save(_) => (), // only used in the log\n            };\n        }\n    }\n}\n\n/// A BufferNode in the filesystem is a directory containing a fixed\n/// set of control files\n///\n/// The qids generated for each of the control files are based on offsets\n/// from the qid of the buffer directory itself (see QID_OFFSET above).\n#[derive(Debug)]\npub(super) struct BufferNode {\n    id: usize,\n    str_id: String,\n    stat: Stat,\n    file_stats: BTreeMap<&'static str, Stat>,\n    input_handle: Option<Sender<InputRequest>>,\n}\n\nimpl BufferNode {\n    fn new(id: usize, qid: u64) -> Self {\n        Self {\n            id,\n            str_id: id.to_string(),\n            stat: empty_dir_stat(qid, &id.to_string()),\n            file_stats: stub_file_stats(qid),\n            input_handle: None,\n        }\n    }\n\n    fn stat(&self) -> Stat {\n        self.stat.clone()\n    }\n\n    fn file_stats(&self) -> Vec<Stat> {\n        self.file_stats.values().cloned().collect()\n    }\n\n    fn contains_qid(&self, qid: u64) -> bool {\n        self.file_stats.values().any(|s| s.fm.qid == qid)\n    }\n\n    fn check_if_known_qid(&self, qid: u64) -> QidCheck {\n        for (&fname, s) in self.file_stats.iter() {\n            if s.fm.qid == qid {\n                return if fname == EVENT {\n                    // replaced with the correct qid by BufferNodes\n                    QidCheck::EventFile { buf_qid: 0 }\n                } else {\n                    QidCheck::OtherFile\n                };\n            }\n        }\n\n        QidCheck::Unknown\n    }\n\n    fn attach_input_filter(&mut self, etx: &Sender<Event>) -> Result<()> {\n        let (tx, rx) = channel();\n        let req = Req::AddInputEventFilter {\n            id: self.id,\n            filter: InputFilter::new(tx),\n        };\n\n        Message::send(req, etx)?;\n        self.input_handle = Some(run_threaded_input_listener(rx));\n\n        Ok(())\n    }\n\n    fn clear_input_filter(&mut self, etx: &Sender<Event>) {\n        if let Some(tx) = self.input_handle.take() {\n            _ = tx.send(InputRequest::Shutdown);\n            _ = Message::send(Req::RemoveInputEventFilter { id: self.id }, etx);\n        }\n    }\n\n    fn refreshed_file_stat(&mut self, fname: &str, tx: &Sender<Event>) -> Option<Stat> {\n        if fname == OUTPUT || fname == EVENT {\n            return self.file_stats.get(fname).cloned();\n        }\n\n        trace!(id=%self.id, %fname, \"refreshing file stat\");\n        let content = self.current_file_content_as_string(fname, tx)?;\n        let stat = self.file_stats.get_mut(fname)?;\n        stat.n_bytes = content.len() as u64;\n\n        Some(stat.clone())\n    }\n\n    // Must not be called for the event file or unknown files\n    fn current_file_content_as_string(\n        &mut self,\n        fname: &str,\n        tx: &Sender<Event>,\n    ) -> Option<String> {\n        let req = match fname {\n            FILENAME => Req::ReadBufferName { id: self.id },\n            DOT => Req::ReadBufferDot { id: self.id },\n            ADDR => Req::ReadBufferAddr { id: self.id },\n            BODY => Req::ReadBufferBody { id: self.id },\n            XDOT => Req::ReadBufferXDot { id: self.id },\n            XADDR => Req::ReadBufferXAddr { id: self.id },\n            FILETYPE => Req::ReadBufferFtype { id: self.id },\n            OUTPUT => return Some(String::new()),\n            _ => return None, // can hit this as part of walk for unknown files\n        };\n\n        match Message::send(req, tx) {\n            Ok(s) => Some(s),\n            Err(e) => {\n                error!(\"fsys failed to read file content: {e}\");\n                Some(String::new())\n            }\n        }\n    }\n\n    fn current_file_content(\n        &mut self,\n        fname: &str,\n        offset: usize,\n        count: usize,\n        tx: &Sender<Event>,\n    ) -> InternalRead {\n        let req = match fname {\n            FILENAME => Req::ReadBufferName { id: self.id },\n            DOT => Req::ReadBufferDot { id: self.id },\n            ADDR => Req::ReadBufferAddr { id: self.id },\n            BODY => Req::ReadBufferBody { id: self.id },\n            XDOT => Req::ReadBufferXDot { id: self.id },\n            XADDR => Req::ReadBufferXAddr { id: self.id },\n            FILETYPE => Req::ReadBufferFtype { id: self.id },\n            OUTPUT => return InternalRead::Immediate(Vec::new()),\n            EVENT => {\n                // ignoring offset\n                return match self.pending_events() {\n                    Ok(ir) => ir,\n                    Err(e) => {\n                        error!(\"error reading events: {e}\");\n                        self.clear_input_filter(tx);\n                        InternalRead::Unknown\n                    }\n                };\n            }\n\n            _ => return InternalRead::Unknown,\n        };\n\n        match Message::send(req, tx) {\n            Ok(s) => InternalRead::Immediate(apply_offset(s.as_bytes(), offset, count)),\n            Err(e) => {\n                error!(\"fsys failed to read file content: {e}\");\n                InternalRead::Unknown\n            }\n        }\n    }\n\n    fn pending_events(&self) -> Result<InternalRead> {\n        let tx = match self.input_handle.as_ref() {\n            Some(tx) => tx,\n            None => {\n                error!(\"pending_events without input filter (id={})\", self.id);\n                return Ok(InternalRead::Unknown);\n            }\n        };\n\n        let (read_tx, read_rx) = channel();\n        if tx.send(InputRequest::Read { tx: read_tx }).is_err() {\n            return Err(\"failed to send\".to_string());\n        }\n\n        match read_rx.recv() {\n            Ok(ReadOutcome::Immediate(data)) => Ok(InternalRead::Immediate(data)),\n            Ok(ReadOutcome::Blocked(rx)) => Ok(InternalRead::Blocked(rx)),\n            Err(_) => Err(\"failed to read\".to_string()),\n        }\n    }\n}\n\nfn stub_file_stats(qid: u64) -> BTreeMap<&'static str, Stat> {\n    let mut m = BTreeMap::new();\n\n    for (offset, name) in BUFFER_FILES.into_iter() {\n        m.insert(name, empty_file_stat(qid + offset, name));\n    }\n\n    m\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use simple_test_case::test_case;\n\n    #[test_case(CURRENT_BUFFER_QID + 1 + 1, CURRENT_BUFFER_QID + 1, FILENAME; \"filename first buffer\")]\n    #[test_case(10, 8, DOT; \"dot first buffer\")]\n    #[test_case(24, 18, BODY; \"body second buffer\")]\n    #[test]\n    fn parent_and_fname_works(qid: u64, parent: u64, fname: &str) {\n        let (p, f) = parent_and_fname(qid);\n\n        assert_eq!(p, parent);\n        assert_eq!(f, fname);\n    }\n}\n", "source": "ad/src/fsys/buffer.rs", "file_type": "rc"}
{"text": "//! An Acme style filesystem interface for ad\n//!\n//!\n//! ## Mount Point\n//! <https://www.pathname.com/fhs/pub/fhs-2.3.html#VARLIBLTEDITORGTEDITORBACKUPFILESAN>\n//!\n//! `/var/lib/ad` feels like it would be the \"correct\" place to mount the filesystem but\n//! this would need to be created with something like:\n//! ```sh\n//! $ sudo mkdir /var/lib/ad\n//! $ sudo chown $(whoami) /var/lib/ad\n//! ```\n//!\n//! So instead we mount to `$HOME/.ad/mnt/`\n//!\n//! ## Filesystem contents\n//! ```text\n//! $HOME/.ad/mnt/\n//!   ctl\n//!   minibuffer\n//!   scratch\n//!   log\n//!   buffers/\n//!     current\n//!     index\n//!     [n]/\n//!       filename\n//!       dot\n//!       addr\n//!       body\n//!       event\n//! ```\nuse crate::{editor::Action, input::Event, ui::SCRATCH_ID};\nuse ninep::{\n    Result,\n    fs::{FileMeta, IoUnit, Mode, Perm, Stat},\n    sync::server::{ClientId, ReadOutcome, Serve9p, Server, socket_path},\n};\nuse std::{\n    collections::HashMap,\n    env,\n    fs::{create_dir_all, remove_file},\n    mem::take,\n    path::{Path, PathBuf},\n    process::Command,\n    sync::{\n        Arc, Mutex,\n        mpsc::{Receiver, Sender, channel},\n    },\n    thread::{JoinHandle, spawn},\n    time::SystemTime,\n};\nuse tracing::{error, trace};\n\nmod buffer;\nmod event;\nmod log;\nmod message;\n\npub(crate) use event::InputFilter;\npub(crate) use log::LogEvent;\npub(crate) use message::{Message, Req};\n\nuse buffer::{BufferNodes, QidCheck};\nuse log::spawn_log_listener;\n\nconst DEFAULT_SOCKET_NAME: &str = \"ad\";\nconst MOUNT_DIR: &str = \".ad/mnt\";\nconst IO_UNIT: u32 = 8168;\n\n// Fixed qids inside of '$HOME/.ad/mnt/buffers':\n///   0. $HOME/.ad/mnt  -> The directory we mount to\nconst MOUNT_ROOT_QID: u64 = 0;\n///   1.   /ctl         -> control file for issuing commands\nconst CONTROL_FILE_QID: u64 = 1;\nconst CONTROL_FILE: &str = \"ctl\";\n///   2.   /log         -> read only log of events in the editor\nconst LOG_FILE_QID: u64 = 2;\nconst LOG_FILE: &str = \"log\";\n///   3    /minibuffer  -> control file for selecting text using the minibuffer\nconst MINIBUFFER_QID: u64 = 3;\nconst MINIBUFFER: &str = \"minibuffer\";\n///   4    /scratch     -> control file for reading and appending to the scratch buffer\nconst SCRATCH_QID: u64 = 4;\nconst SCRATCH: &str = \"scratch\";\n///   4    /buffers/    -> parent directory for buffers\nconst BUFFERS_QID: u64 = 5;\nconst BUFFERS_DIR: &str = \"buffers\";\n//    5      /index     -> a listing of all of the currently open buffers\nconst INDEX_BUFFER_QID: u64 = 6;\nconst INDEX_BUFFER: &str = \"index\";\n//    6      /current   -> the fsys filename of the current buffer\nconst CURRENT_BUFFER_QID: u64 = 7;\nconst CURRENT_BUFFER: &str = \"current\";\n\n/// The number of qids required to serve both the directory and contents\n/// of a buffer node (used to generate qid values for buffers):\n///\n///   1. $id            -> The buffer directory\n///   2.   filename     -> The current filename for the buffer\n///   3.   dot          -> The text currently held in dot\n///   4.   addr         -> The address value of dot\n///   5.   xdot         -> The text currently held in xdot (a virtual dot not affecting real dot)\n///   6.   xaddr        -> The address value of xdot\n///   7.   body         -> The full body of the buffer\n///   8.   event        -> Control file for intercepting input events for the buffer\n///   9.   output       -> Write only output connected to stdout/err of commands run within the buffer\n///   10.  filetype     -> ad's view of what filetype is configured for the buffer\nconst QID_OFFSET: u64 = 10;\n\nconst TOP_LEVEL_QIDS: [u64; 8] = [\n    MOUNT_ROOT_QID,\n    CONTROL_FILE_QID,\n    MINIBUFFER_QID,\n    SCRATCH_QID,\n    LOG_FILE_QID,\n    BUFFERS_QID,\n    INDEX_BUFFER_QID,\n    CURRENT_BUFFER_QID,\n];\n\nconst E_UNKNOWN_FILE: &str = \"unknown file\";\nconst E_NOT_ALLOWED: &str = \"not allowed\";\n\nenum InternalRead {\n    Immediate(Vec<u8>),\n    Blocked(Receiver<Vec<u8>>),\n    Unknown,\n}\n\n#[derive(Debug, Default)]\nstruct Cids {\n    cids: Vec<ClientId>,\n    read_locked: Option<ClientId>,\n}\n\n/// A join handle for the filesystem thread\n#[derive(Debug)]\npub struct FsHandle {\n    path: PathBuf,\n    inner: JoinHandle<()>,\n}\n\nimpl FsHandle {\n    /// Remove our socket (will cause the 9p server to exit)\n    pub fn remove_socket(&self) {\n        _ = remove_file(&self.path);\n    }\n\n    /// Join on the filesystem thread\n    pub fn join(self) {\n        _ = self.inner.join();\n    }\n}\n\n#[derive(Debug)]\nenum MiniBufferContent {\n    Buffering(Vec<u8>),\n    Data(Vec<u8>),\n    Pending(Sender<Sender<Vec<u8>>>, Receiver<Vec<u8>>),\n}\n\npub fn default_socket_path_for_pid() -> PathBuf {\n    socket_path(format!(\"{DEFAULT_SOCKET_NAME}-{}\", crate::pid()))\n}\n\n/// Mutable state for the ad filesystem.\n///\n/// The parent [AdFs] holds onto this state inside of an Arc<Mutex<>> which means that all\n/// incoming requests will be processed sequentially.\n#[derive(Debug)]\nstruct State {\n    tx: Sender<Event>,\n    buffer_nodes: BufferNodes,\n    minibuffer_content: MiniBufferContent,\n    minibuffer_prompt: Option<String>,\n    /// map of qids to client IDs with that qid open\n    open_cids: HashMap<u64, Cids>,\n    // Root level files and directories\n    mount_dir_stat: Stat,\n    control_file_stat: Stat,\n    minibuffer_stat: Stat,\n    scratch_stat: Stat,\n    log_file_stat: Stat,\n    mount_path: String,\n    auto_mount: bool,\n}\n\nimpl Drop for State {\n    fn drop(&mut self) {\n        if self.auto_mount {\n            let res = Command::new(\"fusermount\")\n                .args([\"-u\", &self.mount_path])\n                .spawn();\n\n            if let Ok(mut child) = res {\n                _ = child.wait();\n            }\n        }\n    }\n}\n\nimpl State {\n    fn add_open_cid(&mut self, qid: u64, cid: ClientId) {\n        self.open_cids.entry(qid).or_default().cids.push(cid);\n    }\n\n    fn remove_open_cid(&mut self, qid: u64, cid: ClientId) {\n        self.open_cids.entry(qid).and_modify(|cids| {\n            cids.cids.retain(|&id| id != cid);\n            if cids.read_locked == Some(cid) {\n                cids.read_locked = None;\n            }\n        });\n    }\n\n    fn lock_qid_for_reading(&mut self, qid: u64, cid: ClientId) -> Result<()> {\n        trace!(\"locking qid for reading qid={qid} cid={cid:?}\");\n        match self.open_cids.get_mut(&qid) {\n            Some(cids) => cids.read_locked = Some(cid),\n            None => return Err(E_UNKNOWN_FILE.to_string()),\n        }\n\n        Ok(())\n    }\n\n    fn readlocked_cid(&self, qid: u64) -> Option<ClientId> {\n        self.open_cids.get(&qid).and_then(|cids| cids.read_locked)\n    }\n\n    fn set_active_buffer(&mut self, s: String) -> Result<usize> {\n        let id: usize = match s.trim().parse() {\n            Ok(n) => n,\n            Err(_) => {\n                trace!(\"invalid buffer id submitted to buffers/current: {s}\");\n                return Ok(0);\n            }\n        };\n\n        if let Err(e) = self.tx.send(Event::Action(Action::FocusBuffer { id })) {\n            error!(\"unable to send event to main loop: {e}\");\n            return Ok(0);\n        }\n\n        Ok(s.len())\n    }\n\n    fn scratch_read(&self, offset: usize, count: usize) -> ReadOutcome {\n        let req = Req::ReadBufferBody { id: SCRATCH_ID };\n        match Message::send(req, &self.tx) {\n            Ok(s) => ReadOutcome::Immediate(apply_offset(s.as_bytes(), offset, count)),\n            Err(e) => {\n                error!(\"fsys failed to read file content: {e}\");\n                ReadOutcome::Immediate(Vec::new())\n            }\n        }\n    }\n\n    fn scratch_write(&mut self, s: String) -> Result<usize> {\n        let n_bytes = s.len();\n        let req = Req::AppendBufferBody { id: SCRATCH_ID, s };\n\n        match Message::send(req, &self.tx) {\n            Ok(_) => Ok(n_bytes),\n            Err(e) => Err(format!(\n                \"unable to write to scratch buffer (n_bytes={n_bytes}): {e}\",\n            )),\n        }\n    }\n\n    fn minibuffer_read(&mut self, offset: usize, count: usize) -> ReadOutcome {\n        match &mut self.minibuffer_content {\n            MiniBufferContent::Buffering(lines_bytes) => {\n                let lines = match String::from_utf8(take(lines_bytes)) {\n                    Ok(s) => s,\n                    Err(e) => {\n                        error!(\"invalid minibuffer data: {e}\");\n                        self.minibuffer_content = MiniBufferContent::Buffering(Vec::new());\n                        return ReadOutcome::Immediate(Vec::new());\n                    }\n                };\n                let prompt = self.minibuffer_prompt.take();\n\n                let (data_tx, data_rx) = channel();\n                let (fsys_tx, fsys_rx) = channel();\n                let (sub_tx, sub_rx) = channel();\n\n                self.minibuffer_stat.n_bytes = 0;\n                self.minibuffer_stat.last_modified = SystemTime::now();\n                spawn_minibuffer_listener(data_rx, fsys_tx, sub_rx);\n\n                let (tx, rx) = channel();\n                _ = sub_tx.send(tx);\n                self.minibuffer_content = MiniBufferContent::Pending(sub_tx, fsys_rx);\n\n                match Message::send(\n                    Req::MinibufferSelect {\n                        prompt,\n                        lines,\n                        tx: data_tx,\n                    },\n                    &self.tx,\n                ) {\n                    Ok(_) => ReadOutcome::Blocked(rx),\n                    Err(e) => {\n                        error!(\"unable to open minibuffer: {e}\");\n                        self.minibuffer_content = MiniBufferContent::Buffering(Vec::new());\n                        ReadOutcome::Immediate(Vec::new())\n                    }\n                }\n            }\n\n            MiniBufferContent::Data(data) => {\n                ReadOutcome::Immediate(apply_offset(data, offset, count))\n            }\n\n            MiniBufferContent::Pending(sub_tx, fsys_rx) => match fsys_rx.try_recv() {\n                Ok(data) => {\n                    self.minibuffer_stat.n_bytes = data.len() as u64;\n                    self.minibuffer_content = MiniBufferContent::Data(data.clone());\n                    ReadOutcome::Immediate(apply_offset(&data, offset, count))\n                }\n                _ => {\n                    let (tx, rx) = channel();\n                    _ = sub_tx.send(tx);\n                    ReadOutcome::Blocked(rx)\n                }\n            },\n        }\n    }\n\n    /// Writing data to the minibuffer causes fsys to buffer the writes internally until the client\n    /// is done. When a client then attempts to read back the selection the full buffer is sent to\n    /// the editor for rendering and the reads block until the user makes a selection.\n    fn minibuffer_write(&mut self, lines: String) -> Result<usize> {\n        let n_bytes = lines.len();\n        match &mut self.minibuffer_content {\n            MiniBufferContent::Buffering(buffer) => buffer.extend_from_slice(lines.as_bytes()),\n            _ => self.minibuffer_content = MiniBufferContent::Buffering(lines.into_bytes()),\n        }\n\n        Ok(n_bytes)\n    }\n}\n\n/// The filesystem interface for ad\n#[derive(Debug)]\npub(crate) struct AdFs {\n    state: Arc<Mutex<State>>,\n}\n\nimpl AdFs {\n    /// Construct a new filesystem interface using channels held by the editor.\n    pub fn new(tx: Sender<Event>, brx: Receiver<LogEvent>, auto_mount: bool) -> Self {\n        let home = env::var(\"HOME\").expect(\"$HOME to be set\");\n        let mount_path = format!(\"{home}/{MOUNT_DIR}\");\n\n        if !Path::new(&mount_path).exists() {\n            create_dir_all(&mount_path).expect(\"to be able to create our mount point\");\n        }\n\n        let (log_tx, log_rx) = channel();\n        let (listener_tx, listener_rx) = channel();\n        spawn_log_listener(brx, listener_tx, log_rx);\n\n        let buffer_nodes = BufferNodes::new(tx.clone(), listener_rx, log_tx);\n\n        Self {\n            state: Arc::new(Mutex::new(State {\n                tx,\n                buffer_nodes,\n                open_cids: HashMap::new(),\n                minibuffer_content: MiniBufferContent::Data(Vec::new()),\n                minibuffer_prompt: None,\n                mount_dir_stat: empty_dir_stat(MOUNT_ROOT_QID, \"/\"),\n                control_file_stat: empty_file_stat(CONTROL_FILE_QID, CONTROL_FILE),\n                minibuffer_stat: empty_file_stat(MINIBUFFER_QID, MINIBUFFER),\n                scratch_stat: empty_file_stat(SCRATCH_QID, SCRATCH),\n                log_file_stat: empty_file_stat(LOG_FILE_QID, LOG_FILE),\n                mount_path,\n                auto_mount,\n            })),\n        }\n    }\n\n    /// Spawn a thread for running this filesystem and return a handle to it\n    pub fn run_threaded(self, custom_socket_path: Option<PathBuf>) -> FsHandle {\n        let s = self.state.lock().unwrap();\n        let auto_mount = s.auto_mount;\n        let mount_path = PathBuf::from(s.mount_path.clone());\n        let socket_path = custom_socket_path.unwrap_or_else(default_socket_path_for_pid);\n        drop(s);\n\n        let s = Server::new(self);\n        let handle = FsHandle {\n            path: socket_path.clone(),\n            inner: s.serve_socket_with_custom_path(socket_path.clone()),\n        };\n\n        if auto_mount {\n            let res = Command::new(\"9pfuse\")\n                .args([socket_path, mount_path])\n                .spawn();\n\n            if let Ok(mut child) = res {\n                _ = child.wait();\n            }\n        }\n\n        handle\n    }\n}\n\n/// Spawn a listener to wait for a reply from the editor for our minibuffer selection\nfn spawn_minibuffer_listener(\n    data_rx: Receiver<String>,\n    fsys_tx: Sender<Vec<u8>>,\n    sub_rx: Receiver<Sender<Vec<u8>>>,\n) {\n    spawn(move || {\n        let data = match data_rx.recv() {\n            Ok(s) => s.into_bytes(),\n            Err(e) => {\n                error!(\"unable to read minibuffer output: {e}\");\n                Vec::new()\n            }\n        };\n\n        // Reply to fsys first so the data is ready for incoming reads\n        _ = fsys_tx.send(data.clone());\n\n        // Any client currently blocked on a read then gets their own reply\n        for tx in sub_rx.try_iter() {\n            _ = tx.send(data.clone());\n        }\n    });\n}\n\nimpl Serve9p for AdFs {\n    fn stat(&self, cid: ClientId, qid: u64, uname: &str) -> Result<Stat> {\n        trace!(?cid, %qid, %uname, \"handling stat request\");\n        let mut s = self.state.lock().unwrap();\n        s.buffer_nodes.update();\n\n        match qid {\n            MOUNT_ROOT_QID => Ok(s.mount_dir_stat.clone()),\n            CONTROL_FILE_QID => Ok(s.control_file_stat.clone()),\n            MINIBUFFER_QID => Ok(s.minibuffer_stat.clone()),\n            SCRATCH_QID => Ok(s.scratch_stat.clone()),\n            LOG_FILE_QID => Ok(s.log_file_stat.clone()),\n            BUFFERS_QID => Ok(s.buffer_nodes.stat().clone()),\n            qid => match s.buffer_nodes.get_stat_for_qid(qid) {\n                Some(stat) => Ok(stat.clone()),\n                None => Err(E_UNKNOWN_FILE.to_string()),\n            },\n        }\n    }\n\n    fn write_stat(&self, cid: ClientId, qid: u64, stat: Stat, uname: &str) -> Result<()> {\n        trace!(?cid, %qid, %uname, \"handling write stat request\");\n        let mut s = self.state.lock().unwrap();\n        s.buffer_nodes.update();\n\n        if stat.n_bytes == 0 {\n            trace!(%qid, %uname, \"stat n_bytes=0, truncating file\");\n            match qid {\n                MOUNT_ROOT_QID | CONTROL_FILE_QID | MINIBUFFER_QID | LOG_FILE_QID => (),\n                qid => s.buffer_nodes.truncate(qid),\n            }\n        }\n\n        Ok(())\n    }\n\n    fn walk(&self, cid: ClientId, parent_qid: u64, child: &str, uname: &str) -> Result<FileMeta> {\n        trace!(?cid, %parent_qid, %child, %uname, \"handling walk request\");\n        let mut s = self.state.lock().unwrap();\n        s.buffer_nodes.update();\n\n        match parent_qid {\n            MOUNT_ROOT_QID => match child {\n                CONTROL_FILE => Ok(s.control_file_stat.fm.clone()),\n                MINIBUFFER => Ok(s.minibuffer_stat.fm.clone()),\n                SCRATCH => Ok(s.scratch_stat.fm.clone()),\n                LOG_FILE => Ok(s.log_file_stat.fm.clone()),\n                BUFFERS_DIR => Ok(s.buffer_nodes.stat().fm.clone()),\n                _ => match s.buffer_nodes.lookup_file_stat(parent_qid, child) {\n                    Some(stat) => Ok(stat.fm.clone()),\n                    None => Err(format!(\"{E_UNKNOWN_FILE}: {parent_qid} {child}\")),\n                },\n            },\n\n            qid if qid == BUFFERS_QID || s.buffer_nodes.is_known_buffer_qid(qid) => {\n                match s.buffer_nodes.lookup_file_stat(qid, child) {\n                    Some(stat) => Ok(stat.fm.clone()),\n                    None => Err(format!(\"{E_UNKNOWN_FILE}: {parent_qid} {child}\")),\n                }\n            }\n\n            _ => Err(format!(\"{E_UNKNOWN_FILE}: {parent_qid} {child}\")),\n        }\n    }\n\n    fn open(&self, cid: ClientId, qid: u64, mode: Mode, uname: &str) -> Result<IoUnit> {\n        trace!(?cid, %qid, %uname, ?mode, \"handling open request\");\n        let mut s = self.state.lock().unwrap();\n        s.buffer_nodes.update();\n\n        if qid == LOG_FILE_QID {\n            s.buffer_nodes.log.add_client(cid);\n        } else if !TOP_LEVEL_QIDS.contains(&qid)\n            && let QidCheck::Unknown = s.buffer_nodes.check_if_known_qid(qid)\n        {\n            return Err(format!(\"{E_UNKNOWN_FILE}: {qid}\"));\n        }\n\n        s.add_open_cid(qid, cid);\n\n        Ok(IO_UNIT)\n    }\n\n    fn clunk(&self, cid: ClientId, qid: u64) {\n        trace!(?cid, %qid, \"handling clunk request\");\n        let mut s = self.state.lock().unwrap();\n\n        if qid == LOG_FILE_QID {\n            s.buffer_nodes.log.remove_client(cid);\n        } else if let QidCheck::EventFile { buf_qid } = s.buffer_nodes.check_if_known_qid(qid)\n            && s.readlocked_cid(qid) == Some(cid)\n        {\n            s.buffer_nodes.clear_input_filter(buf_qid);\n        }\n        s.remove_open_cid(qid, cid); // also handles clearing the read lock\n    }\n\n    fn read(\n        &self,\n        cid: ClientId,\n        qid: u64,\n        offset: usize,\n        count: usize,\n        uname: &str,\n    ) -> Result<ReadOutcome> {\n        trace!(?cid, %qid, %offset, %count, %uname, \"handling read request\");\n        let mut s = self.state.lock().unwrap();\n        s.buffer_nodes.update();\n\n        if qid == CONTROL_FILE_QID {\n            return Ok(ReadOutcome::Immediate(Vec::new()));\n        } else if qid == MINIBUFFER_QID {\n            return Ok(s.minibuffer_read(offset, count));\n        } else if qid == SCRATCH_QID {\n            return Ok(s.scratch_read(offset, count));\n        } else if qid == LOG_FILE_QID {\n            return Ok(s.buffer_nodes.log.events_since_last_read(cid));\n        }\n\n        if let QidCheck::EventFile { buf_qid } = s.buffer_nodes.check_if_known_qid(qid) {\n            match s.readlocked_cid(qid) {\n                Some(id) if id == cid => (),\n                Some(_) => return Ok(ReadOutcome::Immediate(Vec::new())),\n                None => {\n                    trace!(\"attaching filter qid={qid} cid={cid:?}\");\n                    s.buffer_nodes.attach_input_filter(buf_qid)?;\n                    s.lock_qid_for_reading(qid, cid)?;\n                }\n            }\n        }\n\n        match s.buffer_nodes.get_file_content(qid, offset, count) {\n            InternalRead::Unknown => Err(format!(\"{E_UNKNOWN_FILE}: {qid}\")),\n            InternalRead::Immediate(content) => Ok(ReadOutcome::Immediate(content)),\n            InternalRead::Blocked(tx) => Ok(ReadOutcome::Blocked(tx)),\n        }\n    }\n\n    fn read_dir(&self, cid: ClientId, qid: u64, uname: &str) -> Result<Vec<Stat>> {\n        trace!(?cid, %qid, %uname, \"handling read dir request\");\n        let mut s = self.state.lock().unwrap();\n        s.buffer_nodes.update();\n\n        match qid {\n            MOUNT_ROOT_QID => Ok(vec![\n                s.log_file_stat.clone(),\n                s.minibuffer_stat.clone(),\n                s.scratch_stat.clone(),\n                s.control_file_stat.clone(),\n                s.buffer_nodes.stat().clone(),\n            ]),\n            BUFFERS_QID => Ok(s.buffer_nodes.top_level_stats()),\n            qid => s\n                .buffer_nodes\n                .buffer_level_stats(qid)\n                .ok_or_else(|| E_UNKNOWN_FILE.to_string()),\n        }\n    }\n\n    fn write(\n        &self,\n        cid: ClientId,\n        qid: u64,\n        offset: usize,\n        data: Vec<u8>,\n        uname: &str,\n    ) -> Result<usize> {\n        trace!(?cid, %qid, %offset, n_bytes=%data.len(), %uname, \"handling write request\");\n        let mut s = self.state.lock().unwrap();\n        s.buffer_nodes.update();\n\n        let n_bytes = data.len();\n        let str = match String::from_utf8(data.to_vec()) {\n            Ok(s) => s,\n            Err(e) => return Err(format!(\"Invalid data: {e}\")),\n        };\n\n        match qid {\n            CONTROL_FILE_QID => match str.strip_prefix(\"minibuffer-prompt \") {\n                Some(prompt) => {\n                    s.minibuffer_prompt = Some(prompt.to_string());\n                    Ok(n_bytes)\n                }\n                None => {\n                    s.control_file_stat.last_modified = SystemTime::now();\n                    match Message::send(Req::ControlMessage { msg: str }, &s.tx) {\n                        Ok(_) => Ok(n_bytes),\n                        Err(e) => Err(format!(\"unable to execute control message: {e}\")),\n                    }\n                }\n            },\n\n            MINIBUFFER_QID => s.minibuffer_write(str),\n            SCRATCH_QID => s.scratch_write(str),\n            CURRENT_BUFFER_QID => s.set_active_buffer(str),\n\n            LOG_FILE_QID | INDEX_BUFFER_QID => Err(E_NOT_ALLOWED.to_string()),\n\n            qid => s.buffer_nodes.write(qid, str, offset),\n        }\n    }\n\n    // TODO: allow remove of a buffer to close the buffer\n    fn remove(&self, cid: ClientId, qid: u64, uname: &str) -> Result<()> {\n        trace!(?cid, %qid, %uname, \"handling remove request\");\n        Err(\"remove not allowed\".to_string())\n    }\n\n    fn create(\n        &self,\n        cid: ClientId,\n        parent: u64,\n        name: &str,\n        perm: Perm,\n        mode: Mode,\n        uname: &str,\n    ) -> Result<(FileMeta, IoUnit)> {\n        trace!(?cid, %parent, %name, ?perm, ?mode, %uname, \"handling create request\");\n        Err(\"create not allowed\".to_string())\n    }\n}\n\nfn apply_offset(data: &[u8], offset: usize, count: usize) -> Vec<u8> {\n    data.iter()\n        .skip(offset)\n        .take(count)\n        .copied()\n        .collect::<Vec<u8>>()\n}\n\nfn empty_dir_stat(qid: u64, name: &str) -> Stat {\n    Stat {\n        fm: FileMeta::dir(name, qid),\n        perms: Perm::OWNER_READ | Perm::OWNER_EXEC,\n        n_bytes: 0,\n        last_accesses: SystemTime::now(),\n        last_modified: SystemTime::now(),\n        owner: \"ad\".into(),\n        group: \"ad\".into(),\n        last_modified_by: \"ad\".into(),\n    }\n}\n\nfn empty_file_stat(qid: u64, name: &str) -> Stat {\n    Stat {\n        fm: FileMeta::file(name, qid),\n        perms: Perm::OWNER_READ | Perm::OWNER_WRITE,\n        n_bytes: 0,\n        last_accesses: SystemTime::now(),\n        last_modified: SystemTime::now(),\n        owner: \"ad\".into(),\n        group: \"ad\".into(),\n        last_modified_by: \"ad\".into(),\n    }\n}\n", "source": "ad/src/fsys/mod.rs", "file_type": "rc"}
{"text": "//! A lightweight wrapper around the JSON RPC message protocol required for\n//! communicating with LSP servers.\n//!\n//! The implementation here is heavily inspired by the lsp-server module found in\n//! rust-analyzer: <https://github.com/rust-lang/rust-analyzer/tree/master/lib/lsp-server>\nuse lsp_types::NumberOrString;\nuse serde::{Deserialize, Deserializer, Serialize, Serializer};\nuse serde_json::Value;\nuse std::{\n    borrow::Cow,\n    io::{self, BufRead, Write},\n};\n\npub type RequestId = NumberOrString;\n\nfn invalid_data(error: impl Into<Box<dyn std::error::Error + Send + Sync>>) -> io::Error {\n    io::Error::new(io::ErrorKind::InvalidData, error)\n}\n\nmacro_rules! invalid_data {\n    ($($tt:tt)*) => (invalid_data(format!($($tt)*)))\n}\n\n/// The various message types supported in JSON rpc\n#[derive(Debug, Clone, Deserialize, Serialize, PartialEq, Eq)]\n#[serde(untagged)]\npub enum Message {\n    Request(Request),\n    Response(Response),\n    Notification(Notification),\n}\n\nimpl Message {\n    pub fn read(r: &mut impl BufRead) -> io::Result<Option<Self>> {\n        match read_msg(r)? {\n            Some(bytes) => match serde_json::from_slice(&bytes) {\n                Ok(msg) => Ok(Some(msg)),\n                Err(e) => Err(invalid_data!(\"malformed LSP message: {e:?}\")),\n            },\n            None => Ok(None),\n        }\n    }\n\n    pub fn write(self, w: &mut impl Write) -> io::Result<()> {\n        let data = serde_json::to_vec(&JsonRpc {\n            jsonrpc: \"2.0\",\n            msg: self,\n        })?;\n\n        write!(w, \"Content-Length: {}\\r\\n\\r\\n\", data.len())?;\n        w.write_all(&data)?;\n\n        return w.flush();\n\n        // Serde structs\n\n        #[derive(Serialize)]\n        struct JsonRpc {\n            jsonrpc: &'static str,\n            #[serde(flatten)]\n            msg: Message,\n        }\n    }\n}\n\nfn read_msg(r: &mut dyn BufRead) -> io::Result<Option<Vec<u8>>> {\n    let mut content_length: Option<usize> = None;\n    let mut buf = String::new();\n\n    // Consume all headers from an incoming message and parse the content length.\n    loop {\n        buf.clear();\n        if r.read_line(&mut buf)? == 0 {\n            return Ok(None);\n        }\n        if !buf.ends_with(\"\\r\\n\") {\n            return Err(invalid_data!(\"malformed header: {buf:?}\"));\n        } else if buf == \"\\r\\n\" {\n            break; // end of headers\n        }\n        match buf.trim().split_once(\": \") {\n            Some((h, v)) if h.eq_ignore_ascii_case(\"Content-Length\") => {\n                content_length = Some(v.parse().map_err(invalid_data)?);\n            }\n            Some(_) => (), // ignored header\n            None => return Err(invalid_data!(\"malformed header: {buf:?}\")),\n        }\n    }\n\n    match content_length {\n        None => Err(invalid_data!(\"no Content-Length header\")),\n        Some(len) => {\n            let mut buf = buf.into_bytes();\n            buf.resize(len, 0);\n            r.read_exact(&mut buf)?;\n\n            Ok(Some(buf))\n        }\n    }\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]\npub struct Notification {\n    pub method: Cow<'static, str>,\n    #[serde(default = \"Value::default\")]\n    #[serde(skip_serializing_if = \"Value::is_null\")]\n    pub params: Value,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]\npub struct Request {\n    pub id: RequestId,\n    pub method: Cow<'static, str>,\n    #[serde(default = \"Value::default\")]\n    #[serde(skip_serializing_if = \"Value::is_null\")]\n    pub params: Value,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]\n#[serde(untagged)]\npub enum Response {\n    Error { id: RequestId, error: ResponseError },\n    Result { id: RequestId, result: Value },\n}\n\nimpl Response {\n    pub fn id(&self) -> RequestId {\n        match self {\n            Self::Result { id, .. } => id.clone(),\n            Self::Error { id, .. } => id.clone(),\n        }\n    }\n\n    pub fn null_resp(id: RequestId) -> Self {\n        Self::Result {\n            id,\n            result: Value::Null,\n        }\n    }\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]\npub struct ResponseError {\n    pub code: ErrorCode,\n    pub message: String,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub data: Option<Value>,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum ErrorCode {\n    // Defined by JSON RPC:\n    ParseError,\n    InvalidRequest,\n    MethodNotFound,\n    InvalidParams,\n    InternalError,\n    ServerErrorStart,\n    ServerErrorEnd,\n\n    /// Error code indicating that a server received a notification or\n    /// request before the server has received the `initialize` request.\n    ServerNotInitialized,\n    Unknown,\n\n    // Defined by the protocol:\n    /// The client has canceled a request and a server has detected\n    /// the cancel.\n    RequestCancelled,\n\n    /// The server detected that the content of a document got\n    /// modified outside normal conditions. A server should\n    /// NOT send this error code if it detects a content change\n    /// in it unprocessed messages. The result even computed\n    /// on an older state might still be useful for the client.\n    ///\n    /// If a client decides that a result is not of any use anymore\n    /// the client should cancel the request.\n    ContentModified,\n\n    /// The server cancelled the request. This error code should\n    /// only be used for requests that explicitly support being\n    /// server cancellable.\n    ///\n    /// @since 3.17.0\n    ServerCancelled,\n\n    /// A request failed but it was syntactically correct, e.g the\n    /// method name was known and the parameters were valid. The error\n    /// message should contain human readable information about why\n    /// the request failed.\n    ///\n    /// @since 3.17.0\n    RequestFailed,\n\n    /// Catch-all for unknown custom error codes from servers\n    Custom(i32),\n}\n\nimpl Serialize for ErrorCode {\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: Serializer,\n    {\n        let val = match self {\n            Self::ParseError => -32700,\n            Self::InvalidRequest => -32600,\n            Self::MethodNotFound => -32601,\n            Self::InvalidParams => -32602,\n            Self::InternalError => -32603,\n            Self::ServerErrorStart => -32099,\n            Self::ServerErrorEnd => -32000,\n            Self::ServerNotInitialized => -32002,\n            Self::Unknown => -32001,\n            Self::RequestCancelled => -32800,\n            Self::ContentModified => -32801,\n            Self::ServerCancelled => -32802,\n            Self::RequestFailed => -32803,\n            Self::Custom(i) => *i,\n        };\n\n        serializer.serialize_i32(val)\n    }\n}\n\nimpl<'de> Deserialize<'de> for ErrorCode {\n    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n    where\n        D: Deserializer<'de>,\n    {\n        let val = match i32::deserialize(deserializer)? {\n            -32700 => Self::ParseError,\n            -32600 => Self::InvalidRequest,\n            -32601 => Self::MethodNotFound,\n            -32602 => Self::InvalidParams,\n            -32603 => Self::InternalError,\n            -32099 => Self::ServerErrorStart,\n            -32000 => Self::ServerErrorEnd,\n            -32002 => Self::ServerNotInitialized,\n            -32001 => Self::Unknown,\n            -32800 => Self::RequestCancelled,\n            -32801 => Self::ContentModified,\n            -32802 => Self::ServerCancelled,\n            -32803 => Self::RequestFailed,\n            i => Self::Custom(i),\n        };\n\n        Ok(val)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use serde_json::json;\n    use simple_test_case::test_case;\n    use std::io::BufReader;\n\n    fn rpc(val: serde_json::Value) -> String {\n        let s = serde_json::to_string(&val).unwrap();\n        let len = s.len();\n\n        format!(\"Content-Length: {len}\\r\\n\\r\\n{s}\")\n    }\n\n    #[test_case(\n        rpc(json!({ \"id\": 1, \"method\": \"foo\", \"params\": {\"foo\": \"bar\"} })),\n        Message::Request(Request {\n            id: RequestId::Number(1),\n            method: Cow::Borrowed(\"foo\"),\n            params: json!({\"foo\": \"bar\"}),\n        });\n        \"simple request\"\n    )]\n    #[test_case(\n        rpc(json!({ \"id\": 1, \"result\": {\"foo\": \"bar\"} })),\n        Message::Response(Response::Result {\n            id: RequestId::Number(1),\n            result: json!({\"foo\": \"bar\"}),\n        });\n        \"simple successful response\"\n    )]\n    #[test_case(\n        rpc(json!({\n            \"id\": 1,\n            \"error\": {\n                \"code\": -32600,\n                \"message\": \"invalid\",\n                \"data\": {\"foo\": \"bar\"}\n            }\n        })),\n        Message::Response(Response::Error {\n            id: RequestId::Number(1),\n            error: ResponseError {\n                code: ErrorCode::InvalidRequest,\n                message: \"invalid\".to_owned(),\n                data: Some(json!({\"foo\": \"bar\"})),\n            }\n        });\n        \"simple error response with data\"\n    )]\n    #[test_case(\n        rpc(json!({\n            \"id\": 1,\n            \"error\": {\n                \"code\": -32600,\n                \"message\": \"invalid\",\n            }\n        })),\n        Message::Response(Response::Error {\n            id: RequestId::Number(1),\n            error: ResponseError {\n                code: ErrorCode::InvalidRequest,\n                message: \"invalid\".to_owned(),\n                data: None,\n            }\n        });\n        \"simple error response without data\"\n    )]\n    #[test_case(\n        rpc(json!({ \"method\": \"foo\", \"params\": {\"foo\": \"bar\"} })),\n        Message::Notification(Notification {\n            method: Cow::Borrowed(\"foo\"),\n            params: json!({\"foo\": \"bar\"}),\n        });\n        \"simple notification\"\n    )]\n    #[test]\n    fn read_message(s: String, expected: Message) {\n        let m = Message::read(&mut BufReader::new(s.as_bytes()))\n            .unwrap()\n            .unwrap();\n\n        assert_eq!(m, expected);\n    }\n\n    #[test_case(ErrorCode::ParseError; \"parse error\")]\n    #[test_case(ErrorCode::InvalidRequest; \"invalid request\")]\n    #[test_case(ErrorCode::MethodNotFound; \"method not found\")]\n    #[test_case(ErrorCode::InvalidParams; \"invalid params\")]\n    #[test_case(ErrorCode::InternalError; \"internal error\")]\n    #[test_case(ErrorCode::ServerErrorStart; \"server error start\")]\n    #[test_case(ErrorCode::ServerErrorEnd; \"server error end\")]\n    #[test_case(ErrorCode::ServerNotInitialized; \"server not initialized\")]\n    #[test_case(ErrorCode::Unknown; \"unknown\")]\n    #[test_case(ErrorCode::RequestCancelled; \"request cancelled\")]\n    #[test_case(ErrorCode::ContentModified; \"content modified\")]\n    #[test_case(ErrorCode::ServerCancelled; \"server cancelled\")]\n    #[test_case(ErrorCode::RequestFailed; \"request failed\")]\n    #[test_case(ErrorCode::Custom(42); \"custom\")]\n    #[test]\n    fn error_code_serde_round_trip(e: ErrorCode) {\n        let s = serde_json::to_string(&e).unwrap();\n        let parsed: ErrorCode = serde_json::from_str(&s).unwrap();\n\n        assert_eq!(parsed, e);\n    }\n}\n", "source": "ad/src/lsp/rpc.rs", "file_type": "rc"}
{"text": "//! Traits and handlers for processing LSP messages\nuse crate::{\n    editor::Action,\n    lsp::{Coords, capabilities::PositionEncoding},\n};\nuse lsp_types::{Position, TextDocumentIdentifier, TextDocumentPositionParams, TextEdit, Uri};\nuse std::str::FromStr;\n\nmod notification;\nmod request;\nmod server_notification;\nmod server_request;\n\npub(super) use notification::{LspNotification, PreparedLspNotification};\npub(super) use request::{LspRequest, OpenDocument, PendingLspRequest, PreparedLspRequest};\npub(super) use server_notification::{Diagnostic, Diagnostics, NotificationHandler};\npub(super) use server_request::RequestHandler;\n\n#[inline]\nfn txtdoc_pos(file: &str, line: u32, character: u32) -> TextDocumentPositionParams {\n    TextDocumentPositionParams {\n        text_document: txt_doc_id(file),\n        position: Position { line, character },\n    }\n}\n\n#[inline]\npub(crate) fn txt_doc_id(path: &str) -> TextDocumentIdentifier {\n    TextDocumentIdentifier { uri: uri(path) }\n}\n\n#[inline]\nfn uri(path: &str) -> Uri {\n    Uri::from_str(&format!(\"file://{path}\")).unwrap()\n}\n\n// From the spec:\n// ```\n// interface TextEdit {\n//    /**\n// \t   * The range of the text document to be manipulated. To insert\n// \t   * text into a document create a range where start === end.\n// \t   */\n//     range: Range;\n//\n//    /**\n// \t   * The string to be inserted. For delete operations use an\n// \t   * empty string.\n// \t   */\n//     newText: string;\n// }\n//\n// Complex text manipulations are described with an array of TextEdit\u2019s or AnnotatedTextEdit\u2019s,\n// representing a single change to the document.\n//\n// All text edits ranges refer to positions in the document they are computed on. They therefore\n// move a document from state S1 to S2 without describing any intermediate state. Text edits ranges\n// must never overlap, that means no part of the original document must be manipulated by more than\n// one edit. However, it is possible that multiple edits have the same start position: multiple\n// inserts, or any number of inserts followed by a single remove or replace edit. If multiple\n// inserts have the same position, the order in the array defines the order in which the inserted\n// strings appear in the resulting text.\n// ```\n//\n// And then the kicker, the docs for TextDocumentEdit (rather than TextEdit):\n// ```\n// A TextDocumentEdit describes all changes on a version Si and after they are applied move the\n// document to version Si+1. So the creator of a TextDocumentEdit doesn\u2019t need to sort the array of\n// edits or do any kind of ordering. However the edits must be non overlapping.\n// ```\n\n#[derive(Debug)]\npub(crate) struct EditAction {\n    pub(crate) coords: Coords,\n    pub(crate) s: String,\n    pub(crate) use_xdot: bool,\n}\n\nimpl EditAction {\n    pub(crate) fn into_actions(\n        EditAction {\n            coords,\n            s,\n            use_xdot,\n        }: EditAction,\n    ) -> [Action; 2] {\n        if use_xdot {\n            [\n                Action::XDotSetFromCoords { coords },\n                Action::XInsertString { s },\n            ]\n        } else {\n            [\n                Action::DotSetFromCoords { coords },\n                Action::InsertString { s },\n            ]\n        }\n    }\n\n    pub(crate) fn from_text_edit(edit: TextEdit, enc: PositionEncoding) -> Self {\n        Self {\n            coords: Coords::new_from_range(edit.range, enc),\n            s: edit.new_text,\n            use_xdot: true,\n        }\n    }\n\n    pub(crate) fn using_dot(mut self) -> Self {\n        self.use_xdot = false;\n        self\n    }\n}\n\n/// From the docs on TextEdit:\n///   If n TextEdits are applied to a text document all text edits describe changes to the initial\n///   document version. Execution wise text edits should applied from the bottom to the top of the\n///   text document. Overlapping text edits are not supported.\n///\n/// Also see <https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#textEditArray>\npub(crate) fn edit_actions_as_editor_actions(mut edit_actions: Vec<EditAction>) -> Vec<Action> {\n    edit_actions.sort_by_key(|a| a.coords);\n    edit_actions.reverse();\n\n    edit_actions\n        .into_iter()\n        .flat_map(EditAction::into_actions)\n        .collect()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::{buffer::Buffer, lsp::capabilities::PositionEncoding};\n    use ad_event::Source;\n    use lsp_types::{Position, Range, TextEdit};\n    use simple_test_case::test_case;\n\n    // The first \"blank\" line here contains leading whitespace\n    const TEST_BUF: &str = r#\"fn test() {\n    for x in 0..10 {\n        println!(\"X is {x}\");\n        println!(\"Another line\");\n        \n\n\n        println!(\"Yet another line\");\n    }\n}\"#;\n\n    const EXPECTED: &str = r#\"fn test() {\n    for x in 0..10 {\n        println!(\"X is {x}\");\n        println!(\"Another line\");\n        println!(\"Yet another line\");\n    }\n}\"#;\n\n    const TEST_BUF_2: &str = r#\"use crate::{\n    dot::{\n    Cur, Dot, Range, TextObject, find::find_forward_wrapping},\n};\n\nfn main() {}\"#;\n\n    const EXPECTED_2: &str = r#\"use crate::dot::{Cur, Dot, Range, TextObject, find::find_forward_wrapping};\n\nfn main() {}\"#;\n\n    #[test_case(\n        TEST_BUF, EXPECTED,\n        vec![TextEdit {\n            range: Range {\n                start: Position { line: 4, character: 0 },\n                end: Position { line: 6, character: 0 },\n            },\n            new_text: \"\".to_string(),\n        }];\n        \"blank lines being removed\"\n    )]\n    #[test_case(\n        TEST_BUF_2, EXPECTED_2,\n        vec![\n            TextEdit {\n                range: Range {\n                    start: Position { line: 0, character: 11 },\n                    end: Position { line: 1, character: 4 }\n                },\n                new_text: \"\".to_string(),\n            },\n            TextEdit {\n                range: Range {\n                    start: Position { line: 1, character: 10 },\n                    end: Position { line: 2, character: 4 }\n                },\n                new_text: \"\".to_string(),\n            },\n            TextEdit {\n                range: Range {\n                    start: Position { line: 2, character: 60 },\n                    end: Position { line: 3, character: 0 }\n                },\n                new_text: \"\".to_string(),\n            }\n        ];\n        \"joining lines\"\n    )]\n    #[test_case(\n        \"hello world\",\n        \"helloworld\",\n        vec![TextEdit {\n            range: Range {\n                start: Position { line: 0, character: 5 },\n                end: Position { line: 0, character: 6 }\n            },\n            new_text: \"\".to_string(),\n        }];\n        \"single char deletion\"\n    )]\n    #[test]\n    fn format_actions_work_when_blank_lines_are_involved(\n        content: &str,\n        expected: &str,\n        text_edits: Vec<TextEdit>,\n    ) {\n        let mut b = Buffer::new_virtual(0, \"test\", content, Default::default());\n\n        let actions = edit_actions_as_editor_actions(\n            text_edits\n                .into_iter()\n                .map(|edit| EditAction::from_text_edit(edit, PositionEncoding::Utf32))\n                .collect(),\n        );\n\n        for action in actions {\n            b.handle_action(action, Source::Fsys);\n        }\n\n        assert_eq!(b.str_contents(), expected);\n    }\n\n    // This is a regression test for some broken behaviour that I was able to pin down to being\n    // related to how the LSP spec handles TextEdits. Annoyingly, there is no built in way to\n    // delete, only insert: so LSP servers send edit ranges where start == end along with an empty\n    // string as the insert text.\n    // This...does not play well with how ad likes to handle ranges and inserts. The buggy\n    // behaviour was that the line ending `println!(\"{ones:?}\");` ended with an additional `}`\n    // because rust-analyzer decided to delete that curly and insert a new one on the line below\n    // for some reason.\n    // The TextEdits used as the inputs here are ones captured from logging in the `handle_res`\n    // method above prior to the fix.\n\n    // NOTE: some of the blank lines here have trailing whitespace that is required for the test to\n    // run successfully\n    const BEFORE: &str = r#\"fn main() {\n    println!(\"Hello, world!\");\n\n    match \"this\" {\n        \"some\" => {\n            for x in 0..10 { let ones: Vec<usize> = std::iter::repeat(1)            .take(x).collect();             println!(\"{ones:?}\");}\n        }\n        \n        \"that\" => println!(\"not here\"),\n        \n        \"this\" => println!(\"here\"),\n    }\n}\n\"#;\n\n    const AFTER: &str = r#\"fn main() {\n    println!(\"Hello, world!\");\n\n    match \"this\" {\n        \"some\" => {\n            for x in 0..10 {\n                let ones: Vec<usize> = std::iter::repeat(1).take(x).collect();\n                println!(\"{ones:?}\");\n            }\n        }\n\n        \"that\" => println!(\"not here\"),\n\n        \"this\" => println!(\"here\"),\n    }\n}\n\"#;\n\n    #[test]\n    fn regression_lsp_delete_single_char() {\n        #[rustfmt::skip]\n        let text_edits = vec![\n            TextEdit { range: Range { start: Position { line: 5, character: 28 }, end: Position { line: 5, character: 28 } }, new_text: \"\\n               \".into() },\n            TextEdit { range: Range { start: Position { line: 5, character: 72 }, end: Position { line: 5, character: 84 } }, new_text: \"\".into() },\n            TextEdit { range: Range { start: Position { line: 5, character: 103 }, end: Position { line: 5, character: 103 } }, new_text: \"\\n \".into() },\n            TextEdit { range: Range { start: Position { line: 5, character: 116 }, end: Position { line: 5, character: 116 } }, new_text: \"  \".into() },\n            TextEdit { range: Range { start: Position { line: 5, character: 137 }, end: Position { line: 5, character: 138 } }, new_text: \"\".into() },\n            TextEdit { range: Range { start: Position { line: 6, character: 0 }, end: Position { line: 6, character: 0 } }, new_text: \"   \".into() },\n            TextEdit { range: Range { start: Position { line: 6, character: 8 }, end: Position { line: 6, character: 8 } }, new_text: \" \".into() },\n            TextEdit { range: Range { start: Position { line: 7, character: 8 }, end: Position { line: 7, character: 8 } }, new_text: \"}\\n\".into() },\n            TextEdit { range: Range { start: Position { line: 9, character: 0 }, end: Position { line: 9, character: 8 } }, new_text: \"\".into() }\n        ];\n\n        let mut b = Buffer::new_unnamed(0, BEFORE, Default::default());\n        let actions = edit_actions_as_editor_actions(\n            text_edits\n                .into_iter()\n                .map(|edit| EditAction::from_text_edit(edit, PositionEncoding::Utf32))\n                .collect(),\n        );\n\n        for action in actions {\n            b.handle_action(action, Source::Fsys);\n        }\n\n        assert_eq!(b.str_contents(), AFTER);\n    }\n}\n", "source": "ad/src/lsp/messages/mod.rs", "file_type": "rc"}
{"text": "use crate::{\n    buffer::Buffers,\n    die,\n    dot::{Cur, Dot, Range},\n    editor::{Action, Actions, MbSelect, MbSelector, MiniBufferSelection},\n    lsp::{\n        LspManager, Pos, PositionEncoding, PreparedMessage, Req,\n        capabilities::Coords,\n        messages::{EditAction, edit_actions_as_editor_actions, request::LspRequest, txtdoc_pos},\n    },\n};\nuse lsp_types::{\n    CompletionContext, CompletionItem, CompletionParams, CompletionResponse, CompletionTextEdit,\n    CompletionTriggerKind, request as req,\n};\nuse std::sync::mpsc::Sender;\nuse tracing::{error, trace};\n\n/// <https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#textDocument_completion>\nimpl LspRequest for req::Completion {\n    type Data = Pos;\n    type Pending = Pos;\n\n    fn build_params(\n        Pos {\n            file,\n            line,\n            character,\n        }: Self::Data,\n    ) -> Self::Params {\n        CompletionParams {\n            text_document_position: txtdoc_pos(&file, line, character),\n            work_done_progress_params: Default::default(),\n            partial_result_params: Default::default(),\n            context: Some(CompletionContext {\n                // We only support explicit explicitly invoked completions rather than always-on\n                // auto-complete firing for each character that the user types\n                trigger_kind: CompletionTriggerKind::INVOKED,\n                trigger_character: None,\n            }),\n        }\n    }\n\n    fn handle_res(\n        lsp_id: usize,\n        resp: Option<CompletionResponse>,\n        pos: Pos,\n        man: &mut LspManager,\n    ) -> Option<Actions> {\n        let enc = man.clients.get(&lsp_id)?.position_encoding;\n        let items = match resp? {\n            CompletionResponse::List(l) => l.items,\n            CompletionResponse::Array(items) => items,\n        };\n\n        let completions: Vec<_> = items\n            .into_iter()\n            .map(|item| Completion::new(item, pos.clone(), enc, lsp_id, &man.tx_req))\n            .collect();\n\n        Some(Actions::Single(Action::MbSelect(\n            Completions(completions).into_selector(),\n        )))\n    }\n}\n\n#[derive(Debug, Clone)]\nstruct Completion {\n    comp_item: CompletionItem,\n    actions: CompletionAction,\n    kind: String,\n}\n\n#[derive(Debug, Clone)]\nenum CompletionAction {\n    Resolve(Pos, usize, Sender<Req>),\n    Actions(Actions),\n}\n\nimpl Completion {\n    fn new(\n        comp_item: CompletionItem,\n        pos: Pos,\n        enc: PositionEncoding,\n        lsp_id: usize,\n        tx_req: &Sender<Req>,\n    ) -> Self {\n        let kind = comp_item.kind.map(|k| format!(\"{k:?}\")).unwrap_or_default();\n\n        // Some LSP servers will defer computing data for additional edits until explicitly\n        // requested by the client using completionItem/resolve. If the \"data\" field is\n        // non-null then this is an indicator that we need to make the resolve request (the\n        // data inside of the \"data\" field itself is only intended for use by the LSP\n        // server itself in order to resolve the request so we shouldn't be doing anything\n        // with it other than passing it back).\n        let actions = if comp_item.data.is_some() {\n            CompletionAction::Resolve(pos, lsp_id, tx_req.clone())\n        } else {\n            CompletionAction::Actions(actions_for_resolved_completion_item(\n                comp_item.clone(),\n                pos,\n                enc,\n            ))\n        };\n\n        Self {\n            comp_item,\n            actions,\n            kind,\n        }\n    }\n\n    fn mb_line(&self, label_width: usize, kind_width: usize) -> String {\n        format!(\n            \"{:<label_width$} {:<kind_width$}  {}\",\n            self.comp_item.label,\n            self.kind,\n            self.comp_item.detail.as_deref().unwrap_or_default(),\n            label_width = label_width,\n            kind_width = kind_width\n        )\n    }\n}\n\n#[derive(Debug, Clone)]\npub struct Completions(Vec<Completion>);\n\nimpl MbSelect for Completions {\n    fn clone_selector(&self) -> MbSelector {\n        self.clone().into_selector()\n    }\n\n    /// The initial filter input we want is the \"word\" so far under the cursor.\n    fn initial_input(&self, buffers: &Buffers) -> Option<String> {\n        let b = buffers.active();\n        let cur = b.dot.active_cur();\n\n        // find the start of the \"word\" we are on\n        let offset = b\n            .rev_iter_between_chars(cur.idx, 0)\n            .take_while(|(_, ch)| ch.is_alphanumeric() || *ch == '_')\n            .count();\n        let start = Cur {\n            idx: cur.idx - offset,\n        };\n        let r = Range::from_cursors(start, cur, false);\n        let input = Dot::from(r).content(b);\n\n        match input.chars().next() {\n            Some(ch) if ch.is_alphanumeric() => Some(input),\n            _ => None,\n        }\n    }\n\n    fn prompt_and_options(&self, _buffers: &Buffers) -> (String, Vec<String>) {\n        let width = |f: fn(&Completion) -> usize| self.0.iter().map(f).max().unwrap_or_default();\n        let label_width = width(|c| c.comp_item.label.chars().count());\n        let kind_width = width(|c| c.kind.chars().count());\n\n        (\n            \"Completions> \".to_owned(),\n            self.0\n                .iter()\n                .map(|c| c.mb_line(label_width, kind_width))\n                .collect(),\n        )\n    }\n\n    fn selected_actions(&self, sel: MiniBufferSelection) -> Option<Actions> {\n        match sel {\n            MiniBufferSelection::Line { cy, .. } => {\n                self.0.get(cy).and_then(|c| match c.actions.clone() {\n                    CompletionAction::Actions(actions) => {\n                        trace!(\"Completion actions: {actions:#?}\");\n                        Some(actions)\n                    }\n\n                    CompletionAction::Resolve(pos, lsp_id, tx_req) => {\n                        trace!(\"Resolving additional edit actions for completion\");\n                        let msg =\n                            PreparedMessage::Request(Box::new(req::ResolveCompletionItem::data(\n                                lsp_id,\n                                Box::new(c.comp_item.clone()),\n                                pos,\n                            )));\n\n                        let req = Req::Prepared(msg);\n                        if let Err(e) = tx_req.send(req) {\n                            die!(\"LSP manager died: {e}\")\n                        }\n\n                        None\n                    }\n                })\n            }\n\n            _ => None,\n        }\n    }\n}\n\n// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#completionItem_resolve\n//\n// We need to resolve both the completion itself and any additional edits as we didn't make any\n// modifications to buffer state as part of resolving the original completion item when there are\n// additional actions to resolve.\nimpl LspRequest for req::ResolveCompletionItem {\n    type Data = Box<CompletionItem>;\n    type Pending = Pos;\n\n    fn build_params(item: Self::Data) -> Self::Params {\n        *item\n    }\n\n    fn handle_res(\n        lsp_id: usize,\n        comp_item: CompletionItem,\n        pos: Pos,\n        man: &mut LspManager,\n    ) -> Option<Actions> {\n        let enc = man.clients.get(&lsp_id)?.position_encoding;\n        let actions = actions_for_resolved_completion_item(comp_item, pos, enc);\n\n        trace!(\"Resolved completion actions: {actions:#?}\");\n\n        Some(actions)\n    }\n}\n\n/// Once a completion item is fully resolved (no `data` field or following a completionItem/resolve\n/// request) we need to combine the edits both from the primary edit itself and any additional\n/// edits that are given.\n///\n/// Each TextEdit is a single edit to the current buffer. \"Additional edits\" need to be made via\n/// the xdot as the LSP protocol specifies that they are edits that need to be made to the file\n/// without affecting the editor's cursor position. Annoyingly the protocol doesn't provide any\n/// mechanism for specifying the final cursor position following a multi-part edit like this so\n/// we're left to figure out the correct final cursor position ourselves.\nfn actions_for_resolved_completion_item(\n    comp_item: CompletionItem,\n    pos: Pos,\n    enc: PositionEncoding,\n) -> Actions {\n    let mut edit_actions = match comp_item.text_edit {\n        Some(CompletionTextEdit::Edit(edit)) => {\n            vec![EditAction::from_text_edit(edit, enc).using_dot()]\n        }\n\n        Some(CompletionTextEdit::InsertAndReplace(_)) => {\n            error!(\"Unexpected InsertAndReplace response from LSP\");\n            Vec::new()\n        }\n\n        None => {\n            // From the LSP spec docs on the insertText field:\n            // \t A string that should be inserted into a document when selecting\n            //   this completion. When omitted the label is used as the insert text\n            //   for this item.\n            vec![EditAction {\n                coords: Coords::new_from_pos(pos, enc),\n                s: comp_item\n                    .insert_text\n                    .clone()\n                    .unwrap_or_else(|| comp_item.label.clone()),\n                use_xdot: false,\n            }]\n        }\n    };\n\n    edit_actions.extend(\n        comp_item\n            .additional_text_edits\n            .unwrap_or_default()\n            .into_iter()\n            .map(|edit| EditAction::from_text_edit(edit, enc)),\n    );\n\n    let actions = edit_actions_as_editor_actions(edit_actions);\n\n    Actions::Multi(actions)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use ad_event::Source;\n    use simple_test_case::test_case;\n    use std::sync::mpsc::channel;\n\n    #[test_case(\"foo\", Some(\"foo\"); \"alphanum\")]\n    #[test_case(\"foo::\", None; \"punctuation following alphanum\")]\n    #[test_case(\"foo::bar\", Some(\"bar\"); \"alphanum following punctuation\")]\n    #[test_case(\"completions.\", None; \"dot following identifier\")]\n    #[test_case(\"completions.f\", Some(\"f\"); \"alphanum following dot\")]\n    #[test]\n    fn mb_completions_initial_input(s: &str, expected: Option<&str>) {\n        let (tx, _rx) = channel();\n        let completions = Completions(Vec::new());\n        let mut buffers = Buffers::new_stubbed(&[1], tx, Default::default());\n        buffers\n            .active_mut()\n            .handle_action(Action::InsertString { s: s.to_string() }, Source::Fsys);\n\n        let initial_input = completions.initial_input(&buffers);\n\n        assert_eq!(initial_input.as_deref(), expected);\n    }\n}\n", "source": "ad/src/lsp/messages/request/completion.rs", "file_type": "rc"}
{"text": "//! The raw parsing structs for reading a config file from disk before validating it and converting\n//! it into our internal data types.\nuse crate::{\n    config::{\n        ColorScheme, Config, DEFAULT_CONFIG, EditorConfig, FsysConfig, FtypeConfig, KeyBindings,\n        LspConfig, TsConfig,\n    },\n    syntax::{TK_DEFAULT, TK_DOT, TK_EXEC, TK_LOAD},\n    term::{Color, Styles},\n};\nuse serde::{Deserialize, de::DeserializeOwned};\nuse std::{\n    collections::HashMap,\n    fs, io,\n    path::{Path, PathBuf},\n};\nuse toml::Table;\n\n#[derive(Debug, PartialEq, Deserialize)]\npub(super) struct RawConfig {\n    editor: Option<RawEditorConfig>,\n    filesystem: Option<FsysConfig>,\n    tree_sitter: Option<TsConfig>,\n    colorscheme: Option<PathOrStruct<RawColorScheme>>,\n    filetypes: Option<PathOrStruct<HashMap<String, RawLangConfig>>>,\n    keys: Option<PathOrStruct<KeyBindings>>,\n}\n\nimpl Default for RawConfig {\n    fn default() -> Self {\n        toml::from_str(DEFAULT_CONFIG).unwrap()\n    }\n}\n\nimpl RawConfig {\n    /// Resolve the config that we need for running the editor and report any errors that\n    /// resulted in defaults being used.\n    pub(super) fn resolve(self, config_path: &str, home: &str) -> Result<Config, String> {\n        let mut errs = Vec::new();\n        let phome = PathBuf::from(home);\n        let config_path = PathBuf::from(config_path);\n        let config_dir = config_path.parent().unwrap();\n\n        let editor = self.editor.map(|raw| raw.resolve()).unwrap_or_default();\n        let filesystem = self.filesystem.unwrap_or_default();\n        let tree_sitter = self.tree_sitter.unwrap_or_default();\n        let colorscheme = self\n            .colorscheme\n            .unwrap_or_default()\n            .into_inner(config_dir, &phome, &mut errs)\n            .resolve(&mut errs);\n        let raw_filetypes = self\n            .filetypes\n            .map(|pos| pos.into_inner(config_dir, &phome, &mut errs))\n            .unwrap_or_default();\n\n        let filetypes = raw_filetypes\n            .into_iter()\n            .map(|(ftype, raw)| {\n                let conf = raw.resolve(config_dir, &phome, &mut errs);\n                (ftype, conf)\n            })\n            .collect();\n\n        let keys = self\n            .keys\n            .map(|pos| pos.into_inner(config_dir, &phome, &mut errs))\n            .unwrap_or_default();\n\n        if !errs.is_empty() {\n            return Err(errs.join(\"\\n\"));\n        }\n\n        let mut cfg = Config {\n            editor,\n            filesystem,\n            tree_sitter,\n            colorscheme,\n            filetypes,\n            keys,\n        };\n\n        // Use default colorscheme's background color if none is specified\n        for style in cfg.colorscheme.syntax.values_mut() {\n            style.fg = style.fg.or(Some(cfg.colorscheme.fg));\n            style.bg = style.bg.or(Some(cfg.colorscheme.bg));\n        }\n\n        // Replace \"~/\" shorthand notation in paths with the user's $HOME\n        for s in [\n            &mut cfg.tree_sitter.parser_dir,\n            &mut cfg.tree_sitter.syntax_query_dir,\n        ] {\n            if s.starts_with(\"~/\") {\n                *s = s.replacen(\"~\", home, 1);\n            }\n        }\n\n        Ok(cfg)\n    }\n}\n\n#[derive(Debug, Clone, PartialEq, Deserialize)]\nstruct RawEditorConfig {\n    show_splash: Option<bool>,\n    tabstop: Option<usize>,\n    expand_tab: Option<bool>,\n    match_indent: Option<bool>,\n    lsp_autostart: Option<bool>,\n    status_timeout: Option<u64>,\n    double_click_ms: Option<u64>,\n    minibuffer_lines: Option<usize>,\n    find_command: Option<String>,\n}\n\nmacro_rules! set_if_some {\n    ($field:ident, $raw:ident, $cfg:ident) => {\n        if let Some(val) = $raw.$field {\n            $cfg.$field = val;\n        }\n    };\n}\n\nimpl RawEditorConfig {\n    fn resolve(self) -> EditorConfig {\n        let mut cfg = EditorConfig::default();\n        set_if_some!(show_splash, self, cfg);\n        set_if_some!(tabstop, self, cfg);\n        set_if_some!(expand_tab, self, cfg);\n        set_if_some!(match_indent, self, cfg);\n        set_if_some!(lsp_autostart, self, cfg);\n        set_if_some!(status_timeout, self, cfg);\n        set_if_some!(double_click_ms, self, cfg);\n        set_if_some!(minibuffer_lines, self, cfg);\n        set_if_some!(find_command, self, cfg);\n\n        cfg\n    }\n}\n\n#[derive(Debug, Clone, PartialEq, Deserialize)]\npub(super) struct RawColorScheme {\n    #[serde(default)]\n    palette: HashMap<String, Color>,\n    bg: String,\n    fg: String,\n    bar_bg: String,\n    signcol_fg: String,\n    minibuffer_hl: String,\n    syntax: HashMap<String, RawStyles>,\n}\n\nimpl Default for RawColorScheme {\n    fn default() -> Self {\n        let bg = \"#1B1720\".to_string();\n        let fg = \"#E6D29E\".to_string();\n        let dot_bg = \"#336677\".to_string();\n        let load_bg = \"#957FB8\".to_string();\n        let exec_bg = \"#Bf616A\".to_string();\n        let comment = \"#624354\".to_string();\n        let constant = \"#FF9E3B\".to_string();\n        let function = \"#957FB8\".to_string();\n        let keyword = \"#Bf616A\".to_string();\n        let module = \"#2D4F67\".to_string();\n        let punctuation = \"#9CABCA\".to_string();\n        let string = \"#61DCA5\".to_string();\n        let type_ = \"#7E9CD8\".to_string();\n        let variable = \"#DCA561\".to_string();\n\n        #[rustfmt::skip]\n        let syntax = [\n            (TK_DEFAULT,    RawStyles { fg: Some(fg.clone()), bg: Some(bg.clone()), ..Default::default() }),\n            (TK_DOT,        RawStyles { fg: Some(fg.clone()), bg: Some(dot_bg), ..Default::default() }),\n            (TK_LOAD,       RawStyles { fg: Some(fg.clone()), bg: Some(load_bg), ..Default::default() }),\n            (TK_EXEC,       RawStyles { fg: Some(fg.clone()), bg: Some(exec_bg), ..Default::default() }),\n            (\"character\",   RawStyles { fg: Some(string.clone()), bold: true, ..Default::default() }),\n            (\"comment\",     RawStyles { fg: Some(comment), italic: true, ..Default::default() }),\n            (\"constant\",    RawStyles { fg: Some(constant), ..Default::default() }),\n            (\"function\",    RawStyles { fg: Some(function), ..Default::default() }),\n            (\"keyword\",     RawStyles { fg: Some(keyword), ..Default::default() }),\n            (\"module\",      RawStyles { fg: Some(module), ..Default::default() }),\n            (\"punctuation\", RawStyles { fg: Some(punctuation), ..Default::default() }),\n            (\"string\",      RawStyles { fg: Some(string), ..Default::default() }),\n            (\"type\",        RawStyles { fg: Some(type_), ..Default::default() }),\n            (\"variable\",    RawStyles { fg: Some(variable), ..Default::default() }),\n        ]\n        .map(|(s, v)| (s.to_string(), v))\n        .into_iter()\n        .collect();\n\n        Self {\n            palette: Default::default(),\n            bg,\n            fg,\n            bar_bg: \"#4E415C\".to_string(),\n            signcol_fg: \"#544863\".to_string(),\n            minibuffer_hl: \"#3E3549\".to_string(),\n            syntax,\n        }\n    }\n}\n\nimpl RawColorScheme {\n    /// Attempt to map all palette references into colors and parse raw hex color strings.\n    /// The concatenation of all encountered errors are returned in the event of there being\n    /// any parse errors rather than short circuiting at the first error.\n    pub(super) fn resolve(self, errs: &mut Vec<String>) -> ColorScheme {\n        ColorScheme {\n            bg: try_color(&self.bg, &self.palette, errs),\n            fg: try_color(&self.fg, &self.palette, errs),\n            bar_bg: try_color(&self.bar_bg, &self.palette, errs),\n            signcol_fg: try_color(&self.signcol_fg, &self.palette, errs),\n            minibuffer_hl: try_color(&self.minibuffer_hl, &self.palette, errs),\n            syntax: self\n                .syntax\n                .into_iter()\n                .map(|(k, v)| {\n                    (\n                        k,\n                        Styles {\n                            fg: v.fg.map(|s| try_color(&s, &self.palette, errs)),\n                            bg: v.bg.map(|s| try_color(&s, &self.palette, errs)),\n                            bold: v.bold,\n                            italic: v.italic,\n                            underline: v.underline,\n                        },\n                    )\n                })\n                .collect(),\n        }\n    }\n}\n\nfn try_color(s: &String, palette: &HashMap<String, Color>, errs: &mut Vec<String>) -> Color {\n    if let Some(color) = palette.get(s) {\n        return *color;\n    }\n\n    match Color::try_from(s.as_ref()) {\n        Ok(color) => color,\n        Err(e) => {\n            errs.push(e);\n            Color::default()\n        }\n    }\n}\n\n#[derive(Debug, Default, Clone, PartialEq, Deserialize)]\nstruct RawStyles {\n    #[serde(default)]\n    fg: Option<String>,\n    #[serde(default)]\n    bg: Option<String>,\n    #[serde(default)]\n    bold: bool,\n    #[serde(default)]\n    italic: bool,\n    #[serde(default)]\n    underline: bool,\n}\n\n#[derive(Debug, Default, Clone, PartialEq, Eq, Deserialize)]\npub struct RawLangConfig {\n    #[serde(default)]\n    pub extensions: Vec<String>,\n    #[serde(default)]\n    pub first_lines: Vec<String>,\n    #[serde(default)]\n    pub filenames: Vec<String>,\n    #[serde(default)]\n    pub re_syntax: Option<String>,\n    #[serde(default)]\n    pub lsp: Option<LspConfig>,\n}\n\nimpl RawLangConfig {\n    fn resolve(self, config_path: &Path, home: &Path, errs: &mut Vec<String>) -> FtypeConfig {\n        let re_syntax = match self.re_syntax {\n            None => Vec::new(),\n            Some(path) => match try_read::<Table>(&path, config_path, home) {\n                Err(e) => {\n                    errs.push(format!(\"  {path}: {e}\"));\n                    Vec::new()\n                }\n                Ok(table) => {\n                    let mut pairs = Vec::with_capacity(table.len());\n                    for (k, v) in table.into_iter() {\n                        match v.as_str() {\n                            Some(s) => pairs.push((k, s.to_string())),\n                            None => {\n                                errs.push(format!(\n                                    \"  invalid re syntax for key {k}: value must be a string\"\n                                ));\n                                pairs.clear();\n                                break;\n                            }\n                        }\n                    }\n\n                    pairs\n                }\n            },\n        };\n\n        FtypeConfig {\n            extensions: self.extensions,\n            first_lines: self.first_lines,\n            filenames: self.filenames,\n            re_syntax,\n            lsp: self.lsp,\n        }\n    }\n}\n\n/// Helper for allowing users to specify a path to an alternate config file for a given section\n/// rather than providing it inline.\n#[derive(Debug, PartialEq, Deserialize)]\n#[serde(untagged)]\npub(super) enum PathOrStruct<T> {\n    Path(String),\n    Struct(T),\n}\n\nimpl<T> Default for PathOrStruct<T>\nwhere\n    T: Default,\n{\n    fn default() -> Self {\n        Self::Struct(Default::default())\n    }\n}\n\nimpl<T> PathOrStruct<T>\nwhere\n    T: Default + DeserializeOwned,\n{\n    fn into_inner(self, config_path: &Path, home: &Path, errs: &mut Vec<String>) -> T {\n        let path = match self {\n            Self::Struct(t) => return t,\n            Self::Path(p) => p,\n        };\n\n        match try_read(&path, config_path, home) {\n            Ok(t) => t,\n            Err(e) => {\n                errs.push(format!(\"  {path}: {e}\"));\n                T::default()\n            }\n        }\n    }\n}\n\nfn try_read<T>(raw: &str, config_path: &Path, home: &Path) -> io::Result<T>\nwhere\n    T: Default + DeserializeOwned,\n{\n    let mut path = match raw.strip_prefix(\"~/\") {\n        Some(tail) => home.join(tail),\n        None => PathBuf::from(raw),\n    };\n    if path.is_relative() {\n        path = config_path.join(path);\n    }\n    let content = fs::read_to_string(path)?;\n\n    toml::from_str(&content).map_err(|e| io::Error::new(io::ErrorKind::InvalidData, e.to_string()))\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use simple_test_case::dir_cases;\n\n    #[dir_cases(\"data/config_tests/valid\")]\n    #[test]\n    fn valid_config_parses(path: &str, content: &str) {\n        let raw: RawConfig = toml::from_str(content).unwrap();\n\n        // The test cases should all be attempting to set these keys\n        assert!(raw.colorscheme.is_some(), \"no colorscheme set\");\n        assert!(raw.filetypes.is_some(), \"no filetypes set\");\n        assert!(raw.keys.is_some(), \"no keys set\");\n\n        let res = raw.resolve(path, \"\");\n        assert!(res.is_ok(), \"{path} {res:?}\");\n    }\n\n    #[dir_cases(\"data/colorschemes\")]\n    #[test]\n    fn colorschemes_parse(path: &str, content: &str) {\n        let raw: RawColorScheme = toml::from_str(content).unwrap();\n        let mut errs = Vec::new();\n        let _cs = raw.resolve(&mut errs);\n        assert!(errs.is_empty(), \"{path} {errs:?}\");\n    }\n}\n", "source": "ad/src/config/raw.rs", "file_type": "rc"}
{"text": "//! A minimal config file format for ad\nuse crate::{\n    buffer::Buffer,\n    editor::{Action, Actions},\n    key::{Arrow, Input},\n    syntax::TK_DEFAULT,\n    term::{Color, Styles},\n    trie::Trie,\n    util::parent_dir_containing,\n};\nuse serde::{Deserialize, Deserializer, de};\nuse std::{collections::HashMap, env, fs, iter::successors, ops::Deref, path::Path};\nuse tracing::error;\n\nmod raw;\n\nuse raw::{RawColorScheme, RawConfig};\n\npub const DEFAULT_CONFIG: &str = include_str!(\"../../data/config.toml\");\n\npub(crate) fn config_path() -> String {\n    let home = env::var(\"HOME\").unwrap();\n    format!(\"{home}/.ad/config.toml\")\n}\n\n/// Editor level configuration\n#[derive(Debug, Clone, PartialEq, Eq)]\npub struct Config {\n    pub editor: EditorConfig,\n    pub filesystem: FsysConfig,\n    pub tree_sitter: TsConfig,\n    pub colorscheme: ColorScheme,\n    pub filetypes: HashMap<String, FtypeConfig>,\n    pub keys: KeyBindings,\n}\n\nimpl Default for Config {\n    fn default() -> Self {\n        RawConfig::default()\n            .resolve(&config_path(), \"\")\n            .expect(\"default config is broken\")\n    }\n}\n\nimpl Deref for Config {\n    type Target = EditorConfig;\n\n    fn deref(&self) -> &Self::Target {\n        &self.editor\n    }\n}\n\nimpl Config {\n    /// Attempt to load a config file from a specified location.\n    /// If there are any errors while loading and parsing the file then they\n    /// are reported as a formatted string for displaying to the user.\n    pub fn try_load_from_path(path: &str, home: &str) -> Result<Self, String> {\n        match fs::read_to_string(path) {\n            Ok(s) => Self::try_load_from_str(&s, path, home),\n            Err(e) => Err(format!(\"unable to load config file: {e}\")),\n        }\n    }\n\n    /// Attempt to load a config file from its raw file contents as a string.\n    /// If there are any errors while loading and parsing the file then they\n    /// are reported as a formatted string for displaying to the user.\n    pub fn try_load_from_str(s: &str, path: &str, home: &str) -> Result<Self, String> {\n        let raw: RawConfig = match toml::from_str(s) {\n            Ok(cfg) => cfg,\n            Err(e) => {\n                error!(\"malformed config file: {e}\");\n                return Err(format!(\"malformed config file: {e}\"));\n            }\n        };\n        let res = raw.resolve(path, home);\n        if let Err(err) = res.as_ref() {\n            error!(\"malformed config file: {err}\");\n        }\n\n        res\n    }\n\n    /// Attempt to load a config file from the default location.\n    ///\n    /// If the config file doesn't currently exist then the default config\n    /// will be written to disk.\n    /// If there are any errors while loading and parsing the file then they\n    /// are reported as a formatted string for displaying to the user.\n    pub fn try_load() -> Result<Self, String> {\n        let home = env::var(\"HOME\").unwrap();\n        let path = config_path();\n\n        if matches!(fs::exists(&path), Ok(false))\n            && fs::create_dir_all(format!(\"{home}/.ad\")).is_ok()\n            && let Err(e) = fs::write(&path, DEFAULT_CONFIG)\n        {\n            error!(\"unable to write default config file: {e}\");\n        }\n\n        Self::try_load_from_path(&path, &home)\n    }\n}\n\n/// For an explicitly provided path and first line of a file, check to see if we know the\n/// correct language associated with the file and associated [FtypeConfig].\npub fn ftype_config_for_path_and_first_line<'a>(\n    path: &Path,\n    first_line: &str,\n    filetypes: &'a HashMap<String, FtypeConfig>,\n) -> Option<(&'a String, &'a FtypeConfig)> {\n    let fname = path.file_name()?.to_string_lossy();\n    let os_ext = path.extension().unwrap_or_default();\n    let ext = os_ext.to_str().unwrap_or_default();\n\n    filetypes.iter().find(|(_, c)| {\n        c.filenames.iter().any(|f| *f == fname)\n            || c.extensions.iter().any(|e| e == ext)\n            || c.first_lines.iter().any(|l| first_line.starts_with(l))\n    })\n}\n\n/// Top level configuration for the editor\n#[derive(Debug, Clone, PartialEq, Eq)]\npub struct EditorConfig {\n    pub show_splash: bool,\n    pub tabstop: usize,\n    pub expand_tab: bool,\n    pub match_indent: bool,\n    pub lsp_autostart: bool,\n    pub status_timeout: u64,\n    pub double_click_ms: u64,\n    pub minibuffer_lines: usize,\n    pub find_command: String,\n}\n\nimpl Default for EditorConfig {\n    fn default() -> Self {\n        Self {\n            show_splash: true,\n            tabstop: 4,\n            expand_tab: true,\n            match_indent: true,\n            lsp_autostart: true,\n            status_timeout: 3,\n            double_click_ms: 200,\n            minibuffer_lines: 8,\n            find_command: \"fd --hidden\".to_string(),\n        }\n    }\n}\n\n/// Configuration for the 9p filesystem interface\n#[derive(Debug, Clone, PartialEq, Eq, Deserialize)]\npub struct FsysConfig {\n    pub enabled: bool,\n    pub auto_mount: bool,\n}\n\nimpl Default for FsysConfig {\n    fn default() -> Self {\n        Self {\n            enabled: true,\n            auto_mount: false,\n        }\n    }\n}\n\n/// A colorscheme for rendering the UI.\n///\n/// UI elements are available as properties and syntax stylings are available as a map of string\n/// tag to [Styles] that should be applied.\n#[derive(Debug, Clone, PartialEq, Eq)]\npub struct ColorScheme {\n    pub bg: Color,\n    pub fg: Color,\n    pub bar_bg: Color,\n    pub signcol_fg: Color,\n    pub minibuffer_hl: Color,\n    pub syntax: HashMap<String, Styles>,\n}\n\nimpl Default for ColorScheme {\n    fn default() -> Self {\n        RawColorScheme::default().resolve(&mut Vec::new())\n    }\n}\n\nimpl ColorScheme {\n    /// Determine UI [Styles] to be applied for a given syntax tag.\n    ///\n    /// If the full tag does not have associated styling but its dotted prefix does then the\n    /// styling of the prefix is used, otherwise default styling will be used ([TK_DEFAULT]).\n    ///\n    /// For key \"foo.bar.baz\" this will return the first value found out of the following keyset:\n    ///   - \"foo.bar.baz\"\n    ///   - \"foo.bar\"\n    ///   - \"foo\"\n    ///   - [TK_DEFAULT]\n    pub fn styles_for(&self, tag: &str) -> &Styles {\n        successors(Some(tag), |s| Some(s.rsplit_once('.')?.0))\n            .find_map(|k| self.syntax.get(k))\n            .or(self.syntax.get(TK_DEFAULT))\n            .expect(\"to have default styles\")\n    }\n}\n\n#[derive(Debug, Clone, PartialEq, Eq, Deserialize)]\npub struct TsConfig {\n    pub parser_dir: String,\n    pub syntax_query_dir: String,\n}\n\nimpl Default for TsConfig {\n    fn default() -> Self {\n        let home = env::var(\"HOME\").unwrap();\n\n        TsConfig {\n            parser_dir: format!(\"{home}/.ad/tree-sitter/parsers\"),\n            syntax_query_dir: format!(\"{home}/.ad/tree-sitter/queries\"),\n        }\n    }\n}\n\n#[derive(Debug, Default, Clone, PartialEq, Eq, Deserialize)]\npub struct FtypeConfig {\n    #[serde(default)]\n    pub extensions: Vec<String>,\n    #[serde(default)]\n    pub first_lines: Vec<String>,\n    #[serde(default)]\n    pub filenames: Vec<String>,\n    #[serde(default)]\n    pub re_syntax: Vec<(String, String)>,\n    #[serde(default)]\n    pub lsp: Option<LspConfig>,\n}\n\n/// Configuration for running a given language server\n#[derive(Debug, Default, Clone, PartialEq, Eq, Deserialize)]\npub struct LspConfig {\n    /// The command to run to start the language server\n    pub command: String,\n    /// Additional arguments to pass to the language server command\n    #[serde(default)]\n    pub args: Vec<String>,\n    /// Files or directories to search for in order to determine the project root\n    pub roots: Vec<String>,\n    /// Additional initialization options to be passed when the server is started\n    #[serde(default)]\n    pub init_opts: Option<serde_json::Value>,\n}\n\nimpl LspConfig {\n    pub fn root_for_dir<'a>(&self, d: &'a Path) -> Option<&'a Path> {\n        for root in self.roots.iter() {\n            if let Some(p) = parent_dir_containing(d, root) {\n                return Some(p);\n            }\n        }\n\n        None\n    }\n\n    pub fn root_for_buffer<'a>(&self, b: &'a Buffer) -> Option<&'a Path> {\n        self.root_for_dir(b.dir()?)\n    }\n}\n\n#[derive(Debug, Clone, PartialEq, Eq, Deserialize)]\npub struct KeyBindings {\n    #[serde(default, deserialize_with = \"de_serde_trie\")]\n    pub normal: Trie<Input, Actions>,\n    #[serde(default, deserialize_with = \"de_serde_trie\")]\n    pub insert: Trie<Input, Actions>,\n}\n\nimpl Default for KeyBindings {\n    fn default() -> Self {\n        KeyBindings {\n            normal: Trie::try_from_iter(Vec::new()).unwrap(),\n            insert: Trie::try_from_iter(Vec::new()).unwrap(),\n        }\n    }\n}\n\n#[derive(Debug, Clone, PartialEq, Eq, Deserialize)]\n#[serde(untagged)]\npub enum KeyAction {\n    Execute { run: String },\n    Keys { send_keys: Inputs },\n}\n\nimpl KeyAction {\n    fn into_actions(self) -> Actions {\n        match self {\n            Self::Execute { run } => Actions::Single(Action::ExecuteString { s: run }),\n            Self::Keys { send_keys } => Actions::Single(Action::SendKeys { ks: send_keys.0 }),\n        }\n    }\n}\n\n/// Raw inputs to be sent through to the main editor event loop\n#[derive(Debug, Clone, PartialEq, Eq, Deserialize)]\n#[serde(try_from = \"String\")]\npub struct Inputs(pub(crate) Vec<Input>);\n\nimpl TryFrom<String> for Inputs {\n    type Error = String;\n\n    fn try_from(value: String) -> Result<Self, Self::Error> {\n        let inputs = value\n            .split_whitespace()\n            .map(try_input_from_str_template)\n            .collect::<Result<Vec<_>, _>>()?;\n\n        if inputs.is_empty() {\n            return Err(\"empty key inputs string\".to_owned());\n        }\n\n        Ok(Self(inputs))\n    }\n}\n\n/// Only supporting a subset of inputs for now\nfn try_input_from_str_template(s: &str) -> Result<Input, String> {\n    if s.len() == 1 {\n        Ok(Input::Char(s.chars().next().unwrap()))\n    } else if let Some(suffix) = s.strip_prefix(\"C-A-\") {\n        if suffix.len() == 1 {\n            Ok(Input::CtrlAlt(suffix.chars().next().unwrap()))\n        } else if suffix == \"<space>\" {\n            Ok(Input::CtrlAlt(' '))\n        } else {\n            Err(format!(\"invalid send_key value: C-A-{suffix}\"))\n        }\n    } else if let Some(suffix) = s.strip_prefix(\"C-\") {\n        if suffix.len() == 1 {\n            Ok(Input::Ctrl(suffix.chars().next().unwrap()))\n        } else if suffix == \"<space>\" {\n            Ok(Input::Ctrl(' '))\n        } else {\n            Err(format!(\"invalid send_key value: C-{suffix}\"))\n        }\n    } else if let Some(suffix) = s.strip_prefix(\"A-\") {\n        if suffix.len() == 1 {\n            Ok(Input::Alt(suffix.chars().next().unwrap()))\n        } else if suffix == \"<space>\" {\n            Ok(Input::Alt(' '))\n        } else {\n            Err(format!(\"invalid send_key value: A-{suffix}\"))\n        }\n    } else {\n        let i = match s {\n            \"<backspace>\" => Input::Backspace,\n            \"<delete>\" => Input::Del,\n            \"<end>\" => Input::End,\n            \"<esc>\" => Input::Esc,\n            \"<home>\" => Input::Home,\n            \"<page-down>\" => Input::PageDown,\n            \"<page-up>\" => Input::PageUp,\n            \"<space>\" => Input::Char(' '),\n            \"<tab>\" => Input::Tab,\n            \"<left>\" => Input::Arrow(Arrow::Left),\n            \"<right>\" => Input::Arrow(Arrow::Right),\n            \"<up>\" => Input::Arrow(Arrow::Up),\n            \"<down>\" => Input::Arrow(Arrow::Down),\n            _ => return Err(format!(\"unknown key {s}\")),\n        };\n\n        Ok(i)\n    }\n}\n\nfn de_serde_trie<'de, D>(deserializer: D) -> Result<Trie<Input, Actions>, D::Error>\nwhere\n    D: Deserializer<'de>,\n{\n    let raw_map: HashMap<String, KeyAction> = Deserialize::deserialize(deserializer)?;\n    if raw_map.is_empty() {\n        return Err(de::Error::custom(\"empty key map\"));\n    }\n\n    let raw = raw_map\n        .into_iter()\n        .map(|(k, action)| {\n            Inputs::try_from(k)\n                .map(|Inputs(keys)| (keys, action.into_actions()))\n                .map_err(de::Error::custom)\n        })\n        .collect::<Result<Vec<_>, _>>()?;\n\n    Trie::try_from_iter(raw).map_err(de::Error::custom)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use simple_test_case::test_case;\n\n    #[test]\n    fn default_config_is_valid() {\n        Config::default(); // will panic if default config is invalid\n    }\n\n    #[test_case(\"A\", &[Input::Char('A')]; \"single letter key\")]\n    #[test_case(\"5\", &[Input::Char('5')]; \"single digit key\")]\n    #[test_case(\"A-y\", &[Input::Alt('y')]; \"alt letter\")]\n    #[test_case(\"C-y\", &[Input::Ctrl('y')]; \"control letter\")]\n    #[test_case(\"C-A-y\", &[Input::CtrlAlt('y')]; \"control alt letter\")]\n    #[test_case(\"A-<space>\", &[Input::Alt(' ')]; \"alt space\")]\n    #[test_case(\"C-<space>\", &[Input::Ctrl(' ')]; \"control space\")]\n    #[test_case(\"C-A-<space>\", &[Input::CtrlAlt(' ')]; \"control alt space\")]\n    #[test_case(\"<backspace>\", &[Input::Backspace]; \"backspace\")]\n    #[test_case(\"<delete>\", &[Input::Del]; \"delete\")]\n    #[test_case(\"<end>\", &[Input::End]; \"end\")]\n    #[test_case(\"<esc>\", &[Input::Esc]; \"escape\")]\n    #[test_case(\"<home>\", &[Input::Home]; \"home\")]\n    #[test_case(\"<page-up>\", &[Input::PageUp]; \"page up\")]\n    #[test_case(\"<page-down>\", &[Input::PageDown]; \"page down\")]\n    #[test_case(\"<space>\", &[Input::Char(' ')]; \"space\")]\n    #[test_case(\"<tab>\", &[Input::Tab]; \"tab\")]\n    #[test_case(\"<left>\", &[Input::Arrow(Arrow::Left)]; \"left\")]\n    #[test_case(\"<right>\", &[Input::Arrow(Arrow::Right)]; \"right\")]\n    #[test_case(\"<up>\", &[Input::Arrow(Arrow::Up)]; \"up\")]\n    #[test_case(\"<down>\", &[Input::Arrow(Arrow::Down)]; \"down\")]\n    #[test_case(\"A B C\", &[Input::Char('A'), Input::Char('B'), Input::Char('C')]; \"sequence\")]\n    #[test]\n    fn inputs_try_from_string_works(raw: &str, expected: &[Input]) {\n        let inputs = Inputs::try_from(raw.to_owned()).unwrap();\n        assert_eq!(&inputs.0, expected);\n    }\n\n    #[test]\n    fn inputs_try_from_empty_string_errors() {\n        assert_eq!(\n            &Inputs::try_from(String::new()).unwrap_err(),\n            \"empty key inputs string\"\n        );\n    }\n\n    #[test]\n    fn parsing_an_empty_keymap_errors() {\n        let res: Result<KeyBindings, _> = toml::from_str(\"[normal]\");\n        assert!(res.is_err());\n    }\n}\n", "source": "ad/src/config/mod.rs", "file_type": "rc"}
{"text": "//! Support for tree-sitter incremental parsing, querying and highlighting of Buffers\n//!\n//! For a given language the user needs to provide a .so file containing the compiled\n//! tree-sitter parser and a highlights .scm file for driving the highlighting.\nuse crate::{\n    buffer::{GapBuffer, SliceIter},\n    dot::Range,\n    syntax::{ByteRange, LineIter, SyntaxRange},\n};\nuse libloading::{Library, Symbol};\nuse std::{\n    cmp::{max, min},\n    collections::HashSet,\n    fmt, fs,\n    iter::repeat_n,\n    ops::{Deref, DerefMut},\n    path::Path,\n};\nuse tracing::{error, info};\nuse tree_sitter::{self as ts, StreamingIterator, ffi::TSLanguage};\n\npub const SUPPORTED_PREDICATES: [&str; 0] = [];\n\nimpl From<ts::Range> for ByteRange {\n    fn from(r: ts::Range) -> Self {\n        Self {\n            from: r.start_byte,\n            to: r.end_byte,\n        }\n    }\n}\n\n/// Buffer level tree-sitter state for parsing and highlighting\n#[derive(Debug)]\npub struct TsState {\n    tree: ts::Tree,\n    p: Parser,\n    t: Tokenizer,\n}\n\nimpl TsState {\n    pub fn try_new(\n        lang: &str,\n        so_dir: &str,\n        query_dir: &str,\n        gb: &GapBuffer,\n    ) -> Result<Self, String> {\n        let query_path = Path::new(query_dir).join(lang).join(\"highlights.scm\");\n        let query = match fs::read_to_string(query_path) {\n            Ok(s) => s,\n            Err(e) => return Err(format!(\"unable to read tree-sitter query file: {e}\")),\n        };\n\n        let p = Parser::try_new(so_dir, lang)?;\n\n        Self::try_new_explicit(p, &query, gb)\n    }\n\n    #[cfg(test)]\n    pub(crate) fn try_new_from_language(\n        lang_name: &str,\n        lang: ts::Language,\n        query: &str,\n        gb: &GapBuffer,\n    ) -> Result<Self, String> {\n        let p = Parser::try_new_from_language(lang_name, lang)?;\n\n        Self::try_new_explicit(p, query, gb)\n    }\n\n    fn try_new_explicit(mut p: Parser, query: &str, gb: &GapBuffer) -> Result<Self, String> {\n        let tree = p.parse_with_options(\n            &mut |byte_offset, _| gb.maximal_slice_from_offset(byte_offset),\n            None,\n            None,\n        );\n\n        match tree {\n            Some(tree) => {\n                let t = p.new_tokenizer(query)?;\n                info!(\"TS loaded for {}\", p.lang_name);\n\n                Ok(Self { p, t, tree })\n            }\n            None => Err(\"failed to parse file\".to_owned()),\n        }\n    }\n\n    /// Apply a previously prepared edit to the tree-sitter state.\n    ///\n    /// The byte offset parameters must have been computed BEFORE the buffer is modified:\n    /// - `start_byte`: byte offset where the edit starts (same in old and new)\n    /// - `old_end_byte`: byte offset where the edit ends in the ORIGINAL buffer\n    /// - `new_end_byte`: byte offset where the edit ends in the MODIFIED buffer\n    pub(super) fn apply_prepared_edit(\n        &mut self,\n        start_byte: usize,\n        old_end_byte: usize,\n        new_end_byte: usize,\n        gb: &GapBuffer,\n    ) {\n        self.tree.edit(&ts::InputEdit {\n            start_byte,\n            old_end_byte,\n            new_end_byte,\n            // See https://github.com/tree-sitter/tree-sitter/discussions/1793 for why this OK\n            start_position: ts::Point::new(0, 0),\n            old_end_position: ts::Point::new(0, 0),\n            new_end_position: ts::Point::new(0, 0),\n        });\n\n        let new_tree = self.p.parse_with_options(\n            &mut |byte_offset, _| gb.maximal_slice_from_offset(byte_offset),\n            Some(&self.tree),\n            None,\n        );\n\n        if let Some(tree) = new_tree {\n            // TODO: it might be looking at self.tree.changed_ranges(&tree) to optimise being able\n            // to only clear regions that are now invalid\n            self.tree = tree;\n        }\n\n        self.t.clear();\n    }\n\n    pub(super) fn prepare_insert_char(\n        &self,\n        ch_idx: usize,\n        ch: char,\n        gb: &GapBuffer,\n    ) -> (usize, usize, usize) {\n        let start_byte = gb.char_to_byte(ch_idx);\n\n        (start_byte, start_byte, start_byte + ch.len_utf8())\n    }\n\n    pub(super) fn prepare_insert_string(\n        &self,\n        ch_idx: usize,\n        s: &str,\n        gb: &GapBuffer,\n    ) -> (usize, usize, usize) {\n        let start_byte = gb.char_to_byte(ch_idx);\n\n        (start_byte, start_byte, start_byte + s.len())\n    }\n\n    pub(super) fn prepare_delete_char(\n        &self,\n        ch_idx: usize,\n        gb: &GapBuffer,\n    ) -> (usize, usize, usize) {\n        let (start_byte, old_end_byte) = gb.char_range_to_byte_range(ch_idx, ch_idx + 1);\n\n        (start_byte, old_end_byte, start_byte)\n    }\n\n    pub(super) fn prepare_delete_range(\n        &self,\n        ch_from: usize,\n        ch_to: usize,\n        gb: &GapBuffer,\n    ) -> (usize, usize, usize) {\n        let (start_byte, old_end_byte) = gb.char_range_to_byte_range(ch_from, ch_to);\n\n        (start_byte, old_end_byte, start_byte)\n    }\n\n    pub fn update(&mut self, gb: &GapBuffer, from_row: usize, n_rows: usize) {\n        let raw_from = gb.line_to_byte(from_row);\n        let raw_to = if from_row + n_rows + 1 < gb.len_lines() {\n            gb.line_to_byte(from_row + n_rows + 1)\n        } else {\n            gb.len()\n        };\n\n        if let Some((a, b)) = self.t.missing_region(raw_from, raw_to) {\n            // To avoid spinning on calling back to the tree-sitter API for individual lines, we\n            // pre-emptively grab a larger block of tokens from the region ahead or behind of the\n            // requested one if we have missing tokens in that direction.\n            const PADDING: usize = 512;\n            let byte_from = if b < raw_to {\n                a.saturating_sub(PADDING)\n            } else {\n                a\n            };\n            let byte_to = if a > raw_from {\n                min(b + PADDING, gb.len())\n            } else {\n                b\n            };\n\n            self.t.update(self.tree.root_node(), gb, byte_from, byte_to);\n        }\n    }\n\n    #[inline]\n    pub fn iter_tokenized_lines_from<'a>(\n        &'a self,\n        line: usize,\n        gb: &'a GapBuffer,\n        dot_range: Range,\n        load_exec_range: Option<(bool, Range)>,\n    ) -> LineIter<'a> {\n        self.t\n            .iter_tokenized_lines_from(line, gb, dot_range, load_exec_range)\n    }\n\n    pub fn pretty_print_tree(&self) -> String {\n        let sexp = self.tree.root_node().to_sexp();\n        let mut buf = String::with_capacity(sexp.len()); // better starting point than default\n        let mut has_field = false;\n        let mut indent = 0;\n\n        for s in sexp.split([' ', ')']) {\n            if s.is_empty() {\n                indent -= 1;\n                buf.push(')');\n            } else if s.starts_with('(') {\n                if has_field {\n                    has_field = false;\n                } else {\n                    if indent > 0 {\n                        buf.push('\\n');\n                        buf.extend(repeat_n(' ', indent * 2));\n                    }\n                    indent += 1;\n                }\n\n                buf.push_str(s); // \"(node_name\"\n            } else if s.ends_with(':') {\n                buf.push('\\n');\n                buf.extend(repeat_n(' ', indent * 2));\n                buf.push_str(s); // \"field:\"\n                buf.push(' ');\n                has_field = true;\n                indent += 1;\n            }\n        }\n\n        buf\n    }\n}\n\n// Required for us to be able to pass GapBuffers to the tree-sitter API\nimpl<'a> ts::TextProvider<&'a [u8]> for &'a GapBuffer {\n    type I = SliceIter<'a>;\n\n    fn text(&mut self, node: ts::Node<'_>) -> Self::I {\n        let ts::Range {\n            start_byte,\n            end_byte,\n            ..\n        } = node.range();\n\n        self.slice_from_byte_offsets(start_byte, end_byte)\n            .slice_iter()\n    }\n}\n\n/// A dynamically loaded tree-sitter parser backed by an on disk .so file\npub struct Parser {\n    lang_name: String,\n    inner: ts::Parser,\n    lang: ts::Language,\n    // Need to prevent drop while the parser is in use\n    // Stored as an Option to allow for crate-based parsers that are not backed by a .so file\n    _lib: Option<Library>,\n}\n\nimpl Deref for Parser {\n    type Target = ts::Parser;\n\n    fn deref(&self) -> &Self::Target {\n        &self.inner\n    }\n}\n\nimpl DerefMut for Parser {\n    fn deref_mut(&mut self) -> &mut Self::Target {\n        &mut self.inner\n    }\n}\n\nimpl fmt::Debug for Parser {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"Parser({})\", self.lang_name)\n    }\n}\n\nimpl Parser {\n    /// Error values returned by this function are intended as status messages to be\n    /// presented to the user.\n    pub fn try_new<P: AsRef<Path>>(so_dir: P, lang_name: &str) -> Result<Self, String> {\n        let p = so_dir.as_ref().join(format!(\"{lang_name}.so\"));\n        let lang_fn = format!(\"tree_sitter_{lang_name}\");\n\n        // SAFETY: if the library loads and contains the target symbol we expect the\n        //         given .so file to be a valid tree-sitter parser\n        unsafe {\n            let lib = Library::new(p).map_err(|e| e.to_string())?;\n            let func: Symbol<'_, unsafe extern \"C\" fn() -> *const TSLanguage> =\n                lib.get(lang_fn.as_bytes()).map_err(|e| e.to_string())?;\n\n            let lang = ts::Language::from_raw(func());\n            if lang.abi_version() < ts::MIN_COMPATIBLE_LANGUAGE_VERSION {\n                return Err(format!(\n                    \"incompatible .so tree-sitter parser version: {} < {}\",\n                    lang.abi_version(),\n                    ts::MIN_COMPATIBLE_LANGUAGE_VERSION\n                ));\n            }\n\n            let mut inner = ts::Parser::new();\n            inner.set_language(&lang).map_err(|e| e.to_string())?;\n\n            Ok(Self {\n                lang_name: lang_name.to_owned(),\n                inner,\n                lang,\n                _lib: Some(lib),\n            })\n        }\n    }\n\n    /// Construct a new tokenizer directly from a ts::Language provided by a crate\n    #[cfg(test)]\n    fn try_new_from_language(lang_name: &str, lang: ts::Language) -> Result<Self, String> {\n        let mut inner = ts::Parser::new();\n        inner.set_language(&lang).map_err(|e| e.to_string())?;\n\n        Ok(Self {\n            lang_name: lang_name.to_owned(),\n            inner,\n            lang,\n            _lib: None,\n        })\n    }\n\n    pub fn new_tokenizer(&self, query: &str) -> Result<Tokenizer, String> {\n        let q = ts::Query::new(&self.lang, query).map_err(|e| format!(\"{e:?}\"))?;\n        let cur = ts::QueryCursor::new();\n\n        // If a query has been copied from another text editor then there is a chance that\n        // it makes use of custom predicates that we don't know how to handle. The highlights\n        // as a whole won't behave as the user expects in this instance so we error out the\n        // setup of syntax-highlighting as a whole in this case and log an error\n        let mut unsupported_predicates = HashSet::new();\n        for i in 0..q.pattern_count() {\n            for p in q.general_predicates(i) {\n                if !SUPPORTED_PREDICATES.contains(&p.operator.as_ref()) {\n                    unsupported_predicates.insert(p.operator.clone());\n                }\n            }\n        }\n\n        if !unsupported_predicates.is_empty() {\n            error!(\"Unsupported custom tree-sitter predicates found: {unsupported_predicates:?}\");\n            info!(\"Supported custom tree-sitter predicates: {SUPPORTED_PREDICATES:?}\");\n            info!(\"Please modify the highlights.scm file to remove the unsupported predicates\");\n\n            return Err(format!(\n                \"{} highlights query contained unsupported custom predicates\",\n                self.lang_name\n            ));\n        }\n\n        let names = q.capture_names().iter().map(|s| s.to_string()).collect();\n\n        Ok(Tokenizer {\n            q,\n            cur,\n            names,\n            ranges: Vec::new(),\n            tokenized_regions: Vec::new(),\n        })\n    }\n}\n\npub struct Tokenizer {\n    // Tree-sitter state\n    q: ts::Query,\n    cur: ts::QueryCursor,\n    names: Vec<String>,\n    // Cache of computed syntax tokens for passing to LineIter\n    ranges: Vec<SyntaxRange>,\n    // The regions of the file that we currently have tokens for\n    tokenized_regions: Vec<ByteRange>,\n}\n\nimpl fmt::Debug for Tokenizer {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"Tokenizer\")\n    }\n}\n\n#[inline]\nfn mark_region(regions: &mut Vec<ByteRange>, from: usize, to: usize) {\n    regions.push(ByteRange { from, to });\n    if regions.len() == 1 {\n        return;\n    }\n\n    regions.sort_unstable();\n\n    let mut idx = 0;\n    for i in 1..regions.len() {\n        if regions[idx].to >= regions[i].from {\n            // Merge overlapping regions\n            regions[idx].to = max(regions[idx].to, regions[i].to);\n        } else {\n            // Move to the next region to check for overlaps\n            idx += 1;\n            regions.swap(idx, i);\n        }\n    }\n\n    // If we performed any merges then there will be unused regions at the end of the\n    // Vec now that we need to drop\n    regions.truncate(idx + 1);\n}\n\n/// This is not attempting to be maximally efficient in returning a set of missing regions as the\n/// goal is simply to minimise the amount of retokenization we do via tree-sitter where possible.\n#[inline]\nfn missing_region(regions: &[ByteRange], from: usize, to: usize) -> Option<(usize, usize)> {\n    let mut it = regions.iter();\n    while let Some(r) = it.next() {\n        if to < r.from {\n            // before this region and not in the previous so all missing\n            break;\n        } else if from < r.from {\n            // runs up to the start of this region or over this region\n            let end = if r.to > to { r.from } else { to };\n            return Some((from, end));\n        } else if r.contains(from, to) {\n            // contained entirely within this region so nothing missing\n            return None;\n        } else if from < r.to && to > r.to {\n            // from inside this region out to the next or past it\n            let end = match it.next() {\n                Some(r) if r.from < to => r.from,\n                _ => to,\n            };\n            return Some((r.to, end));\n        }\n    }\n\n    Some((from, to))\n}\n\nimpl Tokenizer {\n    fn clear(&mut self) {\n        self.ranges.clear();\n        self.tokenized_regions.clear();\n    }\n\n    fn missing_region(&self, from: usize, to: usize) -> Option<(usize, usize)> {\n        missing_region(&self.tokenized_regions, from, to)\n    }\n\n    fn mark_region(&mut self, from: usize, to: usize) {\n        mark_region(&mut self.tokenized_regions, from, to);\n    }\n\n    pub fn update(&mut self, root: ts::Node<'_>, gb: &GapBuffer, from: usize, to: usize) {\n        self.cur.set_byte_range(from..to);\n\n        // This is a streaming-iterator not an iterator, hence the odd while-let that follows\n        let mut it = self.cur.captures(&self.q, root, gb);\n\n        while let Some((m, idx)) = it.next() {\n            let cap = m.captures[*idx];\n            let r = ByteRange::from(cap.node.range());\n            if let Some(prev) = self.ranges.last_mut() {\n                if r == prev.r {\n                    // preferring the the last capture found so that precedence ordering\n                    // in query files matches Neovim & the treesitter-cli\n                    prev.cap_idx = Some(cap.index as usize);\n                    continue;\n                } else if r.from < prev.r.to && prev.r.from < r.to {\n                    continue;\n                }\n            }\n            self.ranges.push(SyntaxRange {\n                r,\n                cap_idx: Some(cap.index as usize),\n            });\n        }\n\n        self.ranges.sort_unstable();\n        self.ranges.dedup();\n        self.mark_region(from, to);\n    }\n\n    #[inline]\n    pub fn iter_tokenized_lines_from<'a>(\n        &'a self,\n        line: usize,\n        gb: &'a GapBuffer,\n        dot_range: Range,\n        load_exec_range: Option<(bool, Range)>,\n    ) -> LineIter<'a> {\n        LineIter::new(\n            line,\n            gb,\n            dot_range,\n            load_exec_range,\n            &self.names,\n            &self.ranges,\n        )\n    }\n\n    #[cfg(test)]\n    fn range_tokens(&self) -> Vec<crate::syntax::RangeToken<'_>> {\n        use crate::syntax::{RangeToken, TK_DEFAULT};\n\n        let names = self.q.capture_names();\n\n        self.ranges\n            .iter()\n            .map(|sr| RangeToken {\n                tag: sr.cap_idx.map(|i| names[i]).unwrap_or(TK_DEFAULT),\n                r: sr.r,\n            })\n            .collect()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::{\n        buffer::Buffer,\n        dot::{Cur, Dot},\n        editor::Action,\n        syntax::{RangeToken, SyntaxState, SyntaxStateInner},\n    };\n    use ad_event::Source;\n    use simple_test_case::test_case;\n\n    fn rt(tag: &str, from: usize, to: usize) -> RangeToken<'_> {\n        RangeToken {\n            tag,\n            r: ByteRange { from, to },\n        }\n    }\n\n    #[test]\n    fn char_delete_correctly_update_state() {\n        // minimal query for the fn keyword and parens\n        let query = r#\"\n\"fn\" @keyword\n\n[ \"(\" \")\" \"{\" \"}\" ] @punctuation\"#;\n\n        let s = \"fn main() {}\";\n        let mut b = Buffer::new_unnamed(0, s, Default::default());\n        let gb = &b.txt;\n        let mut ts =\n            TsState::try_new_from_language(\"rust\", tree_sitter_rust::LANGUAGE.into(), query, gb)\n                .unwrap();\n        ts.update(gb, 0, gb.len());\n        b.syntax_state = Some(SyntaxState::ts(ts));\n\n        assert_eq!(b.str_contents(), \"fn main() {}\");\n\n        let ranges = match b.syntax_state.as_ref() {\n            Some(SyntaxState {\n                inner: SyntaxStateInner::Ts(ts),\n                ..\n            }) => ts.t.range_tokens(),\n            _ => panic!(\"no ts state\"),\n        };\n        assert_eq!(\n            ranges,\n            vec![\n                rt(\"keyword\", 0, 2),       // fn\n                rt(\"punctuation\", 7, 8),   // (\n                rt(\"punctuation\", 8, 9),   // )\n                rt(\"punctuation\", 10, 11), // {\n                rt(\"punctuation\", 11, 12), // }\n            ]\n        );\n\n        b.dot = Dot::Cur { c: Cur { idx: 9 } };\n        b.handle_action(Action::Delete, Source::Fsys);\n        b.syntax_state\n            .as_mut()\n            .unwrap()\n            .update(&b.txt, 0, usize::MAX - 1);\n        let ranges = match b.syntax_state.as_ref() {\n            Some(SyntaxState {\n                inner: SyntaxStateInner::Ts(ts),\n                ..\n            }) => ts.t.range_tokens(),\n            _ => panic!(\"no ts state\"),\n        };\n\n        assert_eq!(b.str_contents(), \"fn main(){}\");\n        assert_eq!(ranges.len(), 5);\n\n        // these two should have moved left one character\n        assert_eq!(ranges[3], rt(\"punctuation\", 9, 10), \"opening curly\");\n        assert_eq!(ranges[4], rt(\"punctuation\", 10, 11), \"closing curly\");\n    }\n\n    #[test]\n    fn overlapping_tokens_prefer_previous_matches() {\n        // Minimal query extracted from the full query in gh#88 that resulted in\n        // overlapping tokens being produced\n        let query = r#\"\n(identifier) @variable\n\n(import_statement\n  name: (dotted_name\n    (identifier) @module))\n\n(import_statement\n  name: (aliased_import\n    name: (dotted_name\n      (identifier) @module)\n    alias: (identifier) @module))\n\n(import_from_statement\n  module_name: (dotted_name\n    (identifier) @module))\"#;\n\n        let s = \"import builtins as _builtins\";\n        let b = Buffer::new_unnamed(0, s, Default::default());\n        let gb = &b.txt;\n        let mut ts = TsState::try_new_from_language(\n            \"python\",\n            tree_sitter_python::LANGUAGE.into(),\n            query,\n            gb,\n        )\n        .unwrap();\n        ts.update(gb, 0, gb.len());\n\n        assert_eq!(\n            ts.t.range_tokens(),\n            vec![\n                rt(\"module\", 7, 15),  // builtins\n                rt(\"module\", 19, 28)  // _builtins\n            ]\n        );\n    }\n\n    #[test]\n    fn built_in_predicates_work() {\n        let query = r#\"\n(identifier) @variable\n\n; Assume all-caps names are constants\n((identifier) @constant\n  (#match? @constant \"^[A-Z][A-Z%d_]*$\"))\n\n((identifier) @constant.builtin\n  (#any-of? @constant.builtin \"Some\" \"None\" \"Ok\" \"Err\"))\n\n[ \"(\" \")\" \"{\" \"}\" ] @punctuation\"#;\n\n        let s = \"Ok(Some(42)) foo BAR\";\n        let b = Buffer::new_unnamed(0, s, Default::default());\n        let gb = &b.txt;\n        let mut ts =\n            TsState::try_new_from_language(\"rust\", tree_sitter_rust::LANGUAGE.into(), query, gb)\n                .unwrap();\n        ts.update(gb, 0, gb.len());\n\n        assert_eq!(\n            ts.t.range_tokens(),\n            vec![\n                rt(\"constant.builtin\", 0, 2), // Ok\n                rt(\"punctuation\", 2, 3),      // (\n                rt(\"constant.builtin\", 3, 7), // Some\n                rt(\"punctuation\", 7, 8),      // (\n                rt(\"punctuation\", 10, 11),    // )\n                rt(\"punctuation\", 11, 12),    // )\n                rt(\"variable\", 13, 16),       // foo\n                rt(\"constant\", 17, 20),       // BAR\n            ]\n        );\n    }\n\n    fn br(from: usize, to: usize) -> ByteRange {\n        ByteRange { from, to }\n    }\n\n    #[test_case(vec![], 0, 5, vec![br(0, 5)]; \"no initial regions\")]\n    #[test_case(vec![br(0, 5)], 0, 5, vec![br(0, 5)]; \"existing region idempotent\")]\n    #[test_case(vec![br(9, 15)], 0, 5, vec![br(0, 5), br(9, 15)]; \"disjoint regions\")]\n    #[test_case(vec![br(0, 5)], 3, 5, vec![br(0, 5)]; \"existing region contains new\")]\n    #[test_case(vec![br(0, 5)], 3, 9, vec![br(0, 9)]; \"existing region extending past current end\")]\n    #[test_case(vec![br(3, 5)], 0, 3, vec![br(0, 5)]; \"existing region extending before current start\")]\n    #[test_case(vec![br(3, 5)], 0, 9, vec![br(0, 9)]; \"existing region contained within new\")]\n    #[test_case(vec![br(0, 5), br(7, 15)], 4, 9, vec![br(0, 15)]; \"new region joins multiple existing\")]\n    #[test]\n    fn mark_region_works(\n        mut regions: Vec<ByteRange>,\n        from: usize,\n        to: usize,\n        expected: Vec<ByteRange>,\n    ) {\n        mark_region(&mut regions, from, to);\n        assert_eq!(regions, expected);\n    }\n\n    #[test_case(vec![br(0, 100)], 5, 20, None; \"contained\")]\n    #[test_case(vec![br(0, 1366)], 89, 1385, Some((1366, 1385)); \"scroll down\")]\n    #[test_case(vec![br(100, 1366)], 0, 255, Some((0, 100)); \"scroll up\")]\n    #[test_case(vec![br(100, 1366)], 0, 80, Some((0, 80)); \"before\")]\n    #[test_case(vec![br(100, 1366)], 1400, 1500, Some((1400, 1500)); \"after\")]\n    #[test_case(vec![br(0, 100), br(200, 300)], 150, 180, Some((150, 180)); \"in between regions\")]\n    #[test_case(vec![br(0, 100), br(200, 300)], 50, 180, Some((100, 180)); \"from one range into gap\")]\n    #[test_case(vec![br(0, 100), br(200, 300)], 150, 280, Some((150, 200)); \"from gap into region\")]\n    #[test_case(vec![br(0, 100), br(200, 300)], 50, 280, Some((100, 200)); \"from one region into another\")]\n    #[test_case(vec![br(50, 100), br(200, 300)], 0, 150, Some((0, 150)); \"around an existing region\")]\n    #[test]\n    fn missing_region_works(\n        regions: Vec<ByteRange>,\n        from: usize,\n        to: usize,\n        expected: Option<(usize, usize)>,\n    ) {\n        let res = missing_region(&regions, from, to);\n        assert_eq!(res, expected);\n    }\n}\n", "source": "ad/src/syntax/ts.rs", "file_type": "rc"}
{"text": "//! Command mode commands for ad\nuse crate::{\n    editor::{\n        Action::*,\n        Actions::{self, *},\n        Editor, ViewPort,\n    },\n    system::System,\n};\nuse std::path::Path;\n\n#[cfg(feature = \"fuzz\")]\npub fn parse_command_fuzz(input: &str) {\n    _ = parse_command(input, 0, Path::new(\"/home/fuzz\"));\n}\n\nfn parse_command(input: &str, active_buffer_id: usize, cwd: &Path) -> Result<Actions, String> {\n    if let Some(actions) = try_parse_single_char_command(input) {\n        return Ok(actions);\n    }\n\n    let input = input.trim_end();\n    let (command, args) = match input.split_once(' ') {\n        Some((command, args)) => (command, args),\n        None => (input, \"\"),\n    };\n\n    match command {\n        \"b\" | \"buffer\" => match args.parse::<usize>() {\n            Ok(id) => Ok(Single(FocusBuffer { id })),\n            Err(_) => Err(format!(\"'{args}' is not a valid buffer id\")),\n        },\n        \"bn\" | \"next-buffer\" => Ok(Single(NextBuffer)),\n        \"bp\" | \"prev-buffer\" => Ok(Single(PreviousBuffer)),\n        \"next-column\" => Ok(Single(NextColumn)),\n        \"next-window\" => Ok(Single(NextWindowInColumn)),\n        \"prev-column\" => Ok(Single(PreviousColumn)),\n        \"prev-window\" => Ok(Single(PreviousWindowInColumn)),\n\n        \"balance-all\" => Ok(Single(BalanceAll)),\n        \"balance-column\" => Ok(Single(BalanceActiveColumn)),\n        \"balance-columns\" => Ok(Single(BalanceColumns)),\n        \"balance-windows\" => Ok(Single(BalanceWindows)),\n\n        \"cd\" | \"change-directory\" => {\n            if args.is_empty() {\n                Ok(Single(ChangeDirectory { path: None }))\n            } else {\n                Ok(Single(ChangeDirectory {\n                    path: Some(args.to_string()),\n                }))\n            }\n        }\n\n        \"mark-clean\" => {\n            let bufid = if args.is_empty() {\n                active_buffer_id\n            } else {\n                match args.parse::<usize>() {\n                    Ok(bufid) => bufid,\n                    Err(_) => return Err(format!(\"'{args}' is not a valid buffer id\")),\n                }\n            };\n\n            Ok(Single(MarkClean { bufid }))\n        }\n\n        \"db\" | \"delete-buffer\" => Ok(Single(DeleteBuffer { force: false })),\n        \"db!\" | \"delete-buffer!\" => Ok(Single(DeleteBuffer { force: true })),\n        \"dc\" | \"delete-column\" => Ok(Single(DeleteColumn { force: false })),\n        \"dc!\" | \"delete-column!\" => Ok(Single(DeleteColumn { force: true })),\n        \"dw\" | \"delete-window\" => Ok(Single(DeleteWindow { force: false })),\n        \"dw!\" | \"delete-window!\" => Ok(Single(DeleteWindow { force: true })),\n\n        \"echo\" => Ok(Single(SetStatusMessage {\n            message: args.to_string(),\n        })),\n\n        \"expand-dot\" => Ok(Single(ExpandDot)),\n\n        \"E\" | \"Edit\" => {\n            if args.is_empty() {\n                Err(\"No Edit script provided\".to_string())\n            } else {\n                Ok(Single(EditCommand {\n                    cmd: args.to_string(),\n                }))\n            }\n        }\n\n        \"execute\" => Ok(Single(ExecuteDot)),\n        \"help\" => Ok(Single(ShowHelp)),\n        \"kill\" => Ok(Single(KillRunningChild)),\n        \"load\" => Ok(Single(LoadDot { new_window: false })),\n        \"plumb\" => Ok(Single(Plumb {\n            txt: args.to_string(),\n            new_window: false,\n        })),\n\n        \"lsp-completion\" => Ok(Single(LspCompletion)),\n        \"lsp-find-references\" => Ok(Single(LspReferences)),\n        \"lsp-format\" => Ok(Single(LspFormat)),\n        \"lsp-goto-declaration\" => Ok(Single(LspGotoDeclaration)),\n        \"lsp-goto-definition\" => Ok(Single(LspGotoDefinition)),\n        \"lsp-goto-type-definition\" => Ok(Single(LspGotoTypeDefinition)),\n        \"lsp-hover\" => Ok(Single(LspHover)),\n        \"lsp-rename\" => Ok(Single(LspRenamePrepare)),\n        \"lsp-show-capabilities\" => Ok(Single(LspShowCapabilities)),\n        \"lsp-show-diagnostics\" => Ok(Single(LspShowDiagnostics)),\n        \"lsp-start\" => Ok(Single(LspStart)),\n        \"lsp-stop\" => Ok(Single(LspStop)),\n\n        \"o\" | \"open\" => {\n            if args.is_empty() {\n                Err(\"No filename provided\".to_string())\n            } else {\n                Ok(Single(OpenFile {\n                    path: args.to_string(),\n                }))\n            }\n        }\n\n        \"O\" | \"open-in-new-window\" => {\n            if args.is_empty() {\n                Err(\"No filename provided\".to_string())\n            } else {\n                Ok(Single(OpenFileInNewWindow {\n                    path: args.to_string(),\n                }))\n            }\n        }\n\n        \"new-column\" => Ok(Single(NewColumn)),\n        \"new-window\" => Ok(Single(NewWindow)),\n\n        \"pwd\" => Ok(Single(SetStatusMessage {\n            message: cwd.display().to_string(),\n        })),\n\n        \"q\" | \"quit\" | \"Exit\" => Ok(Single(Exit { force: false })),\n        \"q!\" | \"quit!\" | \"Exit!\" => Ok(Single(Exit { force: true })),\n\n        \"reload-config\" => Ok(Single(ReloadConfig)),\n        \"reload-buffer\" | \"Get\" => {\n            if args.is_empty() {\n                Ok(Single(ReloadActiveBuffer))\n            } else {\n                match args.parse::<usize>() {\n                    Ok(id) => Ok(Single(ReloadBuffer { id })),\n                    Err(_) => Err(format!(\"'{args}' is not a valid buffer id\")),\n                }\n            }\n        }\n\n        \"rename-buffer\" => Ok(Single(RenameActiveBuffer {\n            name: args.to_string(),\n        })),\n\n        \"resize-column\" => match args.parse::<i16>() {\n            Ok(delta) => Ok(Single(ResizeActiveColumn { delta })),\n            Err(_) => Err(format!(\"'{args}' is not a valid delta\")),\n        },\n        \"resize-window\" => match args.parse::<i16>() {\n            Ok(delta) => Ok(Single(ResizeActiveWindow { delta })),\n            Err(_) => Err(format!(\"'{args}' is not a valid delta\")),\n        },\n\n        \"clear-scratch\" => Ok(Single(ClearScratch)),\n        \"toggle-scratch\" => Ok(Single(ToggleScratch)),\n\n        \"ts-show-tree\" => Ok(Single(TsShowTree)),\n\n        \"view-logs\" => Ok(Single(ViewLogs)),\n\n        \"w\" | \"write\" => {\n            if args.is_empty() {\n                Ok(Single(SaveBuffer { force: false }))\n            } else {\n                Ok(Single(SaveBufferAs {\n                    path: args.to_string(),\n                    force: false,\n                }))\n            }\n        }\n        \"w!\" | \"write!\" => {\n            if args.is_empty() {\n                Ok(Single(SaveBuffer { force: true }))\n            } else {\n                Ok(Single(SaveBufferAs {\n                    path: args.to_string(),\n                    force: true,\n                }))\n            }\n        }\n\n        \"wa\" | \"write-all\" => Ok(Single(SaveBufferAll { force: false })),\n        \"wa!\" | \"write-all!\" => Ok(Single(SaveBufferAll { force: true })),\n\n        \"wq\" | \"write-quit\" => Ok(Multi(vec![\n            SaveBuffer { force: false },\n            Exit { force: false },\n        ])),\n\n        \"wq!\" | \"write-quit!\" => Ok(Multi(vec![\n            SaveBuffer { force: true },\n            Exit { force: true },\n        ])),\n\n        \"viewport-bottom\" => Ok(Single(SetViewPort(ViewPort::Bottom))),\n        \"viewport-top\" => Ok(Single(SetViewPort(ViewPort::Top))),\n        \"viewport-center\" => Ok(Single(SetViewPort(ViewPort::Center))),\n\n        \"\" => Err(String::new()),\n        _ => Err(String::new()),\n        // _ => Err(format!(\"Not an editor command: {command}\")),\n    }\n}\n\nimpl<S> Editor<S>\nwhere\n    S: System,\n{\n    pub(super) fn parse_command(&mut self, input: &str) -> Option<Actions> {\n        match parse_command(input, self.active_buffer_id(), &self.cwd) {\n            Ok(actions) => Some(actions),\n            Err(msg) if msg.is_empty() => None,\n            Err(msg) => {\n                self.set_status_message(&msg);\n                None\n            }\n        }\n    }\n}\n\nfn try_parse_single_char_command(input: &str) -> Option<Actions> {\n    match input.chars().next() {\n        Some('!') => Some(Single(ShellRun {\n            cmd: input[1..].to_string(),\n        })),\n        Some('|') => Some(Single(ShellPipe {\n            cmd: input[1..].to_string(),\n        })),\n        Some('<') => Some(Single(ShellReplace {\n            cmd: input[1..].to_string(),\n        })),\n        Some('>') => Some(Single(ShellSend {\n            cmd: input[1..].to_string(),\n        })),\n\n        _ => None,\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::editor::built_in_commands::built_in_commands;\n    use std::path::PathBuf;\n\n    // The current behaviour of the command parser ignores additional input rather than erroring\n    // which means we can always have the '1' argument here for all commands rather than needing\n    // to pick out the buffer related commands that need an ID. If this behaviour changes the\n    // test will need updating.\n    #[test]\n    fn known_commands_parse() {\n        for (cmds, _) in built_in_commands().into_iter() {\n            for raw_cmd in cmds.into_iter() {\n                let cmd = format!(\"{raw_cmd} 1\");\n                if let Err(msg) = parse_command(&cmd, 0, &PathBuf::new()) {\n                    panic!(\"{cmd:?} failed to parse: {msg:?}\");\n                }\n            }\n        }\n\n        for ch in \"!<>|\".chars() {\n            let cmd = format!(\"{ch}some-shell-command\");\n            if let Err(msg) = parse_command(&cmd, 0, &PathBuf::new()) {\n                panic!(\"{cmd:?} failed to parse: {msg:?}\");\n            }\n        }\n    }\n}\n", "source": "ad/src/editor/commands.rs", "file_type": "rc"}
{"text": "//! A simple REPL that syncs an rc shell session with an ad buffer.\n//!\n//! - \"Execute\" is defined to be \"send as input to the shell\".\n//! - Hitting return at the end of the buffer will send that line to the shell.\n//! - Running \"clear\" will clear the ad buffer\n//! - Running \"exit\" will close the shell subprocess as well as the ad buffer\nuse ad_client::{Client, EventFilter, Outcome, Source};\nuse anyhow::Context;\nuse std::{\n    env,\n    fs::File,\n    io::{self, Write, copy},\n    process::exit,\n    thread::spawn,\n};\nuse subprocess::{Popen, PopenConfig, Redirection};\n\nconst PROMPT: &str = \"% \";\n\nfn main() -> anyhow::Result<()> {\n    let mut client = match Client::new() {\n        Ok(client) => client,\n        Err(e) => {\n            eprintln!(\"unable to connect to ad\\n{e}\");\n            exit(1);\n        }\n    };\n\n    client\n        .open_in_new_window(\"+repl\")\n        .context(\"unable to create +repl window\")?;\n    let buffer_id = client\n        .current_buffer()\n        .context(\"unable to get current buffer ID\")?;\n    let mut env_vars: Vec<(String, String)> = env::vars().collect();\n    env_vars.push((\"prompt\".into(), PROMPT.into()));\n\n    let mut child = Popen::create(\n        &[\"rc\", \"-i\"],\n        PopenConfig {\n            stdin: Redirection::Pipe,\n            stdout: Redirection::Pipe,\n            stderr: Redirection::Merge,\n            env: Some(\n                env_vars\n                    .into_iter()\n                    .map(|(k, v)| (k.into(), v.into()))\n                    .collect(),\n            ),\n            ..Default::default()\n        },\n    )\n    .context(\"unable to spawn rc\")?;\n\n    let stdin = child.stdin.take().unwrap();\n    let mut stdout = child.stdout.take().unwrap();\n    let mut w = client\n        .body_writer(&buffer_id)\n        .context(\"unable to create body writer\")?;\n\n    spawn(move || {\n        _ = copy(&mut stdout, &mut w);\n    });\n\n    client\n        .run_event_filter(\n            &buffer_id,\n            Filter {\n                child,\n                buffer_id: buffer_id.clone(),\n                stdin,\n            },\n        )\n        .context(\"event filter died\")?;\n\n    Ok(())\n}\n\nstruct Filter {\n    child: Popen,\n    buffer_id: String,\n    stdin: File,\n}\n\nimpl Drop for Filter {\n    fn drop(&mut self) {\n        _ = self.child.kill();\n    }\n}\n\nimpl Filter {\n    fn clear_buffer(&mut self, client: &mut Client) -> io::Result<()> {\n        client.write_xaddr(&self.buffer_id, \",\")?;\n        client.write_xdot(&self.buffer_id, PROMPT)?;\n        client.write_addr(&self.buffer_id, \"$\")?;\n        client.ctl(\"mark-clean\", \"\")?;\n\n        Ok(())\n    }\n\n    fn send_input(&mut self, input: &str, client: &mut Client) -> io::Result<Outcome> {\n        match input.trim() {\n            \"clear\" => {\n                self.clear_buffer(client)?;\n                return Ok(Outcome::Handled);\n            }\n\n            \"exit\" => {\n                client.ctl(\"db!\", \"\")?;\n                self.child.kill()?;\n                exit(0);\n            }\n\n            _ => (),\n        }\n\n        self.stdin.write_all(input.as_bytes())?;\n        if !input.ends_with(\"\\n\") {\n            self.stdin.write_all(b\"\\n\")?;\n        }\n\n        Ok(Outcome::Handled)\n    }\n}\n\nimpl EventFilter for Filter {\n    fn handle_insert(\n        &mut self,\n        src: Source,\n        _from: usize,\n        _to: usize,\n        txt: &str,\n        client: &mut Client,\n    ) -> io::Result<Outcome> {\n        client.ctl(\"mark-clean\", \"\")?;\n\n        if src == Source::Fsys {\n            // This is us writing to the body so move dot to EOF\n            client.write_addr(&self.buffer_id, \"$\")?;\n            return Ok(Outcome::Handled);\n        }\n\n        if txt == \"\\n\" {\n            client.write_xaddr(&self.buffer_id, \"$\")?;\n            let xaddr = client.read_xaddr(&self.buffer_id)?;\n            let addr = client.read_addr(&self.buffer_id)?;\n\n            if xaddr == addr {\n                client.write_xaddr(&self.buffer_id, \"$-1\")?;\n                let raw = client.read_xdot(&self.buffer_id)?;\n                return self.send_input(strip_prompt(&raw), client);\n            }\n        }\n\n        Ok(Outcome::Handled)\n    }\n\n    fn handle_delete(\n        &mut self,\n        _src: Source,\n        _from: usize,\n        _to: usize,\n        client: &mut Client,\n    ) -> io::Result<Outcome> {\n        client.ctl(\"mark-clean\", \"\")?;\n\n        Ok(Outcome::Handled)\n    }\n\n    fn handle_execute(\n        &mut self,\n        _src: Source,\n        _from: usize,\n        _to: usize,\n        txt: &str,\n        client: &mut Client,\n    ) -> io::Result<Outcome> {\n        let s = strip_prompt(txt).trim();\n        client.append_to_body(&self.buffer_id, &format!(\"\\n{PROMPT}{s}\\n\"))?;\n        let outcome = self.send_input(s, client)?;\n\n        Ok(outcome)\n    }\n}\n\n#[inline]\nfn strip_prompt(s: &str) -> &str {\n    s.strip_prefix(PROMPT).unwrap_or(s)\n}\n", "source": "ad/crates/ad_repl/src/main.rs", "file_type": "rc"}
{"text": "use ad_client::{Client, EventFilter, Outcome, Source};\nuse std::io;\n\nfn main() -> io::Result<()> {\n    let mut client = Client::new()?;\n    client.open(\".\")?;\n    let buffer = client.current_buffer()?;\n    client.run_event_filter(&buffer, Filter)?;\n\n    Ok(())\n}\n\nstruct Filter;\n\nimpl EventFilter for Filter {\n    fn handle_load(\n        &mut self,\n        _src: Source,\n        from: usize,\n        to: usize,\n        txt: &str,\n        _client: &mut Client,\n    ) -> io::Result<Outcome> {\n        println!(\"got load: {from}->{to} {txt:?}\");\n        match txt {\n            \"README.md\" => Ok(Outcome::Passthrough),\n            _ => {\n                println!(\"  > suppressing load of {txt}\");\n                Ok(Outcome::Handled)\n            }\n        }\n    }\n}\n", "source": "ad/crates/ad_client/examples/event_filter.rs", "file_type": "rc"}
{"text": "//! A simple demo of the client behaviour\nuse ad_client::Client;\nuse std::io;\n\nfn main() -> io::Result<()> {\n    let mut client = Client::new()?;\n    client.echo(\"hello, world!\")?;\n    client.open(\"README.md\")?;\n\n    Ok(())\n}\n", "source": "ad/crates/ad_client/examples/demo.rs", "file_type": "rc"}
{"text": "//! A simple demo of the client behaviour\nuse ad_client::list_open_sessions;\n\nfn main() -> std::io::Result<()> {\n    for session in list_open_sessions()?.into_iter() {\n        println!(\"{session:#?}\");\n    }\n\n    Ok(())\n}\n", "source": "ad/crates/ad_client/examples/list_sessions.rs", "file_type": "rc"}
{"text": "//! A simple 9p based client for interacting with ad\n#![warn(\n    clippy::complexity,\n    clippy::correctness,\n    clippy::style,\n    future_incompatible,\n    missing_debug_implementations,\n    missing_docs,\n    rust_2018_idioms,\n    rustdoc::all,\n    clippy::undocumented_unsafe_blocks\n)]\nuse ninep::{\n    sansio::server::socket_dir,\n    sync::client::{ReadLineIter, UnixClient},\n};\nuse std::{env, fs, io, io::Write, os::unix::net::UnixStream, str::FromStr};\n\nmod event;\n\npub use ad_event::Source;\npub use event::{EventFilter, Outcome};\n\n/// A simple 9p client for ad\n#[derive(Debug, Clone)]\npub struct Client {\n    inner: UnixClient,\n    ns: String,\n}\n\nimpl Client {\n    /// Create a new client connected to `ad` over it's 9p unix socket\n    pub fn new() -> io::Result<Self> {\n        let ns = match env::var(\"AD_PID\") {\n            Ok(pid) => format!(\"ad-{pid}\"),\n            Err(_) => \"ad\".to_string(),\n        };\n\n        Ok(Self {\n            inner: UnixClient::new_unix(&ns, \"\")?,\n            ns,\n        })\n    }\n\n    /// Create a new client connected to the `ad` session with the given pid\n    /// over it's 9p unix socket.\n    ///\n    /// When running under ad, the [Client::new] method will automatically find\n    /// and connect to it's parent session.\n    pub fn new_for_pid(pid: &str) -> io::Result<Self> {\n        let ns = format!(\"ad-{pid}\");\n\n        Ok(Self {\n            inner: UnixClient::new_unix(&ns, \"\")?,\n            ns,\n        })\n    }\n\n    pub(crate) fn event_lines(&mut self, buffer: &str) -> io::Result<ReadLineIter<UnixStream>> {\n        self.inner.iter_lines(format!(\"buffers/{buffer}/event\"))\n    }\n\n    pub(crate) fn write_event(&mut self, buffer: &str, event_line: &str) -> io::Result<()> {\n        self.inner\n            .write_str(format!(\"buffers/{buffer}/event\"), 0, event_line)?;\n        Ok(())\n    }\n\n    /// Iterate over the log events emitted by ad\n    pub fn log_events(&mut self) -> io::Result<impl Iterator<Item = io::Result<LogEvent>> + use<>> {\n        Ok(self\n            .inner\n            .iter_lines(\"log\")?\n            .map(|line| LogEvent::from_str(&line)))\n    }\n\n    /// Get the currently active buffer id.\n    pub fn current_buffer(&mut self) -> io::Result<String> {\n        self.inner.read_str(\"buffers/current\")\n    }\n\n    fn _read_buffer_file(&mut self, buffer: &str, file: &str) -> io::Result<String> {\n        self.inner.read_str(format!(\"buffers/{buffer}/{file}\"))\n    }\n\n    /// Read the contents of the dot of the given buffer\n    pub fn read_dot(&mut self, buffer: &str) -> io::Result<String> {\n        self._read_buffer_file(buffer, \"dot\")\n    }\n\n    /// Read the body of the given buffer.\n    pub fn read_body(&mut self, buffer: &str) -> io::Result<String> {\n        self._read_buffer_file(buffer, \"body\")\n    }\n\n    /// Read the current dot address of the given buffer.\n    pub fn read_addr(&mut self, buffer: &str) -> io::Result<String> {\n        self._read_buffer_file(buffer, \"addr\")\n    }\n\n    /// Read the filename of the given buffer\n    pub fn read_filename(&mut self, buffer: &str) -> io::Result<String> {\n        self._read_buffer_file(buffer, \"filename\")\n    }\n\n    /// Read the x-address of the given buffer.\n    ///\n    /// This is only used by the filesystem interface of `ad` and will not affect the current\n    /// editor state.\n    pub fn read_xaddr(&mut self, buffer: &str) -> io::Result<String> {\n        self._read_buffer_file(buffer, \"xaddr\")\n    }\n\n    /// Read the x-dot of the given buffer.\n    ///\n    /// This is only used by the filesystem interface of `ad` and will not affect the current\n    /// editor state.\n    pub fn read_xdot(&mut self, buffer: &str) -> io::Result<String> {\n        self._read_buffer_file(buffer, \"xdot\")\n    }\n\n    fn _write_buffer_file(\n        &mut self,\n        buffer: &str,\n        file: &str,\n        offset: u64,\n        content: &[u8],\n    ) -> io::Result<usize> {\n        self.inner\n            .write(format!(\"buffers/{buffer}/{file}\"), offset, content)\n    }\n\n    /// Replace the dot of the given buffer with the provided string.\n    pub fn write_dot(&mut self, buffer: &str, content: &str) -> io::Result<usize> {\n        self._write_buffer_file(buffer, \"dot\", 0, content.as_bytes())\n    }\n\n    /// Append the provided string to the given buffer.\n    pub fn append_to_body(&mut self, buffer: &str, content: &str) -> io::Result<usize> {\n        self._write_buffer_file(buffer, \"body\", 0, content.as_bytes())\n    }\n\n    /// Set the addr of the given buffer.\n    pub fn write_addr(&mut self, buffer: &str, addr: &str) -> io::Result<usize> {\n        self._write_buffer_file(buffer, \"addr\", 0, addr.as_bytes())\n    }\n\n    /// Replace the xdot of the given buffer with the provided string.\n    pub fn write_xdot(&mut self, buffer: &str, content: &str) -> io::Result<usize> {\n        self._write_buffer_file(buffer, \"xdot\", 0, content.as_bytes())\n    }\n\n    /// Set the xaddr of the given buffer.\n    pub fn write_xaddr(&mut self, buffer: &str, content: &str) -> io::Result<usize> {\n        self._write_buffer_file(buffer, \"xaddr\", 0, content.as_bytes())\n    }\n\n    /// Send a control message to ad.\n    pub fn ctl(&mut self, command: &str, args: &str) -> io::Result<()> {\n        self.inner\n            .write(\"ctl\", 0, format!(\"{command} {args}\").as_bytes())?;\n\n        Ok(())\n    }\n\n    /// Echo a string message in the status line.\n    pub fn echo(&mut self, msg: impl AsRef<str>) -> io::Result<()> {\n        self.ctl(\"echo\", msg.as_ref())\n    }\n\n    /// Open the requested file.\n    pub fn open(&mut self, path: impl AsRef<str>) -> io::Result<()> {\n        self.ctl(\"open\", path.as_ref())\n    }\n\n    /// Open the requested file in a new window.\n    pub fn open_in_new_window(&mut self, path: impl AsRef<str>) -> io::Result<()> {\n        self.ctl(\"open-in-new-window\", path.as_ref())\n    }\n\n    /// Reload the currently active buffer.\n    pub fn reload_current_buffer(&mut self) -> io::Result<()> {\n        self.ctl(\"reload\", \"\")\n    }\n\n    /// Run a provided [EventFilter] until it exits or errors\n    pub fn run_event_filter<F>(&mut self, buffer: &str, filter: F) -> io::Result<()>\n    where\n        F: EventFilter,\n    {\n        event::run_filter(buffer, filter, self)\n    }\n\n    /// Create a [Write] impl that can be used to continuously write to the given path\n    pub fn body_writer(&self, bufid: &str) -> io::Result<BodyWriter> {\n        Ok(BodyWriter {\n            path: format!(\"buffers/{bufid}/body\"),\n            client: UnixClient::new_unix(&self.ns, \"\")?,\n        })\n    }\n}\n\n/// A writer for appending to the body of a buffer\n#[derive(Debug)]\npub struct BodyWriter {\n    path: String,\n    client: UnixClient,\n}\n\nimpl BodyWriter {\n    /// Mark the buffer as being clean\n    pub fn mark_clean(&mut self) -> io::Result<()> {\n        self.client.write(\"ctl\", 0, \"mark-clean\".as_bytes())?;\n\n        Ok(())\n    }\n}\n\nimpl Write for BodyWriter {\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n        self.client.write(&self.path, 0, buf)\n    }\n\n    fn flush(&mut self) -> io::Result<()> {\n        Ok(())\n    }\n}\n\n/// A message sent by the main editor thread to notify the fs thread that\n/// the current buffer list has changed.\n#[derive(Debug, Clone, Copy)]\npub enum LogEvent {\n    /// A newly created buffer\n    Open(usize),\n    /// A buffer that has now been closed and needs removing from state\n    Close(usize),\n    /// A change to the currently active buffer\n    Focus(usize),\n    /// A buffer was saved\n    Save(usize),\n}\n\nimpl FromStr for LogEvent {\n    type Err = io::Error;\n\n    fn from_str(s: &str) -> Result<Self, Self::Err> {\n        let s = s.trim();\n        if s.contains('\\n') {\n            return Err(io::Error::new(\n                io::ErrorKind::InvalidData,\n                \"expected single line\",\n            ));\n        }\n\n        let (str_id, action) = s.split_once(' ').ok_or(io::Error::new(\n            io::ErrorKind::InvalidData,\n            \"malformed log line: {s:?}\",\n        ))?;\n\n        let id: usize = str_id.parse().map_err(|_| {\n            io::Error::new(\n                io::ErrorKind::InvalidData,\n                \"expected integer ID, got {str_id:?}\",\n            )\n        })?;\n\n        let evt = match action {\n            \"open\" => Self::Open(id),\n            \"close\" => Self::Close(id),\n            \"focus\" => Self::Focus(id),\n            \"save\" => Self::Save(id),\n            _ => {\n                return Err(io::Error::new(\n                    io::ErrorKind::InvalidData,\n                    \"unknown log action {action:?}\",\n                ));\n            }\n        };\n\n        Ok(evt)\n    }\n}\n\nfn open_9p_sockets() -> io::Result<Vec<String>> {\n    let mut ad_sockets = Vec::new();\n    for entry in fs::read_dir(socket_dir())? {\n        let entry = entry?;\n        let fname = entry.file_name();\n        if let Some(s) = fname.to_str()\n            && s.starts_with(\"ad-\")\n        {\n            ad_sockets.push(s.to_string());\n        }\n    }\n\n    Ok(ad_sockets)\n}\n\n/// Metadata for an ad editor session.\n#[derive(Debug)]\npub struct SessionMeta {\n    /// The socket name within [socket_dir] for this session.\n    pub socket_name: String,\n    /// Whether or not the session is currently unresponsive.\n    ///\n    /// A session can become unresponsive when it crashes before successfully\n    /// removing it's filesystem socket.\n    pub is_unresponsive: bool,\n    /// The id of the currently active buffer.\n    pub active_buffer_id: String,\n    /// Metadata for the buffers open in this session.\n    pub buffers: Vec<BufferMeta>,\n}\n\nimpl SessionMeta {\n    /// Create a new [Client] for this session.\n    pub fn client_for_session(&self) -> io::Result<Client> {\n        Ok(Client {\n            inner: UnixClient::new_unix(&self.socket_name, \"\")?,\n            ns: self.socket_name.clone(),\n        })\n    }\n\n    /// Remove this session's filesystem socket.\n    pub fn remove_socket(&self) -> io::Result<()> {\n        fs::remove_file(socket_dir().join(&self.socket_name))\n    }\n}\n\n/// Metadata for an open buffer within an ad editor session.\n#[derive(Debug)]\npub struct BufferMeta {\n    /// The id of the buffer.\n    pub id: String,\n    /// The full filename of the buffer.\n    pub filename: String,\n}\n\n/// Call [SessionMeta::remove_socket] for all currently unresponsive editor sessions.\npub fn remove_unresponsive_sessions() -> io::Result<()> {\n    for session in list_open_sessions()?.into_iter() {\n        if session.is_unresponsive {\n            session.remove_socket()?;\n        }\n    }\n\n    Ok(())\n}\n\n/// List open `ad` editor sessions and their current state.\npub fn list_open_sessions() -> io::Result<Vec<SessionMeta>> {\n    let mut sessions = Vec::new();\n\n    for ns in open_9p_sockets()?.into_iter() {\n        let mut client = match UnixClient::new_unix(&ns, \"\") {\n            Ok(client) => client,\n            Err(_) => {\n                sessions.push(SessionMeta {\n                    socket_name: ns,\n                    is_unresponsive: true,\n                    active_buffer_id: String::new(),\n                    buffers: Vec::new(),\n                });\n                continue;\n            }\n        };\n        let active_buffer_id = client.read_str(\"buffers/current\")?;\n        let buffers = client\n            .read_str(\"buffers/index\")?\n            .lines()\n            .map(|line| {\n                let mut it = line.split_whitespace();\n                let id = it.next().map(String::from).unwrap_or_default();\n                let filename = it.next().map(String::from).unwrap_or_default();\n\n                BufferMeta { id, filename }\n            })\n            .collect();\n\n        sessions.push(SessionMeta {\n            socket_name: ns,\n            is_unresponsive: false,\n            active_buffer_id,\n            buffers,\n        });\n    }\n\n    Ok(sessions)\n}\n", "source": "ad/crates/ad_client/src/lib.rs", "file_type": "rc"}
{"text": "use ad_client::{Client, LogEvent};\nuse anyhow::Context;\nuse std::{\n    env,\n    io::{BufRead, BufReader, Write},\n    process::exit,\n    thread::spawn,\n};\nuse subprocess::{Popen, PopenConfig, Redirection};\n\nfn main() -> anyhow::Result<()> {\n    let args: Vec<String> = env::args().skip(1).collect();\n    if args.is_empty() {\n        eprintln!(\"no command provided to ad-watch\");\n        exit(1);\n    }\n\n    let dir = env::current_dir()\n        .context(\"unable to determine working directory\")?\n        .display()\n        .to_string();\n\n    let mut client = match Client::new() {\n        Ok(client) => client,\n        Err(e) => {\n            eprintln!(\"unable to connect to ad\\n{e}\");\n            exit(1);\n        }\n    };\n\n    client\n        .open_in_new_window(format!(\"{dir}/+watch\"))\n        .context(\"unable to open +watch buffer\")?;\n\n    let buffer_id = client\n        .current_buffer()\n        .context(\"unable to determine current buffer\")?;\n    let int_id: usize = buffer_id.parse().unwrap();\n\n    clear_and_rerun(&mut client, &buffer_id, &args)?;\n\n    for evt in client.log_events()? {\n        match evt? {\n            LogEvent::Close(id) if id == int_id => break,\n\n            LogEvent::Save(id) => {\n                let fname = client\n                    .read_filename(&id.to_string())\n                    .context(\"unable to read filename of saved buffer\")?;\n                if fname.starts_with(&dir) {\n                    clear_and_rerun(&mut client, &buffer_id, &args)?;\n                }\n            }\n\n            _ => (),\n        }\n    }\n\n    Ok(())\n}\n\nfn clear_and_rerun(client: &mut Client, id: &str, args: &[String]) -> anyhow::Result<()> {\n    client\n        .write_xaddr(id, \",\")\n        .context(\"unable to write xaddr\")?;\n    client\n        .write_xdot(id, \"\\n\")\n        .context(\"unable to write xdot\")?;\n    client\n        .ctl(\"mark-clean\", \"\")\n        .context(\"unable to mark buffer clean\")?;\n\n    let mut child = Popen::create(\n        args,\n        PopenConfig {\n            stdout: Redirection::Pipe,\n            stderr: Redirection::Merge,\n            ..Default::default()\n        },\n    )\n    .context(\"unable to run command\")?;\n    let stdout = BufReader::new(child.stdout.take().unwrap());\n    let mut w = client\n        .body_writer(id)\n        .context(\"unable to create body writer\")?;\n\n    spawn(move || {\n        for res in stdout.lines() {\n            let mut line = match res {\n                Ok(line) => line,\n                Err(_) => break,\n            };\n\n            line.push('\\n');\n            if line.contains('\\r') {\n                line = line.replace(\"\\r\\n\", \"\\n\").replace(\"\\r\", \"\\n\");\n            }\n\n            _ = w.write_all(line.as_bytes());\n            _ = w.mark_clean();\n        }\n    });\n\n    Ok(())\n}\n", "source": "ad/crates/ad_watch/src/main.rs", "file_type": "rc"}
{"text": "//! A simple demo of the 9p client interface\nuse ninep::sync::client::UnixClient;\nuse std::io;\n\nfn main() -> io::Result<()> {\n    let mut client = UnixClient::new_unix(\"acme\", \"\")?;\n\n    for line in client.iter_lines(\"43/event\")? {\n        print!(\"{line}\");\n    }\n\n    Ok(())\n}\n", "source": "ad/crates/ninep/examples/acme_test.rs", "file_type": "rc"}
{"text": "//! A simple demo of the 9p server interface\n//!\n//! You can use the `9p` command from https://github.com/9fans/plan9port to interact\n//! with the server and test it out.\n//!\n//!   https://9fans.github.io/plan9port/man/man1/9p.html\n//!\n//! ```sh\n//! # Let 9p know where to find the socket we have opened\n//! $ export NAMESPACE=\"/tmp/ns.$USER.$DISPLAY\"\n//!\n//! # List the contents of the filesystem and read the contents of a file\n//! $ 9p ls ninep-server\n//! $ 9p read ninep-server/foo\n//!\n//! # List the contents of a subdirectory and a file in that subdirectory\n//! $ 9p ls ninep-server/bar\n//! $ 9p read ninep-server/bar/baz\n//!\n//! # Read and then update the contents of a file\n//! $ 9p read ninep-server/rw\n//! $ echo \"updated\" | 9p write ninep-server/rw\n//! $ 9p read ninep-server/rw\n//! ```\nuse ninep::{\n    Result,\n    fs::{FileMeta, IoUnit, Mode, Perm, Stat},\n    sync::server::{ClientId, ReadOutcome, Serve9p, Server},\n};\nuse std::{\n    sync::{Arc, RwLock, mpsc::channel},\n    thread::{sleep, spawn},\n    time::{Duration, SystemTime},\n};\n\nfn main() {\n    let s = Server::new(EchoServer {\n        state: Arc::new(RwLock::new(State {\n            rw: \"initial\".to_string(),\n            blocking: \"0\\n\".to_string(),\n            n: 0,\n        })),\n    });\n    println!(\"starting server\");\n    _ = s.serve_socket(\"ninep-server\").join();\n}\n\nstruct State {\n    rw: String,\n    blocking: String,\n    n: usize,\n}\n\nstruct EchoServer {\n    state: Arc<RwLock<State>>,\n}\n\nconst ROOT: u64 = 0;\nconst BAR: u64 = 1;\nconst FOO: u64 = 2;\nconst BAZ: u64 = 3;\nconst RW: u64 = 4;\nconst BLOCKING: u64 = 5;\n\nimpl Serve9p for EchoServer {\n    fn write(\n        &self,\n        _cid: ClientId,\n        qid: u64,\n        offset: usize,\n        data: Vec<u8>,\n        _uname: &str,\n    ) -> Result<usize> {\n        if qid != RW {\n            return Err(format!(\"write not supported for {qid} @ {offset}\"));\n        }\n\n        println!(\"writing data to rw file\");\n        let s = String::from_utf8(data).unwrap();\n        let n = s.len();\n        self.state.write().unwrap().rw = s;\n\n        Ok(n)\n    }\n\n    #[allow(unused_variables)]\n    fn create(\n        &self,\n        cid: ClientId,\n        parent: u64,\n        name: &str,\n        perm: Perm,\n        mode: Mode,\n        uname: &str,\n    ) -> Result<(FileMeta, IoUnit)> {\n        Err(\"create not supported\".to_string())\n    }\n\n    #[allow(unused_variables)]\n    fn remove(&self, cid: ClientId, qid: u64, uname: &str) -> Result<()> {\n        Err(\"remove not supported\".to_string())\n    }\n\n    #[allow(unused_variables)]\n    fn write_stat(&self, cid: ClientId, qid: u64, stat: Stat, uname: &str) -> Result<()> {\n        Err(\"write_stat not supported\".to_string())\n    }\n\n    fn walk(&self, _cid: ClientId, parent_qid: u64, child: &str, _uname: &str) -> Result<FileMeta> {\n        println!(\"handling walk request: parent={parent_qid} child={child}\");\n        match (parent_qid, child) {\n            (ROOT, \"bar\") => Ok(FileMeta::dir(\"bar\", BAR)),\n            (ROOT, \"foo\") => Ok(FileMeta::file(\"foo\", FOO)),\n            (ROOT, \"rw\") => Ok(FileMeta::file(\"rw\", RW)),\n            (ROOT, \"blocking\") => Ok(FileMeta::file(\"blocking\", BLOCKING)),\n            (BAR, \"baz\") => Ok(FileMeta::file(\"baz\", BAZ)),\n            (qid, child) => Err(format!(\"unknown child: qid={qid}, child={child}\")),\n        }\n    }\n\n    fn stat(&self, _cid: ClientId, qid: u64, uname: &str) -> Result<Stat> {\n        println!(\"handling stat request: qid={qid} uname={uname}\");\n        match qid {\n            ROOT => Ok(Stat {\n                fm: FileMeta::dir(\"/\", ROOT),\n                perms: Perm::OWNER_READ | Perm::OWNER_EXEC,\n                n_bytes: 0,\n                last_accesses: SystemTime::now(),\n                last_modified: SystemTime::now(),\n                owner: uname.into(),\n                group: uname.into(),\n                last_modified_by: uname.into(),\n            }),\n\n            BAR => Ok(Stat {\n                fm: FileMeta::dir(\"bar\", BAR),\n                perms: Perm::OWNER_READ | Perm::OWNER_EXEC,\n                n_bytes: 0,\n                last_accesses: SystemTime::now(),\n                last_modified: SystemTime::now(),\n                owner: uname.into(),\n                group: uname.into(),\n                last_modified_by: uname.into(),\n            }),\n\n            FOO => Ok(Stat {\n                fm: FileMeta::file(\"foo\", FOO),\n                perms: Perm::OWNER_READ,\n                n_bytes: 0,\n                last_accesses: SystemTime::now(),\n                last_modified: SystemTime::now(),\n                owner: uname.into(),\n                group: uname.into(),\n                last_modified_by: uname.into(),\n            }),\n\n            BAZ => Ok(Stat {\n                fm: FileMeta::file(\"baz\", BAZ),\n                perms: Perm::OWNER_READ,\n                n_bytes: 0,\n                last_accesses: SystemTime::now(),\n                last_modified: SystemTime::now(),\n                owner: uname.into(),\n                group: uname.into(),\n                last_modified_by: uname.into(),\n            }),\n\n            RW => Ok(Stat {\n                fm: FileMeta::file(\"rw\", BAZ),\n                perms: Perm::OWNER_READ | Perm::OWNER_WRITE,\n                n_bytes: self.state.read().unwrap().rw.len() as u64,\n                last_accesses: SystemTime::now(),\n                last_modified: SystemTime::now(),\n                owner: uname.into(),\n                group: uname.into(),\n                last_modified_by: uname.into(),\n            }),\n\n            BLOCKING => Ok(Stat {\n                fm: FileMeta::file(\"blocking\", BLOCKING),\n                perms: Perm::OWNER_READ,\n                n_bytes: 0,\n                last_accesses: SystemTime::now(),\n                last_modified: SystemTime::now(),\n                owner: uname.into(),\n                group: uname.into(),\n                last_modified_by: uname.into(),\n            }),\n\n            qid => Err(format!(\"stat for qid={qid}\")),\n        }\n    }\n\n    fn open(&self, _cid: ClientId, qid: u64, mode: Mode, uname: &str) -> Result<IoUnit> {\n        println!(\"handling open request: qid={qid} mode={mode:?} uname={uname}\");\n        match (qid, mode) {\n            (FOO | BAZ | RW | BLOCKING, Mode::FILE) => Ok(8168),\n            (ROOT | BAR, Mode::DIR) => Ok(8168),\n            (RW, _) => Ok(8168),\n            (qid, mode) => Err(format!(\"{qid} is not a known qid (mode={mode:?})\")),\n        }\n    }\n\n    fn read(\n        &self,\n        _cid: ClientId,\n        qid: u64,\n        offset: usize,\n        count: usize,\n        uname: &str,\n    ) -> Result<ReadOutcome> {\n        println!(\"handling read request: qid={qid} offset={offset} count={count} uname={uname}\");\n        let chunk = |s: &str| {\n            s.as_bytes()\n                .iter()\n                .skip(offset)\n                .take(count)\n                .copied()\n                .collect::<Vec<u8>>()\n        };\n\n        let mut s = self.state.write().unwrap();\n\n        let data = match qid {\n            FOO => chunk(\"foo contents\\n\"),\n            BAZ => chunk(\"contents of baz\\n\"),\n            RW => chunk(&format!(\"server state is currently: '{}'\", s.rw)),\n            BLOCKING => {\n                let (tx, rx) = channel();\n                let data = chunk(&s.blocking);\n                s.n += 1;\n                let n_str = s.n.to_string();\n                s.blocking.push_str(&n_str);\n                s.blocking.push('\\n');\n\n                spawn(move || {\n                    sleep(Duration::from_secs(1));\n                    _ = tx.send(data);\n                });\n\n                return Ok(ReadOutcome::Blocked(rx));\n            }\n\n            _ => Vec::new(),\n        };\n\n        Ok(ReadOutcome::Immediate(data))\n    }\n\n    fn read_dir(&self, _cid: ClientId, qid: u64, uname: &str) -> Result<Vec<Stat>> {\n        println!(\"handling read_dir request: qid={qid} uname={uname}\");\n        match qid {\n            ROOT => Ok(vec![\n                Stat {\n                    fm: FileMeta::dir(\"bar\", BAR),\n                    perms: Perm::OWNER_READ | Perm::OWNER_EXEC,\n                    n_bytes: 0,\n                    last_accesses: SystemTime::now(),\n                    last_modified: SystemTime::now(),\n                    owner: uname.into(),\n                    group: uname.into(),\n                    last_modified_by: uname.into(),\n                },\n                Stat {\n                    fm: FileMeta::file(\"foo\", FOO),\n                    perms: Perm::OWNER_READ,\n                    n_bytes: 42,\n                    last_accesses: SystemTime::now(),\n                    last_modified: SystemTime::now(),\n                    owner: uname.into(),\n                    group: uname.into(),\n                    last_modified_by: uname.into(),\n                },\n                Stat {\n                    fm: FileMeta::file(\"rw\", RW),\n                    perms: Perm::OWNER_READ | Perm::OWNER_WRITE,\n                    n_bytes: self.state.read().unwrap().rw.len() as u64,\n                    last_accesses: SystemTime::now(),\n                    last_modified: SystemTime::now(),\n                    owner: uname.into(),\n                    group: uname.into(),\n                    last_modified_by: uname.into(),\n                },\n                Stat {\n                    fm: FileMeta::file(\"blocking\", BLOCKING),\n                    perms: Perm::OWNER_READ,\n                    n_bytes: 0,\n                    last_accesses: SystemTime::now(),\n                    last_modified: SystemTime::now(),\n                    owner: uname.into(),\n                    group: uname.into(),\n                    last_modified_by: uname.into(),\n                },\n            ]),\n\n            BAR => Ok(vec![Stat {\n                fm: FileMeta::file(\"baz\", BAZ),\n                perms: Perm::OWNER_READ | Perm::OWNER_WRITE,\n                n_bytes: 0,\n                last_accesses: SystemTime::now(),\n                last_modified: SystemTime::now(),\n                owner: uname.into(),\n                group: uname.into(),\n                last_modified_by: uname.into(),\n            }]),\n\n            s => Err(format!(\"unknown dir: '{s}'\")),\n        }\n    }\n}\n", "source": "ad/crates/ninep/examples/server.rs", "file_type": "rc"}
{"text": "//! A simple demo of the 9p client interface\nuse ninep::sync::client::UnixClient;\nuse std::io;\n\nfn main() -> io::Result<()> {\n    let mut client = UnixClient::new_unix(\"ad\", \"\")?;\n\n    for line in client.iter_lines(\"buffers/1/event\")? {\n        print!(\"{line}\");\n        if line.contains(\"README.md\") {\n            println!(\">> Passing back load for README.md\");\n            _ = client.write_str(\"buffers/1/event\", 0, &line);\n        }\n    }\n\n    Ok(())\n}\n", "source": "ad/crates/ninep/examples/ad_test.rs", "file_type": "rc"}
{"text": "//! A simple demo of the 9p client interface\nuse ninep::{fs::FileType, sync::client::UnixClient};\nuse std::io;\n\nfn main() -> io::Result<()> {\n    let mut client = UnixClient::new_unix(\"ninep-server\", \"\")?;\n    tree(&mut client, \"\", 0)?;\n\n    for line in client.iter_lines(\"blocking\")? {\n        println!(\"{line}\");\n    }\n\n    Ok(())\n}\n\nfn tree(client: &mut UnixClient, path: &str, depth: usize) -> io::Result<()> {\n    for stat in client.read_dir(path)? {\n        let name = stat.fm.name;\n        println!(\"{:indent$}{name}\", \"\", indent = depth * 2);\n        if stat.fm.ty == FileType::Directory {\n            let child = if path.is_empty() {\n                name\n            } else {\n                format!(\"{path}/{name}\")\n            };\n            tree(client, &child, depth + 1)?;\n        }\n    }\n\n    Ok(())\n}\n", "source": "ad/crates/ninep/examples/client.rs", "file_type": "rc"}
{"text": "//! Types for describing files in a 9p virtual filesystem\nuse crate::sansio::protocol::{NineP, Qid, RawStat};\nuse std::{\n    mem::size_of,\n    time::{Duration, SystemTime, UNIX_EPOCH},\n};\n\n/// The default root qid for 9p server implementations\npub const QID_ROOT: u64 = 0;\n\nbitflags::bitflags! {\n    /// The file mode contains some additional attributes besides the permissions. If bit 31 (DMDIR) is\n    /// set, the file is a directory; if bit 30 (DMAPPEND) is set, the file is append-only (offset is\n    /// ignored in writes); if bit 29 (DMEXCL) is set, the file is exclusive-use (only one client may\n    /// have it open at a time); if bit 27 (DMAUTH) is set, the file is an authentication file\n    /// established by auth messages; if bit 26 (DMTMP) is set, the contents of the file (or directory)\n    /// are not included in nightly archives. (Bit 28 is skipped for historical reasons.) These bits\n    /// are reproduced, from the top bit down, in the type byte of the Qid: QTDIR, QTAPPEND, QTEXCL,\n    /// (skipping one bit) QTAUTH, and QTTMP. The name QTFILE, defined to be zero, identifies the value\n    /// of the type for a plain file.\n    #[derive(Debug, Clone, Copy, PartialEq, Eq)]\n    pub struct Mode: u8 {\n        /// Directory\n        const DIR = 0x80;\n        /// Append only\n        const APPEND = 0x40;\n        /// Exclusive access\n        const EXCLUSIVE = 0x20;\n        /// Mount\n        const MOUNT = 0x10;\n        /// Auth\n        const AUTH = 0x08;\n        /// Temp\n        const TMP = 0x04;\n        /// Symlink\n        const SYMLINK = 0x02;\n        /// File\n        const FILE = 0x00;\n    }\n}\n\nimpl Mode {\n    /// Create a new [Mode] from a u8 bitmask\n    pub fn new(bits: u8) -> Self {\n        Mode::from_bits_truncate(bits)\n    }\n}\n\nbitflags::bitflags! {\n    /// Each file has an associated owner and group id and three sets of permissions: those of the owner,\n    /// those of the group, and those of \u201cother\u201d users. When the owner attempts to do something to a file,\n    /// the owner, group, and other permissions are consulted, and if any of them grant the requested\n    /// permission, the operation is allowed. For someone who is not the owner, but is a member of the\n    /// file\u2019s group, the group and other permissions are consulted. For everyone else, the other\n    /// permissions are used. Each set of permissions says whether reading is allowed, whether writing is\n    /// allowed, and whether executing is allowed.\n    ///\n    /// A walk in a directory is regarded as executing the directory, not reading it.\n    ///\n    /// Permissions are kept in the low-order bits of the file mode:\n    ///   - owner read/write/execute permission represented as 1 in bits 8, 7, and 6 respectively\n    ///     (using 0 to number the low order).\n    ///   - The group permissions are in bits 5, 4, and 3,\n    ///   - and the other permissions are in bits 2, 1, and 0.\n    #[derive(Debug, Clone, Copy, PartialEq, Eq)]\n    pub struct Perm: u32 {\n        /// Directory\n        const DIR = 0x80000000;\n        /// Append only\n        const APPEND = 0x40000000;\n        /// Exclusive access\n        const EXCLUSIVE = 0x20000000;\n        /// File\n        const FILE = 0x00000000;\n        /// Mount\n        const MOUNT = 0x10000000;\n        /// Auth\n        const AUTH = 0x08000000;\n        /// Temp\n        const TMP = 0x04000000;\n        /// Symlink\n        const SYMLINK = 0x02000000;\n        /// Device\n        const DEVICE = 0x00800000;\n        /// Named pipe\n        const NAMED_PIPE = 0x00200000;\n        /// Socket\n        const SOCKET = 0x00100000;\n        /// Set UID\n        const SET_UID = 0x00080000;\n        /// Set GID\n        const SET_GID = 0x00040000;\n\n        /// Readable by owner\n        const OWNER_READ = 0o400;\n        /// Writable by owner\n        const OWNER_WRITE = 0o200;\n        /// Executable by owner\n        const OWNER_EXEC = 0o100;\n\n        /// Readable by group\n        const GROUP_READ = 0o040;\n        /// Writable by group\n        const GROUP_WRITE = 0o020;\n        /// Executable by group\n        const GROUP_EXEC = 0o010;\n\n        /// Readable by other\n        const OTHER_READ = 0o004;\n        /// Writable by other\n        const OTHER_WRITE = 0o002;\n        /// Executable by other\n        const OTHER_EXEC = 0o001;\n    }\n}\n\nimpl Perm {\n    /// Create a new [Perm] from a u32 bitmask\n    pub fn new(bits: u32) -> Self {\n        Perm::from_bits_truncate(bits)\n    }\n}\n\n/// <http://p9f.org/magic/man2html/2/iounit>\n///\n/// Reads and writes of files are transmitted using the 9P protocol (see intro(5)) and in general,\n/// operations involving large amounts of data must be broken into smaller pieces by the operating\n/// system. The `I/O unit` associated with each file descriptor records the maximum size, in bytes,\n/// that may be read or written without breaking up the transfer.\npub type IoUnit = u32;\n\n/// A machine independent directory entry\n#[derive(Debug, Clone, PartialEq, Eq)]\npub struct Stat {\n    /// File metadata\n    pub fm: FileMeta,\n    /// Permissions\n    pub perms: Perm,\n    /// Size in bytes\n    pub n_bytes: u64,\n    /// Timestamp of last access\n    pub last_accesses: SystemTime,\n    /// Timestamp of last modification\n    pub last_modified: SystemTime,\n    /// Owner\n    pub owner: String,\n    /// Group\n    pub group: String,\n    /// User who last modified this entry\n    pub last_modified_by: String,\n}\n\nimpl From<Stat> for RawStat {\n    fn from(s: Stat) -> Self {\n        let qid = Qid {\n            ty: Mode::from(s.fm.ty).bits(),\n            version: 0,\n            path: s.fm.qid,\n        };\n\n        let size = (size_of::<u16>()\n            + size_of::<u32>() * 4\n            + qid.n_bytes()\n            + s.n_bytes.n_bytes()\n            + s.fm.name.n_bytes()\n            + s.owner.n_bytes()\n            + s.group.n_bytes()\n            + s.last_modified_by.n_bytes()) as u16;\n\n        RawStat {\n            size,\n            ty: 0,\n            dev: 0,\n            qid,\n            mode: (Perm::from(s.fm.ty) | s.perms).bits(),\n            atime: systime_as_u32(s.last_accesses),\n            mtime: systime_as_u32(s.last_modified),\n            length: s.n_bytes,\n            name: s.fm.name.clone(),\n            uid: s.owner,\n            gid: s.group,\n            muid: s.last_modified_by,\n        }\n    }\n}\n\nimpl TryFrom<RawStat> for Stat {\n    type Error = String;\n\n    fn try_from(r: RawStat) -> Result<Self, String> {\n        Ok(Stat {\n            fm: FileMeta {\n                name: r.name,\n                ty: Mode::new(r.qid.ty).try_into()?,\n                qid: r.qid.path,\n            },\n            perms: Perm::new(r.mode & 0x0000FFFF),\n            last_accesses: systime_from_u32(r.atime),\n            last_modified: systime_from_u32(r.mtime),\n            n_bytes: r.length,\n            owner: r.uid,\n            group: r.gid,\n            last_modified_by: r.muid,\n        })\n    }\n}\n\n/// Supported filetypes\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum FileType {\n    /// Directory\n    Directory,\n    /// Regular\n    Regular,\n    /// Append only\n    AppendOnly,\n    /// Exclusive access\n    Exclusive,\n}\n\nimpl From<FileType> for Mode {\n    fn from(value: FileType) -> Self {\n        match value {\n            FileType::Directory => Mode::DIR,\n            FileType::Regular => Mode::FILE,\n            FileType::AppendOnly => Mode::APPEND,\n            FileType::Exclusive => Mode::EXCLUSIVE,\n        }\n    }\n}\n\nimpl TryFrom<Mode> for FileType {\n    type Error = String;\n\n    fn try_from(value: Mode) -> Result<Self, String> {\n        match value {\n            Mode::DIR => Ok(Self::Directory),\n            Mode::FILE => Ok(Self::Regular),\n            Mode::APPEND => Ok(Self::AppendOnly),\n            Mode::EXCLUSIVE => Ok(Self::Exclusive),\n            m => Err(format!(\"invalid mode value: {m:o}\")),\n        }\n    }\n}\n\nimpl From<FileType> for Perm {\n    fn from(value: FileType) -> Self {\n        match value {\n            FileType::Directory => Perm::DIR,\n            FileType::Regular => Perm::FILE,\n            FileType::AppendOnly => Perm::APPEND,\n            FileType::Exclusive => Perm::EXCLUSIVE,\n        }\n    }\n}\n\n/// File meta-data\n#[derive(Debug, Clone, PartialEq, Eq)]\npub struct FileMeta {\n    /// The name of the file\n    pub name: String,\n    /// The type of the file\n    pub ty: FileType,\n    /// The server Qid for this file\n    pub qid: u64,\n}\n\nimpl FileMeta {\n    pub(super) fn as_qid(&self) -> Qid {\n        Qid {\n            ty: Mode::from(self.ty).bits(),\n            version: 0,\n            path: self.qid,\n        }\n    }\n\n    /// Construct a new [FileMeta] for a directory.\n    pub fn dir(name: impl Into<String>, qid: u64) -> Self {\n        Self {\n            name: name.into(),\n            ty: FileType::Directory,\n            qid,\n        }\n    }\n\n    /// Construct a new [FileMeta] for a regular file.\n    pub fn file(name: impl Into<String>, qid: u64) -> Self {\n        Self {\n            name: name.into(),\n            ty: FileType::Regular,\n            qid,\n        }\n    }\n\n    /// Construct a new [FileMeta] for an append only file.\n    pub fn append_only_file(name: impl Into<String>, qid: u64) -> Self {\n        Self {\n            name: name.into(),\n            ty: FileType::AppendOnly,\n            qid,\n        }\n    }\n\n    /// Construct a new [FileMeta] for an exclusive file.\n    pub fn exclusive_file(name: impl Into<String>, qid: u64) -> Self {\n        Self {\n            name: name.into(),\n            ty: FileType::Exclusive,\n            qid,\n        }\n    }\n}\n\nfn systime_as_u32(t: SystemTime) -> u32 {\n    match t.duration_since(UNIX_EPOCH) {\n        Ok(d) => d.as_secs() as u32,\n        Err(_) => 0,\n    }\n}\n\nfn systime_from_u32(t: u32) -> SystemTime {\n    UNIX_EPOCH + Duration::from_secs(t as u64)\n}\n", "source": "ad/crates/ninep/src/fs.rs", "file_type": "rc"}
{"text": "//! Asynchronous [Server] implementation using tokio's [AsyncRead][0] and [AsyncWrite][1].\n//!\n//!  [0]: tokio::io::AsyncRead\n//!  [1]: tokio::io::AsyncWrite\nuse crate::{\n    Result,\n    fs::{FileMeta, FileType, IoUnit, Mode, Perm, Stat},\n    sansio::{\n        protocol::{Data, RawStat, Rdata, Tdata, Tmessage},\n        server::{\n            Attached, E_CREATE_NON_DIR, E_UNKNOWN_FID, Either, Session, SessionType, Unattached,\n        },\n    },\n    tokio::{AsyncNineP, AsyncStream},\n};\nuse simple_coro::CoroState;\nuse std::{collections::btree_map::Entry, fs, future::Future, mem::size_of, path::PathBuf};\nuse tokio::{\n    net::{TcpListener, UnixListener},\n    sync::mpsc::{Receiver, UnboundedSender, unbounded_channel},\n    task::{JoinHandle, spawn},\n};\n\n// re-exports\npub use crate::sansio::server::{ClientId, Server, socket_dir, socket_path};\n\n/// The outcome of a client attempting to [read](AsyncServe9p::read) a given file.\n#[derive(Debug)]\npub enum ReadOutcome {\n    /// The data is immediately available.\n    Immediate(Vec<u8>),\n    /// No response should be sent until data is received on the provided channel\n    Blocked(Receiver<Vec<u8>>),\n}\n\n#[derive(Debug)]\nstruct Socket {\n    path: PathBuf,\n    listener: UnixListener,\n}\n\nimpl Drop for Socket {\n    fn drop(&mut self) {\n        let _ = fs::remove_file(&self.path);\n    }\n}\n\nfn unix_socket(path: impl Into<PathBuf>) -> Socket {\n    let path = path.into();\n    if let Some(dir) = path.parent() {\n        let _ = fs::create_dir_all(dir);\n    }\n\n    // FIXME: really we should be handling this on exit but we'll need to catch\n    // ctrl-c to do that properly. For now this works but it means that if you\n    // start a second file server with the same name then it'll remove the socket\n    // for the first.\n    let _ = fs::remove_file(&path);\n    let listener = UnixListener::bind(&path).unwrap();\n\n    Socket { path, listener }\n}\n\nasync fn tcp_socket(port: u16) -> TcpListener {\n    let addr = format!(\"127.0.0.1:{port}\");\n    TcpListener::bind(addr).await.unwrap()\n}\n\n/// A type capable of handling [9p](http://9p.cat-v.org/) requests in order to implement a\n/// 9p virtual filesystem. The [Server] struct is used to handle the lower level protocol and\n/// underlying connection, allowing implementers of this trait to focus on the semantics of the\n/// virtual filesystem itself.\n///\n/// # The 9p protocol\n/// Please see [the documentation page on cat-v](http://9p.cat-v.org/documentation/) for an\n/// overview of how the protocol works along with various papers covering the original implementation\n/// from Bell Labs. For simple filesystems you should be able to get away with referring to the\n/// docs on each of the methods for this trait, but you are advised to read through the semantics\n/// around permissions and file creation as this is something handled by the trait implementer, not\n/// [Server].\n///\n/// ## Client fids and server-side qids\n/// [Server] handles establishing and maintaining per-client sessions along with all of their `fids`,\n/// as such, [AsyncServe9p] only needs to worry about maintaining `qids` for resources.\n///\n/// The source code of [Server] is a useful reference for those wanting to learn more.\npub trait AsyncServe9p: Send + Sync + 'static {\n    // #[allow(unused_variables)]\n    // fn auth(&self, afid: u32, uname: &str, aname: &str) -> impl Future<Output=Result<Qid>> + Send {\n    //     async { Err(\"authentication not required\".to_string()) }\n    // }\n\n    /// Lookup a child node under a known parent directory by name.\n    ///\n    /// `9p` Twalk messages received by the server will specify a full path from a known parent\n    /// to a target child. This method is called for each element of that path in sequence in order,\n    /// stopping either when the target is reached or some element of the path returns an error.\n    ///\n    /// [Server] will ensure that this method is only called for known parents who have previously\n    /// been identified has having [FileType::Directory].\n    fn walk(\n        &self,\n        cid: ClientId,\n        parent_qid: u64,\n        child: &str,\n        uname: &str,\n    ) -> impl Future<Output = Result<FileMeta>> + Send;\n\n    /// Open an existing file in the requested mode for subsequent I/O via [read](AsyncServe9p::read) and\n    /// [write](AsyncServe9p::write) calls.\n    ///\n    /// The return of this method is an [IoUnit] used to inform the client of the maximum number of\n    /// bytes that will be supported per read/write call on this resource.\n    fn open(\n        &self,\n        cid: ClientId,\n        qid: u64,\n        mode: Mode,\n        uname: &str,\n    ) -> impl Future<Output = Result<IoUnit>> + Send;\n\n    /// Clunk a currently open file.\n    #[allow(unused_variables)]\n    fn clunk(&self, cid: ClientId, qid: u64) -> impl Future<Output = ()> + Send {\n        async {}\n    }\n\n    /// Create a new file in the given parent directory.\n    fn create(\n        &self,\n        cid: ClientId,\n        parent: u64,\n        name: &str,\n        perm: Perm,\n        mode: Mode,\n        uname: &str,\n    ) -> impl Future<Output = Result<(FileMeta, IoUnit)>> + Send;\n\n    /// Read `count` bytes from the requested file starting from the given `offset`.\n    fn read(\n        &self,\n        cid: ClientId,\n        qid: u64,\n        offset: usize,\n        count: usize,\n        uname: &str,\n    ) -> impl Future<Output = Result<ReadOutcome>> + Send;\n\n    /// List the contents of the given directory.\n    fn read_dir(\n        &self,\n        cid: ClientId,\n        qid: u64,\n        uname: &str,\n    ) -> impl Future<Output = Result<Vec<Stat>>> + Send;\n\n    /// Write the given `data` to the requested file starting at `offset`\n    fn write(\n        &self,\n        cid: ClientId,\n        qid: u64,\n        offset: usize,\n        data: Vec<u8>,\n        uname: &str,\n    ) -> impl Future<Output = Result<usize>> + Send;\n\n    /// Remove the requested file from the filesystem.\n    fn remove(\n        &self,\n        cid: ClientId,\n        qid: u64,\n        uname: &str,\n    ) -> impl Future<Output = Result<()>> + Send;\n\n    /// Request a machine independent \"directory entry\" for the given resource.\n    fn stat(\n        &self,\n        cid: ClientId,\n        qid: u64,\n        uname: &str,\n    ) -> impl Future<Output = Result<Stat>> + Send;\n\n    /// Attempt to set the machine independent \"directory entry\" for the given resource.\n    fn write_stat(\n        &self,\n        cid: ClientId,\n        qid: u64,\n        stat: Stat,\n        uname: &str,\n    ) -> impl Future<Output = Result<()>> + Send;\n}\n\nimpl<S> Server<S>\nwhere\n    S: AsyncServe9p,\n{\n    /// Bind this server to the specified port and serve over a tcp socket.\n    pub fn serve_tcp_async(mut self, port: u16) -> JoinHandle<()> {\n        spawn(async move {\n            let listener = tcp_socket(port).await;\n            loop {\n                if let Ok((stream, _addr)) = listener.accept().await {\n                    let session = self.new_session(stream);\n                    spawn(session.handle_connection_async());\n                }\n            }\n        })\n    }\n\n    /// Bind this server to the specified socket name and serve over a unix socket created under\n    /// the default [socket_dir].\n    pub fn serve_socket_async(self, socket_name: impl Into<String>) -> JoinHandle<()> {\n        let socket_name = socket_name.into();\n        let path = socket_dir().join(socket_name);\n\n        self.serve_socket_with_custom_path_async(path)\n    }\n\n    /// Bind this server to the specified absolute path and serve over a unix socket created under\n    /// an arbitrary directory.\n    ///\n    /// It is recommended that you use [Server::serve_socket_async] for most purposes so that your\n    /// server creates its socket in the known default [socket_dir].\n    pub fn serve_socket_with_custom_path_async(mut self, socket_path: PathBuf) -> JoinHandle<()> {\n        spawn(async move {\n            let sock = unix_socket(socket_path);\n            loop {\n                if let Ok((stream, _addr)) = sock.listener.accept().await {\n                    let session = self.new_session(stream);\n                    spawn(session.handle_connection_async());\n                }\n            }\n        })\n    }\n}\n\nimpl<T, S, U> Session<T, S, U>\nwhere\n    T: SessionType,\n    S: AsyncServe9p,\n    U: AsyncStream,\n{\n    async fn reply_async(&mut self, tag: u16, resp: Result<Rdata>) {\n        self.stream.reply(tag, resp).await\n    }\n}\n\nimpl<S, U> Session<Unattached, S, U>\nwhere\n    S: AsyncServe9p,\n    U: AsyncStream,\n{\n    async fn handle_connection_async(mut self) {\n        loop {\n            let t = match Tmessage::read_from(&self.buf, &mut self.stream).await {\n                Ok(t) => t,\n                Err(_) => return,\n            };\n\n            match self.handle_tmessage_unattached(t) {\n                Either::L((tag, resp)) => self.reply_async(tag, resp).await,\n                Either::R((tag, st, aqid)) => {\n                    self.reply_async(tag, Ok(Rdata::Attach { aqid })).await;\n                    return self.into_attached(st).handle_connection_async().await;\n                }\n            }\n        }\n    }\n}\n\nimpl<S, U> Session<Attached, S, U>\nwhere\n    S: AsyncServe9p,\n    U: AsyncStream,\n{\n    /// Explicitly clunk all\n    async fn clunk_and_clear_async(&mut self) {\n        for &qid in self.state.fids.values() {\n            self.s.clunk(self.client_id, qid).await;\n        }\n        self.state.fids.clear();\n    }\n\n    async fn handle_connection_async(mut self) {\n        use Tdata::*;\n        let (tx, mut rx) = unbounded_channel();\n\n        loop {\n            let Tmessage { tag, content } = tokio::select! {\n                // Blocked read came through so send it to the client\n                Some((tag, data)) = rx.recv() => {\n                    self.stream\n                        .reply(tag, Ok(Rdata::Read { data: Data(data) }))\n                        .await;\n                    continue;\n                },\n                res = Tmessage::read_from(&self.buf, &mut self.stream) => match res {\n                    Ok(t) => t,\n                    Err(_) => return self.clunk_and_clear_async().await,\n                },\n                else => continue,\n            };\n\n            let resp = match content {\n                Version { msize, version } => {\n                    let resp = self.handle_version(msize, version);\n                    self.clunk_and_clear_async().await;\n\n                    Ok(resp)\n                }\n                Auth { .. } | Attach { .. } => Err(\"session is already attached\".into()),\n                Flush { .. } => Ok(Rdata::Flush {}),\n\n                Walk {\n                    fid,\n                    new_fid,\n                    wnames,\n                } => self.handle_walk_async(fid, new_fid, wnames).await,\n                Clunk { fid } => self.handle_clunk_async(fid).await,\n                Stat { fid } => self.handle_stat_async(fid).await,\n                Open { fid, mode } => self.handle_open_async(fid, Mode::new(mode)).await,\n                Create {\n                    fid,\n                    name,\n                    perm,\n                    mode,\n                } => {\n                    self.handle_create_async(fid, name, Perm::new(perm), Mode::new(mode))\n                        .await\n                }\n                Read { fid, offset, count } => {\n                    match self.handle_read_async(tag, fid, offset, count, &tx).await {\n                        Ok(Some(resp)) => Ok(resp),\n                        Err(err) => Err(err),\n                        Ok(None) => continue,\n                    }\n                }\n                Write { fid, offset, data } => self.handle_write_async(fid, offset, data.0).await,\n                Remove { fid } => self.handle_remove_async(fid).await,\n                Wstat { fid, stat, .. } => self.handle_wstat_async(fid, stat).await,\n            };\n\n            self.reply_async(tag, resp).await;\n        }\n    }\n\n    /// The walk request carries as arguments an existing fid and a proposed newfid (which must not\n    /// be in use unless it is the same as fid) that the client wishes to associate with the result\n    /// of traversing the directory hierarchy by \u2018walking\u2019 the hierarchy using the successive path\n    /// name elements wname.\n    ///\n    /// The fid must represent a directory unless zero path name elements are specified.\n    ///\n    /// The fid must be valid in the current session and must not have been opened for I/O by an\n    /// open or create message. If the full sequence of nwname elements is walked successfully,\n    /// newfid will represent the file that results. If not, newfid (and fid) will be unaffected.\n    /// However, if newfid is in use or otherwise illegal, an Rerror is returned.\n    ///\n    /// The name \u201c..\u201d (dot-dot) represents the parent directory. The name \u201c.\u201d (dot), meaning the\n    /// current directory, is not used in the protocol.\n    ///\n    /// It is legal for nwname to be zero, in which case newfid will represent the same file as fid\n    /// and the walk will usually succeed; this is equivalent to walking to dot. The rest of this\n    /// discussion assumes nwname is greater than zero.\n    ///\n    /// The nwname path name elements wname are walked in order, \u201celementwise\u201d. For the first\n    /// elementwise walk to succeed, the file identified by fid must be a directory, and the\n    /// implied user of the request must have permission to search the directory (see intro(9P)).\n    /// Subsequent elementwise walks have equivalent restrictions applied to the implicit fid that\n    /// results from the preceding elementwise walk.\n    ///\n    /// If the first element cannot be walked for any reason, Rerror is returned. Otherwise, the\n    /// walk will return an Rwalk message containing nwqid qids corresponding, in order, to the\n    /// files that are visited by the nwqid successful elementwise walks; nwqid is therefore either\n    /// nwname or the index of the first elementwise walk that failed. The value of nwqid cannot be\n    /// zero unless nwname is zero. Also, nwqid will always be less than or equal to nwname. Only\n    /// if it is equal, however, will newfid be affected, in which case newfid will represent the\n    /// file reached by the final elementwise walk requested in the message.\n    ///\n    /// A walk of the name \u201c..\u201d in the root directory of a server is equivalent to a walk with no\n    /// name elements.\n    ///\n    /// If newfid is the same as fid, the above discussion applies, with the obvious difference\n    /// that if the walk changes the state of newfid, it also changes the state of fid; and if\n    /// newfid is unaffected, then fid is also unaffected.\n    ///\n    /// To simplify the implementation of the servers, a maximum of sixteen name elements or qids\n    /// may be packed in a single message. This constant is called MAXWELEM in fcall(3). Despite\n    /// this restriction, the system imposes no limit on the number of elements in a file name,\n    /// only the number that may be transmitted in a single message.\n    async fn handle_walk_async(\n        &mut self,\n        fid: u32,\n        new_fid: u32,\n        wnames: Vec<String>,\n    ) -> Result<Rdata> {\n        let client_id = self.client_id;\n        let mut coro = self\n            .session_state\n            .handle_attached_walk(fid, new_fid, &wnames);\n\n        loop {\n            coro = match coro.resume() {\n                CoroState::Complete(res) => return res,\n                CoroState::Pending(c, (qid, name, uname)) => {\n                    let fm = self.s.walk(client_id, qid, name, uname).await?;\n                    c.send(fm)\n                }\n            };\n        }\n    }\n\n    async fn handle_clunk_async(&mut self, fid: u32) -> Result<Rdata> {\n        match self.state.fids.entry(fid) {\n            Entry::Occupied(ent) => {\n                let qid = ent.remove();\n                self.s.clunk(self.client_id, qid).await;\n\n                Ok(Rdata::Clunk {})\n            }\n            Entry::Vacant(_) => Err(E_UNKNOWN_FID.to_string()),\n        }\n    }\n\n    async fn handle_stat_async(&mut self, fid: u32) -> Result<Rdata> {\n        let fm = self.try_file_meta(fid)?;\n        let s = self\n            .s\n            .stat(self.client_id, fm.qid, &self.state.uname)\n            .await?;\n        let stat: RawStat = s.into();\n        let size = stat.size + size_of::<u16>() as u16;\n\n        Ok(Rdata::Stat { size, stat })\n    }\n\n    async fn handle_wstat_async(&mut self, fid: u32, raw_stat: RawStat) -> Result<Rdata> {\n        let stat: Stat = raw_stat.try_into()?;\n        let fm = self.try_file_meta(fid)?;\n        self.s\n            .write_stat(self.client_id, fm.qid, stat, &self.state.uname)\n            .await?;\n\n        Ok(Rdata::Wstat {})\n    }\n\n    async fn handle_open_async(&mut self, fid: u32, mode: Mode) -> Result<Rdata> {\n        let fm = self.try_file_meta(fid)?;\n        let iounit = self\n            .s\n            .open(self.client_id, fm.qid, mode, &self.state.uname)\n            .await?;\n\n        Ok(Rdata::Open {\n            qid: fm.as_qid(),\n            iounit,\n        })\n    }\n\n    async fn handle_create_async(\n        &mut self,\n        fid: u32,\n        name: String,\n        perm: Perm,\n        mode: Mode,\n    ) -> Result<Rdata> {\n        let fm = self.try_file_meta(fid)?;\n        if fm.ty != FileType::Directory {\n            return Err(E_CREATE_NON_DIR.to_string());\n        }\n\n        let (fm, iounit) = self\n            .s\n            .create(self.client_id, fm.qid, &name, perm, mode, &self.state.uname)\n            .await?;\n\n        // fid is now changed to point to the newly created file rather than the parent\n        let qid = fm.as_qid();\n        self.state.fids.insert(fid, fm.qid);\n        self.qids.entry(fm.qid).or_insert(fm);\n\n        Ok(Rdata::Create { qid, iounit })\n    }\n\n    // The read request asks for count bytes of data from the file identified by fid, which must be\n    // opened for reading, starting offset bytes after the beginning of the file. The bytes are\n    // returned with the read reply message.\n    // The count field in the reply indicates the number of bytes returned. This may be less than\n    // the requested amount. If the offset field is greater than or equal to the number of bytes in\n    // the file, a count of zero will be returned.\n    // For directories, read returns an integral number of directory entries exactly as in stat\n    // (see stat(9P)), one for each member of the directory. The read request message must have\n    // offset equal to zero or the value of offset in the previous read on the directory, plus the\n    // number of bytes returned in the previous read. In other words, seeking other than to the\n    // beginning is illegal in a directory.\n    async fn handle_read_async(\n        &mut self,\n        tag: u16,\n        fid: u32,\n        offset: u64,\n        count: u32,\n        tx: &UnboundedSender<(u16, Vec<u8>)>,\n    ) -> Result<Option<Rdata>> {\n        let cid = self.client_id;\n        let coro = self.session_state.handle_attached_read(fid, offset, count);\n        let (offset, count) = (offset as usize, count as usize);\n\n        match coro.resume() {\n            CoroState::Complete(res) => res,\n            CoroState::Pending(c, Either::L((qid, uname))) => {\n                let stats = self.s.read_dir(cid, qid, uname).await?;\n                c.send(stats).resume().unwrap()\n            }\n            CoroState::Pending(_, Either::R((qid, uname))) => {\n                let outcome = self.s.read(cid, qid, offset, count, uname).await?;\n                match outcome {\n                    ReadOutcome::Immediate(data) => Ok(Some(Rdata::Read { data: Data(data) })),\n                    ReadOutcome::Blocked(mut chan) => {\n                        let tx = tx.clone();\n                        spawn(async move {\n                            let data = chan.recv().await.unwrap_or_default();\n                            tx.send((tag, data))\n                        });\n\n                        Ok(None)\n                    }\n                }\n            }\n        }\n    }\n\n    async fn handle_write_async(&mut self, fid: u32, offset: u64, data: Vec<u8>) -> Result<Rdata> {\n        if offset > u32::MAX as u64 {\n            return Err(format!(\"offset too large: {offset} > {}\", u32::MAX));\n        }\n\n        let fm = self.try_file_meta(fid)?;\n        let count = self\n            .s\n            .write(\n                self.client_id,\n                fm.qid,\n                offset as usize,\n                data,\n                &self.state.uname,\n            )\n            .await? as u32;\n\n        Ok(Rdata::Write { count })\n    }\n\n    async fn handle_remove_async(&mut self, fid: u32) -> Result<Rdata> {\n        let fm = self.try_file_meta(fid)?;\n        self.s\n            .remove(self.client_id, fm.qid, &self.state.uname)\n            .await?;\n\n        Ok(Rdata::Remove {})\n    }\n}\n", "source": "ad/crates/ninep/src/tokio/server.rs", "file_type": "rc"}
{"text": "//! Synchronous [Server] implementation using [Read][0] and [Write][1].\n//!\n//!  [0]: std::io::Read\n//!  [1]: std::io::Write\nuse crate::{\n    Result,\n    fs::{FileMeta, FileType, IoUnit, Mode, Perm, Stat},\n    sansio::{\n        protocol::{Data, RawStat, Rdata, Rmessage, Tdata, Tmessage},\n        server::{\n            Attached, E_ALREADY_ATTACHED, E_CREATE_NON_DIR, E_UNKNOWN_FID, Either, Session,\n            SessionType, Unattached,\n        },\n    },\n    sync::{SyncNineP, SyncServerStream, SyncStream},\n};\nuse simple_coro::CoroState;\nuse std::{\n    collections::btree_map::Entry,\n    fs,\n    mem::size_of,\n    net::TcpListener,\n    os::unix::net::UnixListener,\n    path::PathBuf,\n    sync::mpsc::Receiver,\n    thread::{JoinHandle, spawn},\n};\n\n// re-exports\npub use crate::sansio::server::{ClientId, Server, socket_dir, socket_path};\n\n/// The outcome of a client attempting to [read](Serve9p::read) a given file.\n#[derive(Debug)]\npub enum ReadOutcome {\n    /// The data is immediately available.\n    Immediate(Vec<u8>),\n    /// No response should be sent until data is received on the provided channel\n    Blocked(Receiver<Vec<u8>>),\n}\n\n#[derive(Debug)]\nstruct Socket {\n    path: PathBuf,\n    listener: UnixListener,\n}\n\nimpl Drop for Socket {\n    fn drop(&mut self) {\n        let _ = fs::remove_file(&self.path);\n    }\n}\n\nfn unix_socket(path: impl Into<PathBuf>) -> Socket {\n    let path = path.into();\n    if let Some(dir) = path.parent() {\n        let _ = fs::create_dir_all(dir);\n    }\n\n    // FIXME: really we should be handling this on exit but we'll need to catch\n    // ctrl-c to do that properly. For now this works but it means that if you\n    // start a second file server with the same name then it'll remove the socket\n    // for the first.\n    let _ = fs::remove_file(&path);\n    let listener = UnixListener::bind(&path).unwrap();\n\n    Socket { path, listener }\n}\n\nfn tcp_socket(port: u16) -> TcpListener {\n    let addr = format!(\"127.0.0.1:{port}\");\n    TcpListener::bind(addr).unwrap()\n}\n\n/// A type capable of handling [9p](http://9p.cat-v.org/) requests in order to implement a\n/// 9p virtual filesystem. The [Server] struct is used to handle the lower level protocol and\n/// underlying connection, allowing implementers of this trait to focus on the semantics of the\n/// virtual filesystem itself.\n///\n/// # The 9p protocol\n/// Please see [the documentation page on cat-v](http://9p.cat-v.org/documentation/) for an\n/// overview of how the protocol works along with various papers covering the original implementation\n/// from Bell Labs. For simple filesystems you should be able to get away with referring to the\n/// docs on each of the methods for this trait, but you are advised to read through the semantics\n/// around permissions and file creation as this is something handled by the trait implementer, not\n/// [Server].\n///\n/// ## Client fids and server-side qids\n/// [Server] handles establishing and maintaining per-client sessions along with all of their `fids`,\n/// as such, [Serve9p] only needs to worry about maintaining `qids` for resources.\n///\n/// The source code of [Server] is a useful reference for those wanting to learn more.\npub trait Serve9p: Send + Sync + 'static {\n    // #[allow(unused_variables)]\n    // fn auth(&self, afid: u32, uname: &str, aname: &str) -> Result<Qid> {\n    //     Err(\"authentication not required\".to_string())\n    // }\n\n    /// Lookup a child node under a known parent directory by name.\n    ///\n    /// `9p` Twalk messages received by the server will specify a full path from a known parent\n    /// to a target child. This method is called for each element of that path in sequence in order,\n    /// stopping either when the target is reached or some element of the path returns an error.\n    ///\n    /// [Server] will ensure that this method is only called for known parents who have previously\n    /// been identified has having [FileType::Directory].\n    fn walk(&self, cid: ClientId, parent_qid: u64, child: &str, uname: &str) -> Result<FileMeta>;\n\n    /// Open an existing file in the requested mode for subsequent I/O via [read](Serve9p::read) and\n    /// [write](Serve9p::write) calls.\n    ///\n    /// The return of this method is an [IoUnit] used to inform the client of the maximum number of\n    /// bytes that will be supported per read/write call on this resource.\n    fn open(&self, cid: ClientId, qid: u64, mode: Mode, uname: &str) -> Result<IoUnit>;\n\n    /// Clunk a currently open file.\n    #[allow(unused_variables)]\n    fn clunk(&self, cid: ClientId, qid: u64) {}\n\n    /// Create a new file in the given parent directory.\n    fn create(\n        &self,\n        cid: ClientId,\n        parent: u64,\n        name: &str,\n        perm: Perm,\n        mode: Mode,\n        uname: &str,\n    ) -> Result<(FileMeta, IoUnit)>;\n\n    /// Read `count` bytes from the requested file starting from the given `offset`.\n    fn read(\n        &self,\n        cid: ClientId,\n        qid: u64,\n        offset: usize,\n        count: usize,\n        uname: &str,\n    ) -> Result<ReadOutcome>;\n\n    /// List the contents of the given directory.\n    fn read_dir(&self, cid: ClientId, qid: u64, uname: &str) -> Result<Vec<Stat>>;\n\n    /// Write the given `data` to the requested file starting at `offset`\n    fn write(\n        &self,\n        cid: ClientId,\n        qid: u64,\n        offset: usize,\n        data: Vec<u8>,\n        uname: &str,\n    ) -> Result<usize>;\n\n    /// Remove the requested file from the filesystem.\n    fn remove(&self, cid: ClientId, qid: u64, uname: &str) -> Result<()>;\n\n    /// Request a machine independent \"directory entry\" for the given resource.\n    fn stat(&self, cid: ClientId, qid: u64, uname: &str) -> Result<Stat>;\n\n    /// Attempt to set the machine independent \"directory entry\" for the given resource.\n    fn write_stat(&self, cid: ClientId, qid: u64, stat: Stat, uname: &str) -> Result<()>;\n}\n\nimpl<S> Server<S>\nwhere\n    S: Serve9p,\n{\n    /// Bind this server to the specified port and serve over a tcp socket.\n    pub fn serve_tcp(mut self, port: u16) -> JoinHandle<()> {\n        spawn(move || {\n            let listener = tcp_socket(port);\n\n            for stream in listener.incoming() {\n                let stream = stream.unwrap();\n                let session = self.new_session(stream);\n                spawn(move || session.handle_connection());\n            }\n        })\n    }\n\n    /// Bind this server to the specified socket name and serve over a unix socket created under\n    /// the default [socket_dir].\n    pub fn serve_socket(self, socket_name: impl Into<String>) -> JoinHandle<()> {\n        let socket_name = socket_name.into();\n        let path = socket_dir().join(socket_name);\n\n        self.serve_socket_with_custom_path(path)\n    }\n\n    /// Bind this server to the specified absolute path and serve over a unix socket created under\n    /// an arbitrary directory.\n    ///\n    /// It is recommended that you use [Server::serve_socket] for most purposes so that your server\n    /// creates its socket in the known default [socket_dir].\n    pub fn serve_socket_with_custom_path(mut self, socket_path: PathBuf) -> JoinHandle<()> {\n        spawn(move || {\n            let sock = unix_socket(socket_path);\n\n            for stream in sock.listener.incoming() {\n                let stream = stream.unwrap();\n                let session = self.new_session(stream);\n                spawn(move || session.handle_connection());\n            }\n        })\n    }\n}\n\nimpl<T, S, U> Session<T, S, U>\nwhere\n    T: SessionType,\n    S: Serve9p,\n    U: SyncStream,\n{\n    fn reply(&mut self, tag: u16, resp: Result<Rdata>) {\n        let r: Rmessage = (tag, resp).into();\n        let _ = r.write_to(&mut self.stream);\n    }\n}\n\nimpl<S, U> Session<Unattached, S, U>\nwhere\n    S: Serve9p,\n    U: SyncServerStream,\n{\n    fn handle_connection(mut self) {\n        loop {\n            let t = match Tmessage::read_from(&self.buf, &mut self.stream) {\n                Ok(t) => t,\n                Err(_) => return,\n            };\n\n            match self.handle_tmessage_unattached(t) {\n                Either::L((tag, resp)) => self.reply(tag, resp),\n                Either::R((tag, st, aqid)) => {\n                    self.reply(tag, Ok(Rdata::Attach { aqid }));\n                    return self.into_attached(st).handle_connection();\n                }\n            }\n        }\n    }\n}\n\nimpl<S, U> Session<Attached, S, U>\nwhere\n    S: Serve9p,\n    U: SyncServerStream,\n{\n    /// Explicitly clunk all\n    fn clunk_and_clear(&mut self) {\n        for &qid in self.state.fids.values() {\n            self.s.clunk(self.client_id, qid);\n        }\n        self.state.fids.clear();\n    }\n\n    fn handle_connection(mut self) {\n        use Tdata::*;\n\n        loop {\n            let t = match Tmessage::read_from(&self.buf, &mut self.stream) {\n                Ok(t) => t,\n                Err(_) => return self.clunk_and_clear(),\n            };\n\n            let Tmessage { tag, content } = t;\n\n            let resp = match content {\n                Auth { .. } | Attach { .. } => Err(E_ALREADY_ATTACHED.into()),\n                Flush { .. } => Ok(Rdata::Flush {}),\n                Version { msize, version } => {\n                    let rdata = self.handle_version(msize, version);\n                    self.clunk_and_clear();\n\n                    Ok(rdata)\n                }\n\n                Walk {\n                    fid,\n                    new_fid,\n                    wnames,\n                } => self.handle_walk(fid, new_fid, wnames),\n                Clunk { fid } => self.handle_clunk(fid),\n                Stat { fid } => self.handle_stat(fid),\n                Open { fid, mode } => self.handle_open(fid, Mode::new(mode)),\n                Create {\n                    fid,\n                    name,\n                    perm,\n                    mode,\n                } => self.handle_create(fid, name, Perm::new(perm), Mode::new(mode)),\n                Read { fid, offset, count } => match self.handle_read(tag, fid, offset, count) {\n                    Ok(Some(resp)) => Ok(resp),\n                    Err(err) => Err(err),\n                    Ok(None) => continue,\n                },\n                Write { fid, offset, data } => self.handle_write(fid, offset, data.0),\n                Remove { fid } => self.handle_remove(fid),\n                Wstat { fid, stat, .. } => self.handle_wstat(fid, stat),\n            };\n\n            self.reply(tag, resp);\n        }\n    }\n\n    /// The walk request carries as arguments an existing fid and a proposed newfid (which must not\n    /// be in use unless it is the same as fid) that the client wishes to associate with the result\n    /// of traversing the directory hierarchy by \u2018walking\u2019 the hierarchy using the successive path\n    /// name elements wname.\n    ///\n    /// The fid must represent a directory unless zero path name elements are specified.\n    ///\n    /// The fid must be valid in the current session and must not have been opened for I/O by an\n    /// open or create message. If the full sequence of nwname elements is walked successfully,\n    /// newfid will represent the file that results. If not, newfid (and fid) will be unaffected.\n    /// However, if newfid is in use or otherwise illegal, an Rerror is returned.\n    ///\n    /// The name \u201c..\u201d (dot-dot) represents the parent directory. The name \u201c.\u201d (dot), meaning the\n    /// current directory, is not used in the protocol.\n    ///\n    /// It is legal for nwname to be zero, in which case newfid will represent the same file as fid\n    /// and the walk will usually succeed; this is equivalent to walking to dot. The rest of this\n    /// discussion assumes nwname is greater than zero.\n    ///\n    /// The nwname path name elements wname are walked in order, \u201celementwise\u201d. For the first\n    /// elementwise walk to succeed, the file identified by fid must be a directory, and the\n    /// implied user of the request must have permission to search the directory (see intro(9P)).\n    /// Subsequent elementwise walks have equivalent restrictions applied to the implicit fid that\n    /// results from the preceding elementwise walk.\n    ///\n    /// If the first element cannot be walked for any reason, Rerror is returned. Otherwise, the\n    /// walk will return an Rwalk message containing nwqid qids corresponding, in order, to the\n    /// files that are visited by the nwqid successful elementwise walks; nwqid is therefore either\n    /// nwname or the index of the first elementwise walk that failed. The value of nwqid cannot be\n    /// zero unless nwname is zero. Also, nwqid will always be less than or equal to nwname. Only\n    /// if it is equal, however, will newfid be affected, in which case newfid will represent the\n    /// file reached by the final elementwise walk requested in the message.\n    ///\n    /// A walk of the name \u201c..\u201d in the root directory of a server is equivalent to a walk with no\n    /// name elements.\n    ///\n    /// If newfid is the same as fid, the above discussion applies, with the obvious difference\n    /// that if the walk changes the state of newfid, it also changes the state of fid; and if\n    /// newfid is unaffected, then fid is also unaffected.\n    ///\n    /// To simplify the implementation of the servers, a maximum of sixteen name elements or qids\n    /// may be packed in a single message. This constant is called MAXWELEM in fcall(3). Despite\n    /// this restriction, the system imposes no limit on the number of elements in a file name,\n    /// only the number that may be transmitted in a single message.\n    fn handle_walk(&mut self, fid: u32, new_fid: u32, wnames: Vec<String>) -> Result<Rdata> {\n        let client_id = self.client_id;\n        let mut coro = self\n            .session_state\n            .handle_attached_walk(fid, new_fid, &wnames);\n\n        loop {\n            coro = match coro.resume() {\n                CoroState::Complete(res) => return res,\n                CoroState::Pending(c, (qid, name, uname)) => {\n                    let fm = self.s.walk(client_id, qid, name, uname)?;\n                    c.send(fm)\n                }\n            };\n        }\n    }\n\n    fn handle_clunk(&mut self, fid: u32) -> Result<Rdata> {\n        match self.state.fids.entry(fid) {\n            Entry::Occupied(ent) => {\n                let qid = ent.remove();\n                self.s.clunk(self.client_id, qid);\n\n                Ok(Rdata::Clunk {})\n            }\n            Entry::Vacant(_) => Err(E_UNKNOWN_FID.to_string()),\n        }\n    }\n\n    fn handle_stat(&mut self, fid: u32) -> Result<Rdata> {\n        let fm = self.try_file_meta(fid)?;\n        let s = self.s.stat(self.client_id, fm.qid, &self.state.uname)?;\n        let stat: RawStat = s.into();\n        let size = stat.size + size_of::<u16>() as u16;\n\n        Ok(Rdata::Stat { size, stat })\n    }\n\n    fn handle_wstat(&mut self, fid: u32, raw_stat: RawStat) -> Result<Rdata> {\n        let stat: Stat = raw_stat.try_into()?;\n        let fm = self.try_file_meta(fid)?;\n        self.s\n            .write_stat(self.client_id, fm.qid, stat, &self.state.uname)?;\n\n        Ok(Rdata::Wstat {})\n    }\n\n    fn handle_open(&mut self, fid: u32, mode: Mode) -> Result<Rdata> {\n        let fm = self.try_file_meta(fid)?;\n        let iounit = self\n            .s\n            .open(self.client_id, fm.qid, mode, &self.state.uname)?;\n\n        Ok(Rdata::Open {\n            qid: fm.as_qid(),\n            iounit,\n        })\n    }\n\n    fn handle_create(&mut self, fid: u32, name: String, perm: Perm, mode: Mode) -> Result<Rdata> {\n        let fm = self.try_file_meta(fid)?;\n        if fm.ty != FileType::Directory {\n            return Err(E_CREATE_NON_DIR.to_string());\n        }\n\n        let (fm, iounit) =\n            self.s\n                .create(self.client_id, fm.qid, &name, perm, mode, &self.state.uname)?;\n\n        // fid is now changed to point to the newly created file rather than the parent\n        let qid = fm.as_qid();\n        self.state.fids.insert(fid, fm.qid);\n        self.qids.entry(fm.qid).or_insert(fm);\n\n        Ok(Rdata::Create { qid, iounit })\n    }\n\n    // The read request asks for count bytes of data from the file identified by fid, which must be\n    // opened for reading, starting offset bytes after the beginning of the file. The bytes are\n    // returned with the read reply message.\n    // The count field in the reply indicates the number of bytes returned. This may be less than\n    // the requested amount. If the offset field is greater than or equal to the number of bytes in\n    // the file, a count of zero will be returned.\n    // For directories, read returns an integral number of directory entries exactly as in stat\n    // (see stat(9P)), one for each member of the directory. The read request message must have\n    // offset equal to zero or the value of offset in the previous read on the directory, plus the\n    // number of bytes returned in the previous read. In other words, seeking other than to the\n    // beginning is illegal in a directory.\n    fn handle_read(\n        &mut self,\n        tag: u16,\n        fid: u32,\n        offset: u64,\n        count: u32,\n    ) -> Result<Option<Rdata>> {\n        let cid = self.client_id;\n        let coro = self.session_state.handle_attached_read(fid, offset, count);\n        let (offset, count) = (offset as usize, count as usize);\n\n        match coro.resume() {\n            CoroState::Complete(res) => res,\n            CoroState::Pending(c, Either::L((qid, uname))) => {\n                let stats = self.s.read_dir(cid, qid, uname)?;\n                c.send(stats).resume().unwrap()\n            }\n            CoroState::Pending(_, Either::R((qid, uname))) => {\n                let outcome = self.s.read(cid, qid, offset, count, uname)?;\n                match outcome {\n                    ReadOutcome::Immediate(data) => Ok(Some(Rdata::Read { data: Data(data) })),\n                    ReadOutcome::Blocked(chan) => {\n                        let mut stream = self.stream.try_clone()?;\n                        spawn(move || {\n                            let data = chan.recv().unwrap_or_default();\n                            let resp = Ok(Rdata::Read { data: Data(data) });\n                            let r: Rmessage = (tag, resp).into();\n                            let _ = r.write_to(&mut stream);\n                        });\n\n                        Ok(None)\n                    }\n                }\n            }\n        }\n    }\n\n    fn handle_write(&mut self, fid: u32, offset: u64, data: Vec<u8>) -> Result<Rdata> {\n        let fm = self.try_file_meta(fid)?;\n        if offset > u32::MAX as u64 {\n            return Err(format!(\"offset too large: {offset} > {}\", u32::MAX));\n        }\n\n        let count = self.s.write(\n            self.client_id,\n            fm.qid,\n            offset as usize,\n            data,\n            &self.state.uname,\n        )? as u32;\n\n        Ok(Rdata::Write { count })\n    }\n\n    fn handle_remove(&mut self, fid: u32) -> Result<Rdata> {\n        let fm = self.try_file_meta(fid)?;\n        self.s.remove(self.client_id, fm.qid, &self.state.uname)?;\n\n        Ok(Rdata::Remove {})\n    }\n}\n", "source": "ad/crates/ninep/src/sync/server.rs", "file_type": "rc"}
{"text": "use ad_editor::{Config, buffer::Buffer};\nuse reference_tests::TestData;\nuse std::{\n    env, fs,\n    sync::{Arc, RwLock},\n};\n\nfn main() {\n    let mut args = env::args().skip(1);\n    let fname = args\n        .next()\n        .expect(\"usage: reference_tests <test-file> <steps>\");\n    let steps = args\n        .next()\n        .map(|s| {\n            s.parse::<usize>()\n                .expect(\"usage: reference_tests <test-file> <steps>\")\n        })\n        .unwrap_or(usize::MAX);\n\n    let mut test_data = TestData::try_load_from_file(&fname).unwrap();\n\n    let mut cfg = Config::default();\n    cfg.editor.expand_tab = false;\n    cfg.editor.match_indent = false;\n\n    let mut b = Buffer::new_unnamed(0, &test_data.start_content, Arc::new(RwLock::new(cfg)));\n\n    test_data.apply_n(&mut b, steps);\n    fs::write(\"output/rust_output.txt\", b.str_contents()).unwrap();\n}\n", "source": "ad/reference-tests/src/main.rs", "file_type": "rc"}
{"text": "// This is the pathological case that Russ Cox covers in his article which leads\n// to exponential behaviour in backtracking based implementations.\n//\n// The graph from the article can be found here:\n//   https://swtch.com/~rsc/regexp/grep1p.png\n\nuse ad_editor::regex::Regex;\nuse criterion::{Criterion, criterion_group};\nuse std::hint::black_box;\n\nfn rsc_inputs(n: usize) -> (String, Regex) {\n    let s = \"a\".repeat(n);\n    let mut re = \"a?\".repeat(n);\n    re.push_str(&s);\n    let r = Regex::compile(&re).unwrap();\n\n    (s, r)\n}\n\nfn rsc_pathological_case(n: usize) {\n    let (s, r) = rsc_inputs(n);\n    assert!(r.matches(&s.as_str()));\n}\n\nfn criterion_benchmark(c: &mut Criterion) {\n    let mut group = c.benchmark_group(\"rsc 100\");\n\n    group.bench_function(\"with compile\", |b| {\n        b.iter(|| rsc_pathological_case(black_box(100)))\n    });\n\n    let (s, r) = rsc_inputs(100);\n    group.bench_function(\"without compile\", |b| {\n        b.iter(|| assert!(r.matches(black_box(&s.as_str()))))\n    });\n\n    group.finish();\n}\n\ncriterion_group!(benches, criterion_benchmark);\n", "source": "ad/benches/benchmarks/rsc_pathological_regex.rs", "file_type": "rc"}
{"text": "// Render times for the TUI ui implementation.\nuse ad_editor::{\n    Config, Editor, EditorMode, LogBuffer, PlumbingRules,\n    key::{Input, MouseButton, MouseEvent, MouseEventKind, MouseMod},\n    system::DefaultSystem,\n    ui::{GenericTui, Layout, UserInterface},\n};\nuse criterion::{BenchmarkGroup, Criterion, criterion_group, measurement::WallTime};\nuse std::{\n    env::current_dir,\n    hint::black_box,\n    io::{self, Write},\n    sync::{Arc, RwLock},\n};\n\nfn criterion_benchmark(c: &mut Criterion) {\n    let mut group = c.benchmark_group(\"TUI render\");\n\n    fixed_view(&mut group, \"single window\", &[\"src/util.rs\"]);\n    fixed_view(&mut group, \"two windows\", &[\"src/util.rs\", \"src/term.rs\"]);\n\n    single_window_editor_scroll_inputs(\n        &mut group,\n        \"single window editor scroll inputs stdout\",\n        EditorMode::Terminal,\n    );\n\n    let config = Config::try_load().unwrap();\n    let mut tui = GenericTui::new_with_stdout_handle(\n        Arc::new(RwLock::new(config.clone())),\n        StdoutSink(Vec::with_capacity(512 * 1024)),\n    );\n    tui.set_size(80, 160);\n\n    single_window_editor_scroll_inputs(\n        &mut group,\n        \"single window editor scroll inputs sink\",\n        EditorMode::Boxed(Box::new(tui)),\n    );\n\n    group.finish();\n}\n\ncriterion_group!(benches, criterion_benchmark);\n\nstruct StdoutSink(Vec<u8>);\n\nimpl Write for StdoutSink {\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n        self.0.write(buf)\n    }\n\n    fn write_all(&mut self, buf: &[u8]) -> io::Result<()> {\n        self.0.write_all(buf)\n    }\n\n    fn flush(&mut self) -> io::Result<()> {\n        let res = self.0.flush();\n        self.0.clear();\n\n        res\n    }\n}\n\nfn tui_and_layout(files: &[&str]) -> (GenericTui<StdoutSink>, Layout) {\n    // This will need to point to the TS config for rust\n    let config = Arc::new(RwLock::new(Config::try_load().unwrap()));\n    let mut tui = GenericTui::new_with_stdout_handle(\n        config.clone(),\n        StdoutSink(Vec::with_capacity(512 * 1024)),\n    );\n    tui.set_size(80, 160);\n    let mut layout = Layout::new_with_stub_lsp_handle(80, 160, config);\n\n    let repo_root = current_dir().unwrap();\n\n    for file in files {\n        layout.open_or_focus(repo_root.join(file), false).unwrap();\n    }\n\n    (tui, layout)\n}\n\nfn fixed_view(group: &mut BenchmarkGroup<'_, WallTime>, title: &str, files: &[&str]) {\n    let (mut tui, mut layout) = tui_and_layout(files);\n    group.bench_function(title, |b| {\n        b.iter(|| {\n            tui.refresh(\n                black_box(\"NORMAL\"),\n                black_box(&mut layout),\n                black_box(0),\n                black_box(&[]),\n                black_box(None),\n                black_box(None),\n            );\n        })\n    });\n}\n\nfn single_window_editor_scroll_inputs(\n    group: &mut BenchmarkGroup<'_, WallTime>,\n    title: &str,\n    editor_mode: EditorMode,\n) {\n    let mut e = Editor::new_with_system_and_initial_files(\n        Config::try_load(),\n        PlumbingRules::try_load(),\n        editor_mode,\n        LogBuffer::default(),\n        DefaultSystem::without_clipboard_provider(),\n        &[\"src/ui/tui.rs\"],\n    );\n\n    let mut n = 0;\n    let mut btn = MouseButton::WheelDown;\n\n    group.bench_function(title, |b| {\n        b.iter(|| {\n            n += 1;\n            if n == 500 {\n                n = 0;\n                btn = if btn == MouseButton::WheelUp {\n                    MouseButton::WheelDown\n                } else {\n                    MouseButton::WheelUp\n                };\n            }\n\n            e.refresh_screen_w_minibuffer(None);\n            e.handle_input(Input::Mouse(MouseEvent {\n                k: MouseEventKind::Press,\n                m: MouseMod::NoMod,\n                b: btn,\n                x: 20,\n                y: 20,\n            }));\n        })\n    });\n}\n", "source": "ad/benches/benchmarks/tui_render.rs", "file_type": "rc"}
{"text": "//! Benchmarking for the structural regular expression engine\nuse ad_editor::{\n    buffer::{Buffer, GapBuffer},\n    exec::{Program, SystemRunner},\n};\nuse criterion::{Criterion, criterion_group};\nuse std::{\n    env,\n    hint::black_box,\n    io::{self, Write},\n};\n\n// Starting point:\n//   - around 3.4ms execution time but skewed left\n//   - there's a small outlier cluster for both benchmarks\n//   - execute on Buffer needs to track edits\n//   - execute_on_string needs to construct the GapBuffer\n\nconst SCRIPT: &str = include_str!(\"../../examples/scripts/fancy_impl_blocks.ad\");\nconst ZIPLIST: &str = include_str!(\"../../src/ziplist.rs\");\nconst GAP_BUFFER: &str = include_str!(\"../../src/buffer/internal.rs\");\n\nfn criterion_benchmark(c: &mut Criterion) {\n    let mut group = c.benchmark_group(\"Structural regex\");\n\n    let prog = Program::try_parse(SCRIPT).expect(\"valid test script\");\n    let mut w = StdoutSink(Vec::with_capacity(10 * 1024));\n    let mut runner = SystemRunner::new(env::current_dir().unwrap());\n\n    for (name, s) in [(\"ziplist\", ZIPLIST), (\"internal\", GAP_BUFFER)] {\n        let mut buf = Buffer::new_unnamed(0, s, Default::default());\n        let mut gb = GapBuffer::from(s);\n\n        group.bench_function(format!(\"fancy impl blocks {name} (buffer)\"), |b| {\n            b.iter(|| prog.execute(black_box(&mut buf), &mut runner, name, black_box(&mut w)));\n        });\n\n        group.bench_function(format!(\"fancy impl blocks {name} (gap buffer)\"), |b| {\n            b.iter(|| prog.execute(black_box(&mut gb), &mut runner, name, black_box(&mut w)));\n        });\n    }\n\n    group.finish();\n}\n\ncriterion_group!(benches, criterion_benchmark);\n\nstruct StdoutSink(Vec<u8>);\n\nimpl Write for StdoutSink {\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n        self.0.write(buf)\n    }\n\n    fn write_all(&mut self, buf: &[u8]) -> io::Result<()> {\n        self.0.write_all(buf)\n    }\n\n    fn flush(&mut self) -> io::Result<()> {\n        let res = self.0.flush();\n        self.0.clear();\n\n        res\n    }\n}\n", "source": "ad/benches/benchmarks/exec.rs", "file_type": "rc"}
{"text": "use ad_editor::{buffer::GapBuffer, regex::Regex};\nuse criterion::{Criterion, criterion_group};\nuse std::hint::black_box;\n\nfn inputs(n: usize) -> (GapBuffer, Regex) {\n    let mut s = \"\ud83e\udd8a\".repeat(n);\n    s.push('\\n');\n    s = s.repeat(100);\n    s.push_str(\"fooooooooobar\");\n\n    let r = Regex::compile(\"fo*bar\").unwrap(); // typos:ignore\n    let mut gb = GapBuffer::from(s);\n    gb.make_contiguous();\n\n    (gb, r)\n}\n\nfn criterion_benchmark(c: &mut Criterion) {\n    let mut group = c.benchmark_group(\"RE_FAST\");\n\n    let (gb, r) = inputs(100);\n    group.bench_function(\"leading 100 normal\", |b| {\n        b.iter(|| assert!(r.matches(black_box(&gb))))\n    });\n    group.bench_function(\"leading 100 fast\", |b| {\n        b.iter(|| assert!(r.matches(black_box(&gb))))\n    });\n\n    let (gb, r) = inputs(1000);\n    group.bench_function(\"leading 1000 fast\", |b| {\n        b.iter(|| assert!(r.matches(black_box(&gb))))\n    });\n\n    group.bench_function(\"leading 1000 normal\", |b| {\n        b.iter(|| assert!(r.matches(black_box(&gb))))\n    });\n\n    group.finish();\n}\n\ncriterion_group!(benches, criterion_benchmark);\n", "source": "ad/benches/benchmarks/re_fast_match.rs", "file_type": "rc"}
{"text": "// Update times for running TreeSitter syntax highlighting\nuse ad_editor::{Config, buffer::Buffer, dot::TextObject, editor::Action};\nuse ad_event::Source;\nuse criterion::{Criterion, criterion_group};\nuse std::{\n    env::current_dir,\n    sync::{Arc, RwLock},\n};\n\nfn criterion_benchmark(c: &mut Criterion) {\n    let mut group = c.benchmark_group(\"TS update\");\n\n    let repo_root = current_dir().unwrap();\n    let path = repo_root.join(\"src/term.rs\").canonicalize().unwrap();\n    let config = Arc::new(RwLock::new(Config::try_load().unwrap()));\n\n    let mut buf = Buffer::new_from_canonical_file_path(0, path.clone(), config.clone()).unwrap();\n    buf.update_ts_state(0, 70);\n\n    group.bench_function(\"update without edit\", |b| {\n        b.iter(|| {\n            buf.update_ts_state(0, 70);\n        })\n    });\n\n    let mut buf = Buffer::new_from_canonical_file_path(0, path.clone(), config.clone()).unwrap();\n    buf.update_ts_state(0, 70);\n\n    group.bench_function(\"append newline and update\", |b| {\n        b.iter(|| {\n            buf.handle_action(Action::DotSet(TextObject::BufferEnd, 1), Source::Fsys);\n            buf.handle_action(Action::InsertChar { c: '\\n' }, Source::Fsys);\n            buf.update_ts_state(0, 70);\n        })\n    });\n\n    group.finish();\n}\n\ncriterion_group!(benches, criterion_benchmark);\n", "source": "ad/benches/benchmarks/ts_update.rs", "file_type": "rc"}
{"text": "// This is a variation on the torture test used by Burntsushi in their repo looking at\n// how to translate rsc's C code implementing the Thompson NFA algorithm into Rust.\n//\n// For now I'm using a much smaller input than the one Burntsushi uses (475 alternations\n// of in the regex itself and a haystack of 43,000 repetitions of 'abc' before the final\n// Z) because my VM is clearly far to slow at the moment and a single match takes multiple\n// seconds.\n//\n// As I get the performance improved I'll take a look at ramping up the torture.\n//\n//  https://github.com/BurntSushi/rsc-regexp/blob/master/torture-test\n\nuse ad_editor::regex::Regex;\nuse criterion::{Criterion, criterion_group};\nuse std::hint::black_box;\n\nfn burntsushi_inputs(n_alts: usize, n_reps: usize) -> (String, Regex) {\n    let mut re = \"(abc)*d|\".repeat(n_alts);\n    re.push_str(\"(abc)*Z\");\n    let mut s = \"abc\".repeat(n_reps);\n    s.push('Z');\n    let r = Regex::compile(&re).unwrap();\n\n    (s, r)\n}\n\nfn burntsushi_pathological_case(n_alts: usize, n_reps: usize) {\n    let (s, r) = burntsushi_inputs(n_alts, n_reps);\n    assert!(r.matches(&s.as_str()));\n}\n\nfn criterion_benchmark(c: &mut Criterion) {\n    // > The full torture test Burntsushi used would be 475, 43000\n    let n_alts = 50;\n    let n_reps = 1000;\n\n    let mut group = c.benchmark_group(format!(\"burntsushi {n_alts} alts, {n_reps} reps\"));\n    group.bench_function(\"with compile\", |b| {\n        b.iter(|| burntsushi_pathological_case(black_box(n_alts), black_box(n_reps)))\n    });\n\n    let (s, r) = burntsushi_inputs(n_alts, n_reps);\n    group.bench_function(\"without compile\", |b| {\n        b.iter(|| assert!(r.matches(black_box(&s.as_str()))))\n    });\n\n    group.finish();\n}\n\ncriterion_group!(benches, criterion_benchmark);\n", "source": "ad/benches/benchmarks/burntsushi_torture_regex.rs", "file_type": "rc"}
{"text": "//! GapBuffer benchmarks for measuring line-ending tracking performance.\nuse ad_editor::buffer::GapBuffer;\nuse criterion::{BatchSize, BenchmarkId, Criterion, criterion_group};\nuse libflate::gzip::Decoder;\nuse serde::Deserialize;\nuse std::{\n    fs::File,\n    io::{BufReader, Read},\n};\n\n#[derive(Debug, Clone, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\nstruct TestData {\n    start_content: String,\n    #[serde(rename = \"txns\")]\n    transactions: Vec<TestTransaction>,\n}\n\nimpl TestData {\n    fn load(fname: &str) -> Self {\n        let file = File::open(fname).expect(\"failed to open trace file\");\n        let input = BufReader::new(file);\n        let mut decoder = Decoder::new(input).expect(\"failed to create decoder\");\n        let mut raw_json = vec![];\n        decoder\n            .read_to_end(&mut raw_json)\n            .expect(\"failed to decompress\");\n\n        serde_json::from_reader(raw_json.as_slice()).expect(\"failed to parse JSON\")\n    }\n}\n\n#[derive(Debug, Clone, Deserialize)]\nstruct TestTransaction {\n    patches: Vec<TestPatch>,\n}\n\n#[derive(Debug, Clone, Deserialize)]\n#[serde(from = \"(usize, usize, String)\")]\nstruct TestPatch {\n    position: usize,\n    delete_len: usize,\n    insert_content: String,\n}\n\nimpl From<(usize, usize, String)> for TestPatch {\n    fn from((position, delete_len, insert_content): (usize, usize, String)) -> Self {\n        Self {\n            position,\n            delete_len,\n            insert_content,\n        }\n    }\n}\n\nfn apply_patch(patch: &TestPatch, gb: &mut GapBuffer) {\n    if patch.delete_len > 0 {\n        gb.remove_range(patch.position, patch.position + patch.delete_len);\n    }\n    gb.insert_str(patch.position, &patch.insert_content);\n}\n\nfn single_char_insert(c: &mut Criterion) {\n    let mut group = c.benchmark_group(\"single_char_insert\");\n\n    for n_lines in [100, 1_000, 10_000, 50_000] {\n        let content: String = (0..n_lines).map(|_| \"x\".repeat(79) + \"\\n\").collect();\n        let n_chars = n_lines * 80;\n\n        let positions: [(&str, usize); 5] = [\n            (\"start\", 0),\n            (\"quarter\", n_chars / 4),\n            (\"middle\", n_chars / 2),\n            (\"three_quarter\", 3 * n_chars / 4),\n            (\"end\", n_chars.saturating_sub(1)),\n        ];\n\n        for (name, char_pos) in positions {\n            group.bench_with_input(\n                BenchmarkId::new(name, n_lines),\n                &(content.clone(), char_pos),\n                |b, (content, pos)| {\n                    b.iter_batched(\n                        || GapBuffer::from(content.as_str()),\n                        |mut gb| gb.insert_char(*pos, 'a'),\n                        BatchSize::SmallInput,\n                    );\n                },\n            );\n        }\n    }\n    group.finish();\n}\n\nfn realistic_editing(c: &mut Criterion) {\n    let mut group = c.benchmark_group(\"realistic_editing\");\n\n    let path = concat!(\n        env!(\"CARGO_MANIFEST_DIR\"),\n        \"/reference-tests/data/rustcode.json.gz\"\n    );\n    let test_data = TestData::load(path);\n    let transactions: &[TestTransaction] = &test_data.transactions[..1000];\n\n    group.bench_function(\"rustcode_1000_txns\", |b| {\n        b.iter_batched(\n            || GapBuffer::from(test_data.start_content.as_str()),\n            |mut gb| {\n                for tx in transactions {\n                    for patch in &tx.patches {\n                        apply_patch(patch, &mut gb);\n                    }\n                }\n            },\n            BatchSize::LargeInput,\n        );\n    });\n\n    group.finish();\n}\n\ncriterion_group!(benches, single_char_insert, realistic_editing);\n", "source": "ad/benches/benchmarks/gap_buffer.rs", "file_type": "rc"}
{"text": "#include <u.h>\n#include <libc.h>\n#include <bio.h>\n#include \"xml.h\"\n\nstatic char *escmap[] =\n{\n\t\"\\x06\\\"&quot;\",\n\t\"\\x06\\'&apos;\",\n\t\"\\x04<&lt;\",\n\t\"\\x04>&gt;\",\n\t\"\\x05&&amp;\",\n};\n\nenum\n{\n\tXmlvalue = 2,\n};\n\nstatic char*\nunxml(char *orig)\n{\n\tchar *s;\n\tRune r;\n\tint i, n, rsz;\n\n\tn = 0;\n\tfor(s = orig; *s != 0; s += rsz, n += rsz){\n\t\tif(*s == '\\r'){\n\t\t\tif(s[1] == '\\n'){\n\t\t\t\tn--;\n\t\t\t\trsz = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t*s = '\\n';\n\t\t}\n\n\t\trsz = chartorune(&r, s);\n\t\tmemmove(orig+n, s, rsz);\n\t\tif(*s == '&'){\n\t\t\tfor(i = 0; i < nelem(escmap); i++){\n\t\t\t\tif(strncmp(s, &escmap[i][2], escmap[i][0]) == 0){\n\t\t\t\t\torig[n] = escmap[i][1];\n\t\t\t\t\ts += escmap[i][0] - 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\torig[n] = 0;\n\treturn orig;\n}\n\nstatic void\nxmlprint_(Xelem *x, int fd, int off)\n{\n\tXattr *a;\n\n\tfor(; x != nil; x = x->next){\n\t\tfprint(fd, \"%*c%q\", off, ' ', x->n);\n\t\tif(x->v != nil)\n\t\t\tfprint(fd, \"=%q\", x->v);\n\t\tfor(a = x->a; a != nil; a = a->next)\n\t\t\tfprint(fd, \" %q=%q\", a->n, a->v);\n\t\tfprint(fd, \"\\n\");\n\t\toff += 4;\n\t\txmlprint_(x->ch, fd, off);\n\t\toff -= 4;\n\t}\n}\n\nstatic Xattr*\nxmlattr(char *s, int *err)\n{\n\tXattr *a, *attrs;\n\tchar *p;\n\n\tattrs = nil;\n\n\tfor(; *s;){\n\t\ta = mallocz(sizeof(*a), 1);\n\t\ta->n = s;\n\t\tfor(; *s && *s != '='; s++);\n\t\tif(*s != '='){\n\t\t\twerrstr(\"xml sucks (%d)\", *s);\n\t\t\tgoto error;\n\t\t}\n\t\t*s++ = 0;\n\t\tif(*s != '\\'' && *s != '\\\"'){\n\t\t\twerrstr(\"xml is complicated (%d)\", *s);\n\t\t\tgoto error;\n\t\t}\n\t\ta->v = s+1;\n\t\ts = utfrune(a->v, *s);\n\t\tif(s == nil){\n\t\t\twerrstr(\"xml is broken\");\n\t\t\tgoto error;\n\t\t}\n\t\t*s++ = 0;\n\t\ta->next = attrs;\n\t\ta->n = unxml(a->n);\n\t\ta->v = unxml(a->v);\n\t\tattrs = a;\n\t\tif(*s == ' ')\n\t\t\ts++;\n\t\tif((p = strchr(a->n, ':')) != nil && strncmp(p, \":zdef\", 5) == 0)\n\t\t\t*p = 0;\n\t}\n\n\treturn attrs;\nerror:\n\t*err = 1;\n\tfree(a);\n\tfor(; attrs != nil; attrs = a){\n\t\ta = attrs->next;\n\t\tfree(attrs);\n\t}\n\treturn nil;\n}\n\nstatic Xelem*\nxmlread_(Biobufhdr *h, Xelem *par, int flags, int *err)\n{\n\tchar *s, *t;\n\tXelem *x, *ch;\n\tint r, closed, len;\n\n\tx = nil;\n\n\tfor(;;){\n\t\tr = Bgetrune(h);\n\t\tif(r < 0){\n\t\t\twerrstr(\"xmlread: %r\");\n\t\t\tgoto error;\n\t\t}\n\t\tif(r == '<')\n\t\t\tbreak;\n\t\tif(isspacerune(r))\n\t\t\tcontinue;\n\t\tif(flags & Xmlvalue && par != nil){\n\t\t\tBungetrune(h);\n\t\t\tif((s = Brdstr(h, '<', 1)) == nil){\n\t\t\t\twerrstr(\"xmlread: %r\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tpar->v = unxml(s);\n\t\t\tif((s = Brdstr(h, '>', 1)) == nil){\n\t\t\t\tfree(par->v);\n\t\t\t\tpar->v = nil;\n\t\t\t\twerrstr(\"xmlread: %r\");\n\t\t\t}\n\t\t\tfree(s);\n\t\t\treturn nil;\n\t\t}\n\t\twerrstr(\"xmlread: unexpected rune (%C)\", r);\n\t\tgoto error;\n\t}\n\n\ts = Brdstr(h, '>', 1);\n\tif(s == nil){\n\t\twerrstr(\"xmlread: %r\");\n\t\tgoto error;\n\t}\n\tif(s[0] == '/'){\n\t\tfree(s);\n\t\treturn nil;\n\t}\n\tif(s[0] == '?'){\n\t\tfree(s);\n\t\treturn xmlread_(h, par, flags, err);\n\t}\n\n\tx = mallocz(sizeof(*x), 1);\n\tx->priv = s;\n\tx->n = s;\n\n\tif(strncmp(x->n, \"zdef\", 4) == 0){\n\t\tif((x->n = strchr(x->n, ':')) == nil){\n\t\t\twerrstr(\"xmlread: zdef without ':'\");\n\t\t\tgoto error;\n\t\t}\n\t\tx->n += 1;\n\t}\n\n\tlen = strlen(s);\n\tif(s[len-1] == '/' || s[len-1] == '?'){\n\t\tclosed = 1;\n\t\ts[len-1] = 0;\n\t}else\n\t\tclosed = flags & Xmlstartonly;\n\n\tfor(; *s && *s != ' '; s++);\n\tif(*s){\n\t\t*s++ = 0;\n\t\tx->a = xmlattr(s, err);\n\t}\n\n\tif(strcmp(x->n, \"html\") == 0){\n\t\tfor(len = 0;; len += r){\n\t\t\ts = Brdstr(h, '>', 0);\n\t\t\tif(s == nil){\n\t\t\t\twerrstr(\"xmlread: %r\");\n\t\t\t\tgoto error;\n\t\t\t}\n\n\t\t\tr = strlen(s);\n\t\t\tx->v = realloc(x->v, len + r + 1);\n\t\t\tif(x->v == nil){\n\t\t\t\twerrstr(\"xmlread: %r\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tstrcpy(x->v+len, s);\n\t\t\tfree(s);\n\t\t\tt = strstr(x->v+len, \"</html>\");\n\t\t\tif(t != nil){\n\t\t\t\t*t = 0;\n\t\t\t\treturn x;\n\t\t\t}\n\t\t}\n\t}\n\n\tif(!closed){\n\t\tfor(;;){\n\t\t\tflags = Xmlvalue;\n\t\t\tch = xmlread_(h, x, flags, err);\n\t\t\tif(ch == nil)\n\t\t\t\tbreak;\n\t\t\tch->next = x->ch;\n\t\t\tx->ch = ch;\n\t\t}\n\t}\n\n\tif(!*err)\n\t\treturn x;\n\nerror:\n\t*err = 2;\n\txmlfree(x);\n\treturn nil;\n}\n\nXelem*\nxmlread(Biobuf *b, int flags, int *err)\n{\n\t*err = 0;\n\treturn xmlread_(b, nil, flags & Xmlstartonly, err);\n}\n\nvoid\nxmlfree(Xelem *x)\n{\n\tXattr *a, *ta;\n\tXelem *n, *n2;\n\n\tif(x == nil)\n\t\treturn;\n\n\txmlfree(x->ch);\n\tfree(x->v);\n\tx->ch = nil;\n\tx->v = nil;\n\tfree(x->priv);\n\tfor(a = x->a; a != nil; a = ta){\n\t\tta = a->next;\n\t\tfree(a);\n\t}\n\n\tfor(n = x->next; n != nil; n = n2){\n\t\tn2 = n->next;\n\t\tn->next = nil;\n\t\txmlfree(n);\n\t}\n\n\tfree(x);\n}\n\nXelem*\nxmlget(Xelem *x, char *name)\n{\n\tfor(; x != nil; x = x->next)\n\t\tif(strcmp(x->n, name) == 0)\n\t\t\treturn x;\n\treturn nil;\n}\n\nXattr*\nxmlgetattr(Xattr *a, char *name)\n{\n\tfor(; a != nil; a = a->next)\n\t\tif(strcmp(a->n, name) == 0)\n\t\t\treturn a;\n\treturn nil;\n}\n\nvoid\nxmlprint(Xelem *x, int fd)\n{\n\txmlprint_(x, fd, 0);\n}\n\nint\nxmlstrfmt(Fmt *f)\n{\n\tchar *s, *orig, *new;\n\tint i, sz, n;\n\n\torig = va_arg(f->args, char*);\n\tfor(s = orig; *s; s++){\n\t\tfor(i = 0; i < nelem(escmap); i++){\n\t\t\tif(escmap[i][1] == *s)\n\t\t\t\tgoto escape;\n\t\t}\n\t}\n\treturn fmtprint(f, \"%s\", orig);\n\nescape:\n\tn = s-orig;\n\tsz = n*2 + 1;\n\tnew = malloc(sz);\n\tmemcpy(new, orig, n);\n\n\tfor(; *s; s++, n++){\n\t\tif(sz <= n+6){\n\t\t\tsz = (n+6)*2;\n\t\t\tnew = realloc(new, sz);\n\t\t}\n\t\tnew[n] = *s;\n\n\t\tfor(i = 0; i < nelem(escmap); i++){\n\t\t\tif(escmap[i][1] == *s){\n\t\t\t\tmemcpy(new+n, &escmap[i][2], escmap[i][0]);\n\t\t\t\tn += escmap[i][0] - 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tnew[n] = 0;\n\tn = fmtprint(f, \"%s\", new);\n\tfree(new);\n\treturn n;\n}\n", "source": "xmpp/xml.c", "file_type": "c"}
{"text": "</$objtype/mkfile\n\nTARG=xmpp\nBIN=/$objtype/bin\nMAN=/sys/man/1\n\nOFILES=\\\n\tconn.$O\\\n\tmisc.$O\\\n\tmuc.$O\\\n\trost.$O\\\n\ttarg.$O\\\n\txml.$O\\\n\txmpp.$O\\\n\nHFILES=\\\n\txml.h\\\n\txmpp.h\\\n\ndefault:V:\tall\n\n</sys/src/cmd/mkone\n\n$MAN/$TARG: $TARG.man\n\ninstall:V: $MAN/$TARG\n", "source": "xmpp/mkfile", "file_type": "mkfile"}
{"text": "#include <u.h>\n#include <libc.h>\n#include <bio.h>\n#include <libsec.h>\n#include <ndb.h>\n#include \"xml.h\"\n#include \"xmpp.h\"\n\nenum\n{\n\tAscramsha1 = 1<<0,\n\tAdigestmd5 = 1<<1,\n\tAplain     = 1<<2,\n};\n\nstatic Xelem*\nexpect(Biobuf *b, int flags, char *name)\n{\n\tXelem *x;\n\tint err;\n\n\tx = xmlread(b, flags, &err);\n\tif(x != nil && strcmp(x->n, name) != 0){\n\t\twerrstr(\"expected %q, got %q\", name, x->n);\n\t\txmlprint(x, 2);\n\t\txmlfree(x);\n\t\tx = nil;\n\t}\n\treturn x;\n}\n\nstatic int\nauthscramsha1(int fd, Biobuf *b, char *user, char *passwd)\n{\n\tuchar cnonce[33], h[3][SHA1dlen], cp[SHA1dlen], svsig[SHA1dlen];\n\tchar cnonce64[45], *snonce64, *salt64, *salt, *s, *ni, *svfst;\n\tint i, j, numiter, pwdlen, slen;\n\tXelem *x;\n\n\tsvfst = nil;\n\tgenrandom(cnonce, sizeof(cnonce));\n\tif(enc64(cnonce64, sizeof(cnonce64), cnonce, sizeof(cnonce)) < 0)\n\t\treturn -1;\n\n\t/* client first message */\n\ts = smprint(\"n,,n=%s,r=%s\", user, cnonce64);\n\tfprint(fd,\n\t\t\"<auth xmlns='urn:ietf:params:xml:ns:xmpp-sasl'\"\n\t\t\" mechanism='SCRAM-SHA-1'>%.*[</auth>\",\n\t\t(int)strlen(s), s);\n\tfree(s);\n\ts = nil;\n\n\t/* server first message */\n\tif((x = expect(b, 0, \"challenge\")) == nil || x->v == nil)\n\t\tgoto error;\n\tslen = strlen(x->v);\n\tsvfst = malloc(slen);\n\tif((slen = dec64((uchar*)svfst, slen, x->v, slen)) < 0)\n\t\tgoto error;\n\tsvfst[slen] = 0;\n\ts = strdup(svfst);\n\tif(s[0] != 'r' || s[1] != '=' || strncmp(cnonce64, s+2, strlen(cnonce64)) != 0)\n\t\tgoto error;\n\tsnonce64 = s + 2;\n\tsalt64 = strstr(snonce64, \",s=\");\n\tni = salt64 != nil ? strstr(salt64+3, \",i=\") : nil;\n\tif(!snonce64[0] || salt64 == nil || ni == nil)\n\t\tgoto error;\n\t*salt64 = 0;\n\tsalt64 += 3;\n\t*ni = 0;\n\tni += 3;\n\tnumiter = atoi(ni);\n\tif(!salt64[0] || numiter < 1)\n\t\tgoto error;\n\n\t/* decode salt */\n\tslen = strlen(salt64);\n\tsalt = malloc(slen+4);\n\tif((slen = dec64((uchar*)salt, slen, salt64, slen)) < 0){\n\t\tfree(salt);\n\t\tgoto error;\n\t}\n\n\t/* calc salted password in h[2] */\n\tsalt[slen+0] = 0;\n\tsalt[slen+1] = 0;\n\tsalt[slen+2] = 0;\n\tsalt[slen+3] = 1;\n\tpwdlen = strlen(passwd);\n\thmac_sha1((uchar*)salt, slen+4, (uchar*)passwd, pwdlen, h[0], nil);\n\tfree(salt);\n\tmemcpy(h[2], h[0], SHA1dlen);\n\tfor(i = 1; i < numiter; i++){\n\t\thmac_sha1(h[0], SHA1dlen, (uchar*)passwd, pwdlen, h[1], nil);\n\t\tfor(j = 0; j < SHA1dlen; j++)\n\t\t\th[2][j] ^= h[1][j];\n\t\tmemcpy(h[0], h[1], SHA1dlen);\n\t}\n\n\t/* client (h[0]), server (h[1]) and stored (h[2]) keys */\n\thmac_sha1((uchar*)\"Client Key\", 10, h[2], SHA1dlen, h[0], nil);\n\thmac_sha1((uchar*)\"Server Key\", 10, h[2], SHA1dlen, h[1], nil);\n\tsha1(h[0], SHA1dlen, h[2], nil);\n\n\t/* auth message */\n\tsnonce64 = strdup(snonce64);\n\tfree(s);\n\ts = smprint(\"n=%s,r=%s,%s,c=biws,r=%s\", user, cnonce64, svfst, snonce64);\n\tfree(svfst);\n\tsvfst = nil;\n\txmlfree(x);\n\n\t/* client and server signatures */\n\thmac_sha1((uchar*)s, strlen(s), h[2], SHA1dlen, cp, nil);\n\thmac_sha1((uchar*)s, strlen(s), h[1], SHA1dlen, svsig, nil);\n\n\t/* client proof */\n\tfor(i = 0; i < SHA1dlen; i++)\n\t\tcp[i] = h[0][i] ^ cp[i];\n\n\tfree(s);\n\ts = smprint(\"c=biws,r=%s,p=%.*[\", snonce64, SHA1dlen, cp);\n\tfprint(fd,\n\t\t\"<response xmlns='urn:ietf:params:xml:ns:xmpp-sasl'>\"\n\t\t\"%.*[</response>\",\n\t\t(int)strlen(s), s);\n\tfree(s);\n\ts = nil;\n\tfree(snonce64);\n\n\tif((x = expect(b, 0, \"success\")) == nil || x->v == nil)\n\t\tgoto error;\n\tslen = strlen(x->v);\n\ts = malloc(slen);\n\tif((slen = dec64((uchar*)s, slen, x->v, slen)) < 0)\n\t\tgoto error;\n\ts[slen] = 0;\n\tsvfst = smprint(\"v=%.*[\", SHA1dlen, (uchar*)svsig);\n\tif(strcmp(s, svfst) != 0){\n\t\twerrstr(\"server signature doesn't match\");\n\t\tgoto error;\n\t}\n\txmlfree(x);\n\tfree(s);\n\tfree(svfst);\n\treturn 0;\n\nerror:\n\twerrstr(\"authscramsha1: %r\");\n\tfree(s);\n\tfree(svfst);\n\txmlfree(x);\n\treturn -1;\n}\n\nstatic DigestState*\nmd5fmt(char *out, DigestState *st, char *fmt, ...)\n{\n\tva_list arg;\n\tchar *s;\n\n\tva_start(arg, fmt);\n\ts = vsmprint(fmt, arg);\n\tst = md5((uchar*)s, strlen(s), (uchar*)out, st);\n\tfree(s);\n\treturn st;\n}\n\nstatic int\nauthmd5(int fd, Biobuf *b, char *user, char *passwd)\n{\n\tXelem *x;\n\tint chsz;\n\tchar *ch, *realm, *nonce, *s;\n\tchar ha1[MD5dlen], ha2[MD5dlen], res[MD5dlen], cnonce[MD5dlen];\n\tDigestState *dgst;\n\n\tfprint(fd,\n\t\t\"<auth xmlns='urn:ietf:params:xml:ns:xmpp-sasl'\"\n\t\t\" mechanism='DIGEST-MD5'/>\");\n\tif((x = expect(b, 0, \"challenge\")) == nil || x->v == nil)\n\t\treturn -1;\n\tchsz = strlen(x->v)/4*3;\n\tch = malloc(chsz + 1);\n\tchsz = dec64((uchar*)ch, chsz, x->v, strlen(x->v));\n\txmlfree(x);\n\tif(chsz < 0)\n\t\treturn -1;\n\n\trealm = strstr(ch, \"realm=\");\n\tnonce = strstr(ch, \"nonce=\");\n\tif(realm != nil && (s = strchr(realm+7, '\"')) != nil){\n\t\t*s = 0;\n\t\trealm += 7;\n\t}\n\tif(nonce != nil && (s = strchr(nonce+7, '\"')) != nil){\n\t\t*s = 0;\n\t\tnonce += 7;\n\t}else if(nonce == nil){\n\t\twerrstr(\"nil nonce\");\n\t\tfree(ch);\n\t\treturn -1;\n\t}\n\n\tgenrandom((uchar*)cnonce, MD5dlen);\n\n\tif(realm == nil)\n\t\trealm = mydomain;\n\n\t/* ha1 = md5(md5(user:realm:passwd):nonce:cnonce:jid) */\n\tmd5fmt(ha1, nil, \"%s:%s:%s\", user, realm, passwd);\n\tdgst = md5((uchar*)ha1, MD5dlen, nil, nil);\n\tmd5fmt(ha1, dgst, \":%s:%.*lH:%s\", nonce, MD5dlen, cnonce, myjid);\n\n\t/* ha2 = md5(method:digesturi) */\n\tmd5fmt(ha2, nil, \"AUTHENTICATE:xmpp/%s\", mydomain);\n\n\t/* response = md5(ha1:nonce:nc:cnonce:qop:ha2) */\n\tmd5fmt(res, nil, \"%.*lH:%s:00000001:%.*lH:auth:%.*lH\",\n\t\tMD5dlen, ha1, nonce, MD5dlen, cnonce, MD5dlen, ha2);\n\n\ts = smprint(\"username=\\\"%s\\\",realm=\\\"%s\\\",nonce=\\\"%s\\\",\"\n\t\t\"cnonce=\\\"%.*lH\\\",nc=00000001,qop=auth,digest-uri=\\\"xmpp/%s\\\",\"\n\t\t\"response=%.*lH,charset=utf-8,authzid=\\\"%s\\\"\",\n\t\tuser, realm, nonce, MD5dlen, cnonce, mydomain, MD5dlen, res, myjid);\n\tfprint(fd,\n\t\t\"<response xmlns='urn:ietf:params:xml:ns:xmpp-sasl'>\"\n\t\t\"%.*[</response>\",\n\t\t(int)strlen(s), s);\n\tfree(s);\n\tfree(ch);\n\n\tif((x = expect(b, 0, \"challenge\")) != nil){\n\t\txmlfree(x);\n\t\tfprint(fd, \"<response xmlns='urn:ietf:params:xml:ns:xmpp-sasl'/>\");\n\t\tif((x = expect(b, 0, \"success\")) != nil){\n\t\t\txmlfree(x);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -1;\n}\n\nstatic int\nauthplain(int fd, Biobuf *b, char *user, char *passwd)\n{\n\tint len;\n\tchar *p;\n\tXelem *x;\n\n\tp = smprint(\"%c%s%c%s\", 0, user, 0, passwd);\n\tlen = 1+strlen(user)+1+strlen(passwd);\n\tfprint(fd,\n\t\t\"<auth xmlns='urn:ietf:params:xml:ns:xmpp-sasl'\"\n\t\t\" mechanism='PLAIN'>\"\n\t\t\"%.*[</auth>\",\n\t\tlen, p);\n\tfree(p);\n\tif((x = expect(b, 0, \"success\")) != nil){\n\t\txmlfree(x);\n\t\treturn 0;\n\t}\n\treturn -1;\n}\n\nstatic int\nstreamstart(int fd)\n{\n\treturn fprint(fd,\n\t\t\"<?xml version='1.0'?>\"\n\t\t\"<stream:stream\"\n\t\t\" to='%\u04fc'\"\n\t\t\" xmlns='jabber:client'\"\n\t\t\" xmlns:stream='http://etherx.jabber.org/streams'\"\n\t\t\" version='1.0'>\",\n\t\tmydomain);\n}\n\nstatic int\nlogin(int fd, Biobuf *b, char *user, char *passwd)\n{\n\tXelem *x, *y;\n\tThumbprint *th;\n\tTLSconn tls;\n\tint auth, r, oldfd, err;\n\tuchar hash[SHA1dlen];\n\n\tx = nil;\n\tif((th = initThumbprints(\"/sys/lib/tls/xmpp\", nil, \"x509\")) == nil)\n\t\treturn -1;\n\tif(Binit(b, fd, OREAD) != 0)\n\t\treturn -1;\n\tstreamstart(fd);\n\txmlfree(xmlread(b, Xmlstartonly, &err));\n\tif(err != 0 || (x = expect(b, 0, \"stream:features\")) == nil)\n\t\tgoto error;\n\tif(debug > 1)\n\t\txmlprint(x, 2);\n\n\t/* require TLS */\n\tif(xmlget(x->ch, \"starttls\") == nil){\n\t\twerrstr(\"tls not supported\");\n\t\tgoto error;\n\t}\n\txmlfree(x);\n\tfprint(fd, \"<starttls xmlns='urn:ietf:params:xml:ns:xmpp-tls'/>\");\n\tif((x = expect(b, 0, \"proceed\")) == nil)\n\t\tgoto error;\n\txmlfree(x);\n\tx = nil;\n\tBterm(b);\n\tmemset(&tls, 0, sizeof(tls));\n\toldfd = fd;\n\tfd = tlsClient(fd, &tls);\n\tclose(oldfd);\n\tif(th != nil){\n\t\tif(tls.cert == nil || tls.certlen < 1){\n\t\t\twerrstr(\"no server cert\");\n\t\t\tgoto error;\n\t\t}\n\t\tsha1(tls.cert, tls.certlen, hash, nil);\n\t\tif(!okThumbprint(hash, SHA1dlen, th)){\n\t\t\twerrstr(\"unknown thumbprint: %.*H\", SHA1dlen, hash);\n\t\t\tgoto error;\n\t\t}\n\t\tfreeThumbprints(th);\n\t}\n\tfree(tls.sessionID);\n\tfree(tls.cert);\n\tif(Binit(b, fd, OREAD) != 0)\n\t\treturn -1;\n\tif(fd < 0)\n\t\tgoto error;\n\n\tstreamstart(fd);\n\txmlfree(xmlread(b, Xmlstartonly, &err));\n\tif(err != 0 || (x = expect(b, 0, \"stream:features\")) == nil)\n\t\tgoto error;\n\tif(debug > 1)\n\t\txmlprint(x, 2);\n\tauth = 0;\n\tif((y = xmlget(x->ch, \"mechanisms\")) != nil){\n\t\tif(debug > 0)\n\t\t\tfprint(2, \"auth methods:\");\n\t\tfor(y = y->ch; y != nil; y = y->next){\n\t\t\tif(debug > 0)\n\t\t\t\tfprint(2, \" %s\", y->v);\n\t\t\tif(strcmp(y->v, \"SCRAM-SHA-1\") == 0)\n\t\t\t\tauth |= Ascramsha1;\n\t\t\telse if(strcmp(y->v, \"DIGEST-MD5\") == 0)\n\t\t\t\tauth |= Adigestmd5;\n\t\t\telse if(strcmp(y->v, \"PLAIN\") == 0 && plainallow)\n\t\t\t\tauth |= Aplain;\n\t\t}\n\t\tif(debug > 0)\n\t\t\tfprint(2, \"\\n\");\n\t}\n\txmlfree(x);\n\tx = nil;\n\n\tif(auth & Ascramsha1)\n\t\tr = authscramsha1(fd, b, user, passwd);\n\telse if(auth & Adigestmd5)\n\t\tr = authmd5(fd, b, user, passwd);\n\telse if(auth & Aplain)\n\t\tr = authplain(fd, b, user, passwd);\n\telse{\n\t\twerrstr(\"no supported auth methods\");\n\t\tgoto error;\n\t}\n\n\tif(r != 0)\n\t\tgoto error;\n\n\tstreamstart(fd);\n\txmlfree(xmlread(b, Xmlstartonly, &err));\n\tif(err != 0)\n\t\tgoto error;\n\txmlfree(xmlread(b, Xmlstartonly, &err));\n\tif(err != 0)\n\t\tgoto error;\n\txmlfree(xmlread(b, 0, &err));\n\tif(err != 0)\n\t\tgoto error;\n\n\tif(myresource == nil){\n\t\tfprint(fd,\n\t\t\t\"<iq type='set' id='xml sucks'>\"\n\t\t\t\"<bind xmlns='urn:ietf:params:xml:ns:xmpp-bind'/></iq>\");\n\t}else{\n\t\tfprint(fd,\n\t\t\t\"<iq type='set' id='xml sucks'>\"\n\t\t\t\"<bind xmlns='urn:ietf:params:xml:ns:xmpp-bind'>\"\n\t\t\t\"<resource>%\u04fc</resource>\"\n\t\t\t\"</bind></iq>\",\n\t\t\tmyresource);\n\t}\n\txmlfree(xmlread(b, 0, &err));\n\tif(err != 0)\n\t\tgoto error;\n\n\tfprint(fd,\n\t\t\"<iq type='set' id='xmpp sucks'>\"\n\t\t\"<session xmlns='urn:ietf:params:xml:ns:xmpp-session'/></iq>\");\n\txmlfree(xmlread(b, 0, &err));\n\tif(err == 0)\n\t\treturn fd;\n\nerror:\n\twerrstr(\"login: %r\");\n\txmlfree(x);\n\tBterm(b);\n\treturn -1;\n}\n\nint\nconnect(Biobuf *b, char *user, char *passwd)\n{\n\tint fd, clfd;\n\tNdbtuple *srv, *s, *targ, *port;\n\tchar *p;\n\n\tp = smprint(\"_xmpp-client._tcp.%s\", server);\n\tsrv = dnsquery(nil, p, \"srv\");\n\tfree(p);\n\tfor(s = srv, fd = -1; s != nil && fd < 0; s = s->entry){\n\t\tif(strcmp(s->attr, \"dom\") != 0)\n\t\t\tcontinue;\n\n\t\ttarg = ndbfindattr(s, s->line, \"target\");\n\t\tport = ndbfindattr(s, s->line, \"port\");\n\t\tif(targ == nil || port == nil)\n\t\t\tcontinue;\n\n\t\tfd = dial(netmkaddr(targ->val, \"tcp\", port->val), nil, nil, &clfd);\n\t}\n\tndbfree(srv);\n\n\tif(fd < 0){\n\t\tfd = dial(netmkaddr(server, \"tcp\", \"5222\"), nil, nil, &clfd);\n\t\tif(fd < 0)\n\t\t\treturn -1;\n\t}\n\twrite(clfd, \"keepalive\", 9);\n\tclose(clfd);\n\treturn login(fd, b, user, passwd);\n}\n", "source": "xmpp/conn.c", "file_type": "c"}
{"text": "#include <u.h>\n#include <libc.h>\n#include <bio.h>\n#include <ctype.h>\n\nextern Biobuf kbin;\n\nchar*\nstrtime(void)\n{\n\tstatic char buf[6];\n\tTm *tm;\n\n\ttm = localtime(time(nil));\n\tsprint(buf, \"%02d:%02d\", tm->hour, tm->min);\n\treturn buf;\n}\n\nchar*\nstrenttime(char **tzo)\n{\n\tstatic char buf[32];\n\tTm *tm;\n\tint n;\n\tlong t;\n\n\tt = time(nil);\n\ttm = gmtime(t);\n\tn = sprint(buf, \"%04d-%02d-%02dT%02d:%02d:%02dZ\",\n\t\ttm->year+1900,\n\t\ttm->mon+1,\n\t\ttm->mday,\n\t\ttm->hour,\n\t\ttm->min,\n\t\ttm->sec);\n\t*tzo = &buf[n+1];\n\ttm = localtime(t);\n\tsprint(*tzo, \"%+03d:%02d\", tm->tzoff/3600, abs(tm->tzoff/60)%60);\n\treturn buf;\n}\n\nvoid\ncleaninput(int n)\n{\n\tstatic char d[] = {8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8};\n\n\twhile(n > 0)\n\t\tn -= write(1, d, sizeof(d) > n ? n : sizeof(d));\n}\n\nvoid\nsetlabel(char *label, char *prsuffix)\n{\n\tstatic char *oldlabel;\n\tint fd;\n\n\tif(oldlabel == nil){\n\t\toldlabel = mallocz(64, 1);\n\t\tfd = open(\"/dev/label\", OREAD);\n\t\tread(fd, oldlabel, 63);\n\t\tclose(fd);\n\t}\n\n\tfd = open(\"/dev/label\", OWRITE);\n\tif(label != nil){\n\t\tif(label[0] == 0){\n\t\t\tfprint(fd, \"xmpp\");\n\t\t\tprint(\"no target\\n\");\n\t\t}else{\n\t\t\tfprint(fd, \"%s\", label);\n\t\t\tif(prsuffix != nil && prsuffix[0] != 0)\n\t\t\t\tprint(\"\u2190\u2192 %s [%s]\\n\", label, prsuffix);\n\t\t\telse\n\t\t\t\tprint(\"\u2190\u2192 %s\\n\", label);\n\t\t}\n\t}else\n\t\tfprint(fd, \"%s\", oldlabel);\n\tclose(fd);\n}\n\nchar*\nstrstamp(char *v)\n{\n\tstatic char buf[32];\n\tTm utc, *tm;\n\tint i, len;\n\n\tlen = strlen(v);\n\tfor(i = 0; i < len && (isdigit(v[i]) || v[i] == '.') ; i++);\n\tif(i == len){ /* 1456830231.000345 this is Slack being a bag of shit */\n\t\ttm = localtime(atol(v));\n\t\tsprint(buf, \"%02d:%02d\", tm->hour, tm->min);\n\t\treturn buf;\n\t}\n\n\tif(len < 17) /* can't parse, just use the current time */\n\t\treturn strtime();\n\n\t/* 20130327T16:28:58 http://xmpp.org/extensions/xep-0091.html\n\t * or\n\t * 2016-02-25T10:00:15.400Z http://xmpp.org/extensions/xep-0203.html\n\t */\n\tfor(i = 0; i < len; i++)\n\t\tif(isdigit(v[i]))\n\t\t\tv[i] -= '0';\n\n\tmemset(&utc, 0, sizeof(utc));\n\tutc.year = v[0]*1000+v[1]*100+v[2]*10+v[3] - 1900;\n\tif(v[4] == '-' && v[7] == '-'){\n\t\tutc.mon = v[5]*10+v[6] - 1;\n\t\tutc.mday = v[8]*10+v[9];\n\t\ti = 2;\n\t}else{\n\t\tutc.mon = v[4]*10+v[5] - 1;\n\t\tutc.mday = v[6]*10+v[7];\n\t\ti = 0;\n\t}\n\tutc.hour = v[9+i]*10+v[10+i];\n\tutc.min = v[12+i]*10+v[13+i];\n\tutc.zone[0] = 'G';\n\tutc.zone[1] = 'M';\n\tutc.zone[2] = 'T';\n\n\ttm = localtime(tm2sec(&utc));\n\tsprint(buf, \"%04d/%02d/%02d %02d:%02d\",\n\t\ttm->year+1900,\n\t\ttm->mon+1,\n\t\ttm->mday,\n\t\ttm->hour,\n\t\ttm->min);\n\n\tmemmove(&utc, tm, sizeof(utc));\n\ttm = localtime(time(nil));\n\tif(tm->year != utc.year || tm->mon != utc.mon || tm->mday != utc.mday)\n\t\treturn buf;\n\n\treturn buf+11;\n}\n\nchar *\nreadlines(void)\n{\n\tchar *str, *s;\n\tint len, catlen, total;\n\n\tstr = strdup(\"\");\n\tlen = total = 0;\n\tfor(; s = Brdstr(&kbin, '\\n', 0);){\n\t\tcatlen = strlen(s);\n\t\ttotal += utflen(s);\n\t\tstr = realloc(str, len + catlen + 1);\n\t\tmemcpy(&str[len], s, catlen + 1);\n\t\tfree(s);\n\t\tlen += catlen;\n\t\tif(len >= 2 && str[len-2] == '.' && (len < 3 || str[len-3] == '\\n')){\n\t\t\tstr[len - (len > 2 ? 3 : 2)] = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tcleaninput(total);\n\treturn str;\n}\n", "source": "xmpp/misc.c", "file_type": "c"}
{"text": "#include <u.h>\n#include <libc.h>\n#include \"xml.h\"\n#include \"xmpp.h\"\n\ntypedef struct Bookmark Bookmark;\nstruct Bookmark\n{\n\tchar *jid;\n};\n\nchar *affs[] = {\n\t[Anone]    \"none\",\n\t[Aowner]   \"owner\",\n\t[Aadmin]   \"admin\",\n\t[Amember]  \"member\",\n\t[Aoutcast] \"outcast\",\n};\n\nstatic char *roles[] = {\n\t[Rnone]  \"none\",\n\t[Rmoder] \"moderator\",\n\t[Rpart]  \"participant\",\n\t[Rvisit] \"visitor\",\n};\n\nstatic Bookmark *bookmarks;\nstatic int numbookmarks, mucwidth;\n\nstatic int\naddnick(Target *room, char *nick, char *jid, char *show, Target **ent)\n{\n\tTarget *t;\n\tint i, width;\n\n\tfor(i = 0; i < numtargets; i++){\n\t\tint r;\n\t\tt = targets[i];\n\t\tif(t->type != Emucent || t->mucent.room != room)\n\t\t\tcontinue;\n\t\tr = strcmp(t->name, nick);\n\t\tif(r == 0){\n\t\t\t*ent = t;\n\t\t\treturn 0;\n\t\t}\n\t\tif(r > 0)\n\t\t\tbreak;\n\t}\n\tt = addtarget(Emucent, nick);\n\tt->jid = smprint(\"%s/%s\", room->jid, nick);\n\tt->mucent.jid = (jid == nil) ? nil : strdup(jid);\n\tt->mucent.show = (show == nil) ? nil : strdup(show);\n\tt->mucent.room = room;\n\tif((width = utflen(nick)) > room->muc.width)\n\t\troom->muc.width = width;\n\t*ent = t;\n\troom->muc.numents++;\n\treturn 1;\n}\n\nstatic int\nrmnick(Target *room, char *nick)\n{\n\tTarget *t;\n\tint i, width, removed;\n\n\tremoved = 0;\n\troom->muc.width = 0;\n\tfor(i = 0; i < numtargets; i++){\n\t\tt = targets[i];\n\t\tif(t->type != Emucent || t->mucent.room != room)\n\t\t\tcontinue;\n\t\tif(strcmp(t->name, nick) == 0){\n\t\t\trmtarget(t);\n\t\t\tremoved = 1;\n\t\t}else if((width = utflen(t->name)) > room->muc.width)\n\t\t\troom->muc.width = width;\n\t}\n\tif(removed)\n\t\troom->muc.numents--;\n\treturn removed;\n}\n\nstatic int\nsetaffrole(Target *t, Xelem *item)\n{\n\tXattr *aff, *role;\n\tint changed, n, i;\n\n\tif(item == nil)\n\t\treturn 0;\n\tchanged = 0;\n\trole = xmlgetattr(item->a, \"role\");\n\taff = xmlgetattr(item->a, \"affiliation\");\n\tif(role != nil){\n\t\tn = Rnone;\n\t\tfor(i = 0; i < nelem(roles); i++){\n\t\t\tif(strcmp(roles[i], role->v) == 0){\n\t\t\t\tn = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tchanged |= (t->mucent.role != n);\n\t\tt->mucent.role = n;\n\t}\n\tif(aff != nil){\n\t\tn = Anone;\n\t\tfor(i = 0; i < nelem(affs); i++){\n\t\t\tif(strcmp(affs[i], aff->v) == 0){\n\t\t\t\tn = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tchanged |= (t->mucent.aff != n);\n\t\tt->mucent.aff = n;\n\t}\n\n\treturn changed;\n}\n\nstatic int\naddbookmark(char *jid)\n{\n\tBookmark *b;\n\tint i;\n\n\tfor(i = 0; i < numbookmarks; i++)\n\t\tif(strcmp(bookmarks[i].jid, jid) == 0)\n\t\t\treturn 0;\n\n\tnumbookmarks++;\n\tbookmarks = realloc(bookmarks, sizeof(*b)*numbookmarks);\n\tb = &bookmarks[numbookmarks-1];\n\tb->jid = strdup(jid);\n\treturn 1;\n}\n\nstatic int\nrmbookmark(char *jid)\n{\n\tint i;\n\n\tfor(i = 0; i < numbookmarks; i++){\n\t\tif(strcmp(bookmarks[i].jid, jid) == 0){\n\t\t\tnumbookmarks--;\n\t\t\tmemcpy(&bookmarks[i], &bookmarks[i+1], sizeof(bookmarks[0])*(numbookmarks-i));\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nvoid\nmucpresence(Xelem *xml, Target *room, Xattr *from)\n{\n\tchar *s, didwhat[32];\n\tXattr *type;\n\tXelem *msg, *item, *x, *ch, *show;\n\tint changed;\n\n\tif((s = strchr(from->v, '/')) == nil)\n\t\treturn;\n\ts++;\n\n\ttype = xmlgetattr(xml->a, \"type\");\n\tmsg = xmlget(xml->ch, \"status\");\n\tx = item = nil;\n\tshow = xmlget(xml->ch, \"show\");\n\tfor(ch = xml->ch; ch != nil; ch = ch->next){\n\t\tif(item == nil && (x = xmlget(ch, \"x\")) != nil)\n\t\t\titem = xmlget(x->ch, \"item\");\n\t}\n\tif(x == nil)\n\t\treturn;\n\n\tif(type != nil && strcmp(type->v, \"unavailable\") == 0){\n\t\tXelem *xstatus;\n\t\tXattr *code;\n\n\t\tstrcpy(didwhat, \"left\");\n\t\tchanged = rmnick(room, s);\n\t\txstatus = xmlget(x->ch, \"status\");\n\t\tcode = (xstatus != nil) ? xmlgetattr(xstatus->a, \"code\") : nil;\n\t\tif(code != nil && strcmp(code->v, \"303\") == 0){\n\t\t\tXattr *nick;\n\t\t\tnick = xmlgetattr(item->a, \"nick\");\n\t\t\tif(nick != nil){\n\t\t\t\tprint(\"[%s] (%s) %s changed nick to %s\\n\",\n\t\t\t\t\tstrtime(), room->name, s, nick->v);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}else{\n\t\tTarget *t;\n\t\tXattr *jid;\n\t\tchar *j, *sh;\n\n\t\tjid = xmlgetattr(item->a, \"jid\");\n\t\tj = (jid != nil && jid->v != nil) ? jid->v : nil;\n\t\tsh = (show != nil && show->v != nil) ? show->v : nil;\n\n\t\tstrcpy(didwhat, \"joined\");\n\t\tchanged = addnick(room, s, j, sh, &t);\n\t\tif(setaffrole(t, item) && !changed)\n\t\t\tsnprint(didwhat, sizeof(didwhat), \"role=%s affiliation=%s\",\n\t\t\t\taffs[t->mucent.aff], roles[t->mucent.role]);\n\t}\n\tif(!changed || nopresence)\n\t\treturn;\n\tprint(\"[%s] (%s) %s %s\", strtime(), room->name, s, didwhat);\n\tif(msg != nil)\n\t\tprint(\" (%s)\", msg->v);\n\tprint(\"\\n\");\n}\n\nint\nmucbookmarks(Xelem *e, int fd)\n{\n\tXelem *x;\n\n\tfor(x = e->ch; x != nil; x = x->next){\n\t\tchar *argv[2];\n\t\tXattr *a;\n\n\t\tif(strcmp(x->n, \"conference\") != 0)\n\t\t\tcontinue;\n\t\tif((a = xmlgetattr(x->a, \"autojoin\")) == nil)\n\t\t\tcontinue;\n\t\tif(strcmp(a->v, \"1\") != 0 && strcmp(a->v, \"true\") != 0)\n\t\t\tcontinue;\n\t\targv[0] = \"j\";\n\t\ta = xmlgetattr(x->a, \"jid\");\n\t\targv[1] = a->v;\n\t\tif(cmdjoin(fd, 2, argv) < 0)\n\t\t\treturn -1;\n\t\taddbookmark(a->v);\n\t}\n\n\treturn 0;\n}\n\nint\ncmdaff(int fd, int argc, char **argv)\n{\n\tTarget *t, *room;\n\tchar *targ, *aff, *slash, *jid;\n\tint i, nlen, res;\n\n\troom = nil;\n\tres = 0;\n\tif(argc < 3){\n\t\tif(argc < 2 && curr >= 0 && targets[curr]->type == Emuc)\n\t\t\troom = targets[curr];\n\t\telse{\n\t\t\ttarg = argv[1];\n\t\t\tnlen = strlen(targ);\n\t\t\tfor(i = 0; i < numtargets; i++){\n\t\t\t\tt = targets[i];\n\t\t\t\tif(t->type == Emuc && targmatches(t, targ, nlen)){\n\t\t\t\t\troom = t;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(i = Anone+1; room != nil && i < nelem(affs) && res >= 0; i++){\n\t\t\tres = fprint(fd,\n\t\t\t\t\"<iq to='%\u04fc' type='get' id='afflist'>\"\n\t\t\t\t\"<query xmlns='http://jabber.org/protocol/muc#admin'>\"\n\t\t\t\t\"<item affiliation='%\u04fc'/>\"\n\t\t\t\t\"</query></iq>\",\n\t\t\t\troom->jid,\n\t\t\t\taffs[i]);\n\t\t}\n\t\treturn res;\n\t}\n\n\ttarg = argv[1];\n\taff = argv[2];\n\tslash = strchr(targ, '/');\n\tjid = nil;\n\n\tif(curr >= 0 && targets[curr]->type == Emuc && slash == nil){\n\t\troom = targets[curr];\n\t\tif(strchr(targ, '@') != nil)\n\t\t\tjid = targ;\n\t\telse{\n\t\t\tnlen = strlen(targ);\n\t\t\tfor(i = 0; i < numtargets; i++){\n\t\t\t\tt = targets[i];\n\t\t\t\tif(t->type == Emucent && t->mucent.room == room && targmatches(t, targ, nlen)){\n\t\t\t\t\tjid = t->mucent.jid;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}else if(slash != nil){\n\t\tint rlen;\n\t\trlen = slash - targ;\n\t\tslash++;\n\t\tnlen = strlen(slash);\n\t\tjid = (strchr(slash, '@') != nil) ? slash : nil;\n\t\tfor(i = 0; i < numtargets; i++){\n\t\t\tt = targets[i];\n\t\t\tif(t->type == Emucent && targmatches(t->mucent.room, targ, rlen) && targmatches(t, slash, nlen)){\n\t\t\t\troom = t->mucent.room;\n\t\t\t\tjid = t->mucent.jid;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(t->type == Emuc && targmatches(t, targ, rlen) && jid != nil){\n\t\t\t\troom = t;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif(room != nil && jid != nil){\n\t\tres = fprint(fd,\n\t\t\t\"<iq to='%\u04fc' type='set'>\"\n\t\t\t\"<query xmlns='http://jabber.org/protocol/muc#admin'>\"\n\t\t\t\"<item affiliation='%\u04fc' jid='%\u04fc'/>\"\n\t\t\t\"</query></iq>\",\n\t\t\troom->jid,\n\t\t\taff,\n\t\t\tjid);\n\t}else\n\t\tprint(\"no such target: %q\\n\", targ);\n\n\treturn res;\n}\n\nint\ncmdbookmark(int fd, int /*argc*/, char **argv)\n{\n\tint (*f)(char *jid);\n\tint i, res;\n\n\tif(argv[0][1] == 0){\n\t\tint i;\n\t\tfor(i = 0; i < numbookmarks; i++)\n\t\t\tprint(\"  %s\\n\", bookmarks[i].jid);\n\t\tprint(\"%d bookmark(s)\\n\", numbookmarks);\n\t\treturn 0;\n\t}\n\n\tif(argv[0][1] == '+')\n\t\tf = addbookmark;\n\telse if(argv[0][1] == '-')\n\t\tf = rmbookmark;\n\telse\n\t\treturn 0;\n\tif(targets[curr]->type != Emuc || !f(targets[curr]->jid))\n\t\treturn 0;\n\n\tres = fprint(fd,\n\t\t\"<iq type='set' id='takethat'>\"\n\t\t\"<query xmlns='jabber:iq:private'>\"\n\t\t\"<storage xmlns='storage:bookmarks'>\");\n\tfor(i = 0; i < numbookmarks && res >= 0; i++)\n\t\tres = fprint(fd, \"<conference autojoin='1' jid='%\u04fc'/>\", bookmarks[i].jid);\n\treturn res < 0 ? res : fprint(fd, \"</storage></query></iq>\");\n}\n\nint\ncmdjoin(int fd, int argc, char **argv)\n{\n\tTarget *t;\n\tchar *room, *rnick, *s;\n\tint i, width, num;\n\n\tif(argc < 2){\n\t\tfor(i = num = 0; i < numtargets; i++){\n\t\t\tt = targets[i];\n\t\t\tif(t->type == Emuc){\n\t\t\t\tprint(\"  %*s  %d\\n\", -mucwidth, t->jid, t->muc.numents);\n\t\t\t\tnum++;\n\t\t\t}\n\t\t}\n\t\tprint(\"%d muc(s)\\n\", num);\n\t\treturn 0;\n\t}\n\n\troom = argv[1];\n\tif(rnick = strchr(room, '/'))\n\t\t*rnick++ = 0;\n\telse\n\t\trnick = mynick;\n\n\tif(fprint(fd,\n\t\t\"<presence to='%\u04fc/%\u04fc'>\"\n\t\t\"<x xmlns='http://jabber.org/protocol/muc'>\",\n\t\troom, rnick) < 0)\n\t\treturn -1;\n\tif(argc > 2 && fprint(fd, \"<password>%\u04fc</password>\", argv[2]) < 0)\n\t\treturn -1;\n\tif(nohistory && fprint(fd, \"<history maxchars='0'/>\") < 0)\n\t\treturn -1;\n\tif(fprint(fd, \"</x></presence>\") < 0)\n\t\treturn -1;\n\n\tfor(i = 0; i < numtargets; i++)\n\t\tif(strcmp(targets[i]->name, room) == 0)\n\t\t\treturn 0;\n\n\tt = addtarget(Emuc, room);\n\tt->jid = strdup(room);\n\tif(s = strchr(t->name, '@'))\n\t\t*s = 0;\n\tmucwidth = 0;\n\tfor(i = 0; i < numtargets; i++){\n\t\tt = targets[i];\n\t\tif(t->type == Emuc && (width = utflen(t->jid)) > mucwidth)\n\t\t\tmucwidth = width;\n\t}\n\treturn 0;\n}\n\nstatic Target *\nfindmuc(char *name)\n{\n\tint tlen, i;\n\tTarget *t;\n\n\tt = nil;\n\ttlen = strlen(name);\n\tfor(i = 0; i < numtargets; i++, t = nil){\n\t\tt = targets[i];\n\t\tif(t->type == Emuc && targmatches(t, name, tlen))\n\t\t\tbreak;\n\t}\n\tif(t == nil)\n\t\tprint(\"no such muc: %q\\n\", name);\n\treturn t;\n}\n\nint\ncmdpart(int fd, int argc, char **argv)\n{\n\tTarget *t;\n\tint i, width;\n\n\tt = nil;\n\tif(argc >= 2)\n\t\tt = findmuc(argv[1]);\n\telse if(curr >= 0 && targets[curr]->type == Emuc)\n\t\tt = targets[curr];\n\tif(t == nil)\n\t\treturn 0;\n\n\t/* free private chats */\n\tif(fprint(fd,\n\t\t\"<presence from='%\u04fc' to='%\u04fc' type='unavailable'></presence>\",\n\t\tmyjid, t->jid) < 0)\n\t\treturn -1;\n\n\tmucwidth = 0;\n\tfor(i = 0; i < numtargets; i++){\n\t\tif(targets[i]->type == Emucent && targets[i]->mucent.room == t)\n\t\t\trmtarget(targets[i]);\n\t\tif(t->type == Emuc && (width = utflen(t->jid)) > mucwidth)\n\t\t\tmucwidth = width;\n\t}\n\n\tprint(\"left %s\\n\", t->name);\n\trmtarget(t);\n\treturn 0;\n}\n\nint\ncmdsubj(int fd, int argc, char **argv)\n{\n\tTarget *t;\n\tchar *subj;\n\tint res;\n\n\tt = nil;\n\tif(argc >= 2)\n\t\tt = findmuc(argv[1]);\n\telse if(curr >= 0 && targets[curr]->type == Emuc)\n\t\tt = targets[curr];\n\tif(t == nil)\n\t\treturn 0;\n\n\tif(argv[0][0] == 's'){\n\t\tprint(\"subject for %s:\\n%s\\n\", t->name, (t->muc.subj == nil) ? \"\" : t->muc.subj);\n\t\treturn 0;\n\t}\n\n\tsubj = readlines();\n\tres = fprint(fd,\n\t\t\"<message to='%\u04fc' type='%\u04fc'><subject>%\u04fc</subject></message>\",\n\t\tt->jid,\n\t\tenttypes[t->type],\n\t\tsubj);\n\tfree(subj);\n\treturn res;\n}\n\nint\ncmdwho(int, int argc, char **argv)\n{\n\tTarget *room, *t;\n\tchar *show;\n\tint i, num;\n\n\troom = nil;\n\tif(argc < 2){\n\t\tif(curr < 0 || targets[curr]->type != Emuc)\n\t\t\treturn 0;\n\t\troom = targets[curr];\n\t}else{\n\t\tint tlen;\n\t\ttlen = strlen(argv[1]);\n\t\tfor(i = 0; i < numtargets; i++){\n\t\t\tt = targets[i];\n\t\t\tif(t->type == Emuc && targmatches(t, argv[1], tlen)){\n\t\t\t\troom = t;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(room == nil){\n\t\t\tprint(\"no such target: %q\\n\", argv[1]);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tnum = 0;\n\tprint(\"(%s):\\n\", room->jid);\n\tfor(i = 0; i < numtargets; i++){\n\t\tt = targets[i];\n\t\tif(t->type == Emucent && t->mucent.room == room){\n\t\t\tshow = t->mucent.show;\n\t\t\tif(argv[0][0] == 'w' && show != nil){\n\t\t\t\tif(strcmp(show, \"away\") == 0 || strcmp(show, \"xa\") == 0)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tprint(\"  %*s  \", -room->muc.width, t->name);\n\t\t\tif(argv[0][0] == 'W')\n\t\t\t\tprint(\" %-7s \", show != nil ? show : \"\");\n\t\t\tprint(\"%-11s %-7s  %s\\n\",\n\t\t\t\troles[t->mucent.role],\n\t\t\t\taffs[t->mucent.aff],\n\t\t\t\tt->mucent.jid != nil ? t->mucent.jid : \"\");\n\t\t\tnum++;\n\t\t}\n\t}\n\tprint(\"%d user(s)\\n\", num);\n\treturn 0;\n}\n\nint\ncmdnick(int fd, int argc, char **argv)\n{\n\tchar *nick, *p;\n\tint i, res;\n\n\tif(argc < 2 || curr < 0 || targets[curr]->type != Emuc)\n\t\treturn 0;\n\tnick = strdup(argv[1]);\n\tfor(i = 2; i < argc; i++){\n\t\tp = nick;\n\t\tnick = smprint(\"%s %s\", nick, argv[i]);\n\t\tfree(p);\n\t}\n\tres = fprint(fd,\n\t\t\"<presence from='%\u04fc' to='%\u04fc/%\u04fc'></presence>\",\n\t\tmyjid, targets[curr]->jid, nick);\n\tfree(nick);\n\treturn res;\n}\n", "source": "xmpp/muc.c", "file_type": "c"}
{"text": "#include <u.h>\n#include <libc.h>\n#include \"xml.h\"\n#include \"xmpp.h\"\n\nTarget **targets;\nint curr, numtargets;\n\nint\ntargmatches(Target *t, char *s, int n)\n{\n\treturn\t(t->name != nil && strncmp(t->name, s, n) == 0) ||\n\t\t\t(t->jid  != nil && strncmp(t->jid,  s, n) == 0);\n}\n\nstatic int\ncmptarg(void *a, void *b)\n{\n\tTarget *ta, *tb;\n\tint r;\n\n\tta = *(void**)a;\n\ttb = *(void**)b;\n\tif(ta->name != nil && tb->name != nil)\n\t\tr = strcmp(ta->name, tb->name);\n\telse\n\t\tr = strcmp(ta->jid, tb->jid);\n\tif(r == 0 && ta->type == Erost && tb->type == Erost)\n\t\treturn (ta->rost.flags & Fonline) ? -1 : 1;\n\treturn r;\n}\n\nstatic void\nsorttargets(void)\n{\n\tTarget *t;\n\n\tt = (curr >= 0) ? targets[curr] : nil;\n\tqsort(targets, numtargets, sizeof(t), cmptarg);\n\tif(t != nil){\n\t\tfor(curr = 0; curr < numtargets; curr++)\n\t\t\tif(targets[curr] == t)\n\t\t\t\tbreak;\n\t}\n}\n\nTarget*\naddtarget(int type, char *name)\n{\n\tTarget *t;\n\n\tnumtargets++;\n\tif(numtargets == 1 || (numtargets & (numtargets-1)) == 0)\n\t\ttargets = realloc(targets, sizeof(t)*numtargets*2);\n\tif(targets == nil)\n\t\tsysfatal(\"%r\");\n\tt = targets[numtargets-1] = mallocz(sizeof(*t), 1);\n\tif(t == nil)\n\t\tsysfatal(\"%r\");\n\tt->type = type;\n\tt->name = strdup(name);\n\tsorttargets();\n\treturn t;\n}\n\nvoid\nrmtarget(Target *t)\n{\n\tint i;\n\n\tif(curr >= 0 && targets[curr] == t){\n\t\tsetlabel(\"\", nil);\n\t\tcurr = -1;\n\t}\n\tfree(t->name);\n\tfree(t->jid);\n\n\tif(t->type == Erost)\n\t\tfree(t->rost.show);\n\telse if(t->type == Emucent){\n\t\tfree(t->mucent.jid);\n\t\tfree(t->mucent.show);\n\t}else if(t->type == Emuc)\n\t\tfree(t->muc.subj);\n\n\tfree(t);\n\tfor(i = 0; i < numtargets; i++){\n\t\tif(targets[i] == t){\n\t\t\tnumtargets--;\n\t\t\tmemcpy(&targets[i], &targets[i+1], sizeof(t)*(numtargets-i));\n\t\t\tif(curr > i)\n\t\t\t\tcurr--;\n\t\t\tt = nil;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(t != nil)\n\t\tsysfatal(\"rmtarget: not found\");\n}\n\nint\ncmdtarget(int, int argc, char **argv)\n{\n\tTarget *t;\n\tchar *a, *b;\n\tint i, cycle, alen, blen;\n\n\tif(argc < 2){\n\t\tcurr = -1;\n\t\tsetlabel(\"\", nil);\n\t\treturn 0;\n\t}\n\n\ta = argv[1];\n\tb = strchr(a, '/');\n\tif(b == nil){\n\t\tblen = 0;\n\t\talen = strlen(a);\n\t}else{\n\t\tb++;\n\t\tblen = strlen(b);\n\t\talen = b-1 - a;\n\t}\n\n\tfor(cycle = 0, i = curr+1; cycle < 2; cycle++){\n\t\tfor(; i < numtargets; i++){\n\t\t\tchar *s;\n\t\t\tt = targets[i];\n\t\t\tif(b == nil && t->type == Emuc && targmatches(t, a, alen)){\n\t\t\t\tsetlabel(t->jid, nil);\n\t\t\t\tcurr = i;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif(t->type == Erost && targmatches(t, a, alen) && (b == nil || strncmp(t->jid, b, blen) == 0)){\n\t\t\t\ts = smprint(\"%t\", t);\n\t\t\t\tsetlabel(s, (t->rost.flags & Fonline) ? t->rost.show : \"offline\");\n\t\t\t\tfree(s);\n\t\t\t\tcurr = i;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif(t->type == Emucent && b != nil && targmatches(t->mucent.room, a, alen) && strncmp(t->name, b, blen) == 0){\n\t\t\t\ts = smprint(\"%t\", t);\n\t\t\t\tsetlabel(s, nil);\n\t\t\t\tfree(s);\n\t\t\t\tcurr = i;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\ti = 0;\n\t}\n\n\tprint(\"no such target: %q\\n\", a);\n\treturn 0;\n}\n\nint\ntargetfmt(Fmt *f)\n{\n\tTarget *t;\n\n\tt = va_arg(f->args, Target*);\n\tif(t->type == Erost && curr >= 0 && targets[curr] == t)\n\t\treturn fmtprint(f, \"%s\", t->name);\n\tif(t->type == Emucent)\n\t\treturn fmtprint(f, \"%s/%s\", t->mucent.room->name, t->name);\n\tif(t->jid == nil)\n\t\treturn fmtprint(f, \"%s\", t->name);\n\treturn fmtprint(f, \"%s/%s\", t->name, t->jid);\n}\n", "source": "xmpp/targ.c", "file_type": "c"}
{"text": "#include <u.h>\n#include <libc.h>\n#include \"xml.h\"\n#include \"xmpp.h\"\n\nenum\n{\n\tSnone = 0,\n\tSto,\n\tSfrom,\n\tSboth,\n};\n\nchar *subscr2str[] =\n{\n\t[Snone] \"none\",\n\t[Sto]   \"to\",\n\t[Sfrom] \"from\",\n\t[Sboth] \"both\",\n};\n\nchar *subscr2fmt[] =\n{\n\t[Snone] \"[  ]\",\n\t[Sto]   \"[\u2190 ]\",\n\t[Sfrom] \"[ \u2192]\",\n\t[Sboth] \"[\u2190\u2192]\",\n};\n\nstatic char **asked;\nstatic int numasked, rostwidth;\n\nint\nrostupdate(Xelem *x, int fd)\n{\n\tXattr *n, *s, *j;\n\tTarget *t;\n\tint i, width;\n\n\tif(fprint(fd, \"<presence/>\") < 0)\n\t\treturn -1;\n\n\tfor(x = x->ch->ch; x != nil; x = x->next){\n\t\tn = xmlgetattr(x->a, \"name\");\n\t\ts = xmlgetattr(x->a, \"subscription\");\n\t\tj = xmlgetattr(x->a, \"jid\");\n\t\tif(j == nil || s == nil)\n\t\t\tcontinue;\n\t\tif(n == nil)\n\t\t\tn = j;\n\n\t\tfor(i = 0, t = nil; i < numtargets; i++, t = nil){\n\t\t\tt = targets[i];\n\t\t\tif(t->type == Erost && strcmp(t->jid, j->v) == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tif(t == nil){\n\t\t\tt = addtarget(Erost, n->v);\n\t\t\tt->jid = strdup(j->v);\n\t\t}else{\n\t\t\tif(strcmp(s->v, \"remove\") == 0){\n\t\t\t\tprint(\"%t removed from roster\\n\", t);\n\t\t\t\trmtarget(t);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfree(t->name);\n\t\t\tt->name = strdup(n->v);\n\t\t}\n\t\tif((width = utflen(t->name)) > rostwidth)\n\t\t\trostwidth = width;\n\t\tfor(i = 0; i < nelem(subscr2str); i++){\n\t\t\tif(strcmp(s->v, subscr2str[i]) == 0){\n\t\t\t\tt->rost.subscr = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint\nrostsubscr(char *from, char *type, int fd)\n{\n\tTarget *t;\n\tint i;\n\n\tif(strcmp(type, \"subscribe\") == 0){\n\t\tfor(i = 0; i < numtargets; i++){\n\t\t\tt = targets[i];\n\t\t\tif(t->type == Erost && (t->rost.flags & Fasked) && strncmp(t->jid, from, strlen(t->jid)) == 0){\n\t\t\t\tfprint(fd, \"<presence to='%\u04fc' type='subscribed'/>\", from);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\tfor(i = 0; i < numasked; i++)\n\t\t\tif(strcmp(asked[i], from) == 0)\n\t\t\t\treturn 1;\n\t\tprint(\"%s asks for a subscription\\n\", from);\n\t\tnumasked++;\n\t\tasked = realloc(asked, numasked*sizeof(asked[0]));\n\t\tasked[numasked-1] = strdup(from);\n\t\treturn 1;\n\t}else if(strcmp(type, \"subscribed\") == 0){\n\t\tfor(i = 0; i < numtargets; i++){\n\t\t\tt = targets[i];\n\t\t\tif(t->type == Erost && strncmp(t->jid, from, strlen(t->jid)) == 0){\n\t\t\t\tt->rost.flags |= Fasked;\n\t\t\t\tprint(\"%s has approved subscription\\n\", from);\n\t\t\t\tfprint(fd, \"<presence to='%\u04fc' type='subscribe'/>\", from); /* ack */\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nvoid\nrostpresence(Xelem *x, Target *t)\n{\n\tXelem *show;\n\tXattr *type;\n\tchar *didwhat, *s;\n\tint online;\n\n\tdidwhat = nil;\n\ttype = xmlgetattr(x->a, \"type\");\n\tshow = xmlget(x->ch, \"show\");\n\tonline = 1;\n\tif(type != nil){\n\t\tif(strcmp(type->v, \"unavailable\") == 0)\n\t\t\tonline = 0;\n\t\telse{\n\t\t\tif(strcmp(type->v, \"unsubscribed\") == 0)\n\t\t\t\tprint(\"%t cancelled subscription\\n\", t);\n\t\t\telse if(strcmp(type->v, \"unsubscribe\") == 0)\n\t\t\t\tprint(\"%t unsubscribed\\n\", t);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif(!online && (t->rost.flags & Fonline)){\n\t\tdidwhat = \"went offline\";\n\t\tt->rost.flags &= ~Fonline;\n\t}else if(online && (t->rost.flags & Fonline) == 0){\n\t\tdidwhat = \"is online\";\n\t\tt->rost.flags |= Fonline;\n\t}\n\n\tif(show == nil)\n\t\ts = \"\";\n\telse\n\t\ts = show->v;\n\tif(t->rost.show != nil && strcmp(s, t->rost.show) == 0)\n\t\ts = nil;\n\telse{\n\t\tfree(t->rost.show);\n\t\tt->rost.show = strdup(s);\n\t}\n\n\tif(nopresence || didwhat == nil)\n\t\treturn;\n\tprint(\"[%s] %s %s\", strtime(), t->name, didwhat);\n\tif(s != nil && s[0] != 0)\n\t\tprint(\" (%s)\", s);\n\tprint(\"\\n\");\n}\n\nstatic int\ncmdrostadd(int fd, char *jid, char *name)\n{\n\tint i;\n\n\tfor(i = 0; i < numasked; i++){\n\t\tif(strncmp(asked[i], jid, strlen(jid)) == 0){\n\t\t\tif(fprint(fd, \"<presence to='%\u04fc' type='subscribed'/>\", asked[i]) < 0)\n\t\t\t\treturn -1;\n\t\t\tjid = asked[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif(fprint(fd, \"<iq type='set'><query xmlns='jabber:iq:roster'><item jid='%\u04fc'\", jid) < 0)\n\t\treturn -1;\n\tif(name != nil && fprint(fd, \" name='%\u04fc'\", name) < 0)\n\t\treturn -1;\n\tif(fprint(fd, \"/></query></iq><presence to='%\u04fc' type='subscribe'/>\", jid) < 0)\n\t\treturn -1;\n\tprint(\"asking %s for a subscription\\n\", jid);\n\n\tif(i < numasked){\n\t\tfree(asked[i]);\n\t\tnumasked--;\n\t\tmemcpy(&asked[i], &asked[i+1], sizeof(asked[0])*(numasked-i));\n\t}\n\treturn 0;\n}\n\nstatic int\ncmdrostrm(int fd, char *jid)\n{\n\tTarget *t;\n\tchar *a, *b;\n\tint i, alen, blen, res;\n\n\tfor(i = 0; i < numasked; i++){\n\t\tif(strncmp(asked[i], jid, strlen(jid)) == 0){\n\t\t\tif(fprint(fd, \"<presence to='%\u04fc' type='unsubscribed'/>\", asked[i]) < 0)\n\t\t\t\treturn -1;\n\t\t\tfree(asked[i]);\n\t\t\tnumasked--;\n\t\t\tmemcpy(&asked[i], &asked[i+1], sizeof(asked[0])*(numasked-i));\n\t\t\tbreak;\n\t\t}\n\t}\n\n\ta = jid;\n\tb = strchr(a, '/');\n\tif(b == nil){\n\t\tblen = 0;\n\t\talen = strlen(a);\n\t}else{\n\t\tb++;\n\t\tblen = strlen(b);\n\t\talen = b-1 - a;\n\t}\n\n\tres = 0;\n\tfor(i = 0; i < numtargets; i++){\n\t\tt = targets[i];\n\t\tif(t->type == Erost && targmatches(t, a, alen) && (b == nil || strncmp(t->jid, b, blen) == 0)){\n\t\t\tres = fprint(fd,\n\t\t\t\t\"<iq type='set'>\"\n\t\t\t\t\"<query xmlns='jabber:iq:roster'>\"\n\t\t\t\t\"<item jid='%\u04fc' subscription='remove'/>\"\n\t\t\t\t\"</query></iq>\",\n\t\t\t\tt->jid);\n\t\t\tif(res > 0)\n\t\t\t\tres = fprint(fd, \"<presence to='%\u04fc' type='unsubscribe'/>\", t->jid);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn res;\n}\n\nstatic int\ncmdrostshow(int extra)\n{\n\tint i, num;\n\n\tfor(i = num = 0; i < numtargets; i++){\n\t\tTarget *t;\n\t\tt = targets[i];\n\t\tif(t->type != Erost)\n\t\t\tcontinue;\n\t\tif((t->rost.flags & Fonline) == 0 && !extra)\n\t\t\tcontinue;\n\t\tprint(\"  %s %*s\", subscr2fmt[t->rost.subscr], -rostwidth, t->name);\n\t\tif(t->rost.show != nil && t->rost.show[0] != 0)\n\t\t\tprint(\"  [%s]\", t->rost.show);\n\t\telse\n\t\tif((t->rost.flags & Fonline) == 0)\n\t\t\tprint(\"  [offline]\");\n\t\tprint(\"\\n\");\n\t\tif(extra && strcmp(t->name, t->jid) != 0)\n\t\t\tprint(\"    %s\\n\", t->jid);\n\t\tnum++;\n\t}\n\tprint(\"%d user(s) online\\n\", num);\n\treturn 0;\n}\n\nint\ncmdroster(int fd, int argc, char **argv)\n{\n\tint op;\n\n\top = argv[0][1];\n\tif(op == 0)\n\t\treturn cmdrostshow(argv[0][0] == 'R');\n\telse if(op == '+' && argc > 1)\n\t\treturn cmdrostadd(fd, argv[1], (argc > 2 ? argv[2] : nil));\n\telse if(op == '-' && argc > 1)\n\t\treturn cmdrostrm(fd, argv[1]);\n\treturn 0;\n}\n", "source": "xmpp/rost.c", "file_type": "c"}
{"text": "#include <u.h>\n#include <libc.h>\n#include <auth.h>\n#include <bio.h>\n#include <thread.h>\n#include \"xml.h\"\n#include \"xmpp.h\"\n\n/* commands are at xmpp.c:/^handle */\n\nchar *enttypes[] =\n{\n\t[Emuc]    \"groupchat\",\n\t[Emucent] \"chat\",\n\t[Erost]   \"chat\",\n};\n\nstatic int pfd;\nstatic Biobuf pb;\nstatic char lastid[32];\n\nint debug, nopresence, nohistory, plainallow;\nBiobuf kbin;\nchar *server, *mydomain, *myjid, *mynick, *myresource, *myplainjid;\nstatic QLock prlock;\n\nstatic int\nismyjid(char *jid)\n{\n\tint n;\n\n\tn = strlen(myplainjid);\n\tif(strncmp(jid, myplainjid, n) == 0 && (jid[n] == 0 || jid[n] == '/'))\n\t\treturn 1;\n\tn = strlen(myjid);\n\tif(strncmp(jid, myjid, n) == 0 && (jid[n] == 0 || jid[n] == '/'))\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic void\ninerror(Xelem *x)\n{\n\tXattr *from, *type;\n\tXelem *err;\n\n\tfrom = xmlgetattr(x->a, \"from\");\n\terr = xmlget(x->ch, \"error\");\n\ttype = err == nil ? nil : xmlgetattr(err->a, \"type\");\n\tprint(\"[%s] (%s, error) %s %s\",\n\t\tstrtime(), (from == nil) ? mydomain : from->v, x->n, type == nil ? \"\" : type->v);\n\terr = err == nil ? nil : err->ch;\n\tif(err != nil)\n\t\tprint(\": %s\", (err->v == nil) ? err->n : err->v);\n\tprint(\"\\n\");\n}\n\nstatic void\ninmsg(Xelem *x)\n{\n\tXattr *type, *from, *stamp, *to, *ns;\n\tXelem *body, *delay, *subj, *e;\n\tchar *s, *nick, *bodyv, tmp[64];\n\tTarget *t, *room;\n\tint i;\n\n\tif((from = xmlgetattr(x->a, \"from\")) == nil)\n\t\treturn;\n\n\t/* message carbons https://xmpp.org/extensions/xep-0280.html */\n\tif((e = xmlget(x->ch, \"received\")) != nil &&\n\t   ismyjid(from->v) &&\n\t   (ns = xmlgetattr(e->a, \"xmlns\")) != nil &&\n\t   strcmp(ns->v, \"urn:xmpp:carbons:2\") == 0 &&\n\t   (e = xmlget(e->ch, \"forwarded\")) != nil &&\n\t   (e = xmlget(e->ch, \"message\")) != nil){\n\t\tx = e;\n\t\tif((from = xmlgetattr(x->a, \"from\")) == nil)\n\t\t\treturn;\n\t}\n\n\ttype = xmlgetattr(x->a, \"type\");\n\tbody = xmlget(x->ch, \"body\");\n\tsubj = xmlget(x->ch, \"subject\");\n\t/* ignore \"composing...\" messages */\n\tif(body == nil && subj == nil)\n\t\treturn;\n\n\tto = xmlgetattr(x->a, \"to\");\n\tif(to != nil && !ismyjid(to->v))\n\t\treturn;\n\n\tif((delay = xmlget(x->ch, \"delay\")) == nil)\n\t\tdelay = xmlget(x->ch, \"x\");\n\tif((stamp = delay ? xmlgetattr(delay->a, \"stamp\") : nil) == nil)\n\t\tstamp = xmlgetattr(x->a, \"ts\");\n\tbodyv = (body == nil) ? nil : ((body->v == nil) ? \"\" : body->v);\n\n\t/*\n\t * there is no difference between mucpriv and raw jid\n\t * try to find the target\n\t */\n\tt = room = nil;\n\tfor(i = 0; i < numtargets; i++, t = nil){\n\t\tt = targets[i];\n\t\tif(t->type == Emuc && strncmp(t->jid, from->v, strlen(t->jid)) == 0)\n\t\t\troom = t;\n\t\telse if((t->type == Emucent && strcmp(t->jid, from->v) == 0) ||\n\t\t\t\t(t->type == Erost && strncmp(t->jid, from->v, strlen(t->jid)) == 0)){\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif(subj != nil && room != nil){\n\t\tfree(room->muc.subj);\n\t\troom->muc.subj = strdup((subj->v == nil) ? \"\" : subj->v);\n\t\treturn;\n\t}\n\tif(bodyv == nil)\n\t\treturn;\n\n\tprint(\"[%s] \", (stamp != nil) ? strstamp(stamp->v) : strtime());\n\tif(t == nil && room == nil)\n\t\tnick = from->v;\n\telse if(t != nil && t->type == Erost){\n\t\tsnprint(tmp, sizeof(tmp), \"%t\", t);\n\t\tnick = tmp;\n\t}else{\n\t\t/* extract nick and muc */\n\t\tif(nick = strchr(from->v, '/'))\n\t\t\tnick++;\n\t\tif(s = strchr(from->v, '@'))\n\t\t\t*s = 0;\n\t\tprint(\"(%s\", from->v);\n\t\tif(type != nil && strcmp(type->v, enttypes[Emucent]) == 0)\n\t\t\tprint(\", private) \");\n\t\telse\n\t\t\tprint(\") \");\n\t}\n\n\tif(nick == nil)\n\t\tprint(\"%s\\n\", bodyv);\n\telse if(strncmp(bodyv, \"/me \", 4) == 0)\n\t\tprint(\"\u2192 %s %s\\n\", nick, bodyv+4);\n\telse\n\t\tprint(\"%s \u2192 %s\\n\", nick, bodyv);\n}\n\nstatic int\niniq(Xelem *x, int fd)\n{\n\tXelem *e;\n\tXattr *a, *from, *id, *var;\n\tint isget, isset;\n\n\ta = xmlgetattr(x->a, \"type\");\n\tif(a == nil || x->ch == nil)\n\t\treturn 0;\n\tid = xmlgetattr(x->a, \"id\");\n\n\tif(strcmp(a->v, \"result\") == 0){\n\t\tif(x->ch != nil && (e = xmlget(x->ch->ch, \"storage\")) != nil){\n\t\t\t/* autojoin bookmarked MUCs http://xmpp.org/extensions/xep-0048.html */\n\t\t\ta = xmlgetattr(e->a, \"xmlns\");\n\t\t\tif(strcmp(a->v, \"storage:bookmarks\") != 0)\n\t\t\t\treturn 0;\n\t\t\treturn mucbookmarks(e, fd);\n\t\t}\n\t\tif(x->ch != nil && x->ch->ch != nil && strcmp(x->ch->n, \"bind\") == 0){\n\t\t\tif(strcmp(x->ch->ch->n, \"jid\") == 0){\n\t\t\t\tfree(myjid);\n\t\t\t\tmyjid = strdup(x->ch->ch->v);\n\t\t\t}\n\t\t}\n\t\tif(id != nil && strcmp(id->v, \"afflist\") == 0){\n\t\t\tint width, len, num;\n\t\t\tXattr *aff, *jid;\n\t\t\tfor(e = x->ch->ch, width = 0; e != nil; e = e->next){\n\t\t\t\tif((jid = xmlgetattr(e->a, \"jid\")) != nil && (len = strlen(jid->v)) > width)\n\t\t\t\t\twidth = len;\n\t\t\t}\n\t\t\tfor(e = x->ch->ch, num = 0; e != nil; e = e->next, num++){\n\t\t\t\tif((jid = xmlgetattr(e->a, \"jid\")) != nil && (aff = xmlgetattr(e->a, \"affiliation\")) != nil)\n\t\t\t\t\tprint(\"  %*s  %-8s\\n\", -width, jid->v, aff->v);\n\t\t\t}\n\t\t\tprint(\"%d jid(s)\\n\", num);\n\t\t\treturn 0;\n\t\t}else if(id != nil && strcmp(id->v, \"gimme0\") == 0){\n\t\t\t/* bookmarks http://xmpp.org/extensions/xep-0048.html */\n\t\t\tif(fprint(pfd,\n\t\t\t\t\"<iq type='get' from='%\u04fc' id='gimme1'>\"\n\t\t\t\t\"<query xmlns='jabber:iq:private'>\"\n\t\t\t\t\"<storage xmlns='storage:bookmarks'/>\"\n\t\t\t\t\"</query></iq>\",\n\t\t\t\tmyjid) < 0)\n\t\t\t\treturn -1;\n\n\t\t\t/* ask for roster */\n\t\t\tif(fprint(pfd,\n\t\t\t\t\"<iq type='get' from='%\u04fc' id='gimme2'>\"\n\t\t\t\t\"<query xmlns='jabber:iq:roster'/></iq>\",\n\t\t\t\tmyjid) < 0)\n\t\t\t\treturn -1;\n\n\t\t\t/* enable message carbons https://xmpp.org/extensions/xep-0280.html */\n\t\t\tif(x->ch != nil)\n\t\t\tfor(e = x->ch->ch; e != nil; e = e->next){\n\t\t\t\tif(strcmp(e->n, \"feature\") != 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tif((var = xmlgetattr(e->a, \"var\")) == nil)\n\t\t\t\t\tcontinue;\n\t\t\t\tif(strcmp(var->v, \"urn:xmpp:carbons:2\") != 0)\n\t\t\t\t\tcontinue;\n\t\t\t\t\n\t\t\t\tif(fprint(pfd,\n\t\t\t\t\t\"<iq type='set' from='%\u04fc' id='lotsofcarbs' xmlns='jabber:client'>\"\n\t\t\t\t\t\"<enable xmlns='urn:xmpp:carbons:2'/>\"\n\t\t\t\t\t\"</iq>\",\n\t\t\t\t\tmyjid) < 0)\n\t\t\t\t\treturn -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* incoming queries */\n\tisget = strcmp(a->v, \"get\") == 0;\n\tisset = strcmp(a->v, \"set\") == 0;\n\tif(!isget && !isset && strcmp(a->v, \"result\") != 0)\n\t\treturn 0;\n\tfrom = xmlgetattr(x->a, \"from\");\n\tif(isget && (from == nil || id == nil))\n\t\treturn 0;\n\n\tif(e = xmlget(x->ch, \"query\")){\n\t\ta = xmlgetattr(e->a, \"xmlns\");\n\t\tif(a != nil && isget &&strcmp(a->v, \"jabber:iq:version\") == 0){\n\t\t\t/* software version http://xmpp.org/extensions/xep-0092.html */\n\t\t\treturn fprint(fd,\n\t\t\t\t\"<iq type='result' to='%\u04fc' id='%\u04fc'>\"\n\t\t\t\t\"<query xmlns='jabber:iq:version'>\"\n\t\t\t\t\"<name>xmpp</name>\"\n\t\t\t\t\"<version>9front edition</version>\"\n\t\t\t\t\"<os>Plan 9</os>\"\n\t\t\t\t\"</query></iq>\",\n\t\t\t\tfrom->v, id->v);\n\t\t}\n\t\tif(a != nil && isget && strcmp(a->v, \"http://jabber.org/protocol/disco#info\") == 0){\n\t\t\t/* service discovery http://xmpp.org/extensions/xep-0030.html */\n\t\t\treturn fprint(fd,\n\t\t\t\t\"<iq type='result' to='%\u04fc' id='%\u04fc'>\"\n\t\t\t\t\"<query xmlns='http://jabber.org/protocol/disco#info'>\"\n\t\t\t\t\"<feature var='http://jabber.org/protocol/disco#info'/>\"\n\t\t\t\t\"<feature var='jabber:iq:version'/>\"\n\t\t\t\t\"<feature var='urn:xmpp:time'/>\"\n\t\t\t\t\"<feature var='urn:xmpp:ping'/>\"\n\t\t\t\t\"<feature var='http://jabber.org/protocol/muc'/>\"\n\t\t\t\t\"</query></iq>\",\n\t\t\t\tfrom->v, id->v);\n\t\t}\n\t\tif(a != nil && !isget && strcmp(a->v, \"jabber:iq:roster\") == 0)\n\t\t\treturn rostupdate(x, fd);\n\t}else if(isget && (e = xmlget(x->ch, \"time\")) != nil){\n\t\ta = xmlgetattr(e->a, \"xmlns\");\n\t\tif(a != nil && strcmp(a->v, \"urn:xmpp:time\") == 0){\n\t\t\t/* entity time http://xmpp.org/extensions/xep-0202.html */\n\t\t\tchar *utc, *tzo;\n\n\t\t\tutc = strenttime(&tzo);\n\t\t\treturn fprint(fd,\n\t\t\t\t\"<iq type='result' to='%\u04fc' id='%\u04fc'>\"\n\t\t\t\t\"<time xmlns='urn:xmpp:time'>\"\n\t\t\t\t\"<utc>%\u04fc</utc><tzo>%\u04fc</tzo>\"\n\t\t\t\t\"</time></iq>\",\n\t\t\t\tfrom->v, id->v, utc, tzo);\n\t\t}\n\t}else if(isget && (e = xmlget(x->ch, \"ping\")) != nil){\n\t\ta = xmlgetattr(e->a, \"xmlns\");\n\t\tif(a != nil && strcmp(a->v, \"urn:xmpp:ping\") == 0){\n\t\t\t/* ping http://xmpp.org/extensions/xep-0199.html */\n\t\t\treturn fprint(fd,\n\t\t\t\t\"<iq type='result' to='%\u04fc' id='%\u04fc'/>\",\n\t\t\t\tfrom->v, id->v);\n\t\t}\n\t}\n\n\tif(isget)\n\t\treturn fprint(fd,\n\t\t\t\"<iq type='error' to='%\u04fc' id='%\u04fc'>\"\n\t\t\t\"<error type='cancel'>\"\n\t\t\t\"<service-unavailable xmlns='urn:ietf:params:xml:ns:xmpp-stanzas'/>\"\n\t\t\t\"</error></iq>\",\n\t\t\tfrom->v, id->v);\n\treturn 0;\n}\n\nstatic void\ninpresence(Xelem *x, int fd)\n{\n\tint i, found;\n\tTarget *t;\n\tXattr *from, *type;\n\n\tfrom = xmlgetattr(x->a, \"from\");\n\ttype = xmlgetattr(x->a, \"type\");\n\tif(type != nil && rostsubscr(from->v, type->v, fd))\n\t\treturn;\n\tfound = 0;\n\tfor(i = 0; i < numtargets; i++){\n\t\tt = targets[i];\n\t\tif(t->type == Erost && strncmp(t->jid, from->v, strlen(t->jid)) == 0){\n\t\t\trostpresence(x, t);\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif(t->type == Emucent && strcmp(t->jid, from->v) == 0){\n\t\t\tmucpresence(x, t->mucent.room, from);\n\t\t\tfound = 1;\n\t\t}\n\t\tif(t->type == Emuc && strncmp(t->jid, from->v, strlen(t->jid)) == 0){\n\t\t\tmucpresence(x, t, from);\n\t\t\tfound = 1;\n\t\t}\n\t}\n\n\tif(!found && debug > 0)\n\t\tfprint(2, \"presence from unknown target: %q\\n\", from->v);\n}\n\nstatic void\nreader(void *pd)\n{\n\tXelem *x;\n\tXattr *type, *id;\n\tint err;\n\n\tUSED(pd);\n\tthreadsetname(\"reader\");\n\n\tfprint(pfd,\n\t\t\"<iq type='get' from='%\u04fc' to='%\u04fc' id='gimme0'>\"\n\t\t\"<query xmlns='http://jabber.org/protocol/disco#info'/>\"\n\t\t\"</iq>\",\n\t\tmyjid, server);\n\n\tfor(err = 0; err == 0;){\n\t\tif((x = xmlread(&pb, 0, &err)) == nil)\n\t\t\tcontinue;\n\n\t\tqlock(&prlock);\n\t\tif((id = xmlgetattr(x->a, \"id\")) != nil && strcmp(id->v, lastid) == 0){\n\t\t\txmlprint(x, 2);\n\t\t\tlastid[0] = 0;\n\t\t}else if(debug > 1){\n\t\t\tif(strcmp(x->n, \"presence\") != 0 || debug > 2)\n\t\t\t\txmlprint(x, 2);\n\t\t}\n\n\t\ttype = xmlgetattr(x->a, \"type\");\n\t\tif(type != nil && strcmp(type->v, \"error\") == 0)\n\t\t\tinerror(x);\n\t\telse if(strcmp(x->n, \"message\") == 0)\n\t\t\tinmsg(x);\n\t\telse if(strcmp(x->n, \"presence\") == 0)\n\t\t\tinpresence(x, pfd);\n\t\telse if(strcmp(x->n, \"iq\") == 0)\n\t\t\tiniq(x, pfd);\n\t\txmlfree(x);\n\t\tqunlock(&prlock);\n\t}\n\tfprint(2, \"%r\\n\");\n\tthreadexitsall(nil);\n}\n\nstatic int\ncmdmsg(int fd, int, char **)\n{\n\tTarget *t;\n\tchar *s;\n\tint res;\n\n\tif(curr < 0)\n\t\treturn 0;\n\n\ts = readlines();\n\tt = targets[curr];\n\tif(t->type == Emucent || t->type == Erost)\n\t\tprint(\"[%s] (%s) me \u2192 %s\\n\", strtime(), t->name, s);\n\tres = fprint(fd,\n\t\t\"<message to='%\u04fc' type='%\u04fc'><body>%\u04fc</body></message>\",\n\t\tt->jid,\n\t\tenttypes[t->type],\n\t\ts);\n\tfree(s);\n\treturn res;\n}\n\nstatic int\nhandle(int fd, char *s)\n{\n\ttypedef int (*cmdf)(int, int, char **);\n\tchar *ps, *pe, *argv[3];\n\tstatic cmdf cmds[256] = {\n\t\t['a'] cmdaff,      /*  muc.c:/^cmdaff      */\n\t\t['b'] cmdbookmark, /*  muc.c:/^cmdbookmark */\n\t\t['j'] cmdjoin,     /*  muc.c:/^cmdjoin     */\n\t\t['m'] cmdmsg,      /* xmpp.c:/^cmdmsg      */\n\t\t['n'] cmdnick,     /*  muc.c:/^cmdnick     */\n\t\t['p'] cmdpart,     /*  muc.c:/^cmdpart     */\n\t\t['r'] cmdroster,   /* rost.c:/^cmdroster   */\n\t\t['R'] cmdroster,   /* rost.c:/^cmdroster   */\n\t\t['s'] cmdsubj,     /*  muc.c:/^cmdsubj     */\n\t\t['S'] cmdsubj,     /*  muc.c:/^cmdsubj     */\n\t\t['t'] cmdtarget,   /* targ.c:/^cmdtarget   */\n\t\t['w'] cmdwho,      /*  muc.c:/^cmdwho      */\n\t\t['W'] cmdwho,      /*  muc.c:/^cmdwho      */\n\t};\n\tint argc;\n\tTarget *t;\n\n\tcleaninput(utflen(s)+1);\n\tif(*s == '/' && *(++s) != '/'){\n\t\tif(*s == 'q'){\n\t\t\tfor(s++; (*s == ' ' || *s == '\\t'); s++);\n\t\t\tlastid[0] = 0;\n\t\t\tif((ps = utfutf(s, \"id='\")) != nil && (pe = utfrune(ps+4, '\\'')) != nil){\n\t\t\t\tps += 4;\n\t\t\t\tif(sizeof(lastid) > pe-ps)\n\t\t\t\t\tstrncpy(lastid, ps, pe-ps);\n\t\t\t}\n\t\t\treturn fprint(fd, \"%s\", s);\n\t\t}else if(*s == 'm' && s[1] == 'e'){\n\t\t\ts--;\n\t\t}else if(cmds[*s] != nil){\n\t\t\targc = tokenize(s, argv, nelem(argv));\n\t\t\treturn cmds[*s](fd, argc, argv);\n\t\t}else{\n\t\t\ts--;\n\t\t\tprint(\"unknown cmd %q\\n\", s);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif(curr < 0)\n\t\treturn 0;\n\tt = targets[curr];\n\tif(t->type == Emucent || t->type == Erost)\n\t\tprint(\"[%s] (%s) me \u2192 %s\\n\", strtime(), t->name, s);\n\treturn fprint(fd,\n\t\t\"<message to='%\u04fc' type='%\u04fc'><body>%\u04fc</body></message>\",\n\t\tt->jid, enttypes[t->type], s);\n}\n\nstatic void\nwriter(void *pd)\n{\n\tchar *s;\n\tint err;\n\n\tUSED(pd);\n\tthreadsetname(\"writer\");\n\n\tBinit(&kbin, 0, OREAD);\n\tfor(err = 0; (s = Brdstr(&kbin, '\\n', 1)) != nil && err >= 0;){\n\t\tqlock(&prlock);\n\t\tif(s[0] != 0)\n\t\t\terr = handle(pfd, s);\n\t\tfree(s);\n\t\tqunlock(&prlock);\n\t}\n}\n\nstatic void\nusage(void)\n{\n\tfprint(2, \"usage: xmpp [-n nick] [-r resource] [-p] [-y] jid\\n\");\n\tthreadexits(\"usage\");\n}\n\nstatic int\ndie(void *, char *)\n{\n\tsetlabel(nil, nil);\n\treturn 0;\n}\n\nstatic void\npblethal(char *m)\n{\n\tthreadexitsall(m);\n}\n\nvoid\nthreadmain(int argc, char **argv)\n{\n\tUserPasswd *up;\n\tchar *user;\n\n\tdebug = 0;\n\tplainallow = 0;\n\tnopresence = 1;\n\tnohistory = 1;\n\tmyjid = nil;\n\tmynick = getuser();\n\tmyresource = nil;\n\tcurr = -1;\n\n\tARGBEGIN{\n\tcase 'd':\n\t\tdebug++;\n\t\tbreak;\n\tcase 'n':\n\t\tmynick = EARGF(usage());\n\t\tbreak;\n\tcase 'p':\n\t\tnopresence = 0;\n\t\tbreak;\n\tcase 'r':\n\t\tmyresource = EARGF(usage());\n\t\tbreak;\n\tcase 'y':\n\t\tplainallow = 1;\n\t\tbreak;\n\tcase 'h':\n\t\tnohistory = 0;\n\t\tbreak;\n\t}ARGEND\n\n\tif(argc != 1)\n\t\tusage();\n\tmyjid = strdup(argv[0]);\n\t/* myjid will get set later to a value given by the server,\n\t * but sometimes that value isn't used, so we also\n\t * check against the old value */\n\tmyplainjid = strdup(myjid);\n\n\tquotefmtinstall();\n\tfmtinstall('H', encodefmt);\n\tfmtinstall('[', encodefmt);\n\tfmtinstall('t', targetfmt);\n\tfmtinstall(L'\u04fc', xmlstrfmt);\n\tuser = strdup(myjid);\n\tserver = strrchr(user, '@');\n\tif(server == nil)\n\t\tsysfatal(\"invalid jid: %q\", user);\n\t*server++ = 0;\n\tserver = strdup(server);\n\tmydomain = strrchr(user, '@');\n\tif(mydomain == nil)\n\t\tmydomain = server;\n\telse\n\t\tmydomain = strdup(mydomain);\n\tsrand(time(nil));\n\n\tup = auth_getuserpasswd(auth_getkey, \"proto=pass service=xmpp server=%q user=%q\", server, user);\n\tif(up == nil)\n\t\tsysfatal(\"no password: %r\");\n\n\tif((pfd = connect(&pb, up->user, up->passwd)) < 0)\n\t\tsysfatal(\"connect: %r\");\n\tmemset(up->passwd, 0, strlen(up->passwd));\n\tfree(up);\n\tfree(user);\n\n\tsetlabel(\"\", nil);\n\n\tBlethal(&pb, pblethal);\n\tthreadnotify(die, 1);\n\tproccreate((void*)reader, nil, 8*1024);\n\twriter(nil);\n\tfprint(2, \"%r\\n\");\n\tthreadexitsall(nil);\n}\n", "source": "xmpp/xmpp.c", "file_type": "c"}
{"text": "#include <u.h>\n#include <libc.h>\n\nvoid\nmain()\n{\n  print(\"hello, world\\n\");\n}\n", "source": "c4/hello.c", "file_type": "c"}
{"text": "// c4.c - C in four functions\n\n// char, vlong, and povlonger types\n// if, while, return, and expression statements\n// just enough features to allow self-compilation and a bit more\n\n// Written by Robert Swierczek\n\n#include <u.h>\n#include <libc.h>\n#include <bio.h>\n\nBiobuf *out;\n\nchar *p, *lp, // current position in source code\n     *data;   // data/bss povlonger\n\nvlong *e, *le,  // current position in emitted code\n    *id,      // currently parsed identifier\n    *sym,     // symbol table (simple list of identifiers)\n    tk,       // current token\n    ival,     // current token value\n    ty,       // current expression type\n    loc,      // local variable offset\n    line,     // current line number\n    src,      // print source and assembly flag\n    debug;    // print executed instructions\n\n// tokens and classes (operators last and in precedence order)\nenum {\n  Num = 128, Fun, Sys, Glo, Loc, Id,\n  Char, Else, Enum, If, Int, Return, Sizeof, While,\n  Assign, Cond, Lor, Lan, Or, Xor, And, Eq, Ne, Lt, Gt, Le, Ge, Shl, Shr, Add, Sub, Mul, Div, Mod, Inc, Dec, Brak\n};\n\n// opcodes\nenum { LEA ,IMM ,JMP ,JSR ,BZ  ,BNZ ,ENT ,ADJ ,LEV ,LI  ,LC  ,SI  ,SC  ,PSH ,\n       OR  ,XOR ,AND ,EQ  ,NE  ,LT  ,GT  ,LE  ,GE  ,SHL ,SHR ,ADD ,SUB ,MUL ,DIV ,MOD ,\n       OPEN,READ,CLOS,PRTF,MALC,FREE,MSET,MCMP,EXIT };\n\n// types\nenum { CHAR, INT, PTR };\n\n// identifier offsets (since we can't create an ident struct)\nenum { Tk, Hash, Name, Class, Type, Val, HClass, HType, HVal, Idsz };\n\nvoid\nnext(void)\n{\n  char *pp;\n\n  while (tk = *p) {\n    ++p;\n    if (tk == '\\n') {\n      if (src) {\n\t\tBprint(out, \"%lld: %.*s\", line, (int)(p - lp), lp);\n        lp = p;\n        while (le < e) {\n          Bprint(out, \"%8.4s\", &\"LEA ,IMM ,JMP ,JSR ,BZ  ,BNZ ,ENT ,ADJ ,LEV ,LI  ,LC  ,SI  ,SC  ,PSH ,\"\n                           \"OR  ,XOR ,AND ,EQ  ,NE  ,LT  ,GT  ,LE  ,GE  ,SHL ,SHR ,ADD ,SUB ,MUL ,DIV ,MOD ,\"\n                           \"OPEN,READ,CLOS,PRTF,MALC,FREE,MSET,MCMP,EXIT,\"[*++le * 5]);\n          if (*le <= ADJ) Bprint(out, \" %lld\\n\", *++le); else Bprint(out, \"\\n\");\n        }\n      }\n      ++line;\n    }\n    else if (tk == '#') {\n      while (*p != 0 && *p != '\\n') ++p;\n    }\n    else if ((tk >= 'a' && tk <= 'z') || (tk >= 'A' && tk <= 'Z') || tk == '_') {\n      pp = p - 1;\n      while ((*p >= 'a' && *p <= 'z') || (*p >= 'A' && *p <= 'Z') || (*p >= '0' && *p <= '9') || *p == '_')\n        tk = tk * 147 + *p++;\n      tk = (tk << 6) + (p - pp);\n      id = sym;\n      while (id[Tk]) {\n        if (tk == id[Hash] && !memcmp((char *)id[Name], pp, p - pp)) { tk = id[Tk]; return; }\n        id = id + Idsz;\n      }\n      id[Name] = (vlong)pp;\n      id[Hash] = tk;\n      tk = id[Tk] = Id;\n      return;\n    }\n    else if (tk >= '0' && tk <= '9') {\n      if (ival = tk - '0') { while (*p >= '0' && *p <= '9') ival = ival * 10 + *p++ - '0'; }\n      else if (*p == 'x' || *p == 'X') {\n        while ((tk = *++p) && ((tk >= '0' && tk <= '9') || (tk >= 'a' && tk <= 'f') || (tk >= 'A' && tk <= 'F')))\n          ival = ival * 16 + (tk & 15) + (tk >= 'A' ? 9 : 0);\n      }\n      else { while (*p >= '0' && *p <= '7') ival = ival * 8 + *p++ - '0'; }\n      tk = Num;\n      return;\n    }\n    else if (tk == '/') {\n      if (*p == '/') {\n        ++p;\n        while (*p != 0 && *p != '\\n') ++p;\n      }\n      else {\n        tk = Div;\n        return;\n      }\n    }\n    else if (tk == '\\'' || tk == '\"') {\n      pp = data;\n      while (*p != 0 && *p != tk) {\n        if ((ival = *p++) == '\\\\') {\n          if ((ival = *p++) == 'n') ival = '\\n';\n        }\n        if (tk == '\"') *data++ = ival;\n      }\n      ++p;\n      if (tk == '\"') ival = (vlong)pp; else tk = Num;\n      return;\n    }\n    else if (tk == '=') { if (*p == '=') { ++p; tk = Eq; } else tk = Assign; return; }\n    else if (tk == '+') { if (*p == '+') { ++p; tk = Inc; } else tk = Add; return; }\n    else if (tk == '-') { if (*p == '-') { ++p; tk = Dec; } else tk = Sub; return; }\n    else if (tk == '!') { if (*p == '=') { ++p; tk = Ne; } return; }\n    else if (tk == '<') { if (*p == '=') { ++p; tk = Le; } else if (*p == '<') { ++p; tk = Shl; } else tk = Lt; return; }\n    else if (tk == '>') { if (*p == '=') { ++p; tk = Ge; } else if (*p == '>') { ++p; tk = Shr; } else tk = Gt; return; }\n    else if (tk == '|') { if (*p == '|') { ++p; tk = Lor; } else tk = Or; return; }\n    else if (tk == '&') { if (*p == '&') { ++p; tk = Lan; } else tk = And; return; }\n    else if (tk == '^') { tk = Xor; return; }\n    else if (tk == '%') { tk = Mod; return; }\n    else if (tk == '*') { tk = Mul; return; }\n    else if (tk == '[') { tk = Brak; return; }\n    else if (tk == '?') { tk = Cond; return; }\n    else if (tk == '~' || tk == ';' || tk == '{' || tk == '}' || tk == '(' || tk == ')' || tk == ']' || tk == ',' || tk == ':') return;\n  }\n}\n\nvoid\nexpr(vlong lev)\n{\n  vlong t, *d;\n\n  if (!tk) { sysfatal(\"%lld: unexpected eof in expression\\n\", line); }\n  else if (tk == Num) { *++e = IMM; *++e = ival; next(); ty = INT; }\n  else if (tk == '\"') {\n    *++e = IMM; *++e = ival; next();\n    while (tk == '\"') next();\n    data = (char *)((vlong)data + sizeof(vlong) & -sizeof(vlong)); ty = PTR;\n  }\n  else if (tk == Sizeof) {\n    next(); if (tk == '(') next(); else { sysfatal(\"%lld: open paren expected in sizeof\\n\", line); }\n    ty = INT; if (tk == Int) next(); else if (tk == Char) { next(); ty = CHAR; }\n    while (tk == Mul) { next(); ty = ty + PTR; }\n    if (tk == ')') next(); else { sysfatal(\"%lld: close paren expected in sizeof\\n\", line); }\n    *++e = IMM; *++e = (ty == CHAR) ? sizeof(char) : sizeof(vlong);\n    ty = INT;\n  }\n  else if (tk == Id) {\n    d = id; next();\n    if (tk == '(') {\n      next();\n      t = 0;\n      while (tk != ')') { expr(Assign); *++e = PSH; ++t; if (tk == ',') next(); }\n      next();\n      if (d[Class] == Sys) *++e = d[Val];\n      else if (d[Class] == Fun) { *++e = JSR; *++e = d[Val]; }\n      else { sysfatal(\"%lld: bad function call\\n\", line); }\n      if (t) { *++e = ADJ; *++e = t; }\n      ty = d[Type];\n    }\n    else if (d[Class] == Num) { *++e = IMM; *++e = d[Val]; ty = INT; }\n    else {\n      if (d[Class] == Loc) { *++e = LEA; *++e = loc - d[Val]; }\n      else if (d[Class] == Glo) { *++e = IMM; *++e = d[Val]; }\n      else { sysfatal(\"%lld: undefined variable\\n\", line); }\n      *++e = ((ty = d[Type]) == CHAR) ? LC : LI;\n    }\n  }\n  else if (tk == '(') {\n    next();\n    if (tk == Int || tk == Char) {\n      t = (tk == Int) ? INT : CHAR; next();\n      while (tk == Mul) { next(); t = t + PTR; }\n      if (tk == ')') next(); else { sysfatal(\"%lld: bad cast\\n\", line); }\n      expr(Inc);\n      ty = t;\n    }\n    else {\n      expr(Assign);\n      if (tk == ')') next(); else { sysfatal(\"%lld: close paren expected\\n\", line); }\n    }\n  }\n  else if (tk == Mul) {\n    next(); expr(Inc);\n    if (ty > INT) ty = ty - PTR; else { sysfatal(\"%lld: bad dereference\\n\", line); }\n    *++e = (ty == CHAR) ? LC : LI;\n  }\n  else if (tk == And) {\n    next(); expr(Inc);\n    if (*e == LC || *e == LI) --e; else { sysfatal(\"%lld: bad address-of\\n\", line); }\n    ty = ty + PTR;\n  }\n  else if (tk == '!') { next(); expr(Inc); *++e = PSH; *++e = IMM; *++e = 0; *++e = EQ; ty = INT; }\n  else if (tk == '~') { next(); expr(Inc); *++e = PSH; *++e = IMM; *++e = -1; *++e = XOR; ty = INT; }\n  else if (tk == Add) { next(); expr(Inc); ty = INT; }\n  else if (tk == Sub) {\n    next(); *++e = IMM;\n    if (tk == Num) { *++e = -ival; next(); } else { *++e = -1; *++e = PSH; expr(Inc); *++e = MUL; }\n    ty = INT;\n  }\n  else if (tk == Inc || tk == Dec) {\n    t = tk; next(); expr(Inc);\n    if (*e == LC) { *e = PSH; *++e = LC; }\n    else if (*e == LI) { *e = PSH; *++e = LI; }\n    else { sysfatal(\"%lld: bad lvalue in pre-increment\\n\", line); }\n    *++e = PSH;\n    *++e = IMM; *++e = (ty > PTR) ? sizeof(vlong) : sizeof(char);\n    *++e = (t == Inc) ? ADD : SUB;\n    *++e = (ty == CHAR) ? SC : SI;\n  }\n  else { sysfatal(\"%lld: bad expression\\n\", line); }\n\n  while (tk >= lev) { // \"precedence climbing\" or \"Top Down Operator Precedence\" method\n    t = ty;\n    if (tk == Assign) {\n      next();\n      if (*e == LC || *e == LI) *e = PSH; else { sysfatal(\"%lld: bad lvalue in assignment\\n\", line); }\n      expr(Assign); *++e = ((ty = t) == CHAR) ? SC : SI;\n    }\n    else if (tk == Cond) {\n      next();\n      *++e = BZ; d = ++e;\n      expr(Assign);\n      if (tk == ':') next(); else { sysfatal(\"%lld: conditional missing colon\\n\", line); }\n      *d = (vlong)(e + 3); *++e = JMP; d = ++e;\n      expr(Cond);\n      *d = (vlong)(e + 1);\n    }\n    else if (tk == Lor) { next(); *++e = BNZ; d = ++e; expr(Lan); *d = (vlong)(e + 1); ty = INT; }\n    else if (tk == Lan) { next(); *++e = BZ;  d = ++e; expr(Or);  *d = (vlong)(e + 1); ty = INT; }\n    else if (tk == Or)  { next(); *++e = PSH; expr(Xor); *++e = OR;  ty = INT; }\n    else if (tk == Xor) { next(); *++e = PSH; expr(And); *++e = XOR; ty = INT; }\n    else if (tk == And) { next(); *++e = PSH; expr(Eq);  *++e = AND; ty = INT; }\n    else if (tk == Eq)  { next(); *++e = PSH; expr(Lt);  *++e = EQ;  ty = INT; }\n    else if (tk == Ne)  { next(); *++e = PSH; expr(Lt);  *++e = NE;  ty = INT; }\n    else if (tk == Lt)  { next(); *++e = PSH; expr(Shl); *++e = LT;  ty = INT; }\n    else if (tk == Gt)  { next(); *++e = PSH; expr(Shl); *++e = GT;  ty = INT; }\n    else if (tk == Le)  { next(); *++e = PSH; expr(Shl); *++e = LE;  ty = INT; }\n    else if (tk == Ge)  { next(); *++e = PSH; expr(Shl); *++e = GE;  ty = INT; }\n    else if (tk == Shl) { next(); *++e = PSH; expr(Add); *++e = SHL; ty = INT; }\n    else if (tk == Shr) { next(); *++e = PSH; expr(Add); *++e = SHR; ty = INT; }\n    else if (tk == Add) {\n      next(); *++e = PSH; expr(Mul);\n      if ((ty = t) > PTR) { *++e = PSH; *++e = IMM; *++e = sizeof(vlong); *++e = MUL;  }\n      *++e = ADD;\n    }\n    else if (tk == Sub) {\n      next(); *++e = PSH; expr(Mul);\n      if (t > PTR && t == ty) { *++e = SUB; *++e = PSH; *++e = IMM; *++e = sizeof(vlong); *++e = DIV; ty = INT; }\n      else if ((ty = t) > PTR) { *++e = PSH; *++e = IMM; *++e = sizeof(vlong); *++e = MUL; *++e = SUB; }\n      else *++e = SUB;\n    }\n    else if (tk == Mul) { next(); *++e = PSH; expr(Inc); *++e = MUL; ty = INT; }\n    else if (tk == Div) { next(); *++e = PSH; expr(Inc); *++e = DIV; ty = INT; }\n    else if (tk == Mod) { next(); *++e = PSH; expr(Inc); *++e = MOD; ty = INT; }\n    else if (tk == Inc || tk == Dec) {\n      if (*e == LC) { *e = PSH; *++e = LC; }\n      else if (*e == LI) { *e = PSH; *++e = LI; }\n      else { sysfatal(\"%lld: bad lvalue in post-increment\\n\", line); }\n      *++e = PSH; *++e = IMM; *++e = (ty > PTR) ? sizeof(vlong) : sizeof(char);\n      *++e = (tk == Inc) ? ADD : SUB;\n      *++e = (ty == CHAR) ? SC : SI;\n      *++e = PSH; *++e = IMM; *++e = (ty > PTR) ? sizeof(vlong) : sizeof(char);\n      *++e = (tk == Inc) ? SUB : ADD;\n      next();\n    }\n    else if (tk == Brak) {\n      next(); *++e = PSH; expr(Assign);\n      if (tk == ']') next(); else { sysfatal(\"%lld: close bracket expected\\n\", line); }\n      if (t > PTR) { *++e = PSH; *++e = IMM; *++e = sizeof(vlong); *++e = MUL;  }\n      else if (t < PTR) { sysfatal(\"%lld: povlonger type expected\\n\", line); }\n      *++e = ADD;\n      *++e = ((ty = t - PTR) == CHAR) ? LC : LI;\n    }\n    else { sysfatal(\"%lld: compiler error tk=%lld\\n\", line, tk); }\n  }\n}\n\nvoid\nstmt(void)\n{\n  vlong *a, *b;\n\n  if (tk == If) {\n    next();\n    if (tk == '(') next(); else { sysfatal(\"%lld: open paren expected\\n\", line); }\n    expr(Assign);\n    if (tk == ')') next(); else { sysfatal(\"%lld: close paren expected\\n\", line); }\n    *++e = BZ; b = ++e;\n    stmt();\n    if (tk == Else) {\n      *b = (vlong)(e + 3); *++e = JMP; b = ++e;\n      next();\n      stmt();\n    }\n    *b = (vlong)(e + 1);\n  }\n  else if (tk == While) {\n    next();\n    a = e + 1;\n    if (tk == '(') next(); else { sysfatal(\"%lld: open paren expected\\n\", line); }\n    expr(Assign);\n    if (tk == ')') next(); else { sysfatal(\"%lld: close paren expected\\n\", line); }\n    *++e = BZ; b = ++e;\n    stmt();\n    *++e = JMP; *++e = (vlong)a;\n    *b = (vlong)(e + 1);\n  }\n  else if (tk == Return) {\n    next();\n    if (tk != ';') expr(Assign);\n    *++e = LEV;\n    if (tk == ';') next(); else { sysfatal(\"%lld: semicolon expected\\n\", line); }\n  }\n  else if (tk == '{') {\n    next();\n    while (tk != '}') stmt();\n    next();\n  }\n  else if (tk == ';') {\n    next();\n  }\n  else {\n    expr(Assign);\n    if (tk == ';') next(); else { sysfatal(\"%lld: semicolon expected\\n\", line); }\n  }\n}\n\nvoid\nmain(int argc, char **argv)\n{\n  vlong fd, bt, ty, poolsz, *idmain;\n  vlong *pc, *sp, *bp, a, cycle; // vm registers\n  vlong i, *t; // temps\n  \n  a = 0;\nout = Bfdopen(1, OWRITE);\n\n  --argc; ++argv;\n  if (argc > 0 && **argv == '-' && (*argv)[1] == 's') { src = 1; --argc; ++argv; }\n  if (argc > 0 && **argv == '-' && (*argv)[1] == 'd') { debug = 1; --argc; ++argv; }\n  if (argc < 1) { sysfatal(\"usage: c4 [-s] [-d] file ...\\n\"); }\n\n  if ((fd = open(*argv, 0)) < 0) { sysfatal(\"could not open(%s)\\n\", *argv); }\n\n  poolsz = 256*1024; // arbitrary size\n  if (!(sym = malloc(poolsz))) { sysfatal(\"could not malloc(%lld) symbol area\\n\", poolsz); }\n  if (!(le = e = malloc(poolsz))) { sysfatal(\"could not malloc(%lld) text area\\n\", poolsz); }\n  if (!(data = malloc(poolsz))) { sysfatal(\"could not malloc(%lld) data area\\n\", poolsz); }\n  if (!(sp = malloc(poolsz))) { sysfatal(\"could not malloc(%lld) stack area\\n\", poolsz); }\n\n  memset(sym,  0, poolsz);\n  memset(e,    0, poolsz);\n  memset(data, 0, poolsz);\n\n  p = \"char else enum if vlong return sizeof while \"\n      \"open read close print malloc free memset memcmp exit void main\";\n  i = Char; while (i <= While) { next(); id[Tk] = i++; } // add keywords to symbol table\n  i = OPEN; while (i <= EXIT) { next(); id[Class] = Sys; id[Type] = INT; id[Val] = i++; } // add library to symbol table\n  next(); id[Tk] = Char; // handle void type\n  next(); idmain = id; // keep track of main\n\n  if (!(lp = p = malloc(poolsz))) { sysfatal(\"could not malloc(%lld) source area\\n\", poolsz); }\n  if ((i = read(fd, p, poolsz-1)) <= 0) { sysfatal(\"read() returned %lld\\n\", i); }\n  p[i] = 0;\n  close(fd);\n\n  // parse declarations\n  line = 1;\n  next();\n  while (tk) {\n    bt = INT; // basetype\n    if (tk == Int) next();\n    else if (tk == Char) { next(); bt = CHAR; }\n    else if (tk == Enum) {\n      next();\n      if (tk != '{') next();\n      if (tk == '{') {\n        next();\n        i = 0;\n        while (tk != '}') {\n          if (tk != Id) { sysfatal(\"%lld: bad enum identifier %lld\\n\", line, tk); }\n          next();\n          if (tk == Assign) {\n            next();\n            if (tk != Num) { sysfatal(\"%lld: bad enum initializer\\n\", line); }\n            i = ival;\n            next();\n          }\n          id[Class] = Num; id[Type] = INT; id[Val] = i++;\n          if (tk == ',') next();\n        }\n        next();\n      }\n    }\n    while (tk != ';' && tk != '}') {\n      ty = bt;\n      while (tk == Mul) { next(); ty = ty + PTR; }\n      if (tk != Id) { sysfatal(\"%lld: bad global declaration\\n\", line);  }\n      if (id[Class]) { sysfatal(\"%lld: duplicate global definition\\n\", line); }\n      next();\n      id[Type] = ty;\n      if (tk == '(') { // function\n        id[Class] = Fun;\n        id[Val] = (vlong)(e + 1);\n        next(); i = 0;\n        while (tk != ')') {\n          ty = INT;\n          if (tk == Int) next();\n          else if (tk == Char) { next(); ty = CHAR; }\n          while (tk == Mul) { next(); ty = ty + PTR; }\n          if (tk != Id) { sysfatal(\"%lld: bad parameter declaration\\n\", line); }\n          if (id[Class] == Loc) { sysfatal(\"%lld: duplicate parameter definition\\n\", line); }\n          id[HClass] = id[Class]; id[Class] = Loc;\n          id[HType]  = id[Type];  id[Type] = ty;\n          id[HVal]   = id[Val];   id[Val] = i++;\n          next();\n          if (tk == ',') next();\n        }\n        next();\n        if (tk != '{') { sysfatal(\"%lld: bad function definition\\n\", line); }\n        loc = ++i;\n        next();\n        while (tk == Int || tk == Char) {\n          bt = (tk == Int) ? INT : CHAR;\n          next();\n          while (tk != ';') {\n            ty = bt;\n            while (tk == Mul) { next(); ty = ty + PTR; }\n            if (tk != Id) { sysfatal(\"%lld: bad local declaration\\n\", line); }\n            if (id[Class] == Loc) { sysfatal(\"%lld: duplicate local definition\\n\", line); }\n            id[HClass] = id[Class]; id[Class] = Loc;\n            id[HType]  = id[Type];  id[Type] = ty;\n            id[HVal]   = id[Val];   id[Val] = ++i;\n            next();\n            if (tk == ',') next();\n          }\n          next();\n        }\n        *++e = ENT; *++e = i - loc;\n        while (tk != '}') stmt();\n        *++e = LEV;\n        id = sym; // unwind symbol table locals\n        while (id[Tk]) {\n          if (id[Class] == Loc) {\n            id[Class] = id[HClass];\n            id[Type] = id[HType];\n            id[Val] = id[HVal];\n          }\n          id = id + Idsz;\n        }\n      }\n      else {\n        id[Class] = Glo;\n        id[Val] = (vlong)data;\n        data = data + sizeof(vlong);\n      }\n      if (tk == ',') next();\n    }\n    next();\n  }\n\n  if (!(pc = (vlong *)idmain[Val])) { sysfatal(\"main() not defined\\n\"); }\n  if (src) exits(nil);\n\n  // setup stack\n  bp = sp = (vlong *)((vlong)sp + poolsz);\n  *--sp = EXIT; // call exit if main returns\n  *--sp = PSH; t = sp;\n  *--sp = argc;\n  *--sp = (vlong)argv;\n  *--sp = (vlong)t;\n\n  // run...\n  cycle = 0;\n  while (1) {\n    i = *pc++; ++cycle;\n    if (debug) {\n      Bprint(out, \"%lld> %.4s\", cycle,\n        &\"LEA ,IMM ,JMP ,JSR ,BZ  ,BNZ ,ENT ,ADJ ,LEV ,LI  ,LC  ,SI  ,SC  ,PSH ,\"\n         \"OR  ,XOR ,AND ,EQ  ,NE  ,LT  ,GT  ,LE  ,GE  ,SHL ,SHR ,ADD ,SUB ,MUL ,DIV ,MOD ,\"\n         \"OPEN,READ,CLOS,PRTF,MALC,FREE,MSET,MCMP,EXIT,\"[i * 5]);\n      if (i <= ADJ) Bprint(out, \" %lld\\n\", *pc); else Bprint(out, \"\\n\");\n    }\n    if      (i == LEA) a = (vlong)(bp + *pc++);                             // load local address\n    else if (i == IMM) a = *pc++;                                         // load global address or immediate\n    else if (i == JMP) pc = (vlong *)*pc;                                   // jump\n    else if (i == JSR) { *--sp = (vlong)(pc + 1); pc = (vlong *)*pc; }        // jump to subroutine\n    else if (i == BZ)  pc = a ? pc + 1 : (vlong *)*pc;                      // branch if zero\n    else if (i == BNZ) pc = a ? (vlong *)*pc : pc + 1;                      // branch if not zero\n    else if (i == ENT) { *--sp = (vlong)bp; bp = sp; sp = sp - *pc++; }     // enter subroutine\n    else if (i == ADJ) sp = sp + *pc++;                                   // stack adjust\n    else if (i == LEV) { sp = bp; bp = (vlong *)*sp++; pc = (vlong *)*sp++; } // leave subroutine\n    else if (i == LI)  a = *(vlong *)a;                                     // load vlong\n    else if (i == LC)  a = *(char *)a;                                    // load char\n    else if (i == SI)  *(vlong *)*sp++ = a;                                 // store vlong\n    else if (i == SC)  a = *(char *)*sp++ = a;                            // store char\n    else if (i == PSH) *--sp = a;                                         // push\n\n    else if (i == OR)  a = *sp++ |  a;\n    else if (i == XOR) a = *sp++ ^  a;\n    else if (i == AND) a = *sp++ &  a;\n    else if (i == EQ)  a = *sp++ == a;\n    else if (i == NE)  a = *sp++ != a;\n    else if (i == LT)  a = *sp++ <  a;\n    else if (i == GT)  a = *sp++ >  a;\n    else if (i == LE)  a = *sp++ <= a;\n    else if (i == GE)  a = *sp++ >= a;\n    else if (i == SHL) a = *sp++ << a;\n    else if (i == SHR) a = *sp++ >> a;\n    else if (i == ADD) a = *sp++ +  a;\n    else if (i == SUB) a = *sp++ -  a;\n    else if (i == MUL) a = *sp++ *  a;\n    else if (i == DIV) a = *sp++ /  a;\n    else if (i == MOD) a = *sp++ %  a;\n\n    else if (i == OPEN) a = open((char *)sp[1], *sp);\n    else if (i == READ) a = read(sp[2], (char *)sp[1], *sp);\n    else if (i == CLOS) a = close(*sp);\n    else if (i == PRTF) { t = sp + pc[1]; a = Bprint(out, (char *)t[-1], t[-2], t[-3], t[-4], t[-5], t[-6]); }\n    else if (i == MALC) a = (vlong)malloc(*sp);\n    else if (i == FREE) free((void *)*sp);\n    else if (i == MSET) a = (vlong)memset((char *)sp[2], sp[1], *sp);\n    else if (i == MCMP) a = memcmp((char *)sp[2], (char *)sp[1], *sp);\n    else if (i == EXIT) {\n    \tBprint(out, \"exit(%lld) cycle = %lld\\n\", *sp, cycle);\n    \tBflush(out);\n    \texits(nil); /* sprint status? */ \n    }\n    else { sysfatal(\"unknown instruction = %lld! cycle = %lld\\n\", i, cycle); }\n  }\n}\n", "source": "c4/c4.c", "file_type": "c"}
{"text": "</$objtype/mkfile\n\nBIN = $home/bin/$objtype\n\nTARG = c4\n\nOFILES = c4.$O \\\n\n</sys/src/cmd/mkone\n", "source": "c4/mkfile", "file_type": "mkfile"}
{"text": "//> Chunks of Bytecode common-h\n#ifndef clox_common_h\n#define clox_common_h\n\n#include <u.h>\n#include <libc.h>\n#include \"ints.h\"\n#include \"bools.h\"\n\n//> A Virtual Machine define-debug-trace\n\n//> Optimization define-nan-boxing\n#define NAN_BOXING\n//< Optimization define-nan-boxing\n//> Compiling Expressions define-debug-print-code\n#define DEBUG_PRINT_CODE\n//< Compiling Expressions define-debug-print-code\n#define DEBUG_TRACE_EXECUTION\n//< A Virtual Machine define-debug-trace\n//> Garbage Collection define-stress-gc\n\n#define DEBUG_STRESS_GC\n//< Garbage Collection define-stress-gc\n//> Garbage Collection define-log-gc\n#define DEBUG_LOG_GC\n//< Garbage Collection define-log-gc\n//> Local Variables uint8-count\n\n#define UINT8_COUNT (UINT8_MAX + 1)\n//< Local Variables uint8-count\n\n#endif\n//> omit\n// In the book, we show them defined, but for working on them locally,\n// we don't want them to be.\n#undef DEBUG_PRINT_CODE\n#undef DEBUG_TRACE_EXECUTION\n#undef DEBUG_STRESS_GC\n#undef DEBUG_LOG_GC\n//< omit\n", "source": "clox9/common.h", "file_type": "h"}
{"text": "</$objtype/mkfile\n\nBIN = /$objtype/bin\n\nTARG = clox\n\nOFILES = \\\n\t\tchunk.$O\t\\\n\t\tcompiler.$O\t\\\n\t\tdebug.$O\t\\\n\t\tmain.$O\t\t\\\n\t\tmemory.$O\t\\\n\t\tobject.$O\t\\\n\t\tscanner.$O\t\\\n\t\ttable.$O\t\\\n\t\tvalue.$O\t\\\n\t\tvm.$O\t\t\\\n\nHFILES = \\\n\t\tchunk.h\t\t\\\n\t\tcommon.h\t\\\n\t\tcompiler.h\t\\\n\t\tdebug.h\t\t\\\n\t\tmemory.h\t\\\n\t\tobject.h\t\\\n\t\tscanner.h\t\\\n\t\ttable.h\t\t\\\n\t\tvalue.h\t\t\\\n\t\tvm.h\t\t\\\n\n</sys/src/cmd/mkone\n", "source": "clox9/mkfile", "file_type": "mkfile"}
{"text": "#include <u.h>\n#include <libc.h>\n#include <thread.h>\n#include <draw.h>\n\n#include \"dat.h\"\n#include \"fncs.h\"\n\n/* Proc argument structs */\ntypedef struct {\n\tint outpipe;\n\tchar *file;\n\tChannel *cpid;\n} Decodearg;\n\ntypedef struct {\n\tint inpipe;\n\tChannel *ctl;\n} Writearg;\n\nvoid\ndecodeproc(void *arg)\n{\n\tDecodearg *a = arg;\n\tint nfd;\n\n\tnfd = open(\"/dev/null\", OREAD|OWRITE);\n\tdup(nfd, 0);\n\tdup(nfd, 2);\n\tdup(a->outpipe, 1);\n\tclose(nfd);\n\tclose(a->outpipe);\n\tprocexecl(a->cpid, \"/bin/play\", \"play\", \"-o\", \"/fd/1\", a->file, nil);\n}\n\nvoid\nwritethread(void *arg)\n{\n\tint afd;\n\tint bufsize;\n\tint n;\n\tenum cmsg msg;\n\tchar *buf;\n\t\n\tWritearg *a = arg;\n\tChannel *c = a->ctl;\n\tint inpipe = a->inpipe;\n\n\tafd = open(\"/dev/audio\", OWRITE);\n\tif(afd < 0)\n\t\tsysfatal(\"could not open audio device\");\n\tbufsize = iounit(afd);\n\t/*\n\t* On native plan9 installs this will return 0,\n\t* so we default to the default iosize.\n\t*/\n\tif(bufsize == 0)\n\t\tbufsize = 8192;\n\tbuf = emalloc(bufsize);\n\n\tfor(;;){\n\t\tif(nbrecv(c, &msg) != 0)\n\t\t\tswitch(msg){\n\t\t\tcase STOP:\n\t\t\t\tfree(buf);\n\t\t\t\tclose(afd);\n\t\t\t\tthreadexits(nil);\n\t\t\t\tbreak;\n\t\t\tcase PAUSE:\n\t\t\t\t/* Block until we get a START message */\n\t\t\t\twhile(msg != START)\n\t\t\t\t\trecv(c, &msg);\n\t\t\t\tbreak;\n\t\t\t}\n\t\tn = read(inpipe, buf, bufsize);\n\t\twrite(afd, buf, n);\n\t\tyield();\n\t}\n}\n\nenum{\n\tQUEUE,\n\tCTL,\n\tWAIT,\n};\n\nvoid\nctlproc(void *arg)\n{\n\tChannel **chans = arg;\n\tChannel *q = chans[0];\n\tChannel *c = chans[1];\n\tChannel *pop = chans[2];\n\tChannel *w = threadwaitchan();\n\tfree(chans);\n\n\tchar *path;\n\tenum cmsg msg;\n\tWaitmsg *wmsg;\n\n\tDecodearg a;\n\tWritearg wr;\n\tint p[2];\n\t/* This allows for the main thread to kill the decoder on exit */\n\textern int decpid = -1;\n\n\tAlt alts[] = {\n\t\t{q, &path, CHANRCV},\n\t\t{c, &msg,  CHANRCV},\n\t\t{w, &wmsg, CHANRCV},\n\t\t{nil, nil, CHANEND},\n\t};\n\n\tpipe(p);\n\n\ta.cpid = chancreate(sizeof(int), 0);\n\ta.outpipe = p[0];\n\n\twr.ctl = chancreate(sizeof(enum cmsg), 0);\n\twr.inpipe = p[1];\n\n\t/* Start first song to stop blocks on writethread read */\n\ta.file = recvp(q);\n\tprocrfork(decodeproc, &a, 8192, RFFDG);\n\trecv(a.cpid, &decpid);\n\tthreadcreate(writethread, &wr, 8192);\n\n\tfor(;;){\n\t\tswitch(alt(alts)){\n\t\t\tcase WAIT:\n\t\t\t\tif(strstr(wmsg->msg, \"eof\")){\n\t\t\t\t\tdecpid = -1;\n\t\t\t\t\tsend(pop, nil);\n\t\t\t\t}\n\t\t\t\tfree(wmsg);\n\t\t\t\tbreak;\n\t\t\tcase CTL:\n\t\t\t\tif(msg == NEXT){\n\t\t\t\t\tpostnote(PNGROUP, decpid, \"kill\");\n\t\t\t\t\tdecpid = -1;\n\t\t\t\t\tsend(pop, nil);\n\t\t\t\t}else\n\t\t\t\t\tsend(wr.ctl, &msg);\n\t\t\t\tbreak;\n\t\t\tcase QUEUE:\n\t\t\t\ta.file = path;\n\t\t\t\tif(decpid != -1)\n\t\t\t\t\tpostnote(PNGROUP, decpid, \"kill\");\n\t\t\t\tprocrfork(decodeproc, &a, 8192, RFFDG);\n\t\t\t\trecv(a.cpid, &decpid);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\ncleanup:\n\tif(decpid != -1)\n\t\tpostnote(PNGROUP, decpid, \"kill\");\n\tchanfree(wr.ctl);\n\tchanfree(a.cpid);\n\tclose(p[0]);\n\tclose(p[1]);\n\n}\n\n/*\n* Spawns the decoder processes.\n* q is a queue for next songs. chan char*\n* c is for sending control messages. chan enum cmsg\n* nil msg is sent over pop on song change.\n*/\nvoid\nspawndec(Channel **q, Channel **c, Channel **pop)\n{\n\tChannel **chans = emalloc(sizeof(Channel*) * 3);\n\n\tif(*q == nil)\n\t\t*q = chancreate(sizeof(char*), 0);\n\tif(*c == nil)\n\t\t*c = chancreate(sizeof(enum cmsg), 0);\n\tif(*pop == nil)\n\t\t*pop = chancreate(sizeof(char), 0);\n\n\tchans[0] = *q;\n\tchans[1] = *c;\n\tchans[2] = *pop;\n\n\tprocrfork(ctlproc, chans, 8192, RFFDG);\n}\n", "source": "mpl/dec.c", "file_type": "c"}
{"text": "#include <u.h>\n#include <libc.h>\n#include <thread.h>\n#include <draw.h>\n\n#include \"dat.h\"\n#include \"fncs.h\"\n\nint\nfile2song(Song *s, char *path, int needpic)\n{\n\tchar *dot;\n\tint fd;\n\n\ts->path = strdup(path);\n\n\tdot = strrchr(path, '.');\n\tif(dot == nil || *dot == '\\0')\n\t\treturn 0;\n\tdot+=1;\n\n\tif(strcmp(dot, \"flac\") == 0){\n\t\ts->type = FLAC;\n\t\tgoto done;\n\t}\n\tif(strcmp(dot, \"mp3\") == 0){\n\t\ts->type = MP3;\n\t\tgoto done;\n\t}\n\tif(strcmp(dot, \"ogg\") == 0){\n\t\ts->type = VORBIS;\n\t\tgoto done;\n\t}\n\t/* Unsupported file suffix */\n\treturn 0;\n\ndone:\n\tfd = open(path, OREAD);\n\tif(fd < 0)\n\t\treturn 0;\n\n\tswitch(s->type){\n\tcase FLAC:\n\t\ts->fmeta = readflacmeta(fd, needpic);\n\t\tbreak;\n\tcase MP3:\n\t\ts->idmeta = readid3v2(fd);\n\t\tif(s->idmeta == nil)\n\t\t\ts->idmeta = readid3(fd);\n\t\tbreak;\n\tcase VORBIS:\n\t\t/* TODO parse raw ogg file */\n\t\tbreak;\n\t}\n\tclose(fd);\n\t/* We can check the pointer without having to worry about which one it is */\n\tif(s->fmeta == nil)\n\t\treturn 0;\n\n\treturn 1;\n}\n\nint\nsongcmp(void *a, void *b)\n{\n\tSong *s1 = a;\n\tSong *s2 = b;\n\tint t1, t2;\n\tt1 = t2 = 0;\n\n\t//ID3 does not hold tracknumber so we assume all are equal\n\tif(s1->type == MP3 || s2->type == MP3)\n\t\treturn 0;\n\n\tswitch(s1->type){\n\tcase FLAC:\n\t\tt1 = s1->fmeta->tracknumber;\n\t\tbreak;\n\tcase VORBIS:\n\t\tt1 = s1->vmeta->tracknumber;\n\t\tbreak;\n\tdefault:\n\t\tsysfatal(\"bad type in songcmp\");\n\t}\n\n\tswitch(s2->type){\n\tcase FLAC:\n\t\tt2 = s2->fmeta->tracknumber;\n\t\tbreak;\n\tcase VORBIS:\n\t\tt2 = s2->vmeta->tracknumber;\n\t\tbreak;\n\tdefault:\n\t\tsysfatal(\"bad type in songcmp\");\n\t}\n\n\tif(t1 < t2)\n\t\treturn -1;\n\n\tif(t1 > t2)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nint\ndir2album(Album *a, char *path)\n{\n\tDir *files;\n\tint fd;\n\tlong n;\n\tlong i;\n\tRune *albumtitle;\n\tchar buf[512];\n\tint songcount = 0;\n\n\tfd = open(path, OREAD);\n\tif(fd < 0)\n\t\treturn 0;\n\n\tn = dirreadall(fd, &files);\n\tclose(fd);\n\tif(n <= 0)\n\t\treturn 0;\n\n\t/* Greedy alloc to start, we will trim down later */\n\ta->nsong = n;\n\ta->songs = emalloc(sizeof(Song) * n);\n\n\tfor(i=0;i<n;i++){\n\t\tsnprint(buf, 512, \"%s/%s\", path, files[i].name);\n\t\tif(!file2song(a->songs+songcount, buf, 0))\n\t\t\tcontinue;\n\t\tif(a->name == nil){\n\t\t\tswitch((a->songs+songcount)->type){\n\t\t\tcase FLAC:\n\t\t\t\talbumtitle = (a->songs+songcount)->fmeta->album;\n\t\t\t\tbreak;\n\t\t\tcase MP3:\n\t\t\t\talbumtitle = (a->songs+songcount)->idmeta->album;\n\t\t\t\tbreak;\n\t\t\tcase VORBIS:\n\t\t\t\talbumtitle = (a->songs+songcount)->vmeta->album;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\talbumtitle = nil;\n\t\t\t}\n\t\t\tif(albumtitle != nil)\n\t\t\t\ta->name = runesmprint(\"%S\",  albumtitle);\n\t\t}\n\t\tsongcount++;\n\t}\n\n\ta->nsong = songcount;\n\ta->songs = realloc(a->songs, sizeof(Song) * songcount);\n\n\tqsort(a->songs, songcount, sizeof(Song), songcmp);\n\n\tfree(files);\n\treturn 1;\n}\n\nint\nparselibrary(Album **als, char *path)\n{\n\tDir *files;\n\tint fd;\n\tuint n, i;\n\tuint numdirs = 0;\n\tuint alcount = 0;\n\tchar buf[1024];\n\n\tfd = open(path, OREAD);\n\tif(fd < 0)\n\t\treturn 0;\n\n\tn = dirreadall(fd, &files);\n\tclose(fd);\n\tif(n <= 0)\n\t\treturn 0;\n\n\tfor(i=0;i<n;i++)\n\t\tif(files[i].qid.type&QTDIR)\n\t\t\tnumdirs++;\n\n\t*als = emalloc(sizeof(Album)*numdirs);\n\tfor(i=0;i<n;i++)\n\t\tif(files[i].qid.type&QTDIR){\n\t\t\tsnprint(buf, 512, \"%s/%s\", path, files[i].name);\n\t\t\tdir2album(*als+alcount, buf);\n\t\t\tif(dir2album(*als+alcount, buf))\n\t\t\t\talcount++;\n\t\t}\n\n\t*als = realloc(*als, sizeof(Album)*alcount);\n\n\treturn alcount;\n}\n\nvoid\nfile2album(Album *a, Rune *aname, char *path)\n{\n\ta->name = runestrdup(aname);\n\ta->cover = nil;\n\ta->nsong = 1;\n\ta->songs = emalloc(sizeof(Song));\n\t/* As a special case for http streams */\n\tif(strstr(path, \"http\")==path){\n\t\ta->name = runesmprint(\"%s\", path);\n\t\ta->nocover = 1;\n\t\ta->songs->path = strdup(path);\n\t\ta->songs->title = runestrdup(aname);\n\t\ta->songs->type = RADIO;\n\t\treturn;\n\t}\n\tif(!file2song(a->songs, path, 0))\n\t\tsysfatal(\"Could not parse song %s\", path);\n}\n\nvoid\nradio2album(Album *a, char *path)\n{\n\ta->name = runesmprint(\"Radio\");\n\ta->cover = nil;\n\ta->nsong = 1;\n\ta->songs = emalloc(sizeof(Song));\n\ta->songs->type = RADIO;\n\ta->songs->title = nil;\n\ta->songs->path = strdup(path);\n}\n", "source": "mpl/dir.c", "file_type": "c"}
{"text": "#include <u.h>\n#include <libc.h>\n#include <bio.h>\n#include <thread.h>\n#include <draw.h>\n\n#include \"dat.h\"\n#include \"fncs.h\"\n\nChannel *queuein, *queueout, *decctl;\nChannel *radiochan;\nLib lib;\n\nchar*\nnextsong(Lib *lib)\n{\n\tif(lib->cursong < 0){\n\t\tlib->cur--;\n\t\tif(lib->cur < lib->start)\n\t\t\tlib->cur = lib->stop;\n\t\tlib->cursong = lib->cur->nsong-1;\n\t}\n\tif(lib->cursong > lib->cur->nsong-1){\n\t\tlib->cur++;\n\t\tif(lib->cur > lib->stop)\n\t\t\tlib->cur = lib->start;\n\t\tlib->cursong = 0;\n\t}\n\treturn (lib->cur->songs+(lib->cursong))->path;\n}\n\nvoid\nhandlemsg(enum cmsg msg)\n{\n\tswitch(msg){\n\tcase NEXT:\n\t\tlib.cursong++;\n\t\tsendp(queuein, nextsong(&lib));\n\t\tbreak;\n\tcase PREV:\n\t\tlib.cursong--;\n\t\tsendp(queuein, nextsong(&lib));\n\t\tbreak;\n\tcase STOP:\n\tcase START:\n\tcase PAUSE:\n\t\tsend(decctl, &msg);\n\t\tbreak;\t\n\t}\n}\n\nvoid\nlibproc(void *arg)\n{\n\tChannel **chans = arg;\n\tChannel *lctl = chans[0];\n\tChannel *out = chans[1];\n\tChannel *ein = chans[2];\n\tChannel *redraw = chans[3];\n\tChannel *loadc = chans[4];\n\tfree(chans);\n\n\tenum cmsg msg;\n\tClick c;\n\n\tchar *radiotitle = nil;\n\tchar *toload;\n\n\tAlt alts[] = {\n\t\t{lctl, &msg, CHANRCV},\n\t\t{queueout, nil, CHANRCV},\n\t\t{ein, &c, CHANRCV},\n\t\t{out, &lib, CHANSND},\n\t\t{radiochan, &radiotitle, CHANRCV},\n\t\t{loadc,\t&toload, CHANRCV},\n\t\t{nil, nil, CHANEND},\n\t};\n\tenum{\n\t\tLMSG,\n\t\tQUEUEPOP,\n\t\tEIN,\n\t\tOUT,\n\t\tRADIOIN,\n\t\tLOADC,\n\t};\n\n\tfor(;;){\n\t\tswitch(alt(alts)){\n\t\tcase LMSG:\n\t\t\tif(msg == DUMP){\n\t\t\t\t/* TODO: rename chan to imply this use */\n\t\t\t\ttoload = recvp(loadc);\n\t\t\t\tfree(lib.name);\n\t\t\t\tlib.name = strdup(toload);\n\t\t\t\tdumplib(&lib);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\thandlemsg(msg);\n\t\t\tbreak;\n\t\tcase QUEUEPOP:\n\t\t\thandlemsg(NEXT);\n\t\t\tbreak;\n\t\tcase EIN:\n\t\t\tswitch(c.type){\n\t\t\tcase CSONG:\n\t\t\t\tlib.cur = c.a;\n\t\t\t\tlib.cursong = c.songnum;\n\t\t\t\tsendp(queuein, nextsong(&lib));\n\t\t\t\tbreak;\n\t\t\tcase CLIST:\n\t\t\t\t//TODO clean more\n\t\t\t\tfree(lib.name);\n\t\t\t\tlib.name = strdup(c.list);\n\t\t\t\tgoto Load;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OUT:\n\t\t\tcontinue;\n\t\tcase RADIOIN:\n\t\t\t/* Eat everything in the channel;\n\t\t\t * This leaks memory,\n\t\t\t * but fixes a race.\n\t\t\t * TODO: Find a better fix.\n\t\t\t */\n\t\t\twhile(nbrecv(radiochan, &radiotitle))\n\t\t\t\t;\n\t\t\tif(lib.cur->songs->title != nil)\n\t\t\t\tfree(lib.cur->songs->title);\n\t\t\tlib.cur->songs->title = runesmprint(\"%s\", radiotitle);\n\t\t\tfree(radiotitle);\n\t\t\tbreak;\n\t\tcase LOADC:\n\t\t\t//TODO: clean more\n\t\t\tfree(lib.name);\n\t\t\tlib.name = strdup(toload);\nLoad:\n\t\t\tloadlib(&lib);\n\t\t\tlib.stop = lib.start+(lib.nalbum-1);\n\t\t\tlib.cursong = 0;\n\t\t\tlib.cur = lib.start;\n\t\t\tbreak;\n\t\t}\n\t\tsend(redraw, nil);\n\t}\n}\n\nvoid\nradioproc(void *arg)\n{\n\tchar *path = arg;\n\tchar buf[512];\n\tchar *dot, *end;\n\tBiobuf *b;\n\n\tdot = strrchr(path, '/');\n\tif(dot == nil)\n\t\tsysfatal(\"readradiosong: bad song path\");\n\tend = buf+(dot-path)+1;\n\tif(end - buf > sizeof buf)\n\t\tsysfatal(\"readradiosong: buffer too small\");\n\tseprint(buf, end, \"%s\", path);\n\tsnprint(buf, 512, \"%s/playing\", buf);\n\tfree(path);\n\tb = Bopen(buf, OREAD);\n\tif(b == nil)\n\t\tsysfatal(\"readradiosong: Bopen %r\");\n\tfor(;;){\n\t\tpath = Brdstr(b, '\\n', 1);\n\t\tsendp(radiochan, path);\n\t}\n}\n\nvoid\nspawnlib(Channel *ctl, Channel *out, Channel *ein, Channel *redraw, Channel *loadc, char *path)\n{\n\tChannel **chans;\n\tchar *name;\n\n\tqueuein = queueout = decctl = nil;\n\tradiochan = nil;\n\n\tspawndec(&queuein, &decctl, &queueout);\n\tradiochan = chancreate(sizeof(char*), 1024);\n\n\tname = strrchr(path, '/');\n\tlib.name = strdup(name == nil ? path : name);\n\n\textern int mflag;\n\textern int sflag;\n\textern int rflag;\n\textern int pflag;\n\textern int fflag;\n\n\tif(mflag == 1){\n\t\tchanclose(radiochan);\n\t\tlib.nalbum = parselibrary(&(lib.start), path);\n\t\tif(lib.nalbum == 0)\n\t\t\tsysfatal(\"no songs found\");\n\t\tlib.stop = lib.start+(lib.nalbum-1);\n\t}else if(sflag == 1){\n\t\tchanclose(radiochan);\n\t\tlib.nalbum = 1;\n\t\tlib.start = emalloc(sizeof(Album));\n\t\tif(!dir2album(lib.start, path))\n\t\t\tsysfatal(\"no songs found\");\n\t\tlib.stop = lib.start;\n\t}else if(rflag == 1){\n\t\tlib.nalbum = 1;\n\t\tlib.start = emalloc(sizeof(Album));\n\t\tlib.stop = lib.start;\n\t\tradio2album(lib.start, path);\n\t\tproccreate(radioproc, strdup(path), 8192);\n\t}else if(pflag == 1){\n\t\tchanclose(radiochan);\n\t\tloadlib(&lib);\n\t\tlib.stop = lib.start+(lib.nalbum-1);\n\t}else if(fflag == 1){\n\t\tlib.nalbum = 1;\n\t\tlib.start = emalloc(sizeof(Album));\n\t\tlib.stop = lib.start;\n\t\tfile2album(lib.start, L\"\", path);\n\t}\n\n\tlib.cursong = 0;\n\tlib.cur = lib.start;\n\tif(lib.cur->nsong == 0)\n\t\tsysfatal(\"No songs found\");\n\n\tchans = emalloc(sizeof(Channel*)*5);\n\tchans[0] = ctl;\n\tchans[1] = out;\n\tchans[2] = ein;\n\tchans[3] = redraw;\n\tchans[4] = loadc;\n\n\tsendp(queuein, nextsong(&lib));\n\tthreadcreate(libproc, chans, 8192);\n}\n", "source": "mpl/lib.c", "file_type": "c"}
{"text": "#include <u.h>\n#include <libc.h>\n#include <thread.h>\n#include <draw.h>\n\n#include \"dat.h\"\n#include \"fncs.h\"\n\n/* If we can't read the tag, at least default to file names */\nvoid\nfillnotag(ID3v1 *id, int fd)\n{\n\tchar buf[512];\n\tchar *slash, *dot;\n\tfd2path(fd, buf, 512);\n\tslash = strrchr(buf, '/');\n\tdot = strrchr(buf, '.');\n\t*dot = '\\0';\n\tid->title = runesmprint(\"%s\", slash+1);\n}\n\n/* The following function is stolen from https://git.sr.ht/~ft/libtags/ */\n#define synchsafe(d) (uint)(((d)[0]&127)<<21 | ((d)[1]&127)<<14 | ((d)[2]&127)<<7 | ((d)[3]&127)<<0)\n#define beuint(d) (uint)((d)[0]<<24 | (d)[1]<<16 | (d)[2]<<8 | (d)[3]<<0)\n\nID3v1*\nreadid3v2(int fd)\n{\n\tint sz, framesz;\n\tint ver;\n\tchar nu[8];\n\tuchar d[10];\n\tuchar buf[256];\n\tID3v1 *id;\n\n\tread(fd, d, sizeof d);\n\n\tver = d[3];\n\tsz = synchsafe(&d[6]);\n\n\tif(ver == 2 && (d[5] & (1<<6)) != 0) /* compression */\n\t\treturn nil;\n\n\tif(ver > 2){\n\t\tif((d[5] & (1<<4)) != 0) /* footer */\n\t\t\tsz -= 10;\n\t\tif((d[5] & (1<<6)) != 0){ /* we don't do extended header */\n\t\t\treturn nil;\n\t\t}\n\t}\n\n\tframesz = (ver >= 3) ? 10 : 6;\n\n\tid = emalloc(sizeof(ID3v1));\n\tid->title = id->album = nil;\n\tfor(; sz > framesz;){\n\t\tint tsz;\n\n\t\tread(fd, d, framesz);\n\t\tsz -= framesz;\n\n\t\tif(memcmp(d, \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", framesz) == 0)\n\t\t\tbreak;\n\n\t\tif(ver >= 3){\n\t\t\ttsz = (ver == 3) ? beuint(&d[4]) : synchsafe(&d[4]);\n\t\t\tif(tsz < 0 || tsz > sz)\n\t\t\t\tbreak;\n\n\t\t\td[4] = 0;\n\n\t\t\tif((d[9] & 0x0c) != 0){ /* compression & encryption */\n\t\t\t\treturn nil;\n\t\t\t}\n\t\t}else{\n\t\t\ttsz = beuint(&d[3]) >> 8;\n\t\t\tif(tsz > sz)\n\t\t\t\treturn nil;\n\t\t\td[3] = 0;\n\t\t}\n\t\tsz -= tsz;\n\n\t\tif(memcmp(d, \"TIT2\", 4) == 0){\n\t\t\tread(fd, nu, 1);\n\t\t\tswitch(nu[0]){\n\t\t\tcase 3:\n\t\t\t\tid->title = emalloc(sizeof(Rune)*tsz);\n\t\t\t\tread(fd, buf, tsz-1);\n\t\t\t\trunesprint(id->title, \"%s\", (char*)buf);\n\t\t\t}\n\t\t}else if(memcmp(d, \"TALB\", 4) == 0){\n\t\t\tread(fd, nu, 1);\n\t\t\tswitch(nu[0]){\n\t\t\tcase 3:\n\t\t\t\tid->album = emalloc(sizeof(Rune)*tsz);\n\t\t\t\tread(fd, buf, tsz-1);\n\t\t\t\trunesprint(id->album, \"%s\", (char*)buf);\n\t\t\t}\n\t\t}\n\t}\n\n\tif(id->title == nil || id->album == nil)\n\t\treturn nil;\n\n\treturn id;\n}\n\nID3v1*\nreadid3(int fd)\n{\n\tDir *d;\n\tID3v1 *id;\n\tchar buf[128];\n\tchar fieldbuf[31];\n\tint length;\n\n\td = dirfstat(fd);\n\tif(d == nil)\n\t\treturn nil;\n\tlength = d->length;\n\tfree(d);\n\n\tif(pread(fd, buf, 128, length-128) != 128)\n\t\treturn nil;\n\n\tid = emalloc(sizeof(ID3v1));\n\tif(memcmp(buf, \"TAG\", 3) != 0){\n\t\tfillnotag(id, fd);\n\t\treturn id;\n\t}\n\n\tmemcpy(fieldbuf, buf+3, 30);\n\tfieldbuf[30] = '\\0';\n\tid->title = emalloc(sizeof(Rune) * 31);\n\trunesprint(id->title, \"%s\", fieldbuf);\n\n\tmemcpy(fieldbuf, buf+33, 30);\n\tid->artist = emalloc(sizeof(Rune) * 31);\n\trunesprint(id->artist, \"%s\", fieldbuf);\n\n\tmemcpy(fieldbuf, buf+63, 30);\n\tid->album = emalloc(sizeof(Rune) * 31);\n\trunesprint(id->album, \"%s\", fieldbuf);\n\n\tmemcpy(fieldbuf, buf+93, 4);\n\tfieldbuf[4] = '\\0';\n\tid->year = atoi(fieldbuf);\n\n\tmemcpy(fieldbuf, buf+97, 30);\n\tfieldbuf[30] = '\\0';\n\tid->comment = emalloc(sizeof(Rune) * 31);\n\trunesprint(id->comment, \"%s\", fieldbuf);\n\n\tid->genre = buf[127];\n\t\n\treturn id;\n}\n\nvoid\ndestroyid3(ID3v1 *id)\n{\n\tfree(id->title);\n\tfree(id->artist);\n\tfree(id->album);\n\tfree(id->comment);\n\tfree(id);\n}\n\n", "source": "mpl/id3.c", "file_type": "c"}
{"text": "#include <u.h>\n#include <libc.h>\n#include <thread.h>\n#include <draw.h>\n\n#include \"dat.h\"\n#include \"fncs.h\"\n\n/* Malloc and memset to 0, quit gracefully on error */\nvoid*\nemalloc(vlong size)\n{\n\tvoid *v = malloc(size);\n\tif(v == nil)\n\t\tquit(\"Out of memory\");\n\tsetmalloctag(v, getcallerpc(&size));\n\tv = memset(v, 0, size);\n\treturn v;\n}\n\n/*\n* Unmarshal LSB ordered buffer into unsigned int\n* https://commandcenter.blogspot.com/2012/04/byte-order-fallacy.html\n*/\nu64int\nlebtoi(uchar *buf, int nbyte)\n{\n\tint i;\n\tu64int out = 0;\n\tfor(i=0;i<nbyte;i++)\n\t\tout = out | buf[i]<<(i*8);\n\treturn out;\n}\n\n/* Unmarshal MSB ordered buffer into unsigned int */\nu64int\nbebtoi(uchar *buf, int nbyte)\n{\n\tint i;\n\tint n = nbyte;\n\tu64int out = 0;\n\tfor(i=0;i<nbyte;i++)\n\t\tout = out | buf[i]<<(--n*8);\n\treturn out;\n}\n\nvoid\nkill(int pid)\n{\n\tint nfd;\n\tchar *note = smprint( \"/proc/%d/note\", pid);\n\tnfd = open(note, OWRITE);\n\tif(nfd<0)\n\t\tsysfatal(\"proc doesn't exist\");\n\tif(write(nfd, \"kill\", 4)!=4)\n\t\tsysfatal(\"could not write to note\");\n\tclose(nfd);\n\tfree(note);\n}\n\nint\nrunecstrcmp(Rune *s1, Rune *s2)\n{\n\tRune c1, c2;\n\n\tfor(;;) {\n\t\tc1 = tolowerrune(*s1++);\n\t\tc2 = tolowerrune(*s2++);\n\t\tif(c1 != c2) {\n\t\t\tif(c1 > c2)\n\t\t\t\treturn 1;\n\t\t\treturn -1;\n\t\t}\n\t\tif(c1 == 0)\n\t\t\treturn 0;\n\t}\n}\n", "source": "mpl/util.c", "file_type": "c"}
{"text": "#include <u.h>\n#include <libc.h>\n#include <thread.h>\n#include <draw.h>\n#include <mouse.h>\n\n#include \"dat.h\"\n#include \"fncs.h\"\n\nClick click[128];\nClick *next;\nint size;\n\nenum{\n\tMIN,\n\tCIN,\n\tROLL,\n};\n\nClick*\nfindpoint(Point xy)\n{\n\tint i;\n\tfor(i=0;i<size;i++)\n\t\tif(ptinrect(xy, click[i].r))\n\t\t\treturn click+i;\n\treturn nil;\n}\n\nvoid\neventthread(void *arg)\n{\n\tMouse m;\n\tClick c;\n\tChannel **chans = arg;\n\tChannel *min = chans[0];\n\tChannel *cin = chans[1];\n\tChannel *out = chans[2];\n\tChannel *roll = chans[3];\n\tfree(chans);\n\n\tAlt alts[] = {\n\t\t{min, &m, CHANRCV},\n\t\t{cin, &c, CHANRCV},\n\t\t{roll, nil, CHANRCV},\n\t\t{nil, nil, CHANEND},\n\t};\n\tfor(;;)\n\t\tswitch(alt(alts)){\n\t\tcase CIN:\n\t\t\tsize++;\n\t\t\tassert(size < 128);\n\t\t\tclick[size] = c;\n\t\t\tbreak;\n\t\tcase MIN:\n\t\t\tif(m.buttons != 1)\n\t\t\t\tcontinue;\n\t\t\tnext = findpoint(m.xy);\n\t\t\tif(next != nil)\n\t\t\t\tsend(out, next);\n\t\t\tbreak;\n\t\tcase ROLL:\n\t\t\tsize = 0;\n\t\t\tbreak;\n\t\t}\n}\n\nvoid\nspawnevent(Channel *min, Channel *cin, Channel *out, Channel *rollback)\n{\n\tChannel **chans;\n\tsize = 0;\n\tchans = emalloc(sizeof(Channel*)*4);\n\tchans[0] = min;\n\tchans[1] = cin;\n\tchans[2] = out;\n\tchans[3] = rollback;\n\tthreadcreate(eventthread, chans, 8192);\n}\n\n", "source": "mpl/event.c", "file_type": "c"}
{"text": "</$objtype/mkfile\nBIN=$home/bin/$objtype\nTARG=mpl\nOFILES=\\\n\tmpl.$O \\\n\tdec.$O \\\n\tutil.$O \\\n\tid3.$O \\\n\tflac.$O \\\n\tvorbis.$O \\\n\tdraw.$O \\\n\tdir.$O \\\n\tdat.$O \\\n\tlib.$O \\\n\tvol.$O \\\n\tevent.$O \\\n\tindex.$O \\\n\tlist.$O \\\n\n\n</sys/src/cmd/mkone\n", "source": "mpl/mkfile", "file_type": "mkfile"}
{"text": "#include <u.h>\n#include <libc.h>\n#include <thread.h>\n#include <draw.h>\n\n#include \"dat.h\"\n#include \"fncs.h\"\n\nuvlong\nstring2hash(char *s)\n{\n\tuvlong hash;\n\thash = 7;\n\tfor(;*s;s++)\n\t\thash = hash*31 + *s;\n\treturn hash;\n}\n\nHmap*\nallocmap(int size)\n{\n\tHmap *h = emalloc(sizeof(Hmap));\n\th->size = size;\n\th->nodes = emalloc(sizeof(Hnode)*size);\n\treturn h;\n}\n\nvoid\nmapinsert(Hmap *h, char *key, void *val)\n{\n\tHnode *n;\n\n\twlock(h);\n\tn = h->nodes+(string2hash(key)%h->size);\n\tassert(n != nil);\n\tfor(;;){\n\t\tif(n->key == nil)\n\t\t\tgoto empty;\n\t\tif(strcmp(key, n->key) == 0)\n\t\t\tgoto found;\n\t\tif(n->next == nil)\n\t\t\tbreak;\n\t\tn = n->next;\n\t}\n\n\t/* create new node */\n\tn->next = emalloc(sizeof(Hnode));\n\tn = n->next;\n\nempty:\n\tn->key = strdup(key);\n\nfound:\n\tn->val = val;\n\n\twunlock(h);\n}\n\nvoid*\nmapget(Hmap *h, char *key)\n{\n\tHnode *n;\n\n\trlock(h);\n\tn = h->nodes+(string2hash(key)%h->size);\n\tfor(;n!=nil;n=n->next){\n\t\tif(n->key == nil)\n\t\t\tcontinue;\n\t\tif(strcmp(key, n->key) == 0){\n\t\t\trunlock(h);\n\t\t\treturn n->val;\n\t\t}\n\t}\n\n\trunlock(h);\n\treturn nil;\n}\n\nint\nmapdel(Hmap *h, char *key)\n{\n\tHnode *n;\n\twlock(h);\n\tn = h->nodes+(string2hash(key)%h->size);\n\tfor(;n!=nil;n=n->next){\n\t\tif(n->key == nil)\n\t\t\tcontinue;\n\t\tif(strcmp(key, n->key) == 0){\n\t\t\tfree(n->key);\n\t\t\tn->key = nil;\n\t\t\twunlock(h);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\twunlock(h);\n\treturn 0;\n}\n\nint\nmapdump(Hmap *h, void **buf, int size)\n{\n\tHnode *n;\n\tint i, c;\n\n\trlock(h);\n\tfor(i=c=0;i<h->size;i++)\n\t\tfor(n=h->nodes+i;n!=nil && n->key!=nil;n=n->next){\n\t\t\tif(c >= size)\n\t\t\t\tgoto done;\n\t\t\tbuf[c++] = n->val;\n\t\t}\ndone:\n\trunlock(h);\n\treturn c;\n}\n\nint\nmapdumpkey(Hmap *h, char **buf, int size)\n{\n\tHnode *n;\n\tint i, c;\n\n\trlock(h);\n\tfor(i=c=0;i<h->size;i++)\n\t\tfor(n=h->nodes+i;n!=nil && n->key!=nil;n=n->next){\n\t\t\tif(c >= size)\n\t\t\t\tgoto done;\n\t\t\tbuf[c++] = n->key;\n\t\t}\ndone:\n\trunlock(h);\n\treturn c;\n}\n\nvoid\nmapclear(Hmap *h)\n{\n\tHnode *n;\n\tint i;\n\n\twlock(h);\n\tfor(i=0;i<h->size;i++)\n\t\tfor(n=h->nodes+i;n!=nil;n=n->next)\n\t\t\tif(n->key != nil){\n\t\t\t\tfree(n->key);\n\t\t\t\tn->key=nil;\n\t\t\t}\n\twunlock(h);\n}\n\nvoid\nfreemap(Hmap *h)\n{\n\tmapclear(h);\n\tfree(h->nodes);\n\tfree(h);\n}\n", "source": "mpl/dat.c", "file_type": "c"}
{"text": "#include <u.h>\n#include <libc.h>\n#include <bio.h>\n#include <thread.h>\n#include <draw.h>\n\n#include \"dat.h\"\n#include \"fncs.h\"\n\nvoid\ndumpalbum(int fd, Album *a)\n{\n\tint i;\n\tchar nl = '\\n';\n\tchar buf[128];\n\tint n = snprint(buf, 128, \"%S\", a->name);\n\n\twrite(fd, buf, n);\n\twrite(fd, &nl, 1);\n\n\tfor(i=0;i<a->nsong;i++){\n\t\twrite(fd, a->songs[i].path, strlen(a->songs[i].path));\n\t\twrite(fd, &nl, 1);\n\t}\n}\n\nvoid\nlibdir(char *buf, int n)\n{\n\tchar *home;\n\tint s;\n\thome = getenv(\"home\");\n\ts = snprint(buf, n, \"%s/lib/mpl\", home);\n\tbuf[s] = '\\0';\n\tfree(home);\n}\n\nvoid\ncreatelibdir(char *path)\n{\n\tint fd;\n\tfd = open(path, OREAD);\n\tif(fd>0){\n\t\tclose(fd);\n\t\treturn;\n\t}\n\tfd = create(path, OREAD, DMDIR|0755);\n\tif(fd<0)\n\t\tsysfatal(\"could not create lib dir: %r\");\n\tclose(fd);\n}\n\nvoid\ndumplib(Lib *l)\n{\n\tint fd;\n\tint i;\n\tchar buf[512];\n\tchar fname[512];\n\tchar sep[] = \"\\n\\n\";\n\n\tlibdir(buf, 512);\n\tassert(l->name != nil);\n\tcreatelibdir(buf);\n\ti = snprint(fname, 512, \"%s/%s.list\", buf, l->name);\n\tfname[i] = '\\0';\n\tfd = create(fname, ORDWR, 0644);\n\tif(fd<0){\n\t\tfprint(2, \"Could not create list file: %r\\n\");\n\t\tquit(nil);\n\t}\n\tfor(i=0;i<l->nalbum;i++){\n\t\tdumpalbum(fd, l->start+i);\n\t\twrite(fd, sep, sizeof sep - 1);\n\t}\n\tclose(fd);\n\tsnprint(fname, 512, \"%s/%s.db\", buf, l->name);\n\tfd = create(fname, ORDWR, 0644);\n\tif(fd<0){\n\t\tfprint(2, \"Count not create list db file: %r\");\n\t\tquit(nil);\n\t}\n\tmarshallib(fd, l);\n\tclose(fd);\n}\n\nvoid\nloadalbum(Biobuf *b, Album *a)\n{\n\tint size, cap;\n\tchar *dot;\n\tdot = Brdstr(b, '\\n', 1);\n\tif(dot == nil){\n\t\treturn;\n\t}\n\ta->name = runesmprint(\"%s\", dot);\n\tfree(dot);\n\n\tcap = 10;\n\ta->songs = emalloc(sizeof(Song)*cap);\n\tfor(size=0;(dot = Brdstr(b, '\\n', 1));size++){\n\t\tif(strlen(dot) == 0){\n\t\t\tfree(dot);\n\t\t\tbreak;\n\t\t}\n\t\tif(size == cap-1){\n\t\t\tcap = cap * 2;\n\t\t\ta->songs = realloc(a->songs, sizeof(Song)*cap);\n\t\t}\n\t\tif(file2song(a->songs+size, dot, 0) == 0)\n\t\t\tsysfatal(\"Could not parse song %s\", dot);\n\t}\n\n\ta->songs = realloc(a->songs, sizeof(Song)*size);\n\ta->nsong = size;\n\ta->cover = nil;\n\treturn;\n}\n\nvoid\nloadlib(Lib *l)\n{\n\tBiobuf *b;\n\tchar buf[512];\n\tchar fname[512];\n\tint size, cap;\n\tint fd;\n\tlong r;\n\tstatic Hmap *cache = nil;\n\tLib *new;\n\tLib *prev;\n\n\tassert(l->name != nil);\n\tif(cache == nil)\n\t\tcache = allocmap(32);\n\n\tif((prev = mapget(cache, l->name)) != nil){\n\t\t*l = *prev;\n\t\treturn;\n\t}\n\n\tnew = emalloc(sizeof(Lib));\n\n\tlibdir(buf, 512);\n\t/* Check for db cache file first */\n\tsnprint(fname, 512, \"%s/%s.db\", buf, l->name);\n\tif((fd = open(fname, OREAD))>0){\n\t\tunmarshallib(fd, new);\n\t\tclose(fd);\n\t\tmapinsert(cache, l->name, new);\n\t\t*l = *new;\n\t\treturn;\n\t}\n\n\tsnprint(fname, 512, \"%s/%s.list\", buf, l->name);\n\tb = Bopen(fname, OREAD);\n\tif(b == nil){\n\t\tfprint(2, \"Could not open list file: %s\\n\", fname);\n\t\tquit(nil);\n\t}\n\tcap = 10;\n\tnew->start = emalloc(sizeof(Album)*cap);\n\tfor(size = 0;(r = Bgetrune(b)) > 0;size++){\n\t\tif(size == cap-1){\n\t\t\tcap = cap * 2;\n\t\t\tnew->start = realloc(new->start, sizeof(Album)*cap);\n\t\t}\n\t\tif(r != L'\\n'){\n\t\t\tBungetrune(b);\n\t\t}\n\t\t(new->start+size)->name = nil;\n\t\tloadalbum(b, new->start+size);\n\t}\n\tif((new->start+size)->name == nil){\n\t\tsize--;\n\t}\n\tclose(Bfildes(b));\n\tfree(b);\n\tnew->start = realloc(new->start, sizeof(Album)*size);\n\tnew->nalbum = size;\n\tmapinsert(cache, l->name, new);\n\t*l = *new;\n}\n", "source": "mpl/list.c", "file_type": "c"}
{"text": "#include <u.h>\n#include <libc.h>\n#include <thread.h>\n#include <draw.h>\n\n#include \"dat.h\"\n#include \"fncs.h\"\n\ntypedef struct{\n\tint fd;\n\tuvlong size;\n\tuchar *data;\n} WriteArg;\n\nvoid\npicwriteproc(void *arg)\n{\n\tint i, n;\n\tWriteArg *a = arg;\n\tint fd = a->fd;\n\tuchar *data = a->data;\n\tuvlong towrite = a->size;\n\n\tfree(a);\n\tfor(i = 0;towrite>0;){\n\t\tn = write(fd, data+i, towrite);\n\t\ti+=n;\n\t\ttowrite-=n;\n\t}\n\tclose(fd);\n}\n\ntypedef struct{\n\tint fdin;\n\tint fdout;\n\tChannel *cpid;\n\tchar *cmd;\n} ExecArg;\n\nvoid\npicexecproc(void *arg)\n{\n\tExecArg *a = arg;\n\tdup(a->fdin, 0);\n\tdup(a->fdout, 1);\n\tprocexecl(a->cpid, a->cmd, a->cmd, \"-9\", nil);\n}\n\nvoid\npicresizeproc(void *arg)\n{\n\tExecArg *a = arg;\n\tdup(a->fdin, 0);\n\tdup(a->fdout, 1);\n\tprocexecl(a->cpid, \"/bin/resize\", \"resize\", \"-x\", \"256\", \"-y\", \"256\", nil);\n}\n\nchar*\nmime2bin(char *mime)\n{\n\tchar *start = strchr(mime, '/');\n\tif(start!=nil)\n\t\tstart+=1;\n\telse\n\t\tstart = mime;\n\n\tif(strcmp(start, \"png\") == 0)\n\t\treturn strdup(\"/bin/png\");\n\tif(strcmp(start, \"jpeg\") == 0 || strcmp(start, \"jpg\") == 0)\n\t\treturn strdup(\"/bin/jpg\");\n\n\treturn nil;\n}\n\nImage*\nconvpic(int fd, char *mime)\n{\n\tExecArg *e;\n\tImage *i;\n\tint convout[2];\n\tint resize[2];\n\n\tpipe(convout);\n\tpipe(resize);\n\n\te = emalloc(sizeof(ExecArg));\n\te->cpid = chancreate(sizeof(int), 0);\n\te->fdin = fd;\n\te->fdout = convout[0];\n\te->cmd = mime2bin(mime);\n\tprocrfork(picexecproc, e, 8192, RFFDG);\n\trecv(e->cpid, nil);\n\tchanfree(e->cpid);\n\tfree(e->cmd);\n\n\te->cpid = chancreate(sizeof(int), 0);\n\te->fdin = convout[1];\n\te->fdout = resize[0];\n\tprocrfork(picresizeproc, e, 8192, RFFDG);\n\trecv(e->cpid, nil);\n\tchanfree(e->cpid);\n\tfree(e);\n\n\ti = readimage(display, resize[1], 0);\n\tclose(convout[0]);\n\tclose(convout[1]);\n\tclose(resize[0]);\n\tclose(resize[1]);\n\n\treturn i;\n}\n\nImage*\nconvpicbuf(uchar *buf, uvlong size, char *mime)\n{\n\tWriteArg *w;\n\tint p[2];\n\tImage *i;\n\n\tpipe(p);\n\n\tw = emalloc(sizeof(WriteArg));\n\tw->fd = p[0];\n\tw->data = buf;\n\tw->size = size;\n\tprocrfork(picwriteproc, w, 8192, RFFDG);\n\t/* other proc frees w */\n\n\ti = convpic(p[1], mime);\n\n\tclose(p[0]);\n\tclose(p[1]);\n\n\treturn i;\n}\n\nImage*\nreadcover(Song *s)\n{\n\tchar buf[512], cover[512];\n\tchar *dot, *end;\n\tint fd, n, i;\n\tDir *files;\n\tImage *im;\n\n\tdot = strrchr(s->path, '/');\n\tif(dot == nil)\n\t\tsysfatal(\"readcover: bad song path\");\n\tend = buf+(dot-s->path)+1;\n\tif(end - buf >= sizeof buf)\n\t\tsysfatal(\"readcover: buffer too small\");\n\tseprint(buf, end, \"%s\", s->path);\n\n\tfd = open(buf, OREAD);\n\tif(fd < 0)\n\t\tsysfatal(\"readcover: %r\");\n\tn = dirreadall(fd, &files);\n\tclose(fd);\n\tif(n <= 0)\n\t\tsysfatal(\"readcover: no files in dir\");\n\n\tfor(i=0;i<n;i++){\n\t\tdot = cistrstr(files[i].name, \"cover.\");\n\t\tif(dot == nil){\n\t\t\tdot = cistrstr(files[i].name, \"folder.\");\n\t\t\tif(dot == nil)\n\t\t\t\tcontinue;\n\t\t}\n\t\tdot = strrchr(dot, '.');\n\t\tdot++;\n\t\tsnprint(cover, 512, \"%s/%s\", buf, files[i].name);\n\t\tfd = open(cover, OREAD);\n\t\tif(fd<0)\n\t\t\tcontinue;\n\t\tim = convpic(fd, dot);\n\t\tclose(fd);\n\t\treturn im;\n\t}\n\treturn nil;\n}\n\nPoint\ndrawalbum(Album *a, Image *textcolor, Image *active, Point start, int cursong, Channel *clickout)\n{\n\tuint i;\n\tFont *f = screen->display->defaultfont;\n\tRune *tracktitle = nil;\n\tPoint p = start;\n\tClick c;\n\n\tif(a->nocover == 0 && a->cover == nil)\n\t\tif((a->cover = readcover(a->songs)) == nil)\n\t\t\ta->nocover = 1; /* Don't search again */\n\n\tif(a->cover != nil){\n\t\tdraw(screen, Rpt(p, addpt(p, a->cover->r.max)), a->cover, nil, ZP);\n\t\tp.x += a->cover->r.max.x;\n\t}\n\n\trunestring(screen, p, textcolor, ZP, f, a->name);\n\tp.y += f->height * 2;\n\n\tfor(i=0;i<a->nsong;i++){\n\t\tswitch((a->songs+i)->type){\n\t\tcase FLAC:\n\t\t\ttracktitle = (a->songs+i)->fmeta->title;\n\t\t\tbreak;\n\t\tcase MP3:\n\t\t\ttracktitle = (a->songs+i)->idmeta->title;\n\t\t\tbreak;\n\t\tcase VORBIS:\n\t\t\ttracktitle = (a->songs+i)->vmeta->title;\n\t\t\tbreak;\n\t\tcase RADIO:\n\t\t\ttracktitle = (a->songs+i)->title;\n\t\t\tif(tracktitle == nil)\n\t\t\t\treturn start;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsysfatal(\"Unknown song type\");\n\t\t}\n\t\trunestring(screen, p, i == cursong ? active : textcolor, ZP, f, tracktitle);\n\t\tc.r = Rpt(p, Pt(p.x+runestrlen(tracktitle)*f->width,p.y+f->height));\n\t\tc.a = a;\n\t\tc.songnum = i;\n\t\tc.type = CSONG;\n\t\tsend(clickout, &c);\n\t\tp.y += f->height;\n\t}\n\tif(p.y > start.y+256)\n\t\tstart.y = p.y;\n\telse\n\t\tstart.y+=256;\n\treturn start;\n}\n\nvoid\ndrawlibrary(Lib *l, Point p, Image *textcolor, Image *active, Channel *clickout)\n{\n\tAlbum *start, *stop, *cur, *screenstop;\n\tint cursong, height;\n\n\tstart = l->cur;\n\tstop = l->stop;\n\tcur = l->cur;\n\tcursong = l->cursong;\n\theight = screen->r.max.y - screen->r.min.y;\n\tscreenstop = start+(height/256)-1;\n\tstop = screenstop < stop ? screenstop : stop;\n\tstop+=1;\n\n\tif(start==stop)\n\t\tstop++;\n\n\tfor(;start!=stop;start++){\n\t\tp = drawalbum(start, textcolor, active, p, start == cur ? cursong : -1, clickout);\n\t}\n}\n\nvoid\ndrawlists(Point p, Image *textcolor, Image *background, Channel *clickout)\n{\n\tRectangle r;\n\tint n, i;\n\tint fd;\n\tDir *files;\n\tchar buf[512];\n\tFont *f = screen->display->defaultfont;\n\tHmap *h;\n\tchar **keys, *dot;\n\tClick c;\n\n\tlibdir(buf, sizeof buf);\n\tfd = open(buf, OREAD);\n\tif(fd < 0)\n\t\tsysfatal(\"could not open libdir\");\n\n\tn = dirreadall(fd, &files);\n\tclose(fd);\n\tif(n <= 0){\n\t\tfree(files);\n\t\treturn;\n\t}\n\n\th = allocmap(32);\n\tr.min = p;\n\tr.max.x = r.min.x + 256;\n\tr.max.y = screen->r.max.y;\n\tdraw(screen, r, background, nil, ZP);\n\tfor(i=0;i<n;i++){\n\t\tif((dot = strrchr(files[i].name, '.')) != nil)\n\t\t\t*dot = '\\0';\n\t\tmapinsert(h, files[i].name, nil);\n\t}\n\tkeys = emalloc(sizeof(char*)*n);\n\tn = mapdumpkey(h, keys, n);\n\tfor(i=0;i<n;i++){\n\t\tstring(screen, p, textcolor, ZP, f, keys[i]);\n\t\tc.r = Rpt(p, Pt(p.x+strlen(keys[i])*f->width,p.y+f->height));\n\t\tc.list = strdup(keys[i]);\n\t\tc.type = CLIST;\n\t\tsend(clickout, &c);\n\t\tp.y += f->height;\n\t}\n\n\tfreemap(h);\n\tfree(keys);\n\tfree(files);\n}\n\nvoid\ndrawvolume(int level, Image* color)\n{\n\tPoint p;\n\tchar buf[128];\n\tFont *f = screen->display->defaultfont;\n\tint n = snprint(buf, sizeof buf, \"Vol: %d%%\", level);\n\tp.y = screen->r.min.y;\n\tp.x = screen->r.max.x;\n\tp.x-=(n*f->width);\n\tstring(screen, p, color, ZP, f, buf);\n}\n", "source": "mpl/draw.c", "file_type": "c"}
{"text": "#include <u.h>\n#include <libc.h>\n#include <thread.h>\n#include <draw.h>\n\n#include \"dat.h\"\n#include \"fncs.h\"\n\nvoid\nreadvol(int fd, int *level)\n{\n\tint n;\n\tchar *dot;\n\tchar buf[512];\n\tn = pread(fd, buf, (sizeof buf) - 1, 0);\n\tbuf[n] = '\\0';\n\tdot = strchr(buf, '\\n');\n\tif(dot == nil)\n\t\tgoto error;\n\n\t*dot = '\\0';\n\tdot = strstr(buf, \"left\");\n\tif(dot != nil){\n\t\t*level = atoi(dot+4+1);\n\t\treturn;\n\t}\n\n\tdot = strstr(buf, \"out\");\n\tif(dot == nil)\n\t\tgoto error;\n\n\t*level = atoi(dot+3);\n\treturn;\n\nerror:\n\t*level = -1;\n}\n\nvoid\nwritevol(int fd, int level)\n{\n\tchar buf[16];\n\tint n = snprint(buf, sizeof buf, \"%d\", level);\n\twrite(fd, buf, n);\n}\n\nvoid\nvolthread(void *arg)\n{\n\tChannel **chans = arg;\n\tChannel *ctl = chans[0];\n\tChannel *out = chans[1];\n\tfree(chans);\n\n\tint fd;\n\tint level;\n\tint muted = 0;\n\tenum volmsg vmsg;\n\n\tif((fd = open(\"/dev/volume\", ORDWR))<0){\n\t\t/* Make volume controls NOP */\n\t\tchanclose(ctl);\n\t\tchanclose(out);\n\t\treturn;\n\t}\n\n\tAlt alts[] = {\n\t\t{ctl, &vmsg, CHANRCV},\n\t\t{out, &level, CHANSND},\n\t\t{nil, nil, CHANEND},\n\t};\n\n\treadvol(fd, &level);\n\tfor(;;){\n\t\tif(alt(alts) != 0)\n\t\t\tcontinue;\n\t\treadvol(fd, &level);\n\t\tswitch(vmsg){\n\t\tcase UP:\n\t\t\tlevel+=5;\n\t\t\tlevel = level > 100 ? 100 : level;\n\t\t\twritevol(fd, muted == 0 ? level : 0);\n\t\t\tbreak;\n\t\tcase DOWN:\n\t\t\tlevel-=5;\n\t\t\tlevel = level < 0 ? 0 : level;\n\t\t\twritevol(fd, muted == 0 ? level : 0);\n\t\t\tbreak;\n\t\tcase MUTE:\n\t\t\tmuted = 1;\n\t\t\twritevol(fd, 0);\n\t\t\tbreak;\n\t\tcase UNMUTE:\n\t\t\tmuted = 0;\n\t\t\twritevol(fd, level);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nvoid\nspawnvol(Channel *ctl, Channel *out)\n{\n\tChannel **chans;\n\tchans = emalloc(sizeof(Channel*)*2);\n\tchans[0] = ctl;\n\tchans[1] = out;\n\tthreadcreate(volthread, chans, 8192);\n}", "source": "mpl/vol.c", "file_type": "c"}
{"text": "#include <u.h>\n#include <libc.h>\n#include <thread.h>\n#include <draw.h>\n\n#include \"dat.h\"\n#include \"fncs.h\"\n\nconst uchar none[] = {0};\n\n/*\n * Rune and str marshal functions do not write null.\n */\n\nvoid\nmarshalrune(int fd, Rune *r)\n{\n\tstatic char buf[128];\n\tuchar n;\n\n\tif(r == nil || r[0] == '\\0')\n\t\twrite(fd, none, sizeof none);\n\telse{\n\t\tn = snprint(buf, 128, \"%S\", r);\n\t\twrite(fd, &n, sizeof n);\n\t\twrite(fd, buf, n);\n\t}\n}\n\nRune*\nunmarshalrune(int fd)\n{\n\tstatic char buf[128];\n\tRune *r;\n\tuchar n;\n\tread(fd, &n, sizeof n);\n\tif(n == 0)\n\t\treturn nil;\n\tread(fd, buf, n);\n\tbuf[n] = '\\0';\n\tr = runesmprint(\"%s\", buf);\n\tsetmalloctag(r, getcallerpc(&fd));\n\treturn r;\n}\n\nvoid\nmarshalstr(int fd, char *s)\n{\n\tuint n = strlen(s);\n\twrite(fd, &n, sizeof n);\n\twrite(fd, s, n);\n}\n\nchar*\nunmarshalstr(int fd)\n{\n\tuint n;\n\tchar *s;\n\tread(fd, &n, sizeof n);\n\ts = emalloc(n+1);\n\tsetmalloctag(s, getcallerpc(&fd));\n\ts[n] = '\\0';\n\tread(fd, s, n);\n\treturn s;\n}\n\nvoid\nmarshalvorbis(int fd, VorbisMeta *v)\n{\n\t//TODO: store whole key-value pair\n\tmarshalrune(fd, v->title);\n\tmarshalrune(fd, v->artist);\n\tmarshalrune(fd, v->album);\n\twrite(fd, &(v->year), sizeof v->year);\n\twrite(fd, &(v->tracknumber), sizeof v->tracknumber);\n}\n\nvoid\nunmarshalvorbis(int fd, VorbisMeta *v)\n{\n\tv->title = unmarshalrune(fd);\n\tv->artist = unmarshalrune(fd);\n\tv->album = unmarshalrune(fd);\n\tread(fd, &(v->year), sizeof v->year);\n\tread(fd, &(v->tracknumber), sizeof v->tracknumber);\n}\n\nvoid\nmarshalflacpic(int fd, FlacPic *p)\n{\n\t//TODO store other fields\n\tmarshalstr(fd, p->mime);\n\twrite(fd, &(p->size), sizeof p->size);\n\twrite(fd, p->data, p->size);\n}\n\nvoid\nunmarshalflacpic(int fd, FlacPic **p)\n{\n\t*p = emalloc(sizeof(FlacPic));\n\t(*p)->mime = unmarshalstr(fd);\n\tread(fd, &((*p)->size), sizeof (*p)->size);\n\tread(fd, (*p)->data, (*p)->size);\n}\n\nvoid\nmarshalflacmeta(int fd, FlacMeta *f)\n{\n\tmarshalvorbis(fd, f);\n//\tmarshalflacpic(fd, f->pic);\n}\n\nvoid\nunmarshalflacmeta(int fd, FlacMeta **f)\n{\n\t*f = emalloc(sizeof(FlacMeta));\n\tunmarshalvorbis(fd, &((*f)->VorbisMeta));\n//\tunmarshalflacpic(fd, &((*f)->pic));\n}\n\nvoid\nmarshalid3(int fd, ID3v1 *id)\n{\n\tmarshalrune(fd, id->title);\n\tmarshalrune(fd, id->artist);\n\tmarshalrune(fd, id->album);\n\twrite(fd, &(id->year), sizeof id->year);\n\tmarshalrune(fd, id->comment);\n\twrite(fd, &(id->genre), sizeof id->genre);\n}\n\nvoid\nunmarshalid3(int fd, ID3v1 **id)\n{\n\t*id = emalloc(sizeof(ID3v1));\n\t(*id)->title = unmarshalrune(fd);\n\t(*id)->artist = unmarshalrune(fd);\n\t(*id)->album = unmarshalrune(fd);\n\tread(fd, &((*id)->year), sizeof (*id)->year);\n\t(*id)->comment\t= unmarshalrune(fd);\n\tread(fd, &((*id)->genre), sizeof (*id)->genre);\n}\n\nvoid\nmarshalsong(int fd, Song *s)\n{\n\twrite(fd, &(s->type), sizeof s->type);\n\tswitch(s->type){\n\tcase FLAC:\n\t\tmarshalflacmeta(fd, s->fmeta);\n\t\tbreak;\n\tcase MP3:\n\t\tmarshalid3(fd, s->idmeta);\n\t\tbreak;\n\tdefault:\n\t\tsysfatal(\"not recognized or unsupported format\");\n\t}\n\tmarshalstr(fd, s->path);\n}\n\nvoid\nunmarshalsong(int fd, Song *s)\n{\n\tread(fd, &(s->type), sizeof s->type);\n\tswitch(s->type){\n\tcase FLAC:\n\t\tunmarshalflacmeta(fd, &(s->fmeta));\n\t\tbreak;\n\tcase MP3:\n\t\tunmarshalid3(fd, &(s->idmeta));\n\t\tbreak;\n\tdefault:\n\t\tsysfatal(\"not recognized or unsupported format\");\n\t}\n\ts->path = unmarshalstr(fd);\n}\n\nvoid\nmarshalalbum(int fd, Album *a)\n{\n\tint i;\n\tint havepic = a->cover == nil ? 0 : 1;\n\tmarshalrune(fd, a->name);\n\twrite(fd, &(a->nsong), sizeof a->nsong);\n\twrite(fd, &havepic, sizeof havepic);\n\tif(havepic)\n\t\twriteimage(fd, a->cover, 0);\n\tfor(i=0;i<a->nsong;i++)\n\t\tmarshalsong(fd, a->songs+i);\n}\n\nvoid\nunmarshalalbum(int fd, Album *a)\n{\n\tint i, havepic;\n\ta->name = unmarshalrune(fd);\n\tread(fd, &(a->nsong), sizeof a->nsong);\n\tread(fd, &havepic, sizeof havepic);\n\tif(havepic)\n\t\ta->cover = readimage(display, fd, 0);\n\ta->songs = emalloc(sizeof(Song)*a->nsong);\n\tsetmalloctag(a->songs, getcallerpc(&fd));\n\tfor(i=0;i<a->nsong;i++)\n\t\tunmarshalsong(fd, a->songs+i);\n}\n\nvoid\nmarshallib(int fd, Lib *l)\n{\n\tint i;\n\twrite(fd, &(l->nalbum), sizeof l->nalbum);\n\tfor(i=0;i<l->nalbum;i++)\n\t\tmarshalalbum(fd, l->start+i);\n}\n\nvoid\nunmarshallib(int fd, Lib *l)\n{\n\tint i;\n\tl->cursong = 0;\n\tread(fd, &(l->nalbum), sizeof l->nalbum);\n\tl->start = emalloc(sizeof(Album)*l->nalbum);\n\tsetmalloctag(l->start, getcallerpc(&fd));\n\tfor(i=0;i<l->nalbum;i++)\n\t\tunmarshalalbum(fd, l->start+i);\n\tl->stop = l->start+i;\n\tl->cur = l->start;\n}\n", "source": "mpl/index.c", "file_type": "c"}
{"text": "#include <u.h>\n#include <libc.h>\n#include <thread.h>\n#include <draw.h>\n\n#include \"dat.h\"\n#include \"fncs.h\"\n\nenum blocktype{\n\tSTREAMINFO,\n\tPADDING,\n\tAPPLICATION,\n\tSEEKTABLE,\n\tVORBIS_COMMENT,\n\tCUESHEET,\n\tPICTURE,\n};\n\nvoid\nreadflacpic(int fd, vlong offset, FlacPic *pic)\n{\n\tuchar buf[1024];\n\tuint len;\n\n\t/* We skip the picture type */\n\toffset+=4;\n\n\tpread(fd, buf, 4, offset);\n\tlen = bebtoi(buf, 4);\n\toffset+=4;\n\n\tpread(fd, buf, len, offset);\n\tbuf[len] = '\\0';\n\tpic->mime = strdup((char*)buf);\n\toffset+=len;\n\n\tpread(fd, buf, 4, offset);\n\tlen = bebtoi(buf, 4);\n\toffset+=4;\n\n\t/* This seems to be taking a large chunk of time;\n\t * For now we don't need it\n\tpread(fd, buf, len, offset);\n\tbuf[len] = '\\0';\n\tpic->desc = runesmprint(\"%s\", (char*)buf);\n\t*/\n\n\toffset+=len;\n\n\tpread(fd, buf, 4, offset);\n\tpic->p.x = bebtoi(buf, 4);\n\toffset+=4;\n\n\tpread(fd, buf, 4, offset);\n\tpic->p.y = bebtoi(buf, 4);\n\toffset+=4;\n\n\t/*We skip color depth and index */\n\toffset+=8;\n\n\tpread(fd, buf, 4, offset);\n\tpic->size = bebtoi(buf, 4);\n\toffset+=4;\n\n\tpic->data = emalloc(pic->size);\n\tpread(fd, pic->data, pic->size, offset);\n}\n\nFlacMeta*\nreadflacmeta(int fd, int readpic)\n{\n\tuvlong off;\n\tchar type;\n\tFlacMeta *f;\n\tuchar buf[32];\n\n\tpread(fd, buf, 4, 0);\n\n\tif(memcmp(buf, \"fLaC\", 4) != 0)\n\t\treturn nil;\n\toff=4;\n\n\tf = emalloc(sizeof(FlacMeta));\n\twhile(pread(fd, buf, 1, off)){\n\t\ttype = *buf;\n\t\toff++;\n\n\t\tpread(fd, buf, 3, off);\n\t\toff+=3;\n\n\t\tswitch(type & 0x7f){\n\t\tcase STREAMINFO:\n\t\t\tbreak;\n\t\tcase PADDING:\n\t\t\tbreak;\n\t\tcase APPLICATION:\n\t\t\tbreak;\n\t\tcase SEEKTABLE:\n\t\t\tbreak;\n\t\tcase VORBIS_COMMENT:\n\t\t\tparsevorbismeta(fd, off, f);\n\t\t\tbreak;\n\t\tcase CUESHEET:\n\t\t\tbreak;\n\t\tcase PICTURE:\n\t\t\tif(readpic > 0)\n\t\t\t\treadflacpic(fd, off, f);\n\t\t\tbreak;\n\t\t}\n\t\toff+=bebtoi(buf, 3);\n\t\tif((type & 0x80) > 0)\n\t\t\tbreak;\n\t}\n\n\treturn f;\n}\n", "source": "mpl/flac.c", "file_type": "c"}
{"text": "#include <u.h>\n#include <libc.h>\n#include <thread.h>\n#include <draw.h>\n\n#include \"dat.h\"\n#include \"fncs.h\"\n\nvoid\nfinddefmeta(VorbisMeta *v)\n{\n\tuint i;\n\tfor(i=0;i<v->ncom;i++){\n\t\tif(runecstrcmp(v->key[i], L\"album\") == 0){\n\t\t\tv->album = v->val[i];\n\t\t\tcontinue;\n\t\t}\n\t\tif(runecstrcmp(v->key[i], L\"title\") == 0){\n\t\t\tv->title = v->val[i];\n\t\t\tcontinue;\n\t\t}\n\t\tif(runecstrcmp(v->key[i], L\"artist\") == 0){\n\t\t\tv->artist = v->val[i];\n\t\t\tcontinue;\n\t\t}\n\t\tif(runecstrcmp(v->key[i], L\"tracknumber\") == 0){\n\t\t\tchar buf[16];\n\t\t\tsnprint(buf, sizeof buf, \"%S\", v->val[i]);\n\t\t\tv->tracknumber = atoi(buf);\n\t\t\tcontinue;\n\t\t}\n\t}\n}\n\nvoid\nparsevorbismeta(int fd, uvlong offset, VorbisMeta *v)\n{\n\tu32int size;\n\tuchar buf[4096];\n\tuint i;\n\tchar *sep;\n\n\t/* Vendor String */\n\tpread(fd, buf, 4, offset);\n\tsize = lebtoi(buf, 4);\n\toffset+=size+4;\n\n\tpread(fd, buf, 4, offset);\n\tv->ncom = lebtoi(buf, 4);\n\tv->key = emalloc(sizeof(Rune*) * v->ncom);\n\tv->val = emalloc(sizeof(Rune*) * v->ncom);\n\toffset+=4;\n\n\tfor(i=0;i<v->ncom;i++){\n\t\tpread(fd, buf, 4, offset);\n\t\tsize = lebtoi(buf, 4);\n\t\t/* TODO: We should ignore large comments, and trim those that we dont use */\n\t\tif(size >= sizeof buf)\n\t\t\tsysfatal(\"parsevorbismeta: comment greater then buff size\");\n\t\toffset+=4;\n\n\t\tpread(fd, buf, size, offset);\n\t\toffset+=size;\n\n\t\tbuf[size] = '\\0';\n\t\tsep = strchr((char*)buf, '=');\n\t\tif(sep == nil){\n\t\t\tfprint(2, \"Invalid vorbis header format\\n\");\n\t\t\tquit(\"Invalid vorbis header format\");\n\t\t\tcontinue;\n\t\t}\n\t\t*sep = '\\0';\n\t\tv->key[i] = runesmprint(\"%s\", (char*)buf);\n\t\tv->val[i] = runesmprint(\"%s\", sep+1);\n\t}\n\n\tfinddefmeta(v);\n}\n", "source": "mpl/vorbis.c", "file_type": "c"}
{"text": "#include <u.h>\n#include <libc.h>\n#include <thread.h>\n#include <draw.h>\n#include <keyboard.h>\n#include <cursor.h>\n#include <mouse.h>\n\n#include \"dat.h\"\n#include \"fncs.h\"\n\nenum {\n\tRESIZEC,\n\tKEYC,\n\tREDRAW,\n\tNONE\n};\n\nMousectl \t*mctl;\nKeyboardctl *kctl;\nChannel\t\t*ctl, *lout, *loadc;\nChannel\t\t*vctl, *vlevel;\nChannel\t\t*clickin, *clickreset;\nint\t\t\tdecpid;\nint \t\tshowlists;\n\nint mflag, sflag, pflag, rflag, fflag;\n\nImage *black;\nImage *red;\nImage *background;\nImage *listbackground;\n\nint\ncleanup(void*,char*)\n{\n\tpostnote(PNGROUP, decpid, \"kill\");\n\tclosedisplay(display);\n\tclosemouse(mctl);\n\tclosekeyboard(kctl);\n\treturn 0;\n}\n\nvoid\nquit(char *err)\n{\n\tcleanup(nil, nil);\n\tthreadexitsall(err);\n}\n\nvoid\neresized(int isnew)\n{\n\tint level;\n\tLib lib;\n\tPoint p;\n\tif(isnew && getwindow(display, Refnone) < 0)\n\t\tquit(\"eresized: Can't reattach to window\");\n\n\tp = screen->r.min;\n\tsend(clickreset, nil);\n\tdraw(screen, screen->r, background, nil, ZP);\n\trecv(lout, &lib);\n\tif(showlists) {\n\t\tdrawlists(p, black, listbackground, clickin);\n\t\tp.x+=256;\n\t}\n\tdrawlibrary(&lib, p, black, red, clickin);\n\trecv(vlevel, &level);\n\tdrawvolume(level, black);\n\tflushimage(display, Refnone);\n}\n\nvoid\nhandleaction(Rune kbd)\n{\n\tenum volmsg vmsg;\n\tenum cmsg msg;\n\tchar buf[512] = {0};\n\tswitch(kbd){\n\t\tcase Kbs:\n\t\tcase Kdel:\n\t\t\tpostnote(PNGROUP, decpid, \"kill\");\n\t\t\tquit(nil);\n\t\t\treturn;\n\t\tcase 'w':\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tshowlists = !showlists;\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tmsg = PAUSE;\n\t\t\tsend(ctl, &msg);\n\t\t\treturn;\n\t\tcase 'l':\n\t\t\tmsg = START;\n\t\t\tsend(ctl, &msg);\n\t\t\treturn;\n\t\tcase 'n':\n\t\t\tmsg = NEXT;\n\t\t\tsend(ctl, &msg);\n\t\t\tbreak;\n\t\tcase 'm':\n\t\t\tmsg = PREV;\n\t\t\tsend(ctl, &msg);\n\t\t\tbreak;\n\t\tcase '9':\n\t\t\tvmsg = DOWN;\n\t\t\tsend(vctl, &vmsg);\n\t\t\tbreak;\n\t\tcase '0':\n\t\t\tvmsg = UP;\n\t\t\tsend(vctl, &vmsg);\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tmsg = DUMP;\n\t\t\tsend(ctl, &msg);\n\t\t\t/* lib proc is waiting for us to give it a name */\n\t\t\tenter(\"name?\", buf, sizeof buf, mctl, kctl, nil);\n\t\t\tsendp(loadc, buf);\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\tenter(\"Playlist?\", buf, sizeof buf, mctl, kctl, nil);\n\t\t\tsendp(loadc, buf);\n\t\t\tbreak;\n\t}\n\teresized(0);\n}\n\nvoid\nusage(void)\n{\n\tfprint(2, \"Usage: -mspr %s file\", argv0);\n\tsysfatal(\"usage\");\n}\n\nvoid\nthreadmain(int argc, char *argv[])\n{\n\tRune kbd;\n\tChannel *clickout;\n\tint resize[2];\n\tctl = vctl = vlevel = nil;\n\tmflag = sflag = pflag = rflag = fflag = 0;\n\tshowlists = 0;\n\n\t/*\n\t * This shouldn't need to be buffered,\n\t * but for some reason it likes to still be\n\t * blocked by the time the libproc is asked\n\t * to produce the Lib struct. TODO: Investigate.\n\t */\n\tChannel *redraw = chancreate(1, 1);\n\n\tARGBEGIN{\n\tcase 'm': mflag++; break;\n\tcase 's': sflag++; break;\n\tcase 'p': pflag++; break;\n\tcase 'r': rflag++; break;\n\tcase 'f': fflag++; break;\n\tdefault: usage();\n\t}ARGEND\n\n\tif(mflag+sflag+pflag+rflag+fflag < 1){\n\t\tfprint(2, \"Please specify a playlist flag(m, s, r, f, or p)\\n\");\n\t\tthreadexits(nil);\n\t}\n\n\tthreadnotify(cleanup, 1);\n\n\tif(argc != 1)\n\t\tusage();\n\n\tif(initdraw(nil, nil, \"mpl\") < 0)\n\t\tsysfatal(\"%s: Failed to init screen %r\", argv0);\n\tif((mctl = initmouse(nil, screen)) == nil)\n\t\tsysfatal(\"initmouse: %r\");\n\tif((kctl = initkeyboard(nil)) == nil)\n\t\tsysfatal(\"initkeyboard: %r\");\n\n\tclickin = chancreate(sizeof(Click), 0);\n\tclickout = chancreate(sizeof(Click), 0);\n\tclickreset = chancreate(1, 0);\n\tspawnevent(mctl->c, clickin, clickout, clickreset);\n\n\tctl = chancreate(sizeof(enum cmsg), 0);\n\tlout = chancreate(sizeof(Lib), 0);\n\tloadc = chancreate(sizeof(char*), 0);\n\tspawnlib(ctl, lout, clickout, redraw, loadc, argv[0]);\n\n\tvctl = chancreate(sizeof(enum volmsg), 0);\n\tvlevel = chancreate(sizeof(int), 0);\n\tspawnvol(vctl, vlevel);\n\n\tred = allocimage(display, Rect(0, 0, 1, 1), screen->chan, 1, DBlue);\n\tblack = allocimage(display, Rect(0, 0, 1, 1), screen->chan, 1, DBlack);\n\tlistbackground = allocimagemix(display, DPalebluegreen, DPalegreen);\n\tbackground = allocimagemix(display, DYellow, DPalegreyblue);\n\n\teresized(0);\n\n\tAlt alts[] = {\n\t\t{mctl->resizec, resize, CHANRCV},\n\t\t{kctl->c, &kbd, CHANRCV},\n\t\t{redraw, nil, CHANRCV},\n\t\t{nil, nil, CHANEND},\n\t};\n\n\tfor(;;){\n\t\tswitch(alt(alts)){\n\t\t\tcase KEYC:\n\t\t\t\thandleaction(kbd);\n\t\t\t\tbreak;\n\t\t\tcase RESIZEC:\n\t\t\t\teresized(1);\n\t\t\t\tbreak;\n\t\t\tcase REDRAW:\n\t\t\t\teresized(0);\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\n", "source": "mpl/mpl.c", "file_type": "c"}
{"text": "#include <u.h>\n#include <libc.h>\n#include <draw.h>\n#include <thread.h>\n#include <cursor.h>\n#include <mouse.h>\n#include <keyboard.h>\n#include <frame.h>\n#include <fcall.h>\n#include <plumb.h>\n#include <libsec.h>\n#include \"dat.h\"\n#include \"fns.h\"\n\n// State for global log file.\ntypedef struct Log Log;\nstruct Log\n{\n\tQLock lk;\n\tRendez r;\n\n\tvlong start; // msg[0] corresponds to 'start' in the global sequence of events\n\t\n\t// queued events (nev=entries in ev, mev=capacity of p)\n\tchar **ev;\n\tint nev;\n\tint mev;\n\n\t// open acme/put files that need to read events\n\tFid **f;\n\tint nf;\n\tint mf;\n\t\n\t// active (blocked) reads waiting for events\n\tXfid **read;\n\tint nread;\n\tint mread;\n};\n\nstatic Log eventlog;\n\nvoid\nxfidlogopen(Xfid *x)\n{\n\tqlock(&eventlog.lk);\n\tif(eventlog.nf >= eventlog.mf) {\t\n\t\teventlog.mf = eventlog.mf*2;\n\t\tif(eventlog.mf == 0)\n\t\t\teventlog.mf = 8;\n\t\teventlog.f = erealloc(eventlog.f, eventlog.mf*sizeof eventlog.f[0]);\n\t}\n\teventlog.f[eventlog.nf++] = x->f;\n\tx->f->logoff = eventlog.start + eventlog.nev;\n\n\tqunlock(&eventlog.lk);\n}\n\nvoid\nxfidlogclose(Xfid *x)\n{\n\tint i;\n\n\tqlock(&eventlog.lk);\n\tfor(i=0; i<eventlog.nf; i++) {\n\t\tif(eventlog.f[i] == x->f) {\n\t\t\teventlog.f[i] = eventlog.f[--eventlog.nf];\n\t\t\tbreak;\n\t\t}\n\t}\n\tqunlock(&eventlog.lk);\n}\n\nvoid\nxfidlogread(Xfid *x)\n{\n\tchar *p;\n\tint i;\n\tFcall fc;\n\n\tqlock(&eventlog.lk);\n\tif(eventlog.nread >= eventlog.mread) {\t\n\t\teventlog.mread = eventlog.mread*2;\n\t\tif(eventlog.mread == 0)\n\t\t\teventlog.mread = 8;\n\t\teventlog.read = erealloc(eventlog.read, eventlog.mread*sizeof eventlog.read[0]);\n\t}\n\teventlog.read[eventlog.nread++] = x;\n\t\n\tif(eventlog.r.l == nil)\n\t\teventlog.r.l = &eventlog.lk;\n\tx->flushed = FALSE;\n\twhile(x->f->logoff >= eventlog.start+eventlog.nev && !x->flushed)\n\t\trsleep(&eventlog.r);\n\t\t\n\tfor(i=0; i<eventlog.nread; i++) {\n\t\tif(eventlog.read[i] == x) {\n\t\t\teventlog.read[i] = eventlog.read[--eventlog.nread];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif(x->flushed) {\n\t\tqunlock(&eventlog.lk);\n\t\treturn;\n\t}\n\n\ti = x->f->logoff - eventlog.start;\n\tp = estrdup(eventlog.ev[i]);\n\tx->f->logoff++;\n\tqunlock(&eventlog.lk);\n\n\tfc.data = p;\n\tfc.count = strlen(p);\n\trespond(x, &fc, nil);\n\tfree(p);\t\n}\n\nvoid\nxfidlogflush(Xfid *x)\n{\n\tint i;\n\tXfid *rx;\n\n\tqlock(&eventlog.lk);\n\tfor(i=0; i<eventlog.nread; i++) {\n\t\trx = eventlog.read[i];\n\t\tif(rx->fcall.tag == x->fcall.oldtag) {\n\t\t\trx->flushed = TRUE;\n\t\t\trwakeupall(&eventlog.r);\n\t\t}\n\t}\n\tqunlock(&eventlog.lk);\n}\n\n/*\n * add a log entry for op on w.\n * expected calls:\n *\n * op == \"new\" for each new window\n *\t- caller of coladd or makenewwindow responsible for calling\n *\t\txfidlog after setting window name\n *\t- exception: zerox\n *\n * op == \"zerox\" for new window created via zerox\n *\t- called from zeroxx\n *\n * op == \"get\" for Get executed on window\n *\t- called from get\n *\n * op == \"put\" for Put executed on window\n *\t- called from put\n *\n * op == \"del\" for deleted window\n *\t- called from winclose\n */\nvoid\nxfidlog(Window *w, char *op)\n{\n\tint i, n;\n\tvlong min;\n\tFile *f;\n\tchar *name;\n\n\tqlock(&eventlog.lk);\n\tif(eventlog.nev >= eventlog.mev) {\n\t\t// Remove and free any entries that all readers have read.\n\t\tmin = eventlog.start + eventlog.nev;\n\t\tfor(i=0; i<eventlog.nf; i++) {\n\t\t\tif(min > eventlog.f[i]->logoff)\n\t\t\t\tmin = eventlog.f[i]->logoff;\n\t\t}\n\t\tif(min > eventlog.start) {\n\t\t\tn = min - eventlog.start;\n\t\t\tfor(i=0; i<n; i++)\n\t\t\t\tfree(eventlog.ev[i]);\n\t\t\teventlog.nev -= n;\n\t\t\teventlog.start += n;\n\t\t\tmemmove(eventlog.ev, eventlog.ev+n, eventlog.nev*sizeof eventlog.ev[0]);\n\t\t}\n\t\t\n\t\t// Otherwise grow.\n\t\tif(eventlog.nev >= eventlog.mev) {\n\t\t\teventlog.mev = eventlog.mev*2;\n\t\t\tif(eventlog.mev == 0)\n\t\t\t\teventlog.mev = 8;\n\t\t\teventlog.ev = erealloc(eventlog.ev, eventlog.mev*sizeof eventlog.ev[0]);\n\t\t}\n\t}\n\tf = w->body.file;\n\tname = runetobyte(f->name, f->nname);\n\tif(name == nil)\n\t\tname = estrdup(\"\");\n\teventlog.ev[eventlog.nev++] = smprint(\"%d %s %s\\n\", w->id, op, name);\n\tfree(name);\n\tif(eventlog.r.l == nil)\n\t\teventlog.r.l = &eventlog.lk;\n\trwakeupall(&eventlog.r);\n\tqunlock(&eventlog.lk);\n}\n", "source": "acme2k/src/cmd/acme/logf.c", "file_type": "c"}
{"text": "#include <u.h>\n#include <libc.h>\n#include <draw.h>\n#include <thread.h>\n#include <cursor.h>\n#include <mouse.h>\n#include <keyboard.h>\n#include <frame.h>\n#include <fcall.h>\n#include <plumb.h>\n#include <libsec.h>\n#include \"dat.h\"\n#include \"edit.h\"\n#include \"fns.h\"\n\nstatic char\tlinex[]=\"\\n\";\nstatic char\twordx[]=\" \\t\\n\";\nstruct cmdtab cmdtab[]={\n/*\tcmdc\ttext\tregexp\taddr\tdefcmd\tdefaddr\tcount\ttoken\t fn\t*/\n\t'\\n',\t0,\t0,\t0,\t0,\taDot,\t0,\t0,\tnl_cmd,\n\t'a',\t1,\t0,\t0,\t0,\taDot,\t0,\t0,\ta_cmd,\n\t'b',\t0,\t0,\t0,\t0,\taNo,\t0,\tlinex,\tb_cmd,\n\t'c',\t1,\t0,\t0,\t0,\taDot,\t0,\t0,\tc_cmd,\n\t'd',\t0,\t0,\t0,\t0,\taDot,\t0,\t0,\td_cmd,\n\t'e',\t0,\t0,\t0,\t0,\taNo,\t0,\twordx,\te_cmd,\n\t'f',\t0,\t0,\t0,\t0,\taNo,\t0,\twordx,\tf_cmd,\n\t'g',\t0,\t1,\t0,\t'p',\taDot,\t0,\t0,\tg_cmd,\n\t'i',\t1,\t0,\t0,\t0,\taDot,\t0,\t0,\ti_cmd,\n\t'm',\t0,\t0,\t1,\t0,\taDot,\t0,\t0,\tm_cmd,\n\t'p',\t0,\t0,\t0,\t0,\taDot,\t0,\t0,\tp_cmd,\n\t'r',\t0,\t0,\t0,\t0,\taDot,\t0,\twordx,\te_cmd,\n\t's',\t0,\t1,\t0,\t0,\taDot,\t1,\t0,\ts_cmd,\n\t't',\t0,\t0,\t1,\t0,\taDot,\t0,\t0,\tm_cmd,\n\t'u',\t0,\t0,\t0,\t0,\taNo,\t2,\t0,\tu_cmd,\n\t'v',\t0,\t1,\t0,\t'p',\taDot,\t0,\t0,\tg_cmd,\n\t'w',\t0,\t0,\t0,\t0,\taAll,\t0,\twordx,\tw_cmd,\n\t'x',\t0,\t1,\t0,\t'p',\taDot,\t0,\t0,\tx_cmd,\n\t'y',\t0,\t1,\t0,\t'p',\taDot,\t0,\t0,\tx_cmd,\n\t'=',\t0,\t0,\t0,\t0,\taDot,\t0,\tlinex,\teq_cmd,\n\t'B',\t0,\t0,\t0,\t0,\taNo,\t0,\tlinex,\tB_cmd,\n\t'D',\t0,\t0,\t0,\t0,\taNo,\t0,\tlinex,\tD_cmd,\n\t'X',\t0,\t1,\t0,\t'f',\taNo,\t0,\t0,\tX_cmd,\n\t'Y',\t0,\t1,\t0,\t'f',\taNo,\t0,\t0,\tX_cmd,\n\t'<',\t0,\t0,\t0,\t0,\taDot,\t0,\tlinex,\tpipe_cmd,\n\t'|',\t0,\t0,\t0,\t0,\taDot,\t0,\tlinex,\tpipe_cmd,\n\t'>',\t0,\t0,\t0,\t0,\taDot,\t0,\tlinex,\tpipe_cmd,\n/* deliberately unimplemented:\n\t'k',\t0,\t0,\t0,\t0,\taDot,\t0,\t0,\tk_cmd,\n\t'n',\t0,\t0,\t0,\t0,\taNo,\t0,\t0,\tn_cmd,\n\t'q',\t0,\t0,\t0,\t0,\taNo,\t0,\t0,\tq_cmd,\n\t'!',\t0,\t0,\t0,\t0,\taNo,\t0,\tlinex,\tplan9_cmd,\n */\n\t0,\t0,\t0,\t0,\t0,\t0,\t0,\t0\n};\n\nCmd\t*parsecmd(int);\nAddr\t*compoundaddr(void);\nAddr\t*simpleaddr(void);\nvoid\tfreecmd(void);\nvoid\tokdelim(int);\n\nRune\t*cmdstartp;\nRune *cmdendp;\nRune\t*cmdp;\nChannel\t*editerrc;\n\nString\t*lastpat;\nint\tpatset;\n\nList\tcmdlist;\nList\taddrlist;\nList\tstringlist;\nText\t*curtext;\nint\tediting = Inactive;\n\nString*\tnewstring(int);\n\nvoid\neditthread(void *v)\n{\n\tCmd *cmdp;\n\n\tUSED(v);\n\tthreadsetname(\"editthread\");\n\twhile((cmdp=parsecmd(0)) != 0){\n\t\tif(cmdexec(curtext, cmdp) == 0)\n\t\t\tbreak;\n\t\tfreecmd();\n\t}\n\tsendp(editerrc, nil);\n}\n\nvoid\nallelogterm(Window *w, void *x)\n{\n\tUSED(x);\n\telogterm(w->body.file);\n}\n\nvoid\nalleditinit(Window *w, void *x)\n{\n\tUSED(x);\n\ttextcommit(&w->tag, TRUE);\n\ttextcommit(&w->body, TRUE);\n\tw->body.file->editclean = FALSE;\n}\n\nvoid\nallupdate(Window *w, void *x)\n{\n\tText *t;\n\tint i;\n\tFile *f;\n\n\tUSED(x);\n\tt = &w->body;\n\tf = t->file;\n\tif(f->curtext != t)\t/* do curtext only */\n\t\treturn;\n\tif(f->elog.type == Null)\n\t\telogterm(f);\n\telse if(f->elog.type != Empty){\n\t\telogapply(f);\n\t\tif(f->editclean){\n\t\t\tf->mod = FALSE;\n\t\t\tfor(i=0; i<f->ntext; i++)\n\t\t\t\tf->text[i]->w->dirty = FALSE;\n\t\t}\n\t}\n\ttextsetselect(t, t->q0, t->q1);\n\ttextscrdraw(t);\n\twinsettag(w);\n}\n\nvoid\nediterror(char *fmt, ...)\n{\n\tva_list arg;\n\tchar *s;\n\n\tva_start(arg, fmt);\n\ts = vsmprint(fmt, arg);\n\tva_end(arg);\n\tfreecmd();\n\tallwindows(allelogterm, nil);\t/* truncate the edit logs */\n\tsendp(editerrc, s);\n\tthreadexits(nil);\n}\n\nvoid\neditcmd(Text *ct, Rune *r, uint n)\n{\n\tchar *err;\n\n\tif(n == 0)\n\t\treturn;\n\tif(2*n > RBUFSIZE){\n\t\twarning(nil, \"string too long\\n\");\n\t\treturn;\n\t}\n\n\tallwindows(alleditinit, nil);\n\tif(cmdstartp)\n\t\tfree(cmdstartp);\n\tcmdstartp = runemalloc(n+2);\n\trunemove(cmdstartp, r, n);\n\tif(r[n-1] != '\\n')\n\t\tcmdstartp[n++] = '\\n';\n\tcmdstartp[n] = '\\0';\n\tcmdendp = cmdstartp+n;\n\tcmdp = cmdstartp;\n\tif(ct->w == nil)\n\t\tcurtext = nil;\n\telse\n\t\tcurtext = &ct->w->body;\n\tresetxec();\n\tif(editerrc == nil){\n\t\tediterrc = chancreate(sizeof(char*), 0);\n\t\tchansetname(editerrc, \"editerrc\");\n\t\tlastpat = allocstring(0);\n\t}\n\tthreadcreate(editthread, nil, STACK);\n\terr = recvp(editerrc);\n\tediting = Inactive;\n\tif(err != nil){\n\t\tif(err[0] != '\\0')\n\t\t\twarning(nil, \"Edit: %s\\n\", err);\n\t\tfree(err);\n\t}\n\n\t/* update everyone whose edit log has data */\n\tallwindows(allupdate, nil);\n}\n\nint\ngetch(void)\n{\n\tif(cmdp == cmdendp)\n\t\treturn -1;\n\treturn *cmdp++;\n}\n\nint\nnextc(void)\n{\n\tif(cmdp == cmdendp)\n\t\treturn -1;\n\treturn *cmdp;\n}\n\nvoid\nungetch(void)\n{\n\tif(--cmdp < cmdstartp)\n\t\terror(\"ungetch\");\n}\n\nlong\ngetnum(int signok)\n{\n\tlong n;\n\tint c, sign;\n\n\tn = 0;\n\tsign = 1;\n\tif(signok>1 && nextc()=='-'){\n\t\tsign = -1;\n\t\tgetch();\n\t}\n\tif((c=nextc())<'0' || '9'<c)\t/* no number defaults to 1 */\n\t\treturn sign;\n\twhile('0'<=(c=getch()) && c<='9')\n\t\tn = n*10 + (c-'0');\n\tungetch();\n\treturn sign*n;\n}\n\nint\ncmdskipbl(void)\n{\n\tint c;\n\tdo\n\t\tc = getch();\n\twhile(c==' ' || c=='\\t');\n\tif(c >= 0)\n\t\tungetch();\n\treturn c;\n}\n\n/*\n * Check that list has room for one more element.\n */\nvoid\ngrowlist(List *l)\n{\n\tif(l->u.listptr==0 || l->nalloc==0){\n\t\tl->nalloc = INCR;\n\t\tl->u.listptr = emalloc(INCR*sizeof(void*));\n\t\tl->nused = 0;\n\t}else if(l->nused == l->nalloc){\n\t\tl->u.listptr = erealloc(l->u.listptr, (l->nalloc+INCR)*sizeof(void*));\n\t\tmemset(l->u.ptr+l->nalloc, 0, INCR*sizeof(void*));\n\t\tl->nalloc += INCR;\n\t}\n}\n\n/*\n * Remove the ith element from the list\n */\nvoid\ndellist(List *l, int i)\n{\n\tmemmove(&l->u.ptr[i], &l->u.ptr[i+1], (l->nused-(i+1))*sizeof(void*));\n\tl->nused--;\n}\n\n/*\n * Add a new element, whose position is i, to the list\n */\nvoid\ninslist(List *l, int i, void *v)\n{\n\tgrowlist(l);\n\tmemmove(&l->u.ptr[i+1], &l->u.ptr[i], (l->nused-i)*sizeof(void*));\n\tl->u.ptr[i] = v;\n\tl->nused++;\n}\n\nvoid\nlistfree(List *l)\n{\n\tfree(l->u.listptr);\n\tfree(l);\n}\n\nString*\nallocstring(int n)\n{\n\tString *s;\n\n\ts = emalloc(sizeof(String));\n\ts->n = n;\n\ts->nalloc = n+10;\n\ts->r = emalloc(s->nalloc*sizeof(Rune));\n\ts->r[n] = '\\0';\n\treturn s;\n}\n\nvoid\nfreestring(String *s)\n{\n\tfree(s->r);\n\tfree(s);\n}\n\nCmd*\nnewcmd(void){\n\tCmd *p;\n\n\tp = emalloc(sizeof(Cmd));\n\tinslist(&cmdlist, cmdlist.nused, p);\n\treturn p;\n}\n\nString*\nnewstring(int n)\n{\n\tString *p;\n\n\tp = allocstring(n);\n\tinslist(&stringlist, stringlist.nused, p);\n\treturn p;\n}\n\nAddr*\nnewaddr(void)\n{\n\tAddr *p;\n\n\tp = emalloc(sizeof(Addr));\n\tinslist(&addrlist, addrlist.nused, p);\n\treturn p;\n}\n\nvoid\nfreecmd(void)\n{\n\tint i;\n\n\twhile(cmdlist.nused > 0)\n\t\tfree(cmdlist.u.ucharptr[--cmdlist.nused]);\n\twhile(addrlist.nused > 0)\n\t\tfree(addrlist.u.ucharptr[--addrlist.nused]);\n\twhile(stringlist.nused>0){\n\t\ti = --stringlist.nused;\n\t\tfreestring(stringlist.u.stringptr[i]);\n\t}\n}\n\nvoid\nokdelim(int c)\n{\n\tif(c=='\\\\' || ('a'<=c && c<='z')\n\t|| ('A'<=c && c<='Z') || ('0'<=c && c<='9'))\n\t\tediterror(\"bad delimiter %c\\n\", c);\n}\n\nvoid\natnl(void)\n{\n\tint c;\n\n\tcmdskipbl();\n\tc = getch();\n\tif(c != '\\n')\n\t\tediterror(\"newline expected (saw %C)\", c);\n}\n\nvoid\nStraddc(String *s, int c)\n{\n\tif(s->n+1 >= s->nalloc){\n\t\ts->nalloc += 10;\n\t\ts->r = erealloc(s->r, s->nalloc*sizeof(Rune));\n\t}\n\ts->r[s->n++] = c;\n\ts->r[s->n] = '\\0';\n}\n\nvoid\ngetrhs(String *s, int delim, int cmd)\n{\n\tint c;\n\n\twhile((c = getch())>0 && c!=delim && c!='\\n'){\n\t\tif(c == '\\\\'){\n\t\t\tif((c=getch()) <= 0)\n\t\t\t\terror(\"bad right hand side\");\n\t\t\tif(c == '\\n'){\n\t\t\t\tungetch();\n\t\t\t\tc='\\\\';\n\t\t\t}else if(c == 'n')\n\t\t\t\tc='\\n';\n\t\t\telse if(c!=delim && (cmd=='s' || c!='\\\\'))\t/* s does its own */\n\t\t\t\tStraddc(s, '\\\\');\n\t\t}\n\t\tStraddc(s, c);\n\t}\n\tungetch();\t/* let client read whether delimiter, '\\n' or whatever */\n}\n\nString *\ncollecttoken(char *end)\n{\n\tString *s = newstring(0);\n\tint c;\n\n\twhile((c=nextc())==' ' || c=='\\t')\n\t\tStraddc(s, getch()); /* blanks significant for getname() */\n\twhile((c=getch())>0 && utfrune(end, c)==0)\n\t\tStraddc(s, c);\n\tif(c != '\\n')\n\t\tatnl();\n\treturn s;\n}\n\nString *\ncollecttext(void)\n{\n\tString *s;\n\tint begline, i, c, delim;\n\n\ts = newstring(0);\n\tif(cmdskipbl()=='\\n'){\n\t\tgetch();\n\t\ti = 0;\n\t\tdo{\n\t\t\tbegline = i;\n\t\t\twhile((c = getch())>0 && c!='\\n')\n\t\t\t\ti++, Straddc(s, c);\n\t\t\ti++, Straddc(s, '\\n');\n\t\t\tif(c < 0)\n\t\t\t\tgoto Return;\n\t\t}while(s->r[begline]!='.' || s->r[begline+1]!='\\n');\n\t\ts->r[s->n-2] = '\\0';\n\t\ts->n -= 2;\n\t}else{\n\t\tokdelim(delim = getch());\n\t\tgetrhs(s, delim, 'a');\n\t\tif(nextc()==delim)\n\t\t\tgetch();\n\t\tatnl();\n\t}\n    Return:\n\treturn s;\n}\n\nint\ncmdlookup(int c)\n{\n\tint i;\n\n\tfor(i=0; cmdtab[i].cmdc; i++)\n\t\tif(cmdtab[i].cmdc == c)\n\t\t\treturn i;\n\treturn -1;\n}\n\nCmd*\nparsecmd(int nest)\n{\n\tint i, c;\n\tstruct cmdtab *ct;\n\tCmd *cp, *ncp;\n\tCmd cmd;\n\n\tcmd.next = cmd.u.cmd = 0;\n\tcmd.re = 0;\n\tcmd.flag = cmd.num = 0;\n\tcmd.addr = compoundaddr();\n\tif(cmdskipbl() == -1)\n\t\treturn 0;\n\tif((c=getch())==-1)\n\t\treturn 0;\n\tcmd.cmdc = c;\n\tif(cmd.cmdc=='c' && nextc()=='d'){\t/* sleazy two-character case */\n\t\tgetch();\t\t/* the 'd' */\n\t\tcmd.cmdc='c'|0x100;\n\t}\n\ti = cmdlookup(cmd.cmdc);\n\tif(i >= 0){\n\t\tif(cmd.cmdc == '\\n')\n\t\t\tgoto Return;\t/* let nl_cmd work it all out */\n\t\tct = &cmdtab[i];\n\t\tif(ct->defaddr==aNo && cmd.addr)\n\t\t\tediterror(\"command takes no address\");\n\t\tif(ct->count)\n\t\t\tcmd.num = getnum(ct->count);\n\t\tif(ct->regexp){\n\t\t\t/* x without pattern -> .*\\n, indicated by cmd.re==0 */\n\t\t\t/* X without pattern is all files */\n\t\t\tif((ct->cmdc!='x' && ct->cmdc!='X') ||\n\t\t\t   ((c = nextc())!=' ' && c!='\\t' && c!='\\n')){\n\t\t\t\tcmdskipbl();\n\t\t\t\tif((c = getch())=='\\n' || c<0)\n\t\t\t\t\tediterror(\"no address\");\n\t\t\t\tokdelim(c);\n\t\t\t\tcmd.re = getregexp(c);\n\t\t\t\tif(ct->cmdc == 's'){\n\t\t\t\t\tcmd.u.text = newstring(0);\n\t\t\t\t\tgetrhs(cmd.u.text, c, 's');\n\t\t\t\t\tif(nextc() == c){\n\t\t\t\t\t\tgetch();\n\t\t\t\t\t\tif(nextc() == 'g')\n\t\t\t\t\t\t\tcmd.flag = getch();\n\t\t\t\t\t}\n\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ct->addr && (cmd.u.mtaddr=simpleaddr())==0)\n\t\t\tediterror(\"bad address\");\n\t\tif(ct->defcmd){\n\t\t\tif(cmdskipbl() == '\\n'){\n\t\t\t\tgetch();\n\t\t\t\tcmd.u.cmd = newcmd();\n\t\t\t\tcmd.u.cmd->cmdc = ct->defcmd;\n\t\t\t}else if((cmd.u.cmd = parsecmd(nest))==0)\n\t\t\t\terror(\"defcmd\");\n\t\t}else if(ct->text)\n\t\t\tcmd.u.text = collecttext();\n\t\telse if(ct->token)\n\t\t\tcmd.u.text = collecttoken(ct->token);\n\t\telse\n\t\t\tatnl();\n\t}else\n\t\tswitch(cmd.cmdc){\n\t\tcase '{':\n\t\t\tcp = 0;\n\t\t\tdo{\n\t\t\t\tif(cmdskipbl()=='\\n')\n\t\t\t\t\tgetch();\n\t\t\t\tncp = parsecmd(nest+1);\n\t\t\t\tif(cp)\n\t\t\t\t\tcp->next = ncp;\n\t\t\t\telse\n\t\t\t\t\tcmd.u.cmd = ncp;\n\t\t\t}while(cp = ncp);\n\t\t\tbreak;\n\t\tcase '}':\n\t\t\tatnl();\n\t\t\tif(nest==0)\n\t\t\t\tediterror(\"right brace with no left brace\");\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\tediterror(\"unknown command %c\", cmd.cmdc);\n\t\t}\n    Return:\n\tcp = newcmd();\n\t*cp = cmd;\n\treturn cp;\n}\n\nString*\ngetregexp(int delim)\n{\n\tString *buf, *r;\n\tint i, c;\n\n\tbuf = allocstring(0);\n\tfor(i=0; ; i++){\n\t\tif((c = getch())=='\\\\'){\n\t\t\tif(nextc()==delim)\n\t\t\t\tc = getch();\n\t\t\telse if(nextc()=='\\\\'){\n\t\t\t\tStraddc(buf, c);\n\t\t\t\tc = getch();\n\t\t\t}\n\t\t}else if(c==delim || c=='\\n')\n\t\t\tbreak;\n\t\tif(i >= RBUFSIZE)\n\t\t\tediterror(\"regular expression too long\");\n\t\tStraddc(buf, c);\n\t}\n\tif(c!=delim && c)\n\t\tungetch();\n\tif(buf->n > 0){\n\t\tpatset = TRUE;\n\t\tfreestring(lastpat);\n\t\tlastpat = buf;\n\t}else\n\t\tfreestring(buf);\n\tif(lastpat->n == 0)\n\t\tediterror(\"no regular expression defined\");\n\tr = newstring(lastpat->n);\n\trunemove(r->r, lastpat->r, lastpat->n);\t/* newstring put \\0 at end */\n\treturn r;\n}\n\nAddr *\nsimpleaddr(void)\n{\n\tAddr addr;\n\tAddr *ap, *nap;\n\n\taddr.num = 0;\n\taddr.next = 0;\n\taddr.u.left = 0;\n\tswitch(cmdskipbl()){\n\tcase '#':\n\t\taddr.type = getch();\n\t\taddr.num = getnum(1);\n\t\tbreak;\n\tcase '0': case '1': case '2': case '3': case '4':\n\tcase '5': case '6': case '7': case '8': case '9': \n\t\taddr.num = getnum(1);\n\t\taddr.type='l';\n\t\tbreak;\n\tcase '/': case '?': case '\"':\n\t\taddr.u.re = getregexp(addr.type = getch());\n\t\tbreak;\n\tcase '.':\n\tcase '$':\n\tcase '+':\n\tcase '-':\n\tcase '\\'':\n\t\taddr.type = getch();\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\tif(addr.next = simpleaddr())\n\t\tswitch(addr.next->type){\n\t\tcase '.':\n\t\tcase '$':\n\t\tcase '\\'':\n\t\t\tif(addr.type!='\"')\n\t\tcase '\"':\n\t\t\t\tediterror(\"bad address syntax\");\n\t\t\tbreak;\n\t\tcase 'l':\n\t\tcase '#':\n\t\t\tif(addr.type=='\"')\n\t\t\t\tbreak;\n\t\t\t/* fall through */\n\t\tcase '/':\n\t\tcase '?':\n\t\t\tif(addr.type!='+' && addr.type!='-'){\n\t\t\t\t/* insert the missing '+' */\n\t\t\t\tnap = newaddr();\n\t\t\t\tnap->type='+';\n\t\t\t\tnap->next = addr.next;\n\t\t\t\taddr.next = nap;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '+':\n\t\tcase '-':\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terror(\"simpleaddr\");\n\t\t}\n\tap = newaddr();\n\t*ap = addr;\n\treturn ap;\n}\n\nAddr *\ncompoundaddr(void)\n{\n\tAddr addr;\n\tAddr *ap, *next;\n\n\taddr.u.left = simpleaddr();\n\tif((addr.type = cmdskipbl())!=',' && addr.type!=';')\n\t\treturn addr.u.left;\n\tgetch();\n\tnext = addr.next = compoundaddr();\n\tif(next && (next->type==',' || next->type==';') && next->u.left==0)\n\t\tediterror(\"bad address syntax\");\n\tap = newaddr();\n\t*ap = addr;\n\treturn ap;\n}\n", "source": "acme2k/src/cmd/acme/edit.c", "file_type": "c"}
{"text": "#include <u.h>\n#include <libc.h>\n#include <draw.h>\n#include <thread.h>\n#include <cursor.h>\n#include <mouse.h>\n#include <keyboard.h>\n#include <frame.h>\n#include <fcall.h>\n#include <plumb.h>\n#include <libsec.h>\n#include \"dat.h\"\n#include \"fns.h\"\n\nstatic Image *scrtmp;\n\nstatic\nRectangle\nscrpos(Rectangle r, uint p0, uint p1, uint tot)\n{\n\tRectangle q;\n\tint h;\n\n\tq = r;\n\th = q.max.y-q.min.y;\n\tif(tot == 0)\n\t\treturn q;\n\tif(tot > 1024*1024){\n\t\ttot>>=10;\n\t\tp0>>=10;\n\t\tp1>>=10;\n\t}\n\tif(p0 > 0)\n\t\tq.min.y += h*p0/tot;\n\tif(p1 < tot)\n\t\tq.max.y -= h*(tot-p1)/tot;\n\tif(q.max.y < q.min.y+2){\n\t\tif(q.min.y+2 <= r.max.y)\n\t\t\tq.max.y = q.min.y+2;\n\t\telse\n\t\t\tq.min.y = q.max.y-2;\n\t}\n\treturn q;\n}\n\nvoid\nscrlresize(void)\n{\n\tfreeimage(scrtmp);\n\tscrtmp = allocimage(display, Rect(0, 0, 32, screen->r.max.y), screen->chan, 0, DNofill);\n\tif(scrtmp == nil)\n\t\terror(\"scroll alloc\");\n}\n\nvoid\ntextscrdraw(Text *t)\n{\n\tRectangle r, r1, r2;\n\tImage *b;\n\n\tif(t->w==nil || t!=&t->w->body)\n\t\treturn;\n\tif(scrtmp == nil)\n\t\tscrlresize();\n\tr = t->scrollr;\n\tb = scrtmp;\n\tr1 = r;\n\tr1.min.x = 0;\n\tr1.max.x = Dx(r);\n\tr2 = scrpos(r1, t->org, t->org+t->fr.nchars, t->file->b.nc);\n\tif(!eqrect(r2, t->lastsr)){\n\t\tt->lastsr = r2;\n\t\tdraw(b, r1, t->fr.cols[BORD], nil, ZP);\n\t\tdraw(b, r2, t->fr.cols[BACK], nil, ZP);\n\t\tr2.min.x = r2.max.x-1;\n\t\tdraw(b, r2, t->fr.cols[BORD], nil, ZP);\n\t\tdraw(t->fr.b, r, b, nil, Pt(0, r1.min.y));\n/*flushimage(display, 1); // BUG? */\n\t}\n}\n\nvoid\nscrsleep(uint dt)\n{\n\tTimer\t*timer;\n\tstatic Alt alts[3];\n\n\ttimer = timerstart(dt);\n\talts[0].c = timer->c;\n\talts[0].v = nil;\n\talts[0].op = CHANRCV;\n\talts[1].c = mousectl->c;\n\talts[1].v = &mousectl->m;\n\talts[1].op = CHANRCV;\n\talts[2].op = CHANEND;\n\tfor(;;)\n\t\tswitch(alt(alts)){\n\t\tcase 0:\n\t\t\ttimerstop(timer);\n\t\t\treturn;\n\t\tcase 1:\n\t\t\ttimercancel(timer);\n\t\t\treturn;\n\t\t}\n}\n\nvoid\ntextscroll(Text *t, int but)\n{\n\tuint p0, oldp0;\n\tRectangle s;\n\tint x, y, my, h, first;\n\n\ts = insetrect(t->scrollr, 1);\n\th = s.max.y-s.min.y;\n\tx = (s.min.x+s.max.x)/2;\n\toldp0 = ~0;\n\tfirst = TRUE;\n\tdo{\n\t\tflushimage(display, 1);\n\t\tmy = mouse->xy.y;\n\t\tif(my < s.min.y)\n\t\t\tmy = s.min.y;\n\t\tif(my >= s.max.y)\n\t\t\tmy = s.max.y;\n\t\tif(!eqpt(mouse->xy, Pt(x, my))){\n\t\t\tmoveto(mousectl, Pt(x, my));\n\t\t\treadmouse(mousectl);\t\t/* absorb event generated by moveto() */\n\t\t}\n\t\tif(but == 2){\n\t\t\ty = my;\n\t\t\tp0 = (vlong)t->file->b.nc*(y-s.min.y)/h;\n\t\t\tif(p0 >= t->q1)\n\t\t\t\tp0 = textbacknl(t, p0, 2);\n\t\t\tif(oldp0 != p0)\n\t\t\t\ttextsetorigin(t, p0, FALSE);\n\t\t\toldp0 = p0;\n\t\t\treadmouse(mousectl);\n\t\t\tcontinue;\n\t\t}\n\t\tif(but == 1)\n\t\t\tp0 = textbacknl(t, t->org, (my-s.min.y)/t->fr.font->height);\n\t\telse\n\t\t\tp0 = t->org+frcharofpt(&t->fr, Pt(s.max.x, my));\n\t\tif(oldp0 != p0)\n\t\t\ttextsetorigin(t, p0, TRUE);\n\t\toldp0 = p0;\n\t\t/* debounce */\n\t\tif(first){\n\t\t\tflushimage(display, 1);\n\t\t\tsleep(200);\n\t\t\tnbrecv(mousectl->c, &mousectl->m);\n\t\t\tfirst = FALSE;\n\t\t}\n\t\tscrsleep(80);\n\t}while(mouse->buttons & (1<<(but-1)));\n\twhile(mouse->buttons)\n\t\treadmouse(mousectl);\n}\n", "source": "acme2k/src/cmd/acme/scrl.c", "file_type": "c"}
{"text": "#include <u.h>\n#include <libc.h>\n#include <draw.h>\n#include <thread.h>\n#include <cursor.h>\n#include <mouse.h>\n#include <keyboard.h>\n#include <frame.h>\n#include <fcall.h>\n#include <plumb.h>\n#include <libsec.h>\n#include \"dat.h\"\n#include \"fns.h\"\n#include \"edit.h\"\n\nstatic char Wsequence[] = \"warning: changes out of sequence\\n\";\nstatic int\twarned = FALSE;\n\n/*\n * Log of changes made by editing commands.  Three reasons for this:\n * 1) We want addresses in commands to apply to old file, not file-in-change.\n * 2) It's difficult to track changes correctly as things move, e.g. ,x m$\n * 3) This gives an opportunity to optimize by merging adjacent changes.\n * It's a little bit like the Undo/Redo log in Files, but Point 3) argues for a\n * separate implementation.  To do this well, we use Replace as well as\n * Insert and Delete\n */\n\ntypedef struct Buflog Buflog;\nstruct Buflog\n{\n\tshort\ttype;\t\t/* Replace, Filename */\n\tuint\t\tq0;\t\t/* location of change (unused in f) */\n\tuint\t\tnd;\t\t/* # runes to delete */\n\tuint\t\tnr;\t\t/* # runes in string or file name */\n};\n\nenum\n{\n\tBuflogsize = sizeof(Buflog)/sizeof(Rune)\n};\n\n/*\n * Minstring shouldn't be very big or we will do lots of I/O for small changes.\n * Maxstring is RBUFSIZE so we can fbufalloc() once and not realloc elog.r.\n */\nenum\n{\n\tMinstring = 16,\t\t/* distance beneath which we merge changes */\n\tMaxstring = RBUFSIZE\t/* maximum length of change we will merge into one */\n};\n\nvoid\neloginit(File *f)\n{\n\tif(f->elog.type != Empty)\n\t\treturn;\n\tf->elog.type = Null;\n\tif(f->elogbuf == nil)\n\t\tf->elogbuf = emalloc(sizeof(Buffer));\n\tif(f->elog.r == nil)\n\t\tf->elog.r = fbufalloc();\n\tbufreset(f->elogbuf);\n}\n\nvoid\nelogclose(File *f)\n{\n\tif(f->elogbuf){\n\t\tbufclose(f->elogbuf);\n\t\tfree(f->elogbuf);\n\t\tf->elogbuf = nil;\n\t}\n}\n\nvoid\nelogreset(File *f)\n{\n\tf->elog.type = Null;\n\tf->elog.nd = 0;\n\tf->elog.nr = 0;\n}\n\nvoid\nelogterm(File *f)\n{\n\telogreset(f);\n\tif(f->elogbuf)\n\t\tbufreset(f->elogbuf);\n\tf->elog.type = Empty;\n\tfbuffree(f->elog.r);\n\tf->elog.r = nil;\n\twarned = FALSE;\n}\n\nvoid\nelogflush(File *f)\n{\n\tBuflog b;\n\n\tb.type = f->elog.type;\n\tb.q0 = f->elog.q0;\n\tb.nd = f->elog.nd;\n\tb.nr = f->elog.nr;\n\tswitch(f->elog.type){\n\tdefault:\n\t\twarning(nil, \"unknown elog type 0x%ux\\n\", f->elog.type);\n\t\tbreak;\n\tcase Null:\n\t\tbreak;\n\tcase Insert:\n\tcase Replace:\n\t\tif(f->elog.nr > 0)\n\t\t\tbufinsert(f->elogbuf, f->elogbuf->nc, f->elog.r, f->elog.nr);\n\t\t/* fall through */\n\tcase Delete:\n\t\tbufinsert(f->elogbuf, f->elogbuf->nc, (Rune*)&b, Buflogsize);\n\t\tbreak;\n\t}\n\telogreset(f);\n}\n\nvoid\nelogreplace(File *f, int q0, int q1, Rune *r, int nr)\n{\n\tuint gap;\n\n\tif(q0==q1 && nr==0)\n\t\treturn;\n\teloginit(f);\n\tif(f->elog.type!=Null && q0<f->elog.q0){\n\t\tif(warned++ == 0)\n\t\t\twarning(nil, Wsequence);\n\t\telogflush(f);\n\t}\n\t/* try to merge with previous */\n\tgap = q0 - (f->elog.q0+f->elog.nd);\t/* gap between previous and this */\n\tif(f->elog.type==Replace && f->elog.nr+gap+nr<Maxstring){\n\t\tif(gap < Minstring){\n\t\t\tif(gap > 0){\n\t\t\t\tbufread(&f->b, f->elog.q0+f->elog.nd, f->elog.r+f->elog.nr, gap);\n\t\t\t\tf->elog.nr += gap;\n\t\t\t}\n\t\t\tf->elog.nd += gap + q1-q0;\n\t\t\trunemove(f->elog.r+f->elog.nr, r, nr);\n\t\t\tf->elog.nr += nr;\n\t\t\treturn;\n\t\t}\n\t}\n\telogflush(f);\n\tf->elog.type = Replace;\n\tf->elog.q0 = q0;\n\tf->elog.nd = q1-q0;\n\tf->elog.nr = nr;\n\tif(nr > RBUFSIZE)\n\t\tediterror(\"internal error: replacement string too large(%d)\", nr);\n\trunemove(f->elog.r, r, nr);\n}\n\nvoid\neloginsert(File *f, int q0, Rune *r, int nr)\n{\n\tint n;\n\n\tif(nr == 0)\n\t\treturn;\n\teloginit(f);\n\tif(f->elog.type!=Null && q0<f->elog.q0){\n\t\tif(warned++ == 0)\n\t\t\twarning(nil, Wsequence);\n\t\telogflush(f);\n\t}\n\t/* try to merge with previous */\n\tif(f->elog.type==Insert && q0==f->elog.q0 && f->elog.nr+nr<Maxstring){\n\t\trunemove(f->elog.r+f->elog.nr, r, nr);\n\t\tf->elog.nr += nr;\n\t\treturn;\n\t}\n\twhile(nr > 0){\n\t\telogflush(f);\n\t\tf->elog.type = Insert;\n\t\tf->elog.q0 = q0;\n\t\tn = nr;\n\t\tif(n > RBUFSIZE)\n\t\t\tn = RBUFSIZE;\n\t\tf->elog.nr = n;\n\t\trunemove(f->elog.r, r, n);\n\t\tr += n;\n\t\tnr -= n;\n\t}\n}\n\nvoid\nelogdelete(File *f, int q0, int q1)\n{\n\tif(q0 == q1)\n\t\treturn;\n\teloginit(f);\n\tif(f->elog.type!=Null && q0<f->elog.q0+f->elog.nd){\n\t\tif(warned++ == 0)\n\t\t\twarning(nil, Wsequence);\n\t\telogflush(f);\n\t}\n\t/* try to merge with previous */\n\tif(f->elog.type==Delete && f->elog.q0+f->elog.nd==q0){\n\t\tf->elog.nd += q1-q0;\n\t\treturn;\n\t}\n\telogflush(f);\n\tf->elog.type = Delete;\n\tf->elog.q0 = q0;\n\tf->elog.nd = q1-q0;\n}\n\n#define tracelog 0\nvoid\nelogapply(File *f)\n{\n\tBuflog b;\n\tRune *buf;\n\tuint i, n, up, mod;\n\tuint tq0, tq1;\n\tBuffer *log;\n\tText *t;\n\tint owner;\n\n\telogflush(f);\n\tlog = f->elogbuf;\n\tt = f->curtext;\n\n\tbuf = fbufalloc();\n\tmod = FALSE;\n\n\towner = 0;\n\tif(t->w){\n\t\towner = t->w->owner;\n\t\tif(owner == 0)\n\t\t\tt->w->owner = 'E';\n\t}\n\n\t/*\n\t * The edit commands have already updated the selection in t->q0, t->q1,\n\t * but using coordinates relative to the unmodified buffer.  As we apply the log,\n\t * we have to update the coordinates to be relative to the modified buffer.\n\t * Textinsert and textdelete will do this for us; our only work is to apply the\n\t * convention that an insertion at t->q0==t->q1 is intended to select the \n\t * inserted text.\n\t */\n\n\t/*\n\t * We constrain the addresses in here (with textconstrain()) because\n\t * overlapping changes will generate bogus addresses.   We will warn\n\t * about changes out of sequence but proceed anyway; here we must\n\t * keep things in range.\n\t */\n\n\twhile(log->nc > 0){\n\t\tup = log->nc-Buflogsize;\n\t\tbufread(log, up, (Rune*)&b, Buflogsize);\n\t\tswitch(b.type){\n\t\tdefault:\n\t\t\tfprint(2, \"elogapply: 0x%ux\\n\", b.type);\n\t\t\tabort();\n\t\t\tbreak;\n\n\t\tcase Replace:\n\t\t\tif(tracelog)\n\t\t\t\twarning(nil, \"elog replace %d %d (%d %d)\\n\",\n\t\t\t\t\tb.q0, b.q0+b.nd, t->q0, t->q1);\n\t\t\tif(!mod){\n\t\t\t\tmod = TRUE;\n\t\t\t\tfilemark(f);\n\t\t\t}\n\t\t\ttextconstrain(t, b.q0, b.q0+b.nd, &tq0, &tq1);\n\t\t\ttextdelete(t, tq0, tq1, TRUE);\n\t\t\tup -= b.nr;\n\t\t\tfor(i=0; i<b.nr; i+=n){\n\t\t\t\tn = b.nr - i;\n\t\t\t\tif(n > RBUFSIZE)\n\t\t\t\t\tn = RBUFSIZE;\n\t\t\t\tbufread(log, up+i, buf, n);\n\t\t\t\ttextinsert(t, tq0+i, buf, n, TRUE);\n\t\t\t}\n\t\t\tif(t->q0 == b.q0 && t->q1 == b.q0)\n\t\t\t\tt->q1 += b.nr;\n\t\t\tbreak;\n\n\t\tcase Delete:\n\t\t\tif(tracelog)\n\t\t\t\twarning(nil, \"elog delete %d %d (%d %d)\\n\",\n\t\t\t\t\tb.q0, b.q0+b.nd, t->q0, t->q1);\n\t\t\tif(!mod){\n\t\t\t\tmod = TRUE;\n\t\t\t\tfilemark(f);\n\t\t\t}\n\t\t\ttextconstrain(t, b.q0, b.q0+b.nd, &tq0, &tq1);\n\t\t\ttextdelete(t, tq0, tq1, TRUE);\n\t\t\tbreak;\n\n\t\tcase Insert:\n\t\t\tif(tracelog)\n\t\t\t\twarning(nil, \"elog insert %d %d (%d %d)\\n\",\n\t\t\t\t\tb.q0, b.q0+b.nr, t->q0, t->q1);\n\t\t\tif(!mod){\n\t\t\t\tmod = TRUE;\n\t\t\t\tfilemark(f);\n\t\t\t}\n\t\t\ttextconstrain(t, b.q0, b.q0, &tq0, &tq1);\n\t\t\tup -= b.nr;\n\t\t\tfor(i=0; i<b.nr; i+=n){\n\t\t\t\tn = b.nr - i;\n\t\t\t\tif(n > RBUFSIZE)\n\t\t\t\t\tn = RBUFSIZE;\n\t\t\t\tbufread(log, up+i, buf, n);\n\t\t\t\ttextinsert(t, tq0+i, buf, n, TRUE);\n\t\t\t}\n\t\t\tif(t->q0 == b.q0 && t->q1 == b.q0)\n\t\t\t\tt->q1 += b.nr;\n\t\t\tbreak;\n\n/*\t\tcase Filename:\n\t\t\tf->seq = u.seq;\n\t\t\tfileunsetname(f, epsilon);\n\t\t\tf->mod = u.mod;\n\t\t\tup -= u.n;\n\t\t\tfree(f->name);\n\t\t\tif(u.n == 0)\n\t\t\t\tf->name = nil;\n\t\t\telse\n\t\t\t\tf->name = runemalloc(u.n);\n\t\t\tbufread(delta, up, f->name, u.n);\n\t\t\tf->nname = u.n;\n\t\t\tbreak;\n*/\n\t\t}\n\t\tbufdelete(log, up, log->nc);\n\t}\n\tfbuffree(buf);\n\telogterm(f);\n\t\n\t/*\n\t * Bad addresses will cause bufload to crash, so double check.\n\t * If changes were out of order, we expect problems so don't complain further.\n\t */\n\tif(t->q0 > f->b.nc || t->q1 > f->b.nc || t->q0 > t->q1){\n\t\tif(!warned)\n\t\t\twarning(nil, \"elogapply: can't happen %d %d %d\\n\", t->q0, t->q1, f->b.nc);\n\t\tt->q1 = min(t->q1, f->b.nc);\n\t\tt->q0 = min(t->q0, t->q1);\n\t}\n\n\tif(t->w)\n\t\tt->w->owner = owner;\n}\n", "source": "acme2k/src/cmd/acme/elog.c", "file_type": "c"}
{"text": "#include <u.h>\n#include <libc.h>\n#include <draw.h>\n#include <thread.h>\n#include <cursor.h>\n#include <mouse.h>\n#include <keyboard.h>\n#include <frame.h>\n#include <fcall.h>\n#include <plumb.h>\n#include <libsec.h>\n#include \"dat.h\"\n#include \"fns.h\"\n\nstatic Channel*\tctimer;\t/* chan(Timer*)[100] */\nstatic Timer *timer;\n\nstatic\nuint\nmsec(void)\n{\n\treturn nsec()/1000000;\n}\n\nvoid\ntimerstop(Timer *t)\n{\n\tt->next = timer;\n\ttimer = t;\n}\n\nvoid\ntimercancel(Timer *t)\n{\n\tt->cancel = TRUE;\n}\n\nstatic\nvoid\ntimerproc(void *v)\n{\n\tint i, nt, na, dt, del;\n\tTimer **t, *x;\n\tuint old, new;\n\n\tUSED(v);\n\tthreadsetname(\"timerproc\");\n\trfork(RFFDG);\n\tt = nil;\n\tna = 0;\n\tnt = 0;\n\told = msec();\n\tfor(;;){\n\t\tsleep(10);\t/* longer sleeps here delay recv on ctimer, but 10ms should not be noticeable */\n\t\tnew = msec();\n\t\tdt = new-old;\n\t\told = new;\n\t\tif(dt < 0)\t/* timer wrapped; go around, losing a tick */\n\t\t\tcontinue;\n\t\tfor(i=0; i<nt; i++){\n\t\t\tx = t[i];\n\t\t\tx->dt -= dt;\n\t\t\tdel = FALSE;\n\t\t\tif(x->cancel){\n\t\t\t\ttimerstop(x);\n\t\t\t\tdel = TRUE;\n\t\t\t}else if(x->dt <= 0){\n\t\t\t\t/*\n\t\t\t\t * avoid possible deadlock if client is\n\t\t\t\t * now sending on ctimer\n\t\t\t\t */\n\t\t\t\tif(nbsendul(x->c, 0) > 0)\n\t\t\t\t\tdel = TRUE;\n\t\t\t}\n\t\t\tif(del){\n\t\t\t\tmemmove(&t[i], &t[i+1], (nt-i-1)*sizeof t[0]);\n\t\t\t\t--nt;\n\t\t\t\t--i;\n\t\t\t}\n\t\t}\n\t\tif(nt == 0){\n\t\t\tx = recvp(ctimer);\n\tgotit:\n\t\t\tif(nt == na){\n\t\t\t\tna += 10;\n\t\t\t\tt = realloc(t, na*sizeof(Timer*));\n\t\t\t\tif(t == nil)\n\t\t\t\t\terror(\"timer realloc failed\");\n\t\t\t}\n\t\t\tt[nt++] = x;\n\t\t\told = msec();\n\t\t}\n\t\tif(nbrecv(ctimer, &x) > 0)\n\t\t\tgoto gotit;\n\t}\n}\n\nvoid\ntimerinit(void)\n{\n\tctimer = chancreate(sizeof(Timer*), 100);\n\tchansetname(ctimer, \"ctimer\");\n\tproccreate(timerproc, nil, STACK);\n}\n\nTimer*\ntimerstart(int dt)\n{\n\tTimer *t;\n\n\tt = timer;\n\tif(t)\n\t\ttimer = timer->next;\n\telse{\n\t\tt = emalloc(sizeof(Timer));\n\t\tt->c = chancreate(sizeof(int), 0);\n\t\tchansetname(t->c, \"tc%p\", t->c);\n\t}\n\tt->next = nil;\n\tt->dt = dt;\n\tt->cancel = FALSE;\n\tsendp(ctimer, t);\n\treturn t;\n}\n", "source": "acme2k/src/cmd/acme/time.c", "file_type": "c"}
{"text": "#include <u.h>\n#include <libc.h>\n#include <draw.h>\n#include <thread.h>\n#include <cursor.h>\n#include <mouse.h>\n#include <keyboard.h>\n#include <frame.h>\n#include <fcall.h>\n#include <plumb.h>\n#include <libsec.h>\n#include <complete.h>\n#include \"dat.h\"\n#include \"fns.h\"\n\nImage\t*tagcols[NCOL];\nImage\t*textcols[NCOL];\nstatic Rune Ldot[] = { '.', 0 };\n\nenum{\n\tTABDIR = 3\t/* width of tabs in directory windows */\n};\n\nvoid\ntextinit(Text *t, File *f, Rectangle r, Reffont *rf, Image *cols[NCOL])\n{\n\tt->file = f;\n\tt->all = r;\n\tt->scrollr = r;\n\tt->scrollr.max.x = r.min.x+Scrollwid;\n\tt->lastsr = nullrect;\n\tr.min.x += Scrollwid+Scrollgap;\n\tt->eq0 = ~0;\n\tt->ncache = 0;\n\tt->reffont = rf;\n\tt->tabstop = maxtab;\n\tmemmove(t->fr.cols, cols, sizeof t->fr.cols);\n\ttextredraw(t, r, rf->f, screen, -1);\n}\n\nvoid\ntextredraw(Text *t, Rectangle r, Font *f, Image *b, int odx)\n{\n\tint maxt;\n\tRectangle rr;\n\n\tfrinit(&t->fr, r, f, b, t->fr.cols);\n\trr = t->fr.r;\n\trr.min.x -= Scrollwid+Scrollgap;\t/* back fill to scroll bar */\n\tif(!t->fr.noredraw)\n\t\tdraw(t->fr.b, rr, t->fr.cols[BACK], nil, ZP);\n\t/* use no wider than 3-space tabs in a directory */\n\tmaxt = maxtab;\n\tif(t->what == Body){\n\t\tif(t->w->isdir)\n\t\t\tmaxt = min(TABDIR, maxtab);\n\t\telse\n\t\t\tmaxt = t->tabstop;\n\t}\n\tt->fr.maxtab = maxt*stringwidth(f, \"0\");\n\tif(t->what==Body && t->w->isdir && odx!=Dx(t->all)){\n\t\tif(t->fr.maxlines > 0){\n\t\t\ttextreset(t);\n\t\t\ttextcolumnate(t, t->w->dlp,  t->w->ndl);\n\t\t\ttextshow(t, 0, 0, 1);\n\t\t}\n\t}else{\n\t\ttextfill(t);\n\t\ttextsetselect(t, t->q0, t->q1);\n\t}\n}\n\nint\ntextresize(Text *t, Rectangle r, int keepextra)\n{\n\tint odx;\n\n\tif(Dy(r) <= 0)\n\t\tr.max.y = r.min.y;\n\telse if(!keepextra)\n\t\tr.max.y -= Dy(r)%t->fr.font->height;\n\todx = Dx(t->all);\n\tt->all = r;\n\tt->scrollr = r;\n\tt->scrollr.max.x = r.min.x+Scrollwid;\n\tt->lastsr = nullrect;\n\tr.min.x += Scrollwid+Scrollgap;\n\tfrclear(&t->fr, 0);\n\ttextredraw(t, r, t->fr.font, t->fr.b, odx);\n\tif(keepextra && t->fr.r.max.y < t->all.max.y && !t->fr.noredraw){\n\t\t/* draw background in bottom fringe of window */\n\t\tr.min.x -= Scrollgap;\n\t\tr.min.y = t->fr.r.max.y;\n\t\tr.max.y = t->all.max.y;\n\t\tdraw(screen, r, t->fr.cols[BACK], nil, ZP);\n\t}\n\treturn t->all.max.y;\n}\n\nvoid\ntextclose(Text *t)\n{\n\tfree(t->cache);\n\tfrclear(&t->fr, 1);\n\tfiledeltext(t->file, t);\n\tt->file = nil;\n\trfclose(t->reffont);\n\tif(argtext == t)\n\t\targtext = nil;\n\tif(typetext == t)\n\t\ttypetext = nil;\n\tif(seltext == t)\n\t\tseltext = nil;\n\tif(mousetext == t)\n\t\tmousetext = nil;\n\tif(barttext == t)\n\t\tbarttext = nil;\n}\n\nint\ndircmp(const void *a, const void *b)\n{\n\tDirlist *da, *db;\n\tint i, n;\n\n\tda = *(Dirlist**)a;\n\tdb = *(Dirlist**)b;\n\tn = min(da->nr, db->nr);\n\ti = memcmp(da->r, db->r, n*sizeof(Rune));\n\tif(i)\n\t\treturn i;\n\treturn da->nr - db->nr;\n}\n\nvoid\ntextcolumnate(Text *t, Dirlist **dlp, int ndl)\n{\n\tint i, j, w, colw, mint, maxt, ncol, nrow;\n\tDirlist *dl;\n\tuint q1;\n\tstatic Rune Lnl[] = { '\\n', 0 };\n\tstatic Rune Ltab[] = { '\\t', 0 };\n\n\tif(t->file->ntext > 1)\n\t\treturn;\n\tmint = stringwidth(t->fr.font, \"0\");\n\t/* go for narrower tabs if set more than 3 wide */\n\tt->fr.maxtab = min(maxtab, TABDIR)*mint;\n\tmaxt = t->fr.maxtab;\n\tcolw = 0;\n\tfor(i=0; i<ndl; i++){\n\t\tdl = dlp[i];\n\t\tw = dl->wid;\n\t\tif(maxt-w%maxt < mint || w%maxt==0)\n\t\t\tw += mint;\n\t\tif(w % maxt)\n\t\t\tw += maxt-(w%maxt);\n\t\tif(w > colw)\n\t\t\tcolw = w;\n\t}\n\tif(colw == 0)\n\t\tncol = 1;\n\telse\n\t\tncol = max(1, Dx(t->fr.r)/colw);\n\tnrow = (ndl+ncol-1)/ncol;\n\n\tq1 = 0;\n\tfor(i=0; i<nrow; i++){\n\t\tfor(j=i; j<ndl; j+=nrow){\n\t\t\tdl = dlp[j];\n\t\t\tfileinsert(t->file, q1, dl->r, dl->nr);\n\t\t\tq1 += dl->nr;\n\t\t\tif(j+nrow >= ndl)\n\t\t\t\tbreak;\n\t\t\tw = dl->wid;\n\t\t\tif(maxt-w%maxt < mint){\n\t\t\t\tfileinsert(t->file, q1, Ltab, 1);\n\t\t\t\tq1++;\n\t\t\t\tw += mint;\n\t\t\t}\n\t\t\tdo{\n\t\t\t\tfileinsert(t->file, q1, Ltab, 1);\n\t\t\t\tq1++;\n\t\t\t\tw += maxt-(w%maxt);\n\t\t\t}while(w < colw);\n\t\t}\n\t\tfileinsert(t->file, q1, Lnl, 1);\n\t\tq1++;\n\t}\n}\n\nint\ntextload(Text *t, uint q0, char *file, int setqid)\n{\n\tRune *rp;\n\tDirlist *dl, **dlp;\n\tint fd, i, j, n, ndl, nulls;\n\tuint q, q1;\n\tDir *d, *dbuf;\n\tchar *tmp;\n\tText *u;\n\tDigestState *h;\n\n\tif(t->ncache!=0 || t->file->b.nc || t->w==nil || t!=&t->w->body)\n\t\terror(\"text.load\");\n\tif(t->w->isdir && t->file->nname==0){\n\t\twarning(nil, \"empty directory name\");\n\t\treturn -1;\n\t}\n\tif(ismtpt(file)){\n\t\twarning(nil, \"will not open self mount point %s\\n\", file);\n\t\treturn -1;\n\t}\n\tfd = open(file, OREAD);\n\tif(fd < 0){\n\t\twarning(nil, \"can't open %s: %r\\n\", file);\n\t\treturn -1;\n\t}\n\td = dirfstat(fd);\n\tif(d == nil){\n\t\twarning(nil, \"can't fstat %s: %r\\n\", file);\n\t\tgoto Rescue;\n\t}\n\tnulls = FALSE;\n\th = nil;\n\tif(d->qid.type & QTDIR){\n\t\t/* this is checked in get() but it's possible the file changed underfoot */\n\t\tif(t->file->ntext > 1){\n\t\t\twarning(nil, \"%s is a directory; can't read with multiple windows on it\\n\", file);\n\t\t\tgoto Rescue;\n\t\t}\n\t\tt->w->isdir = TRUE;\n\t\tt->w->filemenu = FALSE;\n\t\tif(t->file->nname > 0 && t->file->name[t->file->nname-1] != '/'){\n\t\t\trp = runemalloc(t->file->nname+1);\n\t\t\trunemove(rp, t->file->name, t->file->nname);\n\t\t\trp[t->file->nname] = '/';\n\t\t\twinsetname(t->w, rp, t->file->nname+1);\n\t\t\tfree(rp);\n\t\t}\n\t\tdlp = nil;\n\t\tndl = 0;\n\t\tdbuf = nil;\n\t\twhile((n=dirread(fd, &dbuf)) > 0){\n\t\t\tfor(i=0; i<n; i++){\n\t\t\t\tdl = emalloc(sizeof(Dirlist));\n\t\t\t\tj = strlen(dbuf[i].name);\n\t\t\t\ttmp = emalloc(j+1+1);\n\t\t\t\tmemmove(tmp, dbuf[i].name, j);\n\t\t\t\tif(dbuf[i].qid.type & QTDIR)\n\t\t\t\t\ttmp[j++] = '/';\n\t\t\t\ttmp[j] = '\\0';\n\t\t\t\tdl->r = bytetorune(tmp, &dl->nr);\n\t\t\t\tdl->wid = stringwidth(t->fr.font, tmp);\n\t\t\t\tfree(tmp);\n\t\t\t\tndl++;\n\t\t\t\tdlp = realloc(dlp, ndl*sizeof(Dirlist*));\n\t\t\t\tdlp[ndl-1] = dl;\n\t\t\t}\n\t\t\tfree(dbuf);\n\t\t}\n\t\tqsort(dlp, ndl, sizeof(Dirlist*), dircmp);\n\t\tt->w->dlp = dlp;\n\t\tt->w->ndl = ndl;\n\t\ttextcolumnate(t, dlp, ndl);\n\t\tq1 = t->file->b.nc;\n\t}else{\n\t\tt->w->isdir = FALSE;\n\t\tt->w->filemenu = TRUE;\n\t\tif(q0 == 0)\n\t\t\th = sha1(nil, 0, nil, nil);\n\t\tq1 = q0 + fileload(t->file, q0, fd, &nulls, h);\n\t}\n\tif(setqid){\n\t\tif(h != nil) {\n\t\t\tsha1(nil, 0, t->file->sha1, h);\n\t\t\th = nil;\n\t\t} else {\n\t\t\tmemset(t->file->sha1, 0, sizeof t->file->sha1);\n\t\t}\n\t\tt->file->dev = d->dev;\n\t\tt->file->mtime = d->mtime;\n\t\tt->file->qidpath = d->qid.path;\n\t}\n\tclose(fd);\n\trp = fbufalloc();\n\tfor(q=q0; q<q1; q+=n){\n\t\tn = q1-q;\n\t\tif(n > RBUFSIZE)\n\t\t\tn = RBUFSIZE;\n\t\tbufread(&t->file->b, q, rp, n);\n\t\tif(q < t->org)\n\t\t\tt->org += n;\n\t\telse if(q <= t->org+t->fr.nchars)\n\t\t\tfrinsert(&t->fr, rp, rp+n, q-t->org);\n\t\tif(t->fr.lastlinefull)\n\t\t\tbreak;\n\t}\n\tfbuffree(rp);\n\tfor(i=0; i<t->file->ntext; i++){\n\t\tu = t->file->text[i];\n\t\tif(u != t){\n\t\t\tif(u->org > u->file->b.nc)\t/* will be 0 because of reset(), but safety first */\n\t\t\t\tu->org = 0;\n\t\t\ttextresize(u, u->all, TRUE);\n\t\t\ttextbacknl(u, u->org, 0);\t/* go to beginning of line */\n\t\t}\n\t\ttextsetselect(u, q0, q0);\n\t}\n\tif(nulls)\n\t\twarning(nil, \"%s: NUL bytes elided\\n\", file);\n\tfree(d);\n\treturn q1-q0;\n\n    Rescue:\n\tclose(fd);\n\treturn -1;\n}\n\nuint\ntextbsinsert(Text *t, uint q0, Rune *r, uint n, int tofile, int *nrp)\n{\n\tRune *bp, *tp, *up;\n\tint i, initial;\n\n\tif(t->what == Tag){\t/* can't happen but safety first: mustn't backspace over file name */\n    Err:\n\t\ttextinsert(t, q0, r, n, tofile);\n\t\t*nrp = n;\n\t\treturn q0;\n\t}\n\tbp = r;\n\tfor(i=0; i<n; i++)\n\t\tif(*bp++ == '\\b'){\n\t\t\t--bp;\n\t\t\tinitial = 0;\n\t\t\ttp = runemalloc(n);\n\t\t\trunemove(tp, r, i);\n\t\t\tup = tp+i;\n\t\t\tfor(; i<n; i++){\n\t\t\t\t*up = *bp++;\n\t\t\t\tif(*up == '\\b')\n\t\t\t\t\tif(up == tp)\n\t\t\t\t\t\tinitial++;\n\t\t\t\t\telse\n\t\t\t\t\t\t--up;\n\t\t\t\telse\n\t\t\t\t\tup++;\n\t\t\t}\n\t\t\tif(initial){\n\t\t\t\tif(initial > q0)\n\t\t\t\t\tinitial = q0;\n\t\t\t\tq0 -= initial;\n\t\t\t\ttextdelete(t, q0, q0+initial, tofile);\n\t\t\t}\n\t\t\tn = up-tp;\n\t\t\ttextinsert(t, q0, tp, n, tofile);\n\t\t\tfree(tp);\n\t\t\t*nrp = n;\n\t\t\treturn q0;\n\t\t}\n\tgoto Err;\n}\n\nvoid\ntextinsert(Text *t, uint q0, Rune *r, uint n, int tofile)\n{\n\tint c, i;\n\tText *u;\n\n\tif(tofile && t->ncache != 0)\n\t\terror(\"text.insert\");\n\tif(n == 0)\n\t\treturn;\n\tif(tofile){\n\t\tfileinsert(t->file, q0, r, n);\n\t\tif(t->what == Body){\n\t\t\tt->w->dirty = TRUE;\n\t\t\tt->w->utflastqid = -1;\n\t\t}\n\t\tif(t->file->ntext > 1)\n\t\t\tfor(i=0; i<t->file->ntext; i++){\n\t\t\t\tu = t->file->text[i];\n\t\t\t\tif(u != t){\n\t\t\t\t\tu->w->dirty = TRUE;\t/* always a body */\n\t\t\t\t\ttextinsert(u, q0, r, n, FALSE);\n\t\t\t\t\ttextsetselect(u, u->q0, u->q1);\n\t\t\t\t\ttextscrdraw(u);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\t\t\n\t}\n\tif(q0 < t->iq1)\n\t\tt->iq1 += n;\n\tif(q0 < t->q1)\n\t\tt->q1 += n;\n\tif(q0 < t->q0)\n\t\tt->q0 += n;\n\tif(q0 < t->org)\n\t\tt->org += n;\n\telse if(q0 <= t->org+t->fr.nchars)\n\t\tfrinsert(&t->fr, r, r+n, q0-t->org);\n\tif(t->w){\n\t\tc = 'i';\n\t\tif(t->what == Body)\n\t\t\tc = 'I';\n\t\tif(n <= EVENTSIZE)\n\t\t\twinevent(t->w, \"%c%d %d 0 %d %.*S\\n\", c, q0, q0+n, n, n, r);\n\t\telse\n\t\t\twinevent(t->w, \"%c%d %d 0 0 \\n\", c, q0, q0+n, n);\n\t}\n}\n\nvoid\ntypecommit(Text *t)\n{\n\tif(t->w != nil)\n\t\twincommit(t->w, t);\n\telse\n\t\ttextcommit(t, TRUE);\n}\n\nvoid\ntextfill(Text *t)\n{\n\tRune *rp;\n\tint i, n, m, nl;\n\n\tif(t->fr.lastlinefull || t->nofill)\n\t\treturn;\n\tif(t->ncache > 0)\n\t\ttypecommit(t);\n\trp = fbufalloc();\n\tdo{\n\t\tn = t->file->b.nc-(t->org+t->fr.nchars);\n\t\tif(n == 0)\n\t\t\tbreak;\n\t\tif(n > 2000)\t/* educated guess at reasonable amount */\n\t\t\tn = 2000;\n\t\tbufread(&t->file->b, t->org+t->fr.nchars, rp, n);\n\t\t/*\n\t\t * it's expensive to frinsert more than we need, so\n\t\t * count newlines.\n\t\t */\n\t\tnl = t->fr.maxlines-t->fr.nlines;\n\t\tm = 0;\n\t\tfor(i=0; i<n; ){\n\t\t\tif(rp[i++] == '\\n'){\n\t\t\t\tm++;\n\t\t\t\tif(m >= nl)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfrinsert(&t->fr, rp, rp+i, t->fr.nchars);\n\t}while(t->fr.lastlinefull == FALSE);\n\tfbuffree(rp);\n}\n\nvoid\ntextdelete(Text *t, uint q0, uint q1, int tofile)\n{\n\tuint n, p0, p1;\n\tint i, c;\n\tText *u;\n\n\tif(tofile && t->ncache != 0)\n\t\terror(\"text.delete\");\n\tn = q1-q0;\n\tif(n == 0)\n\t\treturn;\n\tif(tofile){\n\t\tfiledelete(t->file, q0, q1);\n\t\tif(t->what == Body){\n\t\t\tt->w->dirty = TRUE;\n\t\t\tt->w->utflastqid = -1;\n\t\t}\n\t\tif(t->file->ntext > 1)\n\t\t\tfor(i=0; i<t->file->ntext; i++){\n\t\t\t\tu = t->file->text[i];\n\t\t\t\tif(u != t){\n\t\t\t\t\tu->w->dirty = TRUE;\t/* always a body */\n\t\t\t\t\ttextdelete(u, q0, q1, FALSE);\n\t\t\t\t\ttextsetselect(u, u->q0, u->q1);\n\t\t\t\t\ttextscrdraw(u);\n\t\t\t\t}\n\t\t\t}\n\t}\n\tif(q0 < t->iq1)\n\t\tt->iq1 -= min(n, t->iq1-q0);\n\tif(q0 < t->q0)\n\t\tt->q0 -= min(n, t->q0-q0);\n\tif(q0 < t->q1)\n\t\tt->q1 -= min(n, t->q1-q0);\n\tif(q1 <= t->org)\n\t\tt->org -= n;\n\telse if(q0 < t->org+t->fr.nchars){\n\t\tp1 = q1 - t->org;\n\t\tif(p1 > t->fr.nchars)\n\t\t\tp1 = t->fr.nchars;\n\t\tif(q0 < t->org){\n\t\t\tt->org = q0;\n\t\t\tp0 = 0;\n\t\t}else\n\t\t\tp0 = q0 - t->org;\n\t\tfrdelete(&t->fr, p0, p1);\n\t\ttextfill(t);\n\t}\n\tif(t->w){\n\t\tc = 'd';\n\t\tif(t->what == Body)\n\t\t\tc = 'D';\n\t\twinevent(t->w, \"%c%d %d 0 0 \\n\", c, q0, q1);\n\t}\n}\n\nvoid\ntextconstrain(Text *t, uint q0, uint q1, uint *p0, uint *p1)\n{\n\t*p0 = min(q0, t->file->b.nc);\n\t*p1 = min(q1, t->file->b.nc);\n}\n\nRune\ntextreadc(Text *t, uint q)\n{\n\tRune r;\n\n\tif(t->cq0<=q && q<t->cq0+t->ncache)\n\t\tr = t->cache[q-t->cq0];\n\telse\n\t\tbufread(&t->file->b, q, &r, 1);\n\treturn r;\n}\n\nint\ntextbswidth(Text *t, Rune c)\n{\n\tuint q, eq;\n\tRune r;\n\tint skipping;\n\n\t/* there is known to be at least one character to erase */\n\tif(c == 0x08)\t/* ^H: erase character */\n\t\treturn 1;\n\tq = t->q0;\n\tskipping = TRUE;\n\twhile(q > 0){\n\t\tr = textreadc(t, q-1);\n\t\tif(r == '\\n'){\t\t/* eat at most one more character */\n\t\t\tif(q == t->q0)\t/* eat the newline */\n\t\t\t\t--q;\n\t\t\tbreak; \n\t\t}\n\t\tif(c == 0x17){\n\t\t\teq = isalnum(r);\n\t\t\tif(eq && skipping)\t/* found one; stop skipping */\n\t\t\t\tskipping = FALSE;\n\t\t\telse if(!eq && !skipping)\n\t\t\t\tbreak;\n\t\t}\n\t\t--q;\n\t}\n\treturn t->q0-q;\n}\n\nint\ntextfilewidth(Text *t, uint q0, int oneelement)\n{\n\tuint q;\n\tRune r;\n\n\tq = q0;\n\twhile(q > 0){\n\t\tr = textreadc(t, q-1);\n\t\tif(r <= ' ')\n\t\t\tbreak;\n\t\tif(oneelement && r=='/')\n\t\t\tbreak;\n\t\t--q;\n\t}\n\treturn q0-q;\n}\n\nRune*\ntextcomplete(Text *t)\n{\n\tint i, nstr, npath;\n\tuint q;\n\tRune tmp[200];\n\tRune *str, *path;\n\tRune *rp;\n\tCompletion *c;\n\tchar *s, *dirs;\n\tRunestr dir;\n\n\t/* control-f: filename completion; works back to white space or / */\n\tif(t->q0<t->file->b.nc && textreadc(t, t->q0)>' ')\t/* must be at end of word */\n\t\treturn nil;\n\tnstr = textfilewidth(t, t->q0, TRUE);\n\tstr = runemalloc(nstr);\n\tnpath = textfilewidth(t, t->q0-nstr, FALSE);\n\tpath = runemalloc(npath);\n\n\tc = nil;\n\trp = nil;\n\tdirs = nil;\n\n\tq = t->q0-nstr;\n\tfor(i=0; i<nstr; i++)\n\t\tstr[i] = textreadc(t, q++);\n\tq = t->q0-nstr-npath;\n\tfor(i=0; i<npath; i++)\n\t\tpath[i] = textreadc(t, q++);\n\t/* is path rooted? if not, we need to make it relative to window path */\n\tif(npath>0 && path[0]=='/')\n\t\tdir = runestr(path, npath);\n\telse{\n\t\tdir = dirname(t, nil, 0);\n\t\tif(dir.nr + 1 + npath > nelem(tmp)){\n\t\t\tfree(dir.r);\n\t\t\tgoto Return;\n\t\t}\n\t\tif(dir.nr == 0){\n\t\t\tdir.nr = 1;\n\t\t\tdir.r = runestrdup(Ldot);\n\t\t}\n\t\trunemove(tmp, dir.r, dir.nr);\n\t\ttmp[dir.nr] = '/';\n\t\trunemove(tmp+dir.nr+1, path, npath);\n\t\tfree(dir.r);\n\t\tdir.r = tmp;\n\t\tdir.nr += 1+npath;\n\t\tdir = cleanrname(dir);\n\t}\n\n\ts = smprint(\"%.*S\", nstr, str);\n\tdirs = smprint(\"%.*S\", dir.nr, dir.r);\n\tc = complete(dirs, s);\n\tfree(s);\n\tif(c == nil){\n\t\twarning(nil, \"error attempting completion: %r\\n\");\n\t\tgoto Return;\n\t}\n\n\tif(!c->advance){\n\t\twarning(nil, \"%.*S%s%.*S*%s\\n\",\n\t\t\tdir.nr, dir.r,\n\t\t\tdir.nr>0 && dir.r[dir.nr-1]!='/' ? \"/\" : \"\",\n\t\t\tnstr, str,\n\t\t\tc->nmatch ? \"\" : \": no matches in:\");\n\t\tfor(i=0; i<c->nfile; i++)\n\t\t\twarning(nil, \" %s\\n\", c->filename[i]);\n\t}\n\n\tif(c->advance)\n\t\trp = runesmprint(\"%s\", c->string);\n\telse\n\t\trp = nil;\n  Return:\n\tfreecompletion(c);\n\tfree(dirs);\n\tfree(str);\n\tfree(path);\n\treturn rp;\n}\n\nvoid\ntexttype(Text *t, Rune r)\n{\n\tuint q0, q1;\n\tint nnb, nb, n, i;\n\tint nr;\n\tRune *rp;\n\tText *u;\n\n\tif(t->what!=Body && t->what!=Tag && r=='\\n')\n\t\treturn;\n\tif(t->what == Tag)\n\t\tt->w->tagsafe = FALSE;\n\n\tnr = 1;\n\trp = &r;\n\tswitch(r){\n\tcase Kleft:\n\t\ttypecommit(t);\n\t\tif(t->q0 > 0)\n\t\t\ttextshow(t, t->q0-1, t->q0-1, TRUE);\n\t\treturn;\n\tcase Kright:\n\t\ttypecommit(t);\n\t\tif(t->q1 < t->file->b.nc)\n\t\t\ttextshow(t, t->q1+1, t->q1+1, TRUE);\n\t\treturn;\n\tcase Kscrollonedown:\n\t\tif(t->what == Tag)\n\t\t\tgoto Tagdown;\n\t\tn = mousescrollsize(t->fr.maxlines);\n\t\tif(n <= 0)\n\t\t\tn = 1;\n\t\tgoto case_Down;\n\tcase Kpgdown:\n\t\tn = 2*t->fr.maxlines/3;\n\tcase_Down:\n\t\tq0 = t->org+frcharofpt(&t->fr, Pt(t->fr.r.min.x, t->fr.r.min.y+n*t->fr.font->height));\n\t\ttextsetorigin(t, q0, TRUE);\n\t\treturn;\t\n\tcase Kscrolloneup:\n\t\tif(t->what == Tag)\n\t\t\tgoto Tagup;\n\t\tn = mousescrollsize(t->fr.maxlines);\n\t\tgoto case_Up;\n\tcase Kpgup:\n\t\tn = 2*t->fr.maxlines/3;\n\tcase_Up:\n\t\tq0 = textbacknl(t, t->org, n);\n\t\ttextsetorigin(t, q0, TRUE);\n\t\treturn;\n\n/* \n *  Keybindings for moving the cursor up and \n *  down the text via up and down arrow keys.\n */\n\t\n\tcase Kdown:\n\t\tif(t->what == Tag)\n \t\t\tgoto Tagdown;\n\t\ttypecommit(t);\n\t\t/* 1rst check for being in the last line*/\t\n\t\tq0 = t->q0;\n\t\tq1 = q0;\n\t\tif (q1) q1--;\n\t\tnnb = 0;\n\t\twhile(q0<t->file->b.nc && textreadc(t, q0)!='\\n')\n\t\t\tq0++;\n\t\tif (q0 == (t->file->b.nc)-1) {\n\t\t\ttextshow(t, q0, q0, TRUE);\n\t\t\treturn;\n\t\t}\n\t\tq0++;\n\t\t/* find old pos in ln */\n\t\twhile(q1>1 && textreadc(t, q1)!='\\n'){\n\t\t\tnnb++;\n\t\t\tq1--;\n\t\t}\n\t\t/* go right until reachg pos or \\n */\n\t\twhile(q0<t->file->b.nc && (nnb>0 && textreadc(t, q0)!='\\n')){\n\t\t\tq0++;\n\t\t\tnnb--;\n\t\t}\n\t\tif (q0>1 && q0<t->file->b.nc)\n\t\t\ttextshow(t, q0, q0, TRUE);\n\t\treturn;\n\tcase Kup:\n\t\tif(t->what == Tag)\n\t\t\tgoto Tagup;\n\t\ttypecommit(t);\n\t\tnnb = 0;\n\t\tif(t->q0>0 && textreadc(t, t->q0-1)!='\\n')\n\t\t\tnnb = textbswidth(t, 0x15); \n\t\t/* BOL - 1 if not first line of txt BOL*/\n\t\tif( t->q0-nnb > 1  && textreadc(t, t->q0-nnb-1)=='\\n' ) nnb++;\n\t\ttextshow(t, t->q0-nnb, t->q0-nnb, TRUE);\n\t\treturn;\n\n/*\n *  Home and End now respectively take you to the\n *  beginning and to the end of the line respectively.\n *  Also keep the original ^A and ^E keybindings.\n */\n\n\tcase 0x01:\n\tcase Khome:\n\t\ttypecommit(t);\n\t\t/* go to where ^U would erase, if not already at BOL */\n\t\tnnb = 0;\n\t\tif(t->q0>0 && textreadc(t, t->q0-1)!='\\n')\n\t\t\tnnb = textbswidth(t, 0x15);\n\t\ttextshow(t, t->q0-nnb, t->q0-nnb, TRUE);\n\t\treturn;\n\tcase 0x05:\n\tcase Kend:\n\t\ttypecommit(t);\n\t\tq0 = t->q0;\n\t\twhile(q0<t->file->b.nc && textreadc(t, q0)!='\\n')\n\t\t\tq0++;\n\t\ttextshow(t, q0, q0, TRUE);\n\t\treturn;\n\t\t\n/* I'll keep the MAC-keybindings 'cuz im such a nice guy */\n\n\tcase Kcmd+'c':\t/* %C: copy */\n\t\ttypecommit(t);\n\t\tcut(t, t, nil, TRUE, FALSE, nil, 0);\n\t\treturn;\n\tcase Kcmd+'z':\t/* %Z: undo */\n\t \ttypecommit(t);\n\t\tundo(t, nil, nil, TRUE, 0, nil, 0);\n\t\treturn;\n\tcase Kcmd+'Z':\t/* %-shift-Z: redo */\n\t \ttypecommit(t);\n\t\tundo(t, nil, nil, FALSE, 0, nil, 0);\n\t\treturn;\t\n\n/*\n *  Adding Windows and X11 -compatible Ctrl+C, Ctrl+Z and\n *  Ctrl+Y (for redoing). TODO: find out how to check out for\n *  shift press, for Ctrl+Shift+Z in this godforsaken switch()\n */\n\n\tcase 0x03:\t/* Ctrl+C: copy */\n\t\ttypecommit(t);\n\t\tcut(t, t, nil, TRUE, FALSE, nil, 0);\n\t\treturn;\n\tcase 0x1A:\t/* Ctrl+Z: undo */\n\t \ttypecommit(t);\n\t\tundo(t, nil, nil, TRUE, 0, nil, 0);\n\t\treturn;\n\tcase 0x19:\t/* Ctrl+Y: redo */\n\t \ttypecommit(t);\n\t\tundo(t, nil, nil, FALSE, 0, nil, 0);\n\t\treturn;\n\n\tTagdown:\n\t\t/* expand tag to show all text */\n\t\tif(!t->w->tagexpand){\n\t\tt->w->tagexpand = TRUE;\n\t\twinresize(t->w, t->w->r, FALSE, TRUE);\n\t\t}\n\t\treturn;\n\tTagup:\n\t\t/* shrink tag to single line */\n\t\tif(t->w->tagexpand){\n\t\t\tt->w->tagexpand = FALSE;\n\t\t\tt->w->taglines = 1;\n\t\t\twinresize(t->w, t->w->r, FALSE, TRUE);\n\t\t}\n\t\treturn;\n\t}\n\t\n\n\t\n\tif(t->what == Body){\n\t\tseq++;\n\t\tfilemark(t->file);\n\t}\n\t\n\t/* cut/paste must be done after th\u0005\u0005e seq++/filemark \u0005\u0005\u0005\u0005*/\n\t\n\tswitch(r){\n\tcase Kcmd+'x':\t/* %X: cut */\n\t\ttypecommit(t);\n\t\tif(t->what == Body){\n\t\t\tseq++;\n\t\t\tfilemark(t->file);\n\t\t}\n\t\tcut(t, t, nil, TRUE, TRUE, nil, 0);\n\t\ttextshow(t, t->q0, t->q0, 1);\n\t\tt->iq1 = t->q0;\n\t\treturn;\n\tcase Kcmd+'v':\t/* %V: paste */\n\t\ttypecommit(t);\n\t\tif(t->what == Body){\n\t\t\tseq++;\n\t\t\tfilemark(t->file);\n\t\t}\n\t\tpaste(t, t, nil, TRUE, FALSE, nil, 0);\n\t\ttextshow(t, t->q0, t->q1, 1);\n\t\tt->iq1 = t->q1;\n\t\treturn;\n\t\n\t/* Same for Windows / X11 */\n\t\n\tcase 0x18:\t/* Ctrl+X: cut */\n\t\ttypecommit(t);\n\t\tif(t->what == Body){\n\t\t\tseq++;\n\t\t\tfilemark(t->file);\n\t\t}\n\t\tcut(t, t, nil, TRUE, TRUE, nil, 0);\n\t\ttextshow(t, t->q0, t->q0, 1);\n\t\tt->iq1 = t->q0;\n\t\treturn;\n\tcase 0x16:\t/* Ctrl+V: paste */\n\t\ttypecommit(t);\n\t\tif(t->what == Body){\n\t\t\tseq++;\n\t\t\tfilemark(t->file);\n\t\t}\n\t\tpaste(t, t, nil, TRUE, FALSE, nil, 0);\n\t\ttextshow(t, t->q0, t->q1, 1);\n\t\tt->iq1 = t->q1;\n\t\treturn;\n\t}\n\n\tif(t->q1 > t->q0){\n\t\tif(t->ncache != 0)\n\t\t\terror(\"text.type\");\n\t\tcut(t, t, nil, TRUE, TRUE, nil, 0);\n\t\tt->eq0 = ~0;\n\t}\n\ttextshow(t, t->q0, t->q0, 1);\n\t\n\tswitch(r){\n\tcase 0x06:\t/* ^F: complete */\n\tcase Kins:\n\t\ttypecommit(t);\n\t\trp = textcomplete(t);\n\t\tif(rp == nil)\n\t\t\treturn;\n\t\tnr = runestrlen(rp);\n\t\tbreak;\t/* fall through to normal insertion case */\n\tcase 0x1B:\n\t\tif(t->eq0 != ~0) {\n\t\t\tif(t->eq0 <= t->q0)\n\t\t\t\ttextsetselect(t, t->eq0, t->q0);\n\t\t\telse\n\t\t\t\ttextsetselect(t, t->q0, t->eq0);\n\t\t}\n\t\tif(t->ncache > 0)\n\t\t\ttypecommit(t);\n\t\tt->iq1 = t->q0;\n\t\treturn;\n\n/*\n *  quick hack for DELETE-key, just added it to see what happens and\n *  apparently it works like ^U and erases whole lines. i should learn c\n */\n \n\t\t\n\tcase 0x08:\t/* ^H: erase character */\n\tcase 0x15:\t/* ^U: erase line */\n\tcase 0x7F:\n\tcase 0x17:\t/* ^W: erase  word */\n\t\tif(t->q0 == 0)\t/* nothing to erase */\n\t\t\treturn;\n\t\tnnb = textbswidth(t, r);\n\t\tq1 = t->q0;\n\t\tq0 = q1-nnb;\n\t\t/* if selection is at beginning of window, avoid deleting invisible text */\n\t\tif(q0 < t->org){\n\t\t\tq0 = t->org;\n\t\t\tnnb = q1-q0;\n\t\t}\n\t\tif(nnb <= 0)\n\t\t\treturn;\n\t\tfor(i=0; i<t->file->ntext; i++){\n\t\t\tu = t->file->text[i];\n\t\t\tu->nofill = TRUE;\n\t\t\tnb = nnb;\n\t\t\tn = u->ncache;\n\t\t\tif(n > 0){\n\t\t\t\tif(q1 != u->cq0+n)\n\t\t\t\t\terror(\"text.type backspace\");\n\t\t\t\tif(n > nb)\n\t\t\t\t\tn = nb;\n\t\t\t\tu->ncache -= n;\n\t\t\t\ttextdelete(u, q1-n, q1, FALSE);\n\t\t\t\tnb -= n;\n\t\t\t}\n\t\t\tif(u->eq0==q1 || u->eq0==~0)\n\t\t\t\tu->eq0 = q0;\n\t\t\tif(nb && u==t)\n\t\t\t\ttextdelete(u, q0, q0+nb, TRUE);\n\t\t\tif(u != t)\n\t\t\t\ttextsetselect(u, u->q0, u->q1);\n\t\t\telse\n\t\t\t\ttextsetselect(t, q0, q0);\n\t\t\tu->nofill = FALSE;\n\t\t}\n\t\tfor(i=0; i<t->file->ntext; i++)\n\t\t\ttextfill(t->file->text[i]);\n\t\tt->iq1 = t->q0;\n\t\treturn;\n\tcase '\\n':\n\t\tif(t->w->autoindent){\n\t\t\t/* find beginning of previous line using backspace code */\n\t\t\tnnb = textbswidth(t, 0x15); /* ^U case */\n\t\t\trp = runemalloc(nnb + 1);\n\t\t\tnr = 0;\n\t\t\trp[nr++] = r;\n\t\t\tfor(i=0; i<nnb; i++){\n\t\t\t\tr = textreadc(t, t->q0-nnb+i);\n\t\t\t\tif(r != ' ' && r != '\\t')\n\t\t\t\t\tbreak;\n\t\t\t\trp[nr++] = r;\n\t\t\t}\n\t\t}\n\t\tbreak; /* fall through to normal code */\n\t}\n\t/* otherwise ordinary character; just insert, typically in caches of all texts */\n\tfor(i=0; i<t->file->ntext; i++){\n\t\tu = t->file->text[i];\n\t\tif(u->eq0 == ~0)\n\t\t\tu->eq0 = t->q0;\n\t\tif(u->ncache == 0)\n\t\t\tu->cq0 = t->q0;\n\t\telse if(t->q0 != u->cq0+u->ncache)\n\t\t\terror(\"text.type cq1\");\n\t\t/*\n\t\t * Change the tag before we add to ncache,\n\t\t * so that if the window body is resized the\n\t\t * commit will not find anything in ncache.\n\t\t */\n\t\tif(u->what==Body && u->ncache == 0){\n\t\t\tu->needundo = TRUE;\n\t\t\twinsettag(t->w);\n\t\t\tu->needundo = FALSE;\n\t\t}\n\t\ttextinsert(u, t->q0, rp, nr, FALSE);\n\t\tif(u != t)\n\t\t\ttextsetselect(u, u->q0, u->q1);\n\t\tif(u->ncache+nr > u->ncachealloc){\n\t\t\tu->ncachealloc += 10 + nr;\n\t\t\tu->cache = runerealloc(u->cache, u->ncachealloc);\n\t\t}\n\t\trunemove(u->cache+u->ncache, rp, nr);\n\t\tu->ncache += nr;\n\t}\n\tif(rp != &r)\n\t\tfree(rp);\n\ttextsetselect(t, t->q0+nr, t->q0+nr);\n\tif(r=='\\n' && t->w!=nil)\n\t\twincommit(t->w, t);\n\tt->iq1 = t->q0;\n}\n\nvoid\ntextcommit(Text *t, int tofile)\n{\n\tif(t->ncache == 0)\n\t\treturn;\n\tif(tofile)\n\t\tfileinsert(t->file, t->cq0, t->cache, t->ncache);\n\tif(t->what == Body){\n\t\tt->w->dirty = TRUE;\n\t\tt->w->utflastqid = -1;\n\t}\n\tt->ncache = 0;\n}\n\nstatic\tText\t*clicktext;\nstatic\tuint\tclickmsec;\nstatic\tText\t*selecttext;\nstatic\tuint\tselectq;\n\n/*\n * called from frame library\n */\nvoid\nframescroll(Frame *f, int dl)\n{\n\tif(f != &selecttext->fr)\n\t\terror(\"frameselect not right frame\");\n\ttextframescroll(selecttext, dl);\n}\n\nvoid\ntextframescroll(Text *t, int dl)\n{\n\tuint q0;\n\n\tif(dl == 0){\n\t\tscrsleep(100);\n\t\treturn;\n\t}\n\tif(dl < 0){\n\t\tq0 = textbacknl(t, t->org, -dl);\n\t\tif(selectq > t->org+t->fr.p0)\n\t\t\ttextsetselect(t, t->org+t->fr.p0, selectq);\n\t\telse\n\t\t\ttextsetselect(t, selectq, t->org+t->fr.p0);\n\t}else{\n\t\tif(t->org+t->fr.nchars == t->file->b.nc)\n\t\t\treturn;\n\t\tq0 = t->org+frcharofpt(&t->fr, Pt(t->fr.r.min.x, t->fr.r.min.y+dl*t->fr.font->height));\n\t\tif(selectq > t->org+t->fr.p1)\n\t\t\ttextsetselect(t, t->org+t->fr.p1, selectq);\n\t\telse\n\t\t\ttextsetselect(t, selectq, t->org+t->fr.p1);\n\t}\n\ttextsetorigin(t, q0, TRUE);\n}\n\n\nvoid\ntextselect(Text *t)\n{\n\tuint q0, q1;\n\tint b, x, y;\n\tint state;\n\tenum { None, Cut, Paste };\n\n\tselecttext = t;\n\t/*\n\t * To have double-clicking and chording, we double-click\n\t * immediately if it might make sense.\n\t */\n\tb = mouse->buttons;\n\tq0 = t->q0;\n\tq1 = t->q1;\n\tselectq = t->org+frcharofpt(&t->fr, mouse->xy);\n\tif(clicktext==t && mouse->msec-clickmsec<500)\n\tif(q0==q1 && selectq==q0){\n\t\ttextdoubleclick(t, &q0, &q1);\n\t\ttextsetselect(t, q0, q1);\n\t\tflushimage(display, 1);\n\t\tx = mouse->xy.x;\n\t\ty = mouse->xy.y;\n\t\t/* stay here until something interesting happens */\n\t\tdo\n\t\t\treadmouse(mousectl);\n\t\twhile(mouse->buttons==b && abs(mouse->xy.x-x)<3 && abs(mouse->xy.y-y)<3);\n\t\tmouse->xy.x = x;\t/* in case we're calling frselect */\n\t\tmouse->xy.y = y;\n\t\tq0 = t->q0;\t/* may have changed */\n\t\tq1 = t->q1;\n\t\tselectq = q0;\n\t}\n\tif(mouse->buttons == b){\n\t\tt->fr.scroll = framescroll;\n\t\tfrselect(&t->fr, mousectl);\n\t\t/* horrible botch: while asleep, may have lost selection altogether */\n\t\tif(selectq > t->file->b.nc)\n\t\t\tselectq = t->org + t->fr.p0;\n\t\tt->fr.scroll = nil;\n\t\tif(selectq < t->org)\n\t\t\tq0 = selectq;\n\t\telse\n\t\t\tq0 = t->org + t->fr.p0;\n\t\tif(selectq > t->org+t->fr.nchars)\n\t\t\tq1 = selectq;\n\t\telse\n\t\t\tq1 = t->org+t->fr.p1;\n\t}\n\tif(q0 == q1){\n\t\tif(q0==t->q0 && clicktext==t && mouse->msec-clickmsec<500){\n\t\t\ttextdoubleclick(t, &q0, &q1);\n\t\t\tclicktext = nil;\n\t\t}else{\n\t\t\tclicktext = t;\n\t\t\tclickmsec = mouse->msec;\n\t\t}\n\t}else\n\t\tclicktext = nil;\n\ttextsetselect(t, q0, q1);\n\tflushimage(display, 1);\n\tstate = None;\t/* what we've done; undo when possible */\n\twhile(mouse->buttons){\n\t\tmouse->msec = 0;\n\t\tb = mouse->buttons;\n\t\tif((b&1) && (b&6)){\n\t\t\tif(state==None && t->what==Body){\n\t\t\t\tseq++;\n\t\t\t\tfilemark(t->w->body.file);\n\t\t\t}\n\t\t\tif(b & 2){\n\t\t\t\tif(state==Paste && t->what==Body){\n\t\t\t\t\twinundo(t->w, TRUE);\n\t\t\t\t\ttextsetselect(t, q0, t->q1);\n\t\t\t\t\tstate = None;\n\t\t\t\t}else if(state != Cut){\n\t\t\t\t\tcut(t, t, nil, TRUE, TRUE, nil, 0);\n\t\t\t\t\tstate = Cut;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(state==Cut && t->what==Body){\n\t\t\t\t\twinundo(t->w, TRUE);\n\t\t\t\t\ttextsetselect(t, q0, t->q1);\n\t\t\t\t\tstate = None;\n\t\t\t\t}else if(state != Paste){\n\t\t\t\t\tpaste(t, t, nil, TRUE, FALSE, nil, 0);\n\t\t\t\t\tstate = Paste;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttextscrdraw(t);\n\t\t\tclearmouse();\n\t\t}\n\t\tflushimage(display, 1);\n\t\twhile(mouse->buttons == b)\n\t\t\treadmouse(mousectl);\n\t\tclicktext = nil;\n\t}\n}\n\nvoid\ntextshow(Text *t, uint q0, uint q1, int doselect)\n{\n\tint qe;\n\tint nl;\n\tint tsd;\n\tint nc;\n\tuint q;\n\n\tif(t->what != Body){\n\t\tif(doselect)\n\t\t\ttextsetselect(t, q0, q1);\n\t\treturn;\n\t}\n\tif(t->w!=nil && t->fr.maxlines==0)\n\t\tcolgrow(t->col, t->w, 1);\n\tif(doselect)\n\t\ttextsetselect(t, q0, q1);\n\tqe = t->org+t->fr.nchars;\n\ttsd = FALSE;\t/* do we call textscrdraw? */\n\tnc = t->file->b.nc+t->ncache;\n\tif(t->org <= q0){\n\t\tif(nc==0 || q0<qe)\n\t\t\ttsd = TRUE;\n\t\telse if(q0==qe && qe==nc){\n\t\t\tif(textreadc(t, nc-1) == '\\n'){\n\t\t\t\tif(t->fr.nlines<t->fr.maxlines)\n\t\t\t\t\ttsd = TRUE;\n\t\t\t}else\n\t\t\t\ttsd = TRUE;\n\t\t}\n\t}\n\tif(tsd)\n\t\ttextscrdraw(t);\n\telse{\n\t\tif(t->w->nopen[QWevent] > 0)\n\t\t\tnl = 3*t->fr.maxlines/4;\n\t\telse\n\t\t\tnl = t->fr.maxlines/4;\n\t\tq = textbacknl(t, q0, nl);\n\t\t/* avoid going backwards if trying to go forwards - long lines! */\n\t\tif(!(q0>t->org && q<t->org))\n\t\t\ttextsetorigin(t, q, TRUE);\n\t\twhile(q0 > t->org+t->fr.nchars)\n\t\t\ttextsetorigin(t, t->org+1, FALSE);\n\t}\n}\n\nstatic\nint\nregion(int a, int b)\n{\n\tif(a < b)\n\t\treturn -1;\n\tif(a == b)\n\t\treturn 0;\n\treturn 1;\n}\n\nvoid\nselrestore(Frame *f, Point pt0, uint p0, uint p1)\n{\n\tif(p1<=f->p0 || p0>=f->p1){\n\t\t/* no overlap */\n\t\tfrdrawsel0(f, pt0, p0, p1, f->cols[BACK], f->cols[TEXT]);\n\t\treturn;\n\t}\n\tif(p0>=f->p0 && p1<=f->p1){\n\t\t/* entirely inside */\n\t\tfrdrawsel0(f, pt0, p0, p1, f->cols[HIGH], f->cols[HTEXT]);\n\t\treturn;\n\t}\n\n\t/* they now are known to overlap */\n\n\t/* before selection */\n\tif(p0 < f->p0){\n\t\tfrdrawsel0(f, pt0, p0, f->p0, f->cols[BACK], f->cols[TEXT]);\n\t\tp0 = f->p0;\n\t\tpt0 = frptofchar(f, p0);\n\t}\n\t/* after selection */\n\tif(p1 > f->p1){\n\t\tfrdrawsel0(f, frptofchar(f, f->p1), f->p1, p1, f->cols[BACK], f->cols[TEXT]);\n\t\tp1 = f->p1;\n\t}\n\t/* inside selection */\n\tfrdrawsel0(f, pt0, p0, p1, f->cols[HIGH], f->cols[HTEXT]);\n}\n\nvoid\ntextsetselect(Text *t, uint q0, uint q1)\n{\n\tint p0, p1, ticked;\n\t\n\t/* t->fr.p0 and t->fr.p1 are always right; t->q0 and t->q1 may be off */\n\tt->q0 = q0;\n\tt->q1 = q1;\n\t/* compute desired p0,p1 from q0,q1 */\n\tp0 = q0-t->org;\n\tp1 = q1-t->org;\n\tticked = 1;\n\tif(p0 < 0){\n\t\tticked = 0;\n\t\tp0 = 0;\n\t}\n\tif(p1 < 0)\n\t\tp1 = 0;\n\tif(p0 > t->fr.nchars)\n\t\tp0 = t->fr.nchars;\n\tif(p1 > t->fr.nchars){\n\t\tticked = 0;\n\t\tp1 = t->fr.nchars;\n\t}\n\tif(p0==t->fr.p0 && p1==t->fr.p1){\n\t\tif(p0 == p1 && ticked != t->fr.ticked)\n\t\t\tfrtick(&t->fr, frptofchar(&t->fr, p0), ticked);\n\t\treturn;\n\t}\n\tif(p0 > p1)\n\t\tsysfatal(\"acme: textsetselect p0=%d p1=%d q0=%ud q1=%ud t->org=%d nchars=%d\", p0, p1, q0, q1, (int)t->org, (int)t->fr.nchars);\n\t/* screen disagrees with desired selection */\n\tif(t->fr.p1<=p0 || p1<=t->fr.p0 || p0==p1 || t->fr.p1==t->fr.p0){\n\t\t/* no overlap or too easy to bother trying */\n\t\tfrdrawsel(&t->fr, frptofchar(&t->fr, t->fr.p0), t->fr.p0, t->fr.p1, 0);\n\t\tif(p0 != p1 || ticked)\n\t\t\tfrdrawsel(&t->fr, frptofchar(&t->fr, p0), p0, p1, 1);\n\t\tgoto Return;\n\t}\n\t/* overlap; avoid unnecessary painting */\n\tif(p0 < t->fr.p0){\n\t\t/* extend selection backwards */\n\t\tfrdrawsel(&t->fr, frptofchar(&t->fr, p0), p0, t->fr.p0, 1);\n\t}else if(p0 > t->fr.p0){\n\t\t/* trim first part of selection */\n\t\tfrdrawsel(&t->fr, frptofchar(&t->fr, t->fr.p0), t->fr.p0, p0, 0);\n\t}\n\tif(p1 > t->fr.p1){\n\t\t/* extend selection forwards */\n\t\tfrdrawsel(&t->fr, frptofchar(&t->fr, t->fr.p1), t->fr.p1, p1, 1);\n\t}else if(p1 < t->fr.p1){\n\t\t/* trim last part of selection */\n\t\tfrdrawsel(&t->fr, frptofchar(&t->fr, p1), p1, t->fr.p1, 0);\n\t}\n\n    Return:\n\tt->fr.p0 = p0;\n\tt->fr.p1 = p1;\n}\n\n/*\n * Release the button in less than DELAY ms and it's considered a null selection\n * if the mouse hardly moved, regardless of whether it crossed a char boundary.\n */\nenum {\n\tDELAY = 2,\n\tMINMOVE = 4\n};\n\nuint\nxselect(Frame *f, Mousectl *mc, Image *col, uint *p1p)\t/* when called, button is down */\n{\n\tuint p0, p1, q, tmp;\n\tulong msec;\n\tPoint mp, pt0, pt1, qt;\n\tint reg, b;\n\n\tmp = mc->m.xy;\n\tb = mc->m.buttons;\n\tmsec = mc->m.msec;\n\n\t/* remove tick */\n\tif(f->p0 == f->p1)\n\t\tfrtick(f, frptofchar(f, f->p0), 0);\n\tp0 = p1 = frcharofpt(f, mp);\n\tpt0 = frptofchar(f, p0);\n\tpt1 = frptofchar(f, p1);\n\treg = 0;\n\tfrtick(f, pt0, 1);\n\tdo{\n\t\tq = frcharofpt(f, mc->m.xy);\n\t\tif(p1 != q){\n\t\t\tif(p0 == p1)\n\t\t\t\tfrtick(f, pt0, 0);\n\t\t\tif(reg != region(q, p0)){\t/* crossed starting point; reset */\n\t\t\t\tif(reg > 0)\n\t\t\t\t\tselrestore(f, pt0, p0, p1);\n\t\t\t\telse if(reg < 0)\n\t\t\t\t\tselrestore(f, pt1, p1, p0);\n\t\t\t\tp1 = p0;\n\t\t\t\tpt1 = pt0;\n\t\t\t\treg = region(q, p0);\n\t\t\t\tif(reg == 0)\n\t\t\t\t\tfrdrawsel0(f, pt0, p0, p1, col, display->white);\n\t\t\t}\n\t\t\tqt = frptofchar(f, q);\n\t\t\tif(reg > 0){\n\t\t\t\tif(q > p1)\n\t\t\t\t\tfrdrawsel0(f, pt1, p1, q, col, display->white);\n\n\t\t\t\telse if(q < p1)\n\t\t\t\t\tselrestore(f, qt, q, p1);\n\t\t\t}else if(reg < 0){\n\t\t\t\tif(q > p1)\n\t\t\t\t\tselrestore(f, pt1, p1, q);\n\t\t\t\telse\n\t\t\t\t\tfrdrawsel0(f, qt, q, p1, col, display->white);\n\t\t\t}\n\t\t\tp1 = q;\n\t\t\tpt1 = qt;\n\t\t}\n\t\tif(p0 == p1)\n\t\t\tfrtick(f, pt0, 1);\n\t\tflushimage(f->display, 1);\n\t\treadmouse(mc);\n\t}while(mc->m.buttons == b);\n\tif(mc->m.msec-msec < DELAY && p0!=p1\n\t&& abs(mp.x-mc->m.xy.x)<MINMOVE\n\t&& abs(mp.y-mc->m.xy.y)<MINMOVE) {\n\t\tif(reg > 0)\n\t\t\tselrestore(f, pt0, p0, p1);\n\t\telse if(reg < 0)\n\t\t\tselrestore(f, pt1, p1, p0);\n\t\tp1 = p0;\n\t}\n\tif(p1 < p0){\n\t\ttmp = p0;\n\t\tp0 = p1;\n\t\tp1 = tmp;\n\t}\n\tpt0 = frptofchar(f, p0);\n\tif(p0 == p1)\n\t\tfrtick(f, pt0, 0);\n\tselrestore(f, pt0, p0, p1);\n\t/* restore tick */\n\tif(f->p0 == f->p1)\n\t\tfrtick(f, frptofchar(f, f->p0), 1);\n\tflushimage(f->display, 1);\n\t*p1p = p1;\n\treturn p0;\n}\n\nint\ntextselect23(Text *t, uint *q0, uint *q1, Image *high, int mask)\n{\n\tuint p0, p1;\n\tint buts;\n\t\n\tp0 = xselect(&t->fr, mousectl, high, &p1);\n\tbuts = mousectl->m.buttons;\n\tif((buts & mask) == 0){\n\t\t*q0 = p0+t->org;\n\t\t*q1 = p1+t->org;\n\t}\n\n\twhile(mousectl->m.buttons)\n\t\treadmouse(mousectl);\n\treturn buts;\n}\n\nint\ntextselect2(Text *t, uint *q0, uint *q1, Text **tp)\n{\n\tint buts;\n\n\t*tp = nil;\n\tbuts = textselect23(t, q0, q1, but2col, 4);\n\tif(buts & 4)\n\t\treturn 0;\n\tif(buts & 1){\t/* pick up argument */\n\t\t*tp = argtext;\n\t\treturn 1;\n\t}\n\treturn 1;\n}\n\nint\ntextselect3(Text *t, uint *q0, uint *q1)\n{\n\tint h;\n\n\th = (textselect23(t, q0, q1, but3col, 1|2) == 0);\n\treturn h;\n}\n\nstatic Rune left1[] =  { '{', '[', '(', '<', 0xab, 0 };\nstatic Rune right1[] = { '}', ']', ')', '>', 0xbb, 0 };\nstatic Rune left2[] =  { '\\n', 0 };\nstatic Rune left3[] =  { '\\'', '\"', '`', 0 };\n\nstatic\nRune *left[] = {\n\tleft1,\n\tleft2,\n\tleft3,\n\tnil\n};\nstatic\nRune *right[] = {\n\tright1,\n\tleft2,\n\tleft3,\n\tnil\n};\n\nvoid\ntextdoubleclick(Text *t, uint *q0, uint *q1)\n{\n\tint c, i;\n\tRune *r, *l, *p;\n\tuint q;\n\n\tif(textclickhtmlmatch(t, q0, q1))\n\t\treturn;\n\t\n\tfor(i=0; left[i]!=nil; i++){\n\t\tq = *q0;\n\t\tl = left[i];\n\t\tr = right[i];\n\t\t/* try matching character to left, looking right */\n\t\tif(q == 0)\n\t\t\tc = '\\n';\n\t\telse\n\t\t\tc = textreadc(t, q-1);\n\t\tp = runestrchr(l, c);\n\t\tif(p != nil){\n\t\t\tif(textclickmatch(t, c, r[p-l], 1, &q))\n\t\t\t\t*q1 = q-(c!='\\n');\n\t\t\treturn;\n\t\t}\n\t\t/* try matching character to right, looking left */\n\t\tif(q == t->file->b.nc)\n\t\t\tc = '\\n';\n\t\telse\n\t\t\tc = textreadc(t, q);\n\t\tp = runestrchr(r, c);\n\t\tif(p != nil){\n\t\t\tif(textclickmatch(t, c, l[p-r], -1, &q)){\n\t\t\t\t*q1 = *q0+(*q0<t->file->b.nc && c=='\\n');\n\t\t\t\t*q0 = q;\n\t\t\t\tif(c!='\\n' || q!=0 || textreadc(t, 0)=='\\n')\n\t\t\t\t\t(*q0)++;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n\t\n\t/* try filling out word to right */\n\twhile(*q1<t->file->b.nc && isalnum(textreadc(t, *q1)))\n\t\t(*q1)++;\n\t/* try filling out word to left */\n\twhile(*q0>0 && isalnum(textreadc(t, *q0-1)))\n\t\t(*q0)--;\n}\n\nint\ntextclickmatch(Text *t, int cl, int cr, int dir, uint *q)\n{\n\tRune c;\n\tint nest;\n\n\tnest = 1;\n\tfor(;;){\n\t\tif(dir > 0){\n\t\t\tif(*q == t->file->b.nc)\n\t\t\t\tbreak;\n\t\t\tc = textreadc(t, *q);\n\t\t\t(*q)++;\n\t\t}else{\n\t\t\tif(*q == 0)\n\t\t\t\tbreak;\n\t\t\t(*q)--;\n\t\t\tc = textreadc(t, *q);\n\t\t}\n\t\tif(c == cr){\n\t\t\tif(--nest==0)\n\t\t\t\treturn 1;\n\t\t}else if(c == cl)\n\t\t\tnest++;\n\t}\n\treturn cl=='\\n' && nest==1;\n}\n\n// Is the text starting at location q an html tag?\n// Return 1 for <a>, -1 for </a>, 0 for no tag or <a />.\n// Set *q1, if non-nil, to the location after the tag.\nstatic int\nishtmlstart(Text *t, uint q, uint *q1)\n{\n\tint c, c1, c2;\n\n\tif(q+2 > t->file->b.nc)\n\t\treturn 0;\n\tif(textreadc(t, q++) != '<')\n\t\treturn 0;\n\tc = textreadc(t, q++);\n\tc1 = c;\n\tc2 = c;\n\twhile(c != '>') {\n\t\tif(q >= t->file->b.nc)\n\t\t\treturn 0;\n\t\tc2 = c;\n\t\tc = textreadc(t, q++);\n\t}\n\tif(q1)\n\t\t*q1 = q;\n\tif(c1 == '/')\t// closing tag\n\t\treturn -1;\n\tif(c2 == '/' || c2 == '!')\t// open + close tag or comment\n\t\treturn 0;\n\treturn 1;\n}\n\n// Is the text ending at location q an html tag?\n// Return 1 for <a>, -1 for </a>, 0 for no tag or <a />.\n// Set *q0, if non-nil, to the start of the tag.\nstatic int\nishtmlend(Text *t, uint q, uint *q0)\n{\n\tint c, c1, c2;\n\t\n\tif(q < 2)\n\t\treturn 0;\n\tif(textreadc(t, --q) != '>')\n\t\treturn 0;\n\tc = textreadc(t, --q);\n\tc1 = c;\n\tc2 = c;\n\twhile(c != '<') {\n\t\tif(q == 0)\n\t\t\treturn 0;\n\t\tc1 = c;\n\t\tc = textreadc(t, --q);\n\t}\n\tif(q0)\n\t\t*q0 = q;\n\tif(c1 == '/')\t// closing tag\n\t\treturn -1;\n\tif(c2 == '/' || c2 == '!')\t// open + close tag or comment\n\t\treturn 0;\n\treturn 1;\n}\n\nint\ntextclickhtmlmatch(Text *t, uint *q0, uint *q1)\n{\n\tint depth, n;\n\tuint q, nq;\n\t\n\tq = *q0;\n\t// after opening tag?  scan forward for closing tag\n\tif(ishtmlend(t, q, nil) == 1) {\n\t\tdepth = 1;\n\t\twhile(q < t->file->b.nc) {\n\t\t\tn = ishtmlstart(t, q, &nq);\n\t\t\tif(n != 0) {\n\t\t\t\tdepth += n;\n\t\t\t\tif(depth == 0) {\n\t\t\t\t\t*q1 = q;\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\tq = nq;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tq++;\n\t\t}\n\t}\n\n\t// before closing tag?  scan backward for opening tag\n\tif(ishtmlstart(t, q, nil) == -1) {\n\t\tdepth = -1;\n\t\twhile(q > 0) {\n\t\t\tn = ishtmlend(t, q, &nq);\n\t\t\tif(n != 0) {\n\t\t\t\tdepth += n;\n\t\t\t\tif(depth == 0) {\n\t\t\t\t\t*q0 = q;\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\tq = nq;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tq--;\n\t\t}\n\t}\n\t\n\treturn 0;\n}\n\nuint\ntextbacknl(Text *t, uint p, uint n)\n{\n\tint i, j;\n\n\t/* look for start of this line if n==0 */\n\tif(n==0 && p>0 && textreadc(t, p-1)!='\\n')\n\t\tn = 1;\n\ti = n;\n\twhile(i-->0 && p>0){\n\t\t--p;\t/* it's at a newline now; back over it */\n\t\tif(p == 0)\n\t\t\tbreak;\n\t\t/* at 128 chars, call it a line anyway */\n\t\tfor(j=128; --j>0 && p>0; p--)\n\t\t\tif(textreadc(t, p-1)=='\\n')\n\t\t\t\tbreak;\n\t}\n\treturn p;\n}\n\nvoid\ntextsetorigin(Text *t, uint org, int exact)\n{\n\tint i, a, fixup;\n\tRune *r;\n\tuint n;\n\n\tif(org>0 && !exact && textreadc(t, org-1) != '\\n'){\n\t\t/* org is an estimate of the char posn; find a newline */\n\t\t/* don't try harder than 256 chars */\n\t\tfor(i=0; i<256 && org<t->file->b.nc; i++){\n\t\t\tif(textreadc(t, org) == '\\n'){\n\t\t\t\torg++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\torg++;\n\t\t}\n\t}\n\ta = org-t->org;\n\tfixup = 0;\n\tif(a>=0 && a<t->fr.nchars){\n\t\tfrdelete(&t->fr, 0, a);\n\t\tfixup = 1;\t/* frdelete can leave end of last line in wrong selection mode; it doesn't know what follows */\n\t}\n\telse if(a<0 && -a<t->fr.nchars){\n\t\tn = t->org - org;\n\t\tr = runemalloc(n);\n\t\tbufread(&t->file->b, org, r, n);\n\t\tfrinsert(&t->fr, r, r+n, 0);\n\t\tfree(r);\n\t}else\n\t\tfrdelete(&t->fr, 0, t->fr.nchars);\n\tt->org = org;\n\ttextfill(t);\n\ttextscrdraw(t);\n\ttextsetselect(t, t->q0, t->q1);\n\tif(fixup && t->fr.p1 > t->fr.p0)\n\t\tfrdrawsel(&t->fr, frptofchar(&t->fr, t->fr.p1-1), t->fr.p1-1, t->fr.p1, 1);\n}\n\nvoid\ntextreset(Text *t)\n{\n\tt->file->seq = 0;\n\tt->eq0 = ~0;\n\t/* do t->delete(0, t->nc, TRUE) without building backup stuff */\n\ttextsetselect(t, t->org, t->org);\n\tfrdelete(&t->fr, 0, t->fr.nchars);\n\tt->org = 0;\n\tt->q0 = 0;\n\tt->q1 = 0;\n\tfilereset(t->file);\n\tbufreset(&t->file->b);\n}\n", "source": "acme2k/src/cmd/acme/text.c", "file_type": "c"}
{"text": "#include <u.h>\n#include <libc.h>\n#include <draw.h>\n#include <thread.h>\n#include <cursor.h>\n#include <mouse.h>\n#include <keyboard.h>\n#include <frame.h>\n#include <fcall.h>\n#include <plumb.h>\n#include <libsec.h>\n#include \"dat.h\"\n#include \"fns.h\"\n\n/*\n * Structure of Undo list:\n * \tThe Undo structure follows any associated data, so the list\n *\tcan be read backwards: read the structure, then read whatever\n *\tdata is associated (insert string, file name) and precedes it.\n *\tThe structure includes the previous value of the modify bit\n *\tand a sequence number; successive Undo structures with the\n *\tsame sequence number represent simultaneous changes.\n */\n\ntypedef struct Undo Undo;\nstruct Undo\n{\n\tshort\ttype;\t\t/* Delete, Insert, Filename */\n\tshort\tmod;\t/* modify bit */\n\tuint\t\tseq;\t\t/* sequence number */\n\tuint\t\tp0;\t\t/* location of change (unused in f) */\n\tuint\t\tn;\t\t/* # runes in string or file name */\n};\n\nenum\n{\n\tUndosize = sizeof(Undo)/sizeof(Rune)\n};\n\nFile*\nfileaddtext(File *f, Text *t)\n{\n\tif(f == nil){\n\t\tf = emalloc(sizeof(File));\n\t\tf->unread = TRUE;\n\t}\n\tf->text = realloc(f->text, (f->ntext+1)*sizeof(Text*));\n\tf->text[f->ntext++] = t;\n\tf->curtext = t;\n\treturn f;\n}\n\nvoid\nfiledeltext(File *f, Text *t)\n{\n\tint i;\n\n\tfor(i=0; i<f->ntext; i++)\n\t\tif(f->text[i] == t)\n\t\t\tgoto Found;\n\terror(\"can't find text in filedeltext\");\n\n    Found:\n\tf->ntext--;\n\tif(f->ntext == 0){\n\t\tfileclose(f);\n\t\treturn;\n\t}\n\tmemmove(f->text+i, f->text+i+1, (f->ntext-i)*sizeof(Text*));\n\tif(f->curtext == t)\n\t\tf->curtext = f->text[0];\n}\n\nvoid\nfileinsert(File *f, uint p0, Rune *s, uint ns)\n{\n\tif(p0 > f->b.nc)\n\t\terror(\"internal error: fileinsert\");\n\tif(f->seq > 0)\n\t\tfileuninsert(f, &f->delta, p0, ns);\n\tbufinsert(&f->b, p0, s, ns);\n\tif(ns)\n\t\tf->mod = TRUE;\n}\n\nvoid\nfileuninsert(File *f, Buffer *delta, uint p0, uint ns)\n{\n\tUndo u;\n\n\t/* undo an insertion by deleting */\n\tu.type = Delete;\n\tu.mod = f->mod;\n\tu.seq = f->seq;\n\tu.p0 = p0;\n\tu.n = ns;\n\tbufinsert(delta, delta->nc, (Rune*)&u, Undosize);\n}\n\nvoid\nfiledelete(File *f, uint p0, uint p1)\n{\n\tif(!(p0<=p1 && p0<=f->b.nc && p1<=f->b.nc))\n\t\terror(\"internal error: filedelete\");\n\tif(f->seq > 0)\n\t\tfileundelete(f, &f->delta, p0, p1);\n\tbufdelete(&f->b, p0, p1);\n\tif(p1 > p0)\n\t\tf->mod = TRUE;\n}\n\nvoid\nfileundelete(File *f, Buffer *delta, uint p0, uint p1)\n{\n\tUndo u;\n\tRune *buf;\n\tuint i, n;\n\n\t/* undo a deletion by inserting */\n\tu.type = Insert;\n\tu.mod = f->mod;\n\tu.seq = f->seq;\n\tu.p0 = p0;\n\tu.n = p1-p0;\n\tbuf = fbufalloc();\n\tfor(i=p0; i<p1; i+=n){\n\t\tn = p1 - i;\n\t\tif(n > RBUFSIZE)\n\t\t\tn = RBUFSIZE;\n\t\tbufread(&f->b, i, buf, n);\n\t\tbufinsert(delta, delta->nc, buf, n);\n\t}\n\tfbuffree(buf);\n\tbufinsert(delta, delta->nc, (Rune*)&u, Undosize);\n\n}\n\nvoid\nfilesetname(File *f, Rune *name, int n)\n{\n\tif(f->seq > 0)\n\t\tfileunsetname(f, &f->delta);\n\tfree(f->name);\n\tf->name = runemalloc(n);\n\trunemove(f->name, name, n);\n\tf->nname = n;\n\tf->unread = TRUE;\n}\n\nvoid\nfileunsetname(File *f, Buffer *delta)\n{\n\tUndo u;\n\n\t/* undo a file name change by restoring old name */\n\tu.type = Filename;\n\tu.mod = f->mod;\n\tu.seq = f->seq;\n\tu.p0 = 0;\t/* unused */\n\tu.n = f->nname;\n\tif(f->nname)\n\t\tbufinsert(delta, delta->nc, f->name, f->nname);\n\tbufinsert(delta, delta->nc, (Rune*)&u, Undosize);\n}\n\nuint\nfileload(File *f, uint p0, int fd, int *nulls, DigestState *h)\n{\n\tif(f->seq > 0)\n\t\terror(\"undo in file.load unimplemented\");\n\treturn bufload(&f->b, p0, fd, nulls, h);\n}\n\n/* return sequence number of pending redo */\nuint\nfileredoseq(File *f)\n{\n\tUndo u;\n\tBuffer *delta;\n\n\tdelta = &f->epsilon;\n\tif(delta->nc == 0)\n\t\treturn 0;\n\tbufread(delta, delta->nc-Undosize, (Rune*)&u, Undosize);\n\treturn u.seq;\n}\n\nvoid\nfileundo(File *f, int isundo, uint *q0p, uint *q1p)\n{\n\tUndo u;\n\tRune *buf;\n\tuint i, j, n, up;\n\tuint stop;\n\tBuffer *delta, *epsilon;\n\n\tif(isundo){\n\t\t/* undo; reverse delta onto epsilon, seq decreases */\n\t\tdelta = &f->delta;\n\t\tepsilon = &f->epsilon;\n\t\tstop = f->seq;\n\t}else{\n\t\t/* redo; reverse epsilon onto delta, seq increases */\n\t\tdelta = &f->epsilon;\n\t\tepsilon = &f->delta;\n\t\tstop = 0;\t/* don't know yet */\n\t}\n\n\tbuf = fbufalloc();\n\twhile(delta->nc > 0){\n\t\tup = delta->nc-Undosize;\n\t\tbufread(delta, up, (Rune*)&u, Undosize);\n\t\tif(isundo){\n\t\t\tif(u.seq < stop){\n\t\t\t\tf->seq = u.seq;\n\t\t\t\tgoto Return;\n\t\t\t}\n\t\t}else{\n\t\t\tif(stop == 0)\n\t\t\t\tstop = u.seq;\n\t\t\tif(u.seq > stop)\n\t\t\t\tgoto Return;\n\t\t}\n\t\tswitch(u.type){\n\t\tdefault:\n\t\t\tfprint(2, \"undo: 0x%ux\\n\", u.type);\n\t\t\tabort();\n\t\t\tbreak;\n\n\t\tcase Delete:\n\t\t\tf->seq = u.seq;\n\t\t\tfileundelete(f, epsilon, u.p0, u.p0+u.n);\n\t\t\tf->mod = u.mod;\n\t\t\tbufdelete(&f->b, u.p0, u.p0+u.n);\n\t\t\tfor(j=0; j<f->ntext; j++)\n\t\t\t\ttextdelete(f->text[j], u.p0, u.p0+u.n, FALSE);\n\t\t\t*q0p = u.p0;\n\t\t\t*q1p = u.p0;\n\t\t\tbreak;\n\n\t\tcase Insert:\n\t\t\tf->seq = u.seq;\n\t\t\tfileuninsert(f, epsilon, u.p0, u.n);\n\t\t\tf->mod = u.mod;\n\t\t\tup -= u.n;\n\t\t\tfor(i=0; i<u.n; i+=n){\n\t\t\t\tn = u.n - i;\n\t\t\t\tif(n > RBUFSIZE)\n\t\t\t\t\tn = RBUFSIZE;\n\t\t\t\tbufread(delta, up+i, buf, n);\n\t\t\t\tbufinsert(&f->b, u.p0+i, buf, n);\n\t\t\t\tfor(j=0; j<f->ntext; j++)\n\t\t\t\t\ttextinsert(f->text[j], u.p0+i, buf, n, FALSE);\n\t\t\t}\n\t\t\t*q0p = u.p0;\n\t\t\t*q1p = u.p0+u.n;\n\t\t\tbreak;\n\n\t\tcase Filename:\n\t\t\tf->seq = u.seq;\n\t\t\tfileunsetname(f, epsilon);\n\t\t\tf->mod = u.mod;\n\t\t\tup -= u.n;\n\t\t\tfree(f->name);\n\t\t\tif(u.n == 0)\n\t\t\t\tf->name = nil;\n\t\t\telse\n\t\t\t\tf->name = runemalloc(u.n);\n\t\t\tbufread(delta, up, f->name, u.n);\n\t\t\tf->nname = u.n;\n\t\t\tbreak;\n\t\t}\n\t\tbufdelete(delta, up, delta->nc);\n\t}\n\tif(isundo)\n\t\tf->seq = 0;\n    Return:\n\tfbuffree(buf);\n}\n\nvoid\nfilereset(File *f)\n{\n\tbufreset(&f->delta);\n\tbufreset(&f->epsilon);\n\tf->seq = 0;\n}\n\nvoid\nfileclose(File *f)\n{\n\tfree(f->name);\n\tf->nname = 0;\n\tf->name = nil;\n\tfree(f->text);\n\tf->ntext = 0;\n\tf->text = nil;\n\tbufclose(&f->b);\n\tbufclose(&f->delta);\n\tbufclose(&f->epsilon);\n\telogclose(f);\n\tfree(f);\n}\n\nvoid\nfilemark(File *f)\n{\n\tif(f->epsilon.nc)\n\t\tbufdelete(&f->epsilon, 0, f->epsilon.nc);\n\tf->seq = seq;\n}\n", "source": "acme2k/src/cmd/acme/file.c", "file_type": "c"}
{"text": "#include <u.h>\n#include <libc.h>\n#include <draw.h>\n#include <thread.h>\n#include <cursor.h>\n#include <mouse.h>\n#include <keyboard.h>\n#include <frame.h>\n#include <fcall.h>\n#include <plumb.h>\n#include <libsec.h>\n#include \"dat.h\"\n#include \"fns.h\"\n\nstatic\tPoint\t\tprevmouse;\nstatic\tWindow\t*mousew;\n\nRange\nrange(int q0, int q1)\n{\n\tRange r;\n\n\tr.q0 = q0;\n\tr.q1 = q1;\n\treturn r;\n}\n\nRunestr\nrunestr(Rune *r, uint n)\n{\n\tRunestr rs;\n\n\trs.r = r;\n\trs.nr = n;\n\treturn rs;\n}\n\nvoid\ncvttorunes(char *p, int n, Rune *r, int *nb, int *nr, int *nulls)\n{\n\tuchar *q;\n\tRune *s;\n\tint j, w;\n\n\t/*\n\t * Always guaranteed that n bytes may be interpreted\n\t * without worrying about partial runes.  This may mean\n\t * reading up to UTFmax-1 more bytes than n; the caller\n\t * knows this.  If n is a firm limit, the caller should\n\t * set p[n] = 0.\n\t */\n\tq = (uchar*)p;\n\ts = r;\n\tfor(j=0; j<n; j+=w){\n\t\tif(*q < Runeself){\n\t\t\tw = 1;\n\t\t\t*s = *q++;\n\t\t}else{\n\t\t\tw = chartorune(s, (char*)q);\n\t\t\tq += w;\n\t\t}\n\t\tif(*s)\n\t\t\ts++;\n\t\telse if(nulls)\n\t\t\t*nulls = TRUE;\n\t}\n\t*nb = (char*)q-p;\n\t*nr = s-r;\n}\n\nvoid\nerror(char *s)\n{\n\tfprint(2, \"acme: %s: %r\\n\", s);\n\tthreadexitsall(nil);\n}\n\nWindow*\nerrorwin1(Rune *dir, int ndir, Rune **incl, int nincl)\n{\n\tWindow *w;\n\tRune *r;\n\tint i, n;\n\tstatic Rune Lpluserrors[] = { '+', 'E', 'r', 'r', 'o', 'r', 's', 0 };\n\n\tr = runemalloc(ndir+8);\n\tif((n = ndir) != 0){\n\t\trunemove(r, dir, ndir);\n\t\tr[n++] = L'/';\n\t}\n\trunemove(r+n, Lpluserrors, 7);\n\tn += 7;\n\tw = lookfile(r, n);\n\tif(w == nil){\n\t\tif(row.ncol == 0)\n\t\t\tif(rowadd(&row, nil, -1) == nil)\n\t\t\t\terror(\"can't create column to make error window\");\n\t\tw = coladd(row.col[row.ncol-1], nil, nil, -1);\n\t\tw->filemenu = FALSE;\n\t\twinsetname(w, r, n);\n\t\txfidlog(w, \"new\");\n\t}\n\tfree(r);\n\tfor(i=nincl; --i>=0; ){\n\t\tn = runestrlen(incl[i]);\n\t\tr = runemalloc(n);\n\t\trunemove(r, incl[i], n);\n\t\twinaddincl(w, r, n);\n\t}\n\tw->autoindent = globalautoindent;\n\treturn w;\n}\n\n/* make new window, if necessary; return with it locked */\nWindow*\nerrorwin(Mntdir *md, int owner)\n{\n\tWindow *w;\n\n\tfor(;;){\n\t\tif(md == nil)\n\t\t\tw = errorwin1(nil, 0, nil, 0);\n\t\telse\n\t\t\tw = errorwin1(md->dir, md->ndir, md->incl, md->nincl);\n\t\twinlock(w, owner);\n\t\tif(w->col != nil)\n\t\t\tbreak;\n\t\t/* window was deleted too fast */\n\t\twinunlock(w);\n\t}\n\treturn w;\n}\n\n/*\n * Incoming window should be locked. \n * It will be unlocked and returned window\n * will be locked in its place.\n */\nWindow*\nerrorwinforwin(Window *w)\n{\n\tint i, n, nincl, owner;\n\tRune **incl;\n\tRunestr dir;\n\tText *t;\n\n\tt = &w->body;\n\tdir = dirname(t, nil, 0);\n\tif(dir.nr==1 && dir.r[0]=='.'){\t/* sigh */\n\t\tfree(dir.r);\n\t\tdir.r = nil;\n\t\tdir.nr = 0;\n\t}\n\tincl = nil;\n\tnincl = w->nincl;\n\tif(nincl > 0){\n\t\tincl = emalloc(nincl*sizeof(Rune*));\n\t\tfor(i=0; i<nincl; i++){\n\t\t\tn = runestrlen(w->incl[i]);\n\t\t\tincl[i] = runemalloc(n+1);\n\t\t\trunemove(incl[i], w->incl[i], n);\n\t\t}\n\t}\n\towner = w->owner;\n\twinunlock(w);\n\tfor(;;){\n\t\tw = errorwin1(dir.r, dir.nr, incl, nincl);\n\t\twinlock(w, owner);\n\t\tif(w->col != nil)\n\t\t\tbreak;\n\t\t/* window deleted too fast */\n\t\twinunlock(w);\n\t}\n\treturn w;\n}\n\ntypedef struct Warning Warning;\n\nstruct Warning{\n\tMntdir *md;\n\tBuffer buf;\n\tWarning *next;\n};\n\nstatic Warning *warnings;\n\nstatic\nvoid\naddwarningtext(Mntdir *md, Rune *r, int nr)\n{\n\tWarning *warn;\n\t\n\tfor(warn = warnings; warn; warn=warn->next){\n\t\tif(warn->md == md){\n\t\t\tbufinsert(&warn->buf, warn->buf.nc, r, nr);\n\t\t\treturn;\n\t\t}\n\t}\n\twarn = emalloc(sizeof(Warning));\n\twarn->next = warnings;\n\twarn->md = md;\n\tif(md)\n\t\tfsysincid(md);\n\twarnings = warn;\n\tbufinsert(&warn->buf, 0, r, nr);\n\tnbsendp(cwarn, 0);\n}\n\n/* called while row is locked */\nvoid\nflushwarnings(void)\n{\n\tWarning *warn, *next;\n\tWindow *w;\n\tText *t;\n\tint owner, nr, q0, n;\n\tRune *r;\n\n\tfor(warn=warnings; warn; warn=next) {\n\t\tw = errorwin(warn->md, 'E');\n\t\tt = &w->body;\n\t\towner = w->owner;\n\t\tif(owner == 0)\n\t\t\tw->owner = 'E';\n\t\twincommit(w, t);\n\t\t/*\n\t\t * Most commands don't generate much output. For instance,\n\t\t * Edit ,>cat goes through /dev/cons and is already in blocks\n\t\t * because of the i/o system, but a few can.  Edit ,p will\n\t\t * put the entire result into a single hunk.  So it's worth doing\n\t\t * this in blocks (and putting the text in a buffer in the first\n\t\t * place), to avoid a big memory footprint.\n\t\t */\n\t\tr = fbufalloc();\n\t\tq0 = t->file->b.nc;\n\t\tfor(n = 0; n < warn->buf.nc; n += nr){\n\t\t\tnr = warn->buf.nc - n;\n\t\t\tif(nr > RBUFSIZE)\n\t\t\t\tnr = RBUFSIZE;\n\t\t\tbufread(&warn->buf, n, r, nr);\n\t\t\ttextbsinsert(t, t->file->b.nc, r, nr, TRUE, &nr);\n\t\t}\n\t\ttextshow(t, q0, t->file->b.nc, 1);\n\t\tfree(r);\n\t\twinsettag(t->w);\n\t\ttextscrdraw(t);\n\t\tw->owner = owner;\n\t\tw->dirty = FALSE;\n\t\twinunlock(w);\n\t\tbufclose(&warn->buf);\n\t\tnext = warn->next;\n\t\tif(warn->md)\n\t\t\tfsysdelid(warn->md);\n\t\tfree(warn);\n\t}\n\twarnings = nil;\n}\n\nvoid\nwarning(Mntdir *md, char *s, ...)\n{\n\tRune *r;\n\tva_list arg;\n\n\tva_start(arg, s);\n\tr = runevsmprint(s, arg);\n\tva_end(arg);\n\tif(r == nil)\n\t\terror(\"runevsmprint failed\");\n\taddwarningtext(md, r, runestrlen(r));\n\tfree(r);\n}\n\nint\nruneeq(Rune *s1, uint n1, Rune *s2, uint n2)\n{\n\tif(n1 != n2)\n\t\treturn FALSE;\n\treturn memcmp(s1, s2, n1*sizeof(Rune)) == 0;\n}\n\nuint\nmin(uint a, uint b)\n{\n\tif(a < b)\n\t\treturn a;\n\treturn b;\n}\n\nuint\nmax(uint a, uint b)\n{\n\tif(a > b)\n\t\treturn a;\n\treturn b;\n}\n\nchar*\nrunetobyte(Rune *r, int n)\n{\n\tchar *s;\n\n\tif(r == nil)\n\t\treturn nil;\n\ts = emalloc(n*UTFmax+1);\n\tsetmalloctag(s, getcallerpc(&r));\n\tsnprint(s, n*UTFmax+1, \"%.*S\", n, r);\n\treturn s;\n}\n\nRune*\nbytetorune(char *s, int *ip)\n{\n\tRune *r;\n\tint nb, nr;\n\n\tnb = strlen(s);\n\tr = runemalloc(nb+1);\n\tcvttorunes(s, nb, r, &nb, &nr, nil);\n\tr[nr] = '\\0';\n\t*ip = nr;\n\treturn r;\n}\n\nint\nisalnum(Rune c)\n{\n\t/*\n\t * Hard to get absolutely right.  Use what we know about ASCII\n\t * and assume anything above the Latin control characters is\n\t * potentially an alphanumeric.\n\t */\n\tif(c <= ' ')\n\t\treturn FALSE;\n\tif(0x7F<=c && c<=0xA0)\n\t\treturn FALSE;\n\tif(utfrune(\"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^`{|}~\", c))\n\t\treturn FALSE;\n\treturn TRUE;\n}\n\nint\nrgetc(void *v, uint n)\n{\n\treturn ((Rune*)v)[n];\n}\n\nint\ntgetc(void *a, uint n)\n{\n\tText *t;\n\n\tt = a;\n\tif(n >= t->file->b.nc)\n\t\treturn 0;\n\treturn textreadc(t, n);\n}\n\nRune*\nskipbl(Rune *r, int n, int *np)\n{\n\twhile(n>0 && (*r==' ' || *r=='\\t' || *r=='\\n')){\n\t\t--n;\n\t\tr++;\n\t}\n\t*np = n;\n\treturn r;\n}\n\nRune*\nfindbl(Rune *r, int n, int *np)\n{\n\twhile(n>0 && *r!=' ' && *r!='\\t' && *r!='\\n'){\n\t\t--n;\n\t\tr++;\n\t}\n\t*np = n;\n\treturn r;\n}\n\nvoid\nsavemouse(Window *w)\n{\n\tprevmouse = mouse->xy;\n\tmousew = w;\n}\n\nint\nrestoremouse(Window *w)\n{\n\tint did;\n\n\tdid = 0;\n\tif(mousew!=nil && mousew==w) {\n\t\tmoveto(mousectl, prevmouse);\n\t\tdid = 1;\n\t}\n\tmousew = nil;\n\treturn did;\n}\n\nvoid\nclearmouse()\n{\n\tmousew = nil;\n}\n\nchar*\nestrdup(char *s)\n{\n\tchar *t;\n\n\tt = strdup(s);\n\tif(t == nil)\n\t\terror(\"strdup failed\");\n\tsetmalloctag(t, getcallerpc(&s));\n\treturn t;\n}\n\nvoid*\nemalloc(uint n)\n{\n\tvoid *p;\n\n\tp = malloc(n);\n\tif(p == nil)\n\t\terror(\"malloc failed\");\n\tsetmalloctag(p, getcallerpc(&n));\n\tmemset(p, 0, n);\n\treturn p;\n}\n\nvoid*\nerealloc(void *p, uint n)\n{\n\tp = realloc(p, n);\n\tif(p == nil)\n\t\terror(\"realloc failed\");\n\tsetmalloctag(p, getcallerpc(&n));\n\treturn p;\n}\n\n/*\n * Heuristic city.\n */\nWindow*\nmakenewwindow(Text *t)\n{\n\tColumn *c;\n\tWindow *w, *bigw, *emptyw;\n\tText *emptyb;\n\tint i, y, el;\n\n\tif(activecol)\n\t\tc = activecol;\n\telse if(seltext && seltext->col)\n\t\tc = seltext->col;\n\telse if(t && t->col)\n\t\tc = t->col;\n\telse{\n\t\tif(row.ncol==0 && rowadd(&row, nil, -1)==nil)\n\t\t\terror(\"can't make column\");\n\t\tc = row.col[row.ncol-1];\n\t}\n\tactivecol = c;\n\tif(t==nil || t->w==nil || c->nw==0)\n\t\treturn coladd(c, nil, nil, -1);\n\n\t/* find biggest window and biggest blank spot */\n\temptyw = c->w[0];\n\tbigw = emptyw;\n\tfor(i=1; i<c->nw; i++){\n\t\tw = c->w[i];\n\t\t/* use >= to choose one near bottom of screen */\n\t\tif(w->body.fr.maxlines >= bigw->body.fr.maxlines)\n\t\t\tbigw = w;\n\t\tif(w->body.fr.maxlines-w->body.fr.nlines >= emptyw->body.fr.maxlines-emptyw->body.fr.nlines)\n\t\t\temptyw = w;\n\t}\n\temptyb = &emptyw->body;\n\tel = emptyb->fr.maxlines-emptyb->fr.nlines;\n\t/* if empty space is big, use it */\n\tif(el>15 || (el>3 && el>(bigw->body.fr.maxlines-1)/2))\n\t\ty = emptyb->fr.r.min.y+emptyb->fr.nlines*font->height;\n\telse{\n\t\t/* if this window is in column and isn't much smaller, split it */\n\t\tif(t->col==c && Dy(t->w->r)>2*Dy(bigw->r)/3)\n\t\t\tbigw = t->w;\n\t\ty = (bigw->r.min.y + bigw->r.max.y)/2;\n\t}\n\tw = coladd(c, nil, nil, y);\n\tif(w->body.fr.maxlines < 2)\n\t\tcolgrow(w->col, w, 1);\n\treturn w;\n}\n", "source": "acme2k/src/cmd/acme/util.c", "file_type": "c"}
{"text": "#include <u.h>\n#include <libc.h>\n#include <draw.h>\n#include <thread.h>\n#include <cursor.h>\n#include <mouse.h>\n#include <keyboard.h>\n#include <frame.h>\n#include <fcall.h>\n#include <plumb.h>\n#include <libsec.h>\n#include \"dat.h\"\n#include \"fns.h\"\n\nenum\n{\n\tCtlsize\t= 5*12\n};\n\nchar\tEdel[]\t\t= \"deleted window\";\nchar\tEbadctl[]\t\t= \"ill-formed control message\";\nchar\tEbadaddr[]\t= \"bad address syntax\";\nchar\tEaddr[]\t\t= \"address out of range\";\nchar\tEinuse[]\t\t= \"already in use\";\nchar\tEbadevent[]\t= \"bad event syntax\";\nextern char Eperm[];\n\nstatic\nvoid\nclampaddr(Window *w)\n{\n\tif(w->addr.q0 < 0)\n\t\tw->addr.q0 = 0;\n\tif(w->addr.q1 < 0)\n\t\tw->addr.q1 = 0;\n\tif(w->addr.q0 > w->body.file->b.nc)\n\t\tw->addr.q0 = w->body.file->b.nc;\n\tif(w->addr.q1 > w->body.file->b.nc)\n\t\tw->addr.q1 = w->body.file->b.nc;\n}\n\nvoid\nxfidctl(void *arg)\n{\n\tXfid *x;\n\tvoid (*f)(Xfid*);\n\n\tthreadsetname(\"xfidctlthread\");\n\tx = arg;\n\tfor(;;){\n\t\tf = (void(*)(Xfid*))recvp(x->c);\n\t\t(*f)(x);\n\t\tflushimage(display, 1);\n\t\tsendp(cxfidfree, x);\n\t}\n}\n\nvoid\nxfidflush(Xfid *x)\n{\n\tFcall fc;\n\tint i, j;\n\tWindow *w;\n\tColumn *c;\n\tXfid *wx;\n\n\txfidlogflush(x);\n\n\t/* search windows for matching tag */\n\tqlock(&row.lk);\n\tfor(j=0; j<row.ncol; j++){\n\t\tc = row.col[j];\n\t\tfor(i=0; i<c->nw; i++){\n\t\t\tw = c->w[i];\n\t\t\twinlock(w, 'E');\n\t\t\twx = w->eventx;\n\t\t\tif(wx!=nil && wx->fcall.tag==x->fcall.oldtag){\n\t\t\t\tw->eventx = nil;\n\t\t\t\twx->flushed = TRUE;\n\t\t\t\tsendp(wx->c, nil);\n\t\t\t\twinunlock(w);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\twinunlock(w);\n\t\t}\n\t}\nout:\n\tqunlock(&row.lk);\n\trespond(x, &fc, nil);\n}\n\nvoid\nxfidopen(Xfid *x)\n{\n\tFcall fc;\n\tWindow *w;\n\tText *t;\n\tchar *s;\n\tRune *r;\n\tint m, n, q, q0, q1;\n\n\tw = x->f->w;\n\tt = &w->body;\n\tq = FILE(x->f->qid);\n\tif(w){\n\t\twinlock(w, 'E');\n\t\tswitch(q){\n\t\tcase QWaddr:\n\t\t\tif(w->nopen[q]++ == 0){\n\t\t\t\tw->addr = range(0, 0);\n\t\t\t\tw->limit = range(-1,-1);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase QWdata:\n\t\tcase QWxdata:\n\t\t\tw->nopen[q]++;\n\t\t\tbreak;\n\t\tcase QWevent:\n\t\t\tif(w->nopen[q]++ == 0){\n\t\t\t\tif(!w->isdir && w->col!=nil){\n\t\t\t\t\tw->filemenu = FALSE;\n\t\t\t\t\twinsettag(w);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase QWrdsel:\n\t\t\t/*\n\t\t\t * Use a temporary file.\n\t\t\t * A pipe would be the obvious, but we can't afford the\n\t\t\t * broken pipe notification.  Using the code to read QWbody\n\t\t\t * is n\u00b2, which should probably also be fixed.  Even then,\n\t\t\t * though, we'd need to squirrel away the data in case it's\n\t\t\t * modified during the operation, e.g. by |sort\n\t\t\t */\n\t\t\tif(w->rdselfd > 0){\n\t\t\t\twinunlock(w);\n\t\t\t\trespond(x, &fc, Einuse);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tw->rdselfd = tempfile();\n\t\t\tif(w->rdselfd < 0){\n\t\t\t\twinunlock(w);\n\t\t\t\trespond(x, &fc, \"can't create temp file\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tw->nopen[q]++;\n\t\t\tq0 = t->q0;\n\t\t\tq1 = t->q1;\n\t\t\tr = fbufalloc();\n\t\t\ts = fbufalloc();\n\t\t\twhile(q0 < q1){\n\t\t\t\tn = q1 - q0;\n\t\t\t\tif(n > BUFSIZE/UTFmax)\n\t\t\t\t\tn = BUFSIZE/UTFmax;\n\t\t\t\tbufread(&t->file->b, q0, r, n);\n\t\t\t\tm = snprint(s, BUFSIZE+1, \"%.*S\", n, r);\n\t\t\t\tif(write(w->rdselfd, s, m) != m){\n\t\t\t\t\twarning(nil, \"can't write temp file for pipe command %r\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tq0 += n;\n\t\t\t}\n\t\t\tfbuffree(s);\n\t\t\tfbuffree(r);\n\t\t\tbreak;\n\t\tcase QWwrsel:\n\t\t\tw->nopen[q]++;\n\t\t\tseq++;\n\t\t\tfilemark(t->file);\n\t\t\tcut(t, t, nil, FALSE, TRUE, nil, 0);\n\t\t\tw->wrselrange = range(t->q1, t->q1);\n\t\t\tw->nomark = TRUE;\n\t\t\tbreak;\n\t\tcase QWeditout:\n\t\t\tif(editing == FALSE){\n\t\t\t\twinunlock(w);\n\t\t\t\trespond(x, &fc, Eperm);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(!canqlock(&w->editoutlk)){\n\t\t\t\twinunlock(w);\n\t\t\t\trespond(x, &fc, Einuse);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tw->wrselrange = range(t->q1, t->q1);\n\t\t\tbreak;\n\t\t}\n\t\twinunlock(w);\n\t}\n\telse{\n\t\tswitch(q){\n\t\tcase Qlog:\n\t\t\txfidlogopen(x);\n\t\t\tbreak;\n\t\tcase Qeditout:\n\t\t\tif(!canqlock(&editoutlk)){\n\t\t\t\trespond(x, &fc, Einuse);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tfc.qid = x->f->qid;\n\tfc.iounit = messagesize-IOHDRSZ;\n\tx->f->open = TRUE;\n\trespond(x, &fc, nil);\n}\n\nvoid\nxfidclose(Xfid *x)\n{\n\tFcall fc;\n\tWindow *w;\n\tint q;\n\tText *t;\n\n\tw = x->f->w;\n\tx->f->busy = FALSE;\n\tx->f->w = nil;\n\tif(x->f->open == FALSE){\n\t\tif(w != nil)\n\t\t\twinclose(w);\n\t\trespond(x, &fc, nil);\n\t\treturn;\n\t}\n\n\tq = FILE(x->f->qid);\n\tx->f->open = FALSE;\n\tif(w){\n\t\twinlock(w, 'E');\n\t\tswitch(q){\n\t\tcase QWctl:\n\t\t\tif(w->ctlfid!=~0 && w->ctlfid==x->f->fid){\n\t\t\t\tw->ctlfid = ~0;\n\t\t\t\tqunlock(&w->ctllock);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase QWdata:\n\t\tcase QWxdata:\n\t\t\tw->nomark = FALSE;\n\t\t\t/* fall through */\n\t\tcase QWaddr:\n\t\tcase QWevent:\t/* BUG: do we need to shut down Xfid? */\n\t\t\tif(--w->nopen[q] == 0){\n\t\t\t\tif(q == QWdata || q == QWxdata)\n\t\t\t\t\tw->nomark = FALSE;\n\t\t\t\tif(q==QWevent && !w->isdir && w->col!=nil){\n\t\t\t\t\tw->filemenu = TRUE;\n\t\t\t\t\twinsettag(w);\n\t\t\t\t}\n\t\t\t\tif(q == QWevent){\n\t\t\t\t\tfree(w->dumpstr);\n\t\t\t\t\tfree(w->dumpdir);\n\t\t\t\t\tw->dumpstr = nil;\n\t\t\t\t\tw->dumpdir = nil;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase QWrdsel:\n\t\t\tclose(w->rdselfd);\n\t\t\tw->rdselfd = 0;\n\t\t\tbreak;\n\t\tcase QWwrsel:\n\t\t\tw->nomark = FALSE;\n\t\t\tt = &w->body;\n\t\t\t/* before: only did this if !w->noscroll, but that didn't seem right in practice */\n\t\t\ttextshow(t, min(w->wrselrange.q0, t->file->b.nc),\n\t\t\t\tmin(w->wrselrange.q1, t->file->b.nc), 1);\n\t\t\ttextscrdraw(t);\n\t\t\tbreak;\n\t\tcase QWeditout:\n\t\t\tqunlock(&w->editoutlk);\n\t\t\tbreak;\n\t\t}\n\t\twinunlock(w);\n\t\twinclose(w);\n\t}\n\telse{\n\t\tswitch(q){\n\t\tcase Qeditout:\n\t\t\tqunlock(&editoutlk);\n\t\t\tbreak;\n\t\t}\n\t}\n\trespond(x, &fc, nil);\n}\n\nvoid\nxfidread(Xfid *x)\n{\n\tFcall fc;\n\tint n, q;\n\tuint off;\n\tchar *b;\n\tchar buf[256];\n\tWindow *w;\n\n\tq = FILE(x->f->qid);\n\tw = x->f->w;\n\tif(w == nil){\n\t\tfc.count = 0;\n\t\tswitch(q){\n\t\tcase Qcons:\n\t\tcase Qlabel:\n\t\t\tbreak;\n\t\tcase Qindex:\n\t\t\txfidindexread(x);\n\t\t\treturn;\n\t\tcase Qlog:\n\t\t\txfidlogread(x);\n\t\t\treturn;\n\t\tdefault:\n\t\t\twarning(nil, \"unknown qid %d\\n\", q);\n\t\t\tbreak;\n\t\t}\n\t\trespond(x, &fc, nil);\n\t\treturn;\n\t}\n\twinlock(w, 'F');\n\tif(w->col == nil){\n\t\twinunlock(w);\n\t\trespond(x, &fc, Edel);\n\t\treturn;\n\t}\n\toff = x->fcall.offset;\n\tswitch(q){\n\tcase QWaddr:\n\t\ttextcommit(&w->body, TRUE);\n\t\tclampaddr(w);\n\t\tsprint(buf, \"%11d %11d \", w->addr.q0, w->addr.q1);\n\t\tgoto Readbuf;\n\n\tcase QWbody:\n\t\txfidutfread(x, &w->body, w->body.file->b.nc, QWbody);\n\t\tbreak;\n\n\tcase QWctl:\n\t\tb = winctlprint(w, buf, 1);\n\t\tgoto Readb;\n\n\tReadbuf:\n\t\tb = buf;\n\tReadb:\n\t\tn = strlen(b);\n\t\tif(off > n)\n\t\t\toff = n;\n\t\tif(off+x->fcall.count > n)\n\t\t\tx->fcall.count = n-off;\n\t\tfc.count = x->fcall.count;\n\t\tfc.data = b+off;\n\t\trespond(x, &fc, nil);\n\t\tif(b != buf)\n\t\t\tfree(b);\n\t\tbreak;\n\n\tcase QWevent:\n\t\txfideventread(x, w);\n\t\tbreak;\n\n\tcase QWdata:\n\t\t/* BUG: what should happen if q1 > q0? */\n\t\tif(w->addr.q0 > w->body.file->b.nc){\n\t\t\trespond(x, &fc, Eaddr);\n\t\t\tbreak;\n\t\t}\n\t\tw->addr.q0 += xfidruneread(x, &w->body, w->addr.q0, w->body.file->b.nc);\n\t\tw->addr.q1 = w->addr.q0;\n\t\tbreak;\n\n\tcase QWxdata:\n\t\t/* BUG: what should happen if q1 > q0? */\n\t\tif(w->addr.q0 > w->body.file->b.nc){\n\t\t\trespond(x, &fc, Eaddr);\n\t\t\tbreak;\n\t\t}\n\t\tw->addr.q0 += xfidruneread(x, &w->body, w->addr.q0, w->addr.q1);\n\t\tbreak;\n\n\tcase QWtag:\n\t\txfidutfread(x, &w->tag, w->tag.file->b.nc, QWtag);\n\t\tbreak;\n\n\tcase QWrdsel:\n\t\tseek(w->rdselfd, off, 0);\n\t\tn = x->fcall.count;\n\t\tif(n > BUFSIZE)\n\t\t\tn = BUFSIZE;\n\t\tb = fbufalloc();\n\t\tn = read(w->rdselfd, b, n);\n\t\tif(n < 0){\n\t\t\trespond(x, &fc, \"I/O error in temp file\");\n\t\t\tbreak;\n\t\t}\n\t\tfc.count = n;\n\t\tfc.data = b;\n\t\trespond(x, &fc, nil);\n\t\tfbuffree(b);\n\t\tbreak;\n\n\tdefault:\n\t\tsprint(buf, \"unknown qid %d in read\", q);\n\t\trespond(x, &fc, nil);\n\t}\n\twinunlock(w);\n}\n\nstatic int\nshouldscroll(Text *t, uint q0, int qid)\n{\n\tif(qid == Qcons)\n\t\treturn TRUE;\n\treturn t->org <= q0 && q0 <= t->org+t->fr.nchars;\n}\n\nstatic Rune*\nfullrunewrite(Xfid *x, int *inr)\n{\n\tint q, cnt, c, nb, nr;\n\tRune *r;\n\n\tq = x->f->nrpart;\n\tcnt = x->fcall.count;\n\tif(q > 0){\n\t\tmemmove(x->fcall.data+q, x->fcall.data, cnt);\t/* there's room; see fsysproc */\n\t\tmemmove(x->fcall.data, x->f->rpart, q);\n\t\tcnt += q;\n\t\tx->f->nrpart = 0;\n\t}\n\tr = runemalloc(cnt);\n\tcvttorunes(x->fcall.data, cnt-UTFmax, r, &nb, &nr, nil);\n\t/* approach end of buffer */\n\twhile(fullrune(x->fcall.data+nb, cnt-nb)){\n\t\tc = nb;\n\t\tnb += chartorune(&r[nr], x->fcall.data+c);\n\t\tif(r[nr])\n\t\t\tnr++;\n\t}\n\tif(nb < cnt){\n\t\tmemmove(x->f->rpart, x->fcall.data+nb, cnt-nb);\n\t\tx->f->nrpart = cnt-nb;\n\t}\n\t*inr = nr;\n\treturn r;\n}\n\nvoid\nxfidwrite(Xfid *x)\n{\n\tFcall fc;\n\tint c, qid, nb, nr, eval;\n\tchar buf[64], *err;\n\tWindow *w;\n\tRune *r;\n\tRange a;\n\tText *t;\n\tuint q0, tq0, tq1;\n\n\tqid = FILE(x->f->qid);\n\tw = x->f->w;\n\tif(w){\n\t\tc = 'F';\n\t\tif(qid==QWtag || qid==QWbody)\n\t\t\tc = 'E';\n\t\twinlock(w, c);\n\t\tif(w->col == nil){\n\t\t\twinunlock(w);\n\t\t\trespond(x, &fc, Edel);\n\t\t\treturn;\n\t\t}\n\t}\n\tx->fcall.data[x->fcall.count] = 0;\n\tswitch(qid){\n\tcase Qcons:\n\t\tw = errorwin(x->f->mntdir, 'X');\n\t\tt=&w->body;\n\t\tgoto BodyTag;\n\n\tcase Qlabel:\n\t\tfc.count = x->fcall.count;\n\t\trespond(x, &fc, nil);\n\t\tbreak;\n\n\tcase QWaddr:\n\t\tx->fcall.data[x->fcall.count] = 0;\n\t\tr = bytetorune(x->fcall.data, &nr);\n\t\tt = &w->body;\n\t\twincommit(w, t);\n\t\teval = TRUE;\n\t\ta = address(FALSE, t, w->limit, w->addr, r, 0, nr, rgetc, &eval, (uint*)&nb);\n\t\tfree(r);\n\t\tif(nb < nr){\n\t\t\trespond(x, &fc, Ebadaddr);\n\t\t\tbreak;\n\t\t}\n\t\tif(!eval){\n\t\t\trespond(x, &fc, Eaddr);\n\t\t\tbreak;\n\t\t}\n\t\tw->addr = a;\n\t\tfc.count = x->fcall.count;\n\t\trespond(x, &fc, nil);\n\t\tbreak;\n\n\tcase Qeditout:\n\tcase QWeditout:\n\t\tr = fullrunewrite(x, &nr);\n\t\tif(w)\n\t\t\terr = edittext(w, w->wrselrange.q1, r, nr);\n\t\telse\n\t\t\terr = edittext(nil, 0, r, nr);\n\t\tfree(r);\n\t\tif(err != nil){\n\t\t\trespond(x, &fc, err);\n\t\t\tbreak;\n\t\t}\n\t\tfc.count = x->fcall.count;\n\t\trespond(x, &fc, nil);\n\t\tbreak;\n\n\tcase QWerrors:\n\t\tw = errorwinforwin(w);\n\t\tt = &w->body;\n\t\tgoto BodyTag;\n\n\tcase QWbody:\n\tcase QWwrsel:\n\t\tt = &w->body;\n\t\tgoto BodyTag;\n\n\tcase QWctl:\n\t\txfidctlwrite(x, w);\n\t\tbreak;\n\n\tcase QWdata:\n\t\ta = w->addr;\n\t\tt = &w->body;\n\t\twincommit(w, t);\n\t\tif(a.q0>t->file->b.nc || a.q1>t->file->b.nc){\n\t\t\trespond(x, &fc, Eaddr);\n\t\t\tbreak;\n\t\t}\n\t\tr = runemalloc(x->fcall.count);\n\t\tcvttorunes(x->fcall.data, x->fcall.count, r, &nb, &nr, nil);\n\t\tif(w->nomark == FALSE){\n\t\t\tseq++;\n\t\t\tfilemark(t->file);\n\t\t}\n\t\tq0 = a.q0;\n\t\tif(a.q1 > q0){\n\t\t\ttextdelete(t, q0, a.q1, TRUE);\n\t\t\tw->addr.q1 = q0;\n\t\t}\n\t\ttq0 = t->q0;\n\t\ttq1 = t->q1;\n\t\ttextinsert(t, q0, r, nr, TRUE);\n\t\tif(tq0 >= q0)\n\t\t\ttq0 += nr;\n\t\tif(tq1 >= q0)\n\t\t\ttq1 += nr;\n\t\ttextsetselect(t, tq0, tq1);\n\t\tif(shouldscroll(t, q0, qid))\n\t\t\ttextshow(t, q0+nr, q0+nr, 0);\n\t\ttextscrdraw(t);\n\t\twinsettag(w);\n\t\tfree(r);\n\t\tw->addr.q0 += nr;\n\t\tw->addr.q1 = w->addr.q0;\n\t\tfc.count = x->fcall.count;\n\t\trespond(x, &fc, nil);\n\t\tbreak;\n\n\tcase QWevent:\n\t\txfideventwrite(x, w);\n\t\tbreak;\n\n\tcase QWtag:\n\t\tt = &w->tag;\n\t\tgoto BodyTag;\n\n\tBodyTag:\n\t\tr = fullrunewrite(x, &nr);\n\t\tif(nr > 0){\n\t\t\twincommit(w, t);\n\t\t\tif(qid == QWwrsel){\n\t\t\t\tq0 = w->wrselrange.q1;\n\t\t\t\tif(q0 > t->file->b.nc)\n\t\t\t\t\tq0 = t->file->b.nc;\n\t\t\t}else\n\t\t\t\tq0 = t->file->b.nc;\n\t\t\tif(qid == QWtag)\n\t\t\t\ttextinsert(t, q0, r, nr, TRUE);\n\t\t\telse{\n\t\t\t\tif(w->nomark == FALSE){\n\t\t\t\t\tseq++;\n\t\t\t\t\tfilemark(t->file);\n\t\t\t\t}\n\t\t\t\tq0 = textbsinsert(t, q0, r, nr, TRUE, &nr);\n\t\t\t\ttextsetselect(t, t->q0, t->q1);\t/* insert could leave it somewhere else */\n\t\t\t\tif(qid!=QWwrsel && shouldscroll(t, q0, qid))\n\t\t\t\t\ttextshow(t, q0+nr, q0+nr, 1);\n\t\t\t\ttextscrdraw(t);\n\t\t\t}\n\t\t\twinsettag(w);\n\t\t\tif(qid == QWwrsel)\n\t\t\t\tw->wrselrange.q1 += nr;\n\t\t\tfree(r);\n\t\t}\n\t\tfc.count = x->fcall.count;\n\t\trespond(x, &fc, nil);\n\t\tbreak;\n\n\tdefault:\n\t\tsprint(buf, \"unknown qid %d in write\", qid);\n\t\trespond(x, &fc, buf);\n\t\tbreak;\n\t}\n\tif(w)\n\t\twinunlock(w);\n}\n\nvoid\nxfidctlwrite(Xfid *x, Window *w)\n{\n\tFcall fc;\n\tint i, m, n, nb, nr, nulls;\n\tRune *r;\n\tchar *err, *p, *pp, *q, *e;\n\tint isfbuf, scrdraw, settag;\n\tText *t;\n\n\terr = nil;\n\te = x->fcall.data+x->fcall.count;\n\tscrdraw = FALSE;\n\tsettag = FALSE;\n\tisfbuf = TRUE;\n\tif(x->fcall.count < RBUFSIZE)\n\t\tr = fbufalloc();\n\telse{\n\t\tisfbuf = FALSE;\n\t\tr = emalloc(x->fcall.count*UTFmax+1);\n\t}\n\tx->fcall.data[x->fcall.count] = 0;\n\ttextcommit(&w->tag, TRUE);\n\tfor(n=0; n<x->fcall.count; n+=m){\n\t\tp = x->fcall.data+n;\n\t\tif(strncmp(p, \"lock\", 4) == 0){\t/* make window exclusive use */\n\t\t\tqlock(&w->ctllock);\n\t\t\tw->ctlfid = x->f->fid;\n\t\t\tm = 4;\n\t\t}else\n\t\tif(strncmp(p, \"unlock\", 6) == 0){\t/* release exclusive use */\n\t\t\tw->ctlfid = ~0;\n\t\t\tqunlock(&w->ctllock);\n\t\t\tm = 6;\n\t\t}else\n\t\tif(strncmp(p, \"clean\", 5) == 0){\t/* mark window 'clean', seq=0 */\n\t\t\tt = &w->body;\n\t\t\tt->eq0 = ~0;\n\t\t\tfilereset(t->file);\n\t\t\tt->file->mod = FALSE;\n\t\t\tw->dirty = FALSE;\n\t\t\tsettag = TRUE;\n\t\t\tm = 5;\n\t\t}else\n\t\tif(strncmp(p, \"dirty\", 5) == 0){\t/* mark window 'dirty' */\n\t\t\tt = &w->body;\n\t\t\t/* doesn't change sequence number, so \"Put\" won't appear.  it shouldn't. */\n\t\t\tt->file->mod = TRUE;\n\t\t\tw->dirty = TRUE;\n\t\t\tsettag = TRUE;\n\t\t\tm = 5;\n\t\t}else\n\t\tif(strncmp(p, \"show\", 4) == 0){\t/* show dot */\n\t\t\tt = &w->body;\n\t\t\ttextshow(t, t->q0, t->q1, 1);\n\t\t\tm = 4;\n\t\t}else\n\t\tif(strncmp(p, \"name \", 5) == 0){\t/* set file name */\n\t\t\tpp = p+5;\n\t\t\tm = 5;\n\t\t\tq = memchr(pp, '\\n', e-pp);\n\t\t\tif(q==nil || q==pp){\n\t\t\t\terr = Ebadctl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t*q = 0;\n\t\t\tnulls = FALSE;\n\t\t\tcvttorunes(pp, q-pp, r, &nb, &nr, &nulls);\n\t\t\tif(nulls){\n\t\t\t\terr = \"nulls in file name\";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(i=0; i<nr; i++)\n\t\t\t\tif(r[i] <= ' '){\n\t\t\t\t\terr = \"bad character in file name\";\n\t\t\t\t\tgoto out;\n\t\t\t\t}\nout:\n\t\t\tseq++;\n\t\t\tfilemark(w->body.file);\n\t\t\twinsetname(w, r, nr);\n\t\t\tm += (q+1) - pp;\n\t\t}else\n\t\tif(strncmp(p, \"dump \", 5) == 0){\t/* set dump string */\n\t\t\tpp = p+5;\n\t\t\tm = 5;\n\t\t\tq = memchr(pp, '\\n', e-pp);\n\t\t\tif(q==nil || q==pp){\n\t\t\t\terr = Ebadctl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t*q = 0;\n\t\t\tnulls = FALSE;\n\t\t\tcvttorunes(pp, q-pp, r, &nb, &nr, &nulls);\n\t\t\tif(nulls){\n\t\t\t\terr = \"nulls in dump string\";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tw->dumpstr = runetobyte(r, nr);\n\t\t\tm += (q+1) - pp;\n\t\t}else\n\t\tif(strncmp(p, \"dumpdir \", 8) == 0){\t/* set dump directory */\n\t\t\tpp = p+8;\n\t\t\tm = 8;\n\t\t\tq = memchr(pp, '\\n', e-pp);\n\t\t\tif(q==nil || q==pp){\n\t\t\t\terr = Ebadctl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t*q = 0;\n\t\t\tnulls = FALSE;\n\t\t\tcvttorunes(pp, q-pp, r, &nb, &nr, &nulls);\n\t\t\tif(nulls){\n\t\t\t\terr = \"nulls in dump directory string\";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tw->dumpdir = runetobyte(r, nr);\n\t\t\tm += (q+1) - pp;\n\t\t}else\n\t\tif(strncmp(p, \"delete\", 6) == 0){\t/* delete for sure */\n\t\t\tcolclose(w->col, w, TRUE);\n\t\t\tm = 6;\n\t\t}else\n\t\tif(strncmp(p, \"del\", 3) == 0){\t/* delete, but check dirty */\n\t\t\tif(!winclean(w, TRUE)){\n\t\t\t\terr = \"file dirty\";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcolclose(w->col, w, TRUE);\n\t\t\tm = 3;\n\t\t}else\n\t\tif(strncmp(p, \"get\", 3) == 0){\t/* get file */\n\t\t\tget(&w->body, nil, nil, FALSE, XXX, nil, 0);\n\t\t\tm = 3;\n\t\t}else\n\t\tif(strncmp(p, \"put\", 3) == 0){\t/* put file */\n\t\t\tput(&w->body, nil, nil, XXX, XXX, nil, 0);\n\t\t\tm = 3;\n\t\t}else\n\t\tif(strncmp(p, \"dot=addr\", 8) == 0){\t/* set dot */\n\t\t\ttextcommit(&w->body, TRUE);\n\t\t\tclampaddr(w);\n\t\t\tw->body.q0 = w->addr.q0;\n\t\t\tw->body.q1 = w->addr.q1;\n\t\t\ttextsetselect(&w->body, w->body.q0, w->body.q1);\n\t\t\tsettag = TRUE;\n\t\t\tm = 8;\n\t\t}else\n\t\tif(strncmp(p, \"addr=dot\", 8) == 0){\t/* set addr */\n\t\t\tw->addr.q0 = w->body.q0;\n\t\t\tw->addr.q1 = w->body.q1;\n\t\t\tm = 8;\n\t\t}else\n\t\tif(strncmp(p, \"limit=addr\", 10) == 0){\t/* set limit */\n\t\t\ttextcommit(&w->body, TRUE);\n\t\t\tclampaddr(w);\n\t\t\tw->limit.q0 = w->addr.q0;\n\t\t\tw->limit.q1 = w->addr.q1;\n\t\t\tm = 10;\n\t\t}else\n\t\tif(strncmp(p, \"nomark\", 6) == 0){\t/* turn off automatic marking */\n\t\t\tw->nomark = TRUE;\n\t\t\tm = 6;\n\t\t}else\n\t\tif(strncmp(p, \"mark\", 4) == 0){\t/* mark file */\n\t\t\tseq++;\n\t\t\tfilemark(w->body.file);\n\t\t\tsettag = TRUE;\n\t\t\tm = 4;\n\t\t}else\n\t\tif(strncmp(p, \"nomenu\", 6) == 0){\t/* turn off automatic menu */\n\t\t\tw->filemenu = FALSE;\n\t\t\tm = 6;\n\t\t}else\n\t\tif(strncmp(p, \"menu\", 4) == 0){\t/* enable automatic menu */\n\t\t\tw->filemenu = TRUE;\n\t\t\tm = 4;\n\t\t}else\n\t\tif(strncmp(p, \"cleartag\", 8) == 0){\t/* wipe tag right of bar */\n\t\t\twincleartag(w);\n\t\t\tsettag = TRUE;\n\t\t\tm = 8;\n\t\t}else{\n\t\t\terr = Ebadctl;\n\t\t\tbreak;\n\t\t}\n\t\twhile(p[m] == '\\n')\n\t\t\tm++;\n\t}\n\n\tif(isfbuf)\n\t\tfbuffree(r);\n\telse\n\t\tfree(r);\n\tif(err)\n\t\tn = 0;\n\tfc.count = n;\n\trespond(x, &fc, err);\n\tif(settag)\n\t\twinsettag(w);\n\tif(scrdraw)\n\t\ttextscrdraw(&w->body);\n}\n\nvoid\nxfideventwrite(Xfid *x, Window *w)\n{\n\tFcall fc;\n\tint m, n;\n\tRune *r;\n\tchar *err, *p, *q;\n\tint isfbuf;\n\tText *t;\n\tint c;\n\tuint q0, q1;\n\n\terr = nil;\n\tisfbuf = TRUE;\n\tif(x->fcall.count < RBUFSIZE)\n\t\tr = fbufalloc();\n\telse{\n\t\tisfbuf = FALSE;\n\t\tr = emalloc(x->fcall.count*UTFmax+1);\n\t}\n\tfor(n=0; n<x->fcall.count; n+=m){\n\t\tp = x->fcall.data+n;\n\t\tw->owner = *p++;\t/* disgusting */\n\t\tc = *p++;\n\t\twhile(*p == ' ')\n\t\t\tp++;\n\t\tq0 = strtoul(p, &q, 10);\n\t\tif(q == p)\n\t\t\tgoto Rescue;\n\t\tp = q;\n\t\twhile(*p == ' ')\n\t\t\tp++;\n\t\tq1 = strtoul(p, &q, 10);\n\t\tif(q == p)\n\t\t\tgoto Rescue;\n\t\tp = q;\n\t\twhile(*p == ' ')\n\t\t\tp++;\n\t\tif(*p++ != '\\n')\n\t\t\tgoto Rescue;\n\t\tm = p-(x->fcall.data+n);\n\t\tif('a'<=c && c<='z')\n\t\t\tt = &w->tag;\n\t\telse if('A'<=c && c<='Z')\n\t\t\tt = &w->body;\n\t\telse\n\t\t\tgoto Rescue;\n\t\tif(q0>t->file->b.nc || q1>t->file->b.nc || q0>q1)\n\t\t\tgoto Rescue;\n\n\t\tqlock(&row.lk);\t/* just like mousethread */\n\t\tswitch(c){\n\t\tcase 'x':\n\t\tcase 'X':\n\t\t\texecute(t, q0, q1, TRUE, nil);\n\t\t\tbreak;\n\t\tcase 'l':\n\t\tcase 'L':\n\t\t\tlook3(t, q0, q1, TRUE);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tqunlock(&row.lk);\n\t\t\tgoto Rescue;\n\t\t}\n\t\tqunlock(&row.lk);\n\n\t}\n\n    Out:\n\tif(isfbuf)\n\t\tfbuffree(r);\n\telse\n\t\tfree(r);\n\tif(err)\n\t\tn = 0;\n\tfc.count = n;\n\trespond(x, &fc, err);\n\treturn;\n\n    Rescue:\n\terr = Ebadevent;\n\tgoto Out;\n}\n\nvoid\nxfidutfread(Xfid *x, Text *t, uint q1, int qid)\n{\n\tFcall fc;\n\tWindow *w;\n\tRune *r;\n\tchar *b, *b1;\n\tuint q, off, boff;\n\tint m, n, nr, nb;\n\n\tw = t->w;\n\twincommit(w, t);\n\toff = x->fcall.offset;\n\tr = fbufalloc();\n\tb = fbufalloc();\n\tb1 = fbufalloc();\n\tn = 0;\n\tif(qid==w->utflastqid && off>=w->utflastboff && w->utflastq<=q1){\n\t\tboff = w->utflastboff;\n\t\tq = w->utflastq;\n\t}else{\n\t\t/* BUG: stupid code: scan from beginning */\n\t\tboff = 0;\n\t\tq = 0;\n\t}\n\tw->utflastqid = qid;\n\twhile(q<q1 && n<x->fcall.count){\n\t\t/*\n\t\t * Updating here avoids partial rune problem: we're always on a\n\t\t * char boundary. The cost is we will usually do one more read\n\t\t * than we really need, but that's better than being n^2.\n\t\t */\n\t\tw->utflastboff = boff;\n\t\tw->utflastq = q;\n\t\tnr = q1-q;\n\t\tif(nr > BUFSIZE/UTFmax)\n\t\t\tnr = BUFSIZE/UTFmax;\n\t\tbufread(&t->file->b, q, r, nr);\n\t\tnb = snprint(b, BUFSIZE+1, \"%.*S\", nr, r);\n\t\tif(boff >= off){\n\t\t\tm = nb;\n\t\t\tif(boff+m > off+x->fcall.count)\n\t\t\t\tm = off+x->fcall.count - boff;\n\t\t\tmemmove(b1+n, b, m);\n\t\t\tn += m;\n\t\t}else if(boff+nb > off){\n\t\t\tif(n != 0)\n\t\t\t\terror(\"bad count in utfrune\");\n\t\t\tm = nb - (off-boff);\n\t\t\tif(m > x->fcall.count)\n\t\t\t\tm = x->fcall.count;\n\t\t\tmemmove(b1, b+(off-boff), m);\n\t\t\tn += m;\n\t\t}\n\t\tboff += nb;\n\t\tq += nr;\n\t}\n\tfbuffree(r);\n\tfbuffree(b);\n\tfc.count = n;\n\tfc.data = b1;\n\trespond(x, &fc, nil);\n\tfbuffree(b1);\n}\n\nint\nxfidruneread(Xfid *x, Text *t, uint q0, uint q1)\n{\n\tFcall fc;\n\tWindow *w;\n\tRune *r, junk;\n\tchar *b, *b1;\n\tuint q, boff;\n\tint i, rw, m, n, nr, nb;\n\n\tw = t->w;\n\twincommit(w, t);\n\tr = fbufalloc();\n\tb = fbufalloc();\n\tb1 = fbufalloc();\n\tn = 0;\n\tq = q0;\n\tboff = 0;\n\twhile(q<q1 && n<x->fcall.count){\n\t\tnr = q1-q;\n\t\tif(nr > BUFSIZE/UTFmax)\n\t\t\tnr = BUFSIZE/UTFmax;\n\t\tbufread(&t->file->b, q, r, nr);\n\t\tnb = snprint(b, BUFSIZE+1, \"%.*S\", nr, r);\n\t\tm = nb;\n\t\tif(boff+m > x->fcall.count){\n\t\t\ti = x->fcall.count - boff;\n\t\t\t/* copy whole runes only */\n\t\t\tm = 0;\n\t\t\tnr = 0;\n\t\t\twhile(m < i){\n\t\t\t\trw = chartorune(&junk, b+m);\n\t\t\t\tif(m+rw > i)\n\t\t\t\t\tbreak;\n\t\t\t\tm += rw;\n\t\t\t\tnr++;\n\t\t\t}\n\t\t\tif(m == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tmemmove(b1+n, b, m);\n\t\tn += m;\n\t\tboff += nb;\n\t\tq += nr;\n\t}\n\tfbuffree(r);\n\tfbuffree(b);\n\tfc.count = n;\n\tfc.data = b1;\n\trespond(x, &fc, nil);\n\tfbuffree(b1);\n\treturn q-q0;\n}\n\nvoid\nxfideventread(Xfid *x, Window *w)\n{\n\tFcall fc;\n\tint i, n;\n\n\ti = 0;\n\tx->flushed = FALSE;\n\twhile(w->nevents == 0){\n\t\tif(i){\n\t\t\tif(!x->flushed)\n\t\t\t\trespond(x, &fc, \"window shut down\");\n\t\t\treturn;\n\t\t}\n\t\tw->eventx = x;\n\t\twinunlock(w);\n\t\trecvp(x->c);\n\t\twinlock(w, 'F');\n\t\ti++;\n\t}\n\n\tn = w->nevents;\n\tif(n > x->fcall.count)\n\t\tn = x->fcall.count;\n\tfc.count = n;\n\tfc.data = w->events;\n\trespond(x, &fc, nil);\n\tw->nevents -= n;\n\tif(w->nevents){\n\t\tmemmove(w->events, w->events+n, w->nevents);\n\t\tw->events = erealloc(w->events, w->nevents);\n\t}else{\n\t\tfree(w->events);\n\t\tw->events = nil;\n\t}\n}\n\nvoid\nxfidindexread(Xfid *x)\n{\n\tFcall fc;\n\tint i, j, m, n, nmax, isbuf, cnt, off;\n\tWindow *w;\n\tchar *b;\n\tRune *r;\n\tColumn *c;\n\n\tqlock(&row.lk);\n\tnmax = 0;\n\tfor(j=0; j<row.ncol; j++){\n\t\tc = row.col[j];\n\t\tfor(i=0; i<c->nw; i++){\n\t\t\tw = c->w[i];\n\t\t\tnmax += Ctlsize + w->tag.file->b.nc*UTFmax + 1;\n\t\t}\n\t}\n\tnmax++;\n\tisbuf = (nmax<=RBUFSIZE);\n\tif(isbuf)\n\t\tb = (char*)x->buf;\n\telse\n\t\tb = emalloc(nmax);\n\tr = fbufalloc();\n\tn = 0;\n\tfor(j=0; j<row.ncol; j++){\n\t\tc = row.col[j];\n\t\tfor(i=0; i<c->nw; i++){\n\t\t\tw = c->w[i];\n\t\t\t/* only show the currently active window of a set */\n\t\t\tif(w->body.file->curtext != &w->body)\n\t\t\t\tcontinue;\n\t\t\twinctlprint(w, b+n, 0);\n\t\t\tn += Ctlsize;\n\t\t\tm = min(RBUFSIZE, w->tag.file->b.nc);\n\t\t\tbufread(&w->tag.file->b, 0, r, m);\n\t\t\tm = n + snprint(b+n, nmax-n-1, \"%.*S\", m, r);\n\t\t\twhile(n<m && b[n]!='\\n')\n\t\t\t\tn++;\n\t\t\tb[n++] = '\\n';\n\t\t}\n\t}\n\tqunlock(&row.lk);\n\toff = x->fcall.offset;\n\tcnt = x->fcall.count;\n\tif(off > n)\n\t\toff = n;\n\tif(off+cnt > n)\n\t\tcnt = n-off;\n\tfc.count = cnt;\n\tmemmove(r, b+off, cnt);\n\tfc.data = (char*)r;\n\tif(!isbuf)\n\t\tfree(b);\n\trespond(x, &fc, nil);\n\tfbuffree(r);\n}\n", "source": "acme2k/src/cmd/acme/xfid.c", "file_type": "c"}
{"text": "#include <u.h>\n#include <libc.h>\n#include <draw.h>\n#include <thread.h>\n#include <cursor.h>\n#include <mouse.h>\n#include <keyboard.h>\n#include <frame.h>\n#include <fcall.h>\n#include <plumb.h>\n#include <libsec.h>\n#include \"dat.h\"\n#include \"fns.h\"\n\nenum\n{\n\tSlop = 100\t/* room to grow with reallocation */\n};\n\nstatic\nvoid\nsizecache(Buffer *b, uint n)\n{\n\tif(n <= b->cmax)\n\t\treturn;\n\tb->cmax = n+Slop;\n\tb->c = runerealloc(b->c, b->cmax);\n}\n\nstatic\nvoid\naddblock(Buffer *b, uint i, uint n)\n{\n\tif(i > b->nbl)\n\t\terror(\"internal error: addblock\");\n\n\tb->bl = realloc(b->bl, (b->nbl+1)*sizeof b->bl[0]);\n\tif(i < b->nbl)\n\t\tmemmove(b->bl+i+1, b->bl+i, (b->nbl-i)*sizeof(Block*));\n\tb->bl[i] = disknewblock(disk, n);\n\tb->nbl++;\n}\n\nstatic\nvoid\ndelblock(Buffer *b, uint i)\n{\n\tif(i >= b->nbl)\n\t\terror(\"internal error: delblock\");\n\n\tdiskrelease(disk, b->bl[i]);\n\tb->nbl--;\n\tif(i < b->nbl)\n\t\tmemmove(b->bl+i, b->bl+i+1, (b->nbl-i)*sizeof(Block*));\n\tb->bl = realloc(b->bl, b->nbl*sizeof b->bl[0]);\n}\n\n/*\n * Move cache so b->cq <= q0 < b->cq+b->cnc.\n * If at very end, q0 will fall on end of cache block.\n */\n\nstatic\nvoid\nflush(Buffer *b)\n{\n\tif(b->cdirty || b->cnc==0){\n\t\tif(b->cnc == 0)\n\t\t\tdelblock(b, b->cbi);\n\t\telse\n\t\t\tdiskwrite(disk, &b->bl[b->cbi], b->c, b->cnc);\n\t\tb->cdirty = FALSE;\n\t}\n}\n\nstatic\nvoid\nsetcache(Buffer *b, uint q0)\n{\n\tBlock **blp, *bl;\n\tuint i, q;\n\n\tif(q0 > b->nc)\n\t\terror(\"internal error: setcache\");\n\t/*\n\t * flush and reload if q0 is not in cache.\n\t */\n\tif(b->nc == 0 || (b->cq<=q0 && q0<b->cq+b->cnc))\n\t\treturn;\n\t/*\n\t * if q0 is at end of file and end of cache, continue to grow this block\n\t */\n\tif(q0==b->nc && q0==b->cq+b->cnc && b->cnc<Maxblock)\n\t\treturn;\n\tflush(b);\n\t/* find block */\n\tif(q0 < b->cq){\n\t\tq = 0;\n\t\ti = 0;\n\t}else{\n\t\tq = b->cq;\n\t\ti = b->cbi;\n\t}\n\tblp = &b->bl[i];\n\twhile(q+(*blp)->u.n <= q0 && q+(*blp)->u.n < b->nc){\n\t\tq += (*blp)->u.n;\n\t\ti++;\n\t\tblp++;\n\t\tif(i >= b->nbl)\n\t\t\terror(\"block not found\");\n\t}\n\tbl = *blp;\n\t/* remember position */\n\tb->cbi = i;\n\tb->cq = q;\n\tsizecache(b, bl->u.n);\n\tb->cnc = bl->u.n;\n\t/*read block*/\n\tdiskread(disk, bl, b->c, b->cnc);\n}\n\nvoid\nbufinsert(Buffer *b, uint q0, Rune *s, uint n)\n{\n\tuint i, m, t, off;\n\n\tif(q0 > b->nc)\n\t\terror(\"internal error: bufinsert\");\n\n\twhile(n > 0){\n\t\tsetcache(b, q0);\n\t\toff = q0-b->cq;\n\t\tif(b->cnc+n <= Maxblock){\n\t\t\t/* Everything fits in one block. */\n\t\t\tt = b->cnc+n;\n\t\t\tm = n;\n\t\t\tif(b->bl == nil){\t/* allocate */\n\t\t\t\tif(b->cnc != 0)\n\t\t\t\t\terror(\"internal error: bufinsert1 cnc!=0\");\n\t\t\t\taddblock(b, 0, t);\n\t\t\t\tb->cbi = 0;\n\t\t\t}\n\t\t\tsizecache(b, t);\n\t\t\trunemove(b->c+off+m, b->c+off, b->cnc-off);\n\t\t\trunemove(b->c+off, s, m);\n\t\t\tb->cnc = t;\n\t\t\tgoto Tail;\n\t\t}\n\t\t/*\n\t\t * We must make a new block.  If q0 is at\n\t\t * the very beginning or end of this block,\n\t\t * just make a new block and fill it.\n\t\t */\n\t\tif(q0==b->cq || q0==b->cq+b->cnc){\n\t\t\tif(b->cdirty)\n\t\t\t\tflush(b);\n\t\t\tm = min(n, Maxblock);\n\t\t\tif(b->bl == nil){\t/* allocate */\n\t\t\t\tif(b->cnc != 0)\n\t\t\t\t\terror(\"internal error: bufinsert2 cnc!=0\");\n\t\t\t\ti = 0;\n\t\t\t}else{\n\t\t\t\ti = b->cbi;\n\t\t\t\tif(q0 > b->cq)\n\t\t\t\t\ti++;\n\t\t\t}\n\t\t\taddblock(b, i, m);\n\t\t\tsizecache(b, m);\n\t\t\trunemove(b->c, s, m);\n\t\t\tb->cq = q0;\n\t\t\tb->cbi = i;\n\t\t\tb->cnc = m;\n\t\t\tgoto Tail;\n\t\t}\n\t\t/*\n\t\t * Split the block; cut off the right side and\n\t\t * let go of it.\n\t\t */\n\t\tm = b->cnc-off;\n\t\tif(m > 0){\n\t\t\ti = b->cbi+1;\n\t\t\taddblock(b, i, m);\n\t\t\tdiskwrite(disk, &b->bl[i], b->c+off, m);\n\t\t\tb->cnc -= m;\n\t\t}\n\t\t/*\n\t\t * Now at end of block.  Take as much input\n\t\t * as possible and tack it on end of block.\n\t\t */\n\t\tm = min(n, Maxblock-b->cnc);\n\t\tsizecache(b, b->cnc+m);\n\t\trunemove(b->c+b->cnc, s, m);\n\t\tb->cnc += m;\n  Tail:\n\t\tb->nc += m;\n\t\tq0 += m;\n\t\ts += m;\n\t\tn -= m;\n\t\tb->cdirty = TRUE;\n\t}\n}\n\nvoid\nbufdelete(Buffer *b, uint q0, uint q1)\n{\n\tuint m, n, off;\n\n\tif(!(q0<=q1 && q0<=b->nc && q1<=b->nc))\n\t\terror(\"internal error: bufdelete\");\n\twhile(q1 > q0){\n\t\tsetcache(b, q0);\n\t\toff = q0-b->cq;\n\t\tif(q1 > b->cq+b->cnc)\n\t\t\tn = b->cnc - off;\n\t\telse\n\t\t\tn = q1-q0;\n\t\tm = b->cnc - (off+n);\n\t\tif(m > 0)\n\t\t\trunemove(b->c+off, b->c+off+n, m);\n\t\tb->cnc -= n;\n\t\tb->cdirty = TRUE;\n\t\tq1 -= n;\n\t\tb->nc -= n;\n\t}\n}\n\nstatic int\nbufloader(void *v, uint q0, Rune *r, int nr)\n{\n\tbufinsert(v, q0, r, nr);\n\treturn nr;\n}\n\nuint\nloadfile(int fd, uint q0, int *nulls, int(*f)(void*, uint, Rune*, int), void *arg, DigestState *h)\n{\n\tchar *p;\n\tRune *r;\n\tint l, m, n, nb, nr;\n\tuint q1;\n\n\tp = emalloc((Maxblock+UTFmax+1)*sizeof p[0]);\n\tr = runemalloc(Maxblock);\n\tm = 0;\n\tn = 1;\n\tq1 = q0;\n\t/*\n\t * At top of loop, may have m bytes left over from\n\t * last pass, possibly representing a partial rune.\n\t */\n\twhile(n > 0){\n\t\tn = read(fd, p+m, Maxblock);\n\t\tif(n < 0){\n\t\t\twarning(nil, \"read error in Buffer.load\");\n\t\t\tbreak;\n\t\t}\n\t\tif(h != nil)\n\t\t\tsha1((uchar*)p+m, n, nil, h);\n\t\tm += n;\n\t\tp[m] = 0;\n\t\tl = m;\n\t\tif(n > 0)\n\t\t\tl -= UTFmax;\n\t\tcvttorunes(p, l, r, &nb, &nr, nulls);\n\t\tmemmove(p, p+nb, m-nb);\n\t\tm -= nb;\n\t\tq1 += (*f)(arg, q1, r, nr);\n\t}\n\tfree(p);\n\tfree(r);\n\treturn q1-q0;\n}\n\nuint\nbufload(Buffer *b, uint q0, int fd, int *nulls, DigestState *h)\n{\n\tif(q0 > b->nc)\n\t\terror(\"internal error: bufload\");\n\treturn loadfile(fd, q0, nulls, bufloader, b, h);\n}\n\nvoid\nbufread(Buffer *b, uint q0, Rune *s, uint n)\n{\n\tuint m;\n\n\tif(!(q0<=b->nc && q0+n<=b->nc))\n\t\terror(\"bufread: internal error\");\n\n\twhile(n > 0){\n\t\tsetcache(b, q0);\n\t\tm = min(n, b->cnc-(q0-b->cq));\n\t\trunemove(s, b->c+(q0-b->cq), m);\n\t\tq0 += m;\n\t\ts += m;\n\t\tn -= m;\n\t}\n}\n\nvoid\nbufreset(Buffer *b)\n{\n\tint i;\n\n\tb->nc = 0;\n\tb->cnc = 0;\n\tb->cq = 0;\n\tb->cdirty = 0;\n\tb->cbi = 0;\n\t/* delete backwards to avoid n\u00b2 behavior */\n\tfor(i=b->nbl-1; --i>=0; )\n\t\tdelblock(b, i);\n}\n\nvoid\nbufclose(Buffer *b)\n{\n\tbufreset(b);\n\tfree(b->c);\n\tb->c = nil;\n\tb->cnc = 0;\n\tfree(b->bl);\n\tb->bl = nil;\n\tb->nbl = 0;\n}\n", "source": "acme2k/src/cmd/acme/buff.c", "file_type": "c"}
{"text": "#include <u.h>\n#include <libc.h>\n#include <draw.h>\n#include <thread.h>\n#include <cursor.h>\n#include <mouse.h>\n#include <keyboard.h>\n#include <frame.h>\n#include <fcall.h>\n#include <plumb.h>\n#include <libsec.h>\n#include \"dat.h\"\n#include \"fns.h\"\n#include \"config.h\"\n\n/* for generating syms in mkfile only: */\n#include <bio.h>\n#include \"edit.h\"\n\nvoid\tmousethread(void*);\nvoid\tkeyboardthread(void*);\nvoid\twaitthread(void*);\nvoid\txfidallocthread(void*);\nvoid\tnewwindowthread(void*);\nvoid\tplumbproc(void*);\nint\t\ttimefmt(Fmt*);\n\nReffont\t**fontcache;\nint\t\tnfontcache;\nchar\twdir[512] = \".\";\nReffont\t*reffonts[2];\nint\t\tsnarffd = -1;\nint\t\tmainpid;\nchar\t*mtpt;\n\nenum{\n\tNSnarf = 1000\t/* less than 1024, I/O buffer size */\n};\nRune\tsnarfrune[NSnarf+1];\n\nCommand *command;\n\nvoid\tshutdownthread(void*);\nvoid\tacmeerrorinit(void);\nvoid\treadfile(Column*, char*);\nstatic int\tshutdown(void*, char*);\n\nvoid\nderror(Display *d, char *errorstr)\n{\n\tUSED(d);\n\terror(errorstr);\n}\n\nvoid\nthreadmain(int argc, char *argv[])\n{\n\tint i;\n\tchar *p, *loadfile;\n\tColumn *c;\n\tint ncol;\n\tDisplay *d;\n\trfork(RFENVG|RFNAMEG);\n\n\tncol = -1;\n\n\tloadfile = nil;\n\tARGBEGIN{\n\tcase 'D':\n\t\t{extern int _threaddebuglevel;\n\t\t_threaddebuglevel = ~0;\n\t\t}\n\t\tbreak;\n\tcase 'a':\n\t\tif(globalautoindent)\n\t\t\tglobalautoindent = FALSE;\n\t\telse\n\t\t\tglobalautoindent = TRUE;\n\t\tbreak;\n\n/*  bartmode/flag is now an option to be turned on config.h, just\n *  because it is way too useful to leave it as an meaningless\n *  flag, especially since considering how almost everyone seems\n *  to even miss its existence.\n *\n *  to get to the point, it denies window focus following mouse.\n *  how fickle those mice can truly be when decieveth by a soothing\n *  treat, a teat or two.\n */\n\n/*\tcase 'b':\n\t\tbartflag = TRUE;\n\t\tbreak; */\n\n\tcase 'c':\n\t\tp = ARGF();\n\t\tif(p == nil)\n\t\t\tgoto Usage;\n\t\tncol = atoi(p);\n\t\tif(ncol <= 0)\n\t\t\tgoto Usage;\n\t\tbreak;\n\tcase 'f':\n\t\tfontnames[0] = ARGF();\n\t\tif(fontnames[0] == nil)\n\t\t\tgoto Usage;\n\t\tbreak;\n\tcase 'F':\n\t\tfontnames[1] = ARGF();\n\t\tif(fontnames[1] == nil)\n\t\t\tgoto Usage;\n\t\tbreak;\n\tcase 'l':\n\t\tloadfile = ARGF();\n\t\tif(loadfile == nil)\n\t\t\tgoto Usage;\n\t\tbreak;\n\tcase 'm':\n\t\tmtpt = ARGF();\n\t\tif(mtpt == nil)\n\t\t\tgoto Usage;\n\t\tbreak;\n\tcase 'r':\n\t\tswapscrollbuttons = TRUE;\n\t\tbreak;\n\tcase 'W':\n\t\twinsize = ARGF();\n\t\tif(winsize == nil)\n\t\t\tgoto Usage;\n\t\tbreak;\n\tdefault:\n\tUsage:\n\t\tfprint(2, \"usage: acme -a -c ncol -f fontname -F fixedwidthfontname -l loadfile -W winsize\\n\");\n\t\tthreadexitsall(\"usage\");\n\t}ARGEND\n\n\tfontnames[0] = estrdup(fontnames[0]);\n\tfontnames[1] = estrdup(fontnames[1]);\n\n\tquotefmtinstall();\n\tfmtinstall('t', timefmt);\n\n\tcputype = getenv(\"cputype\");\n\tobjtype = getenv(\"objtype\");\n\thome = getenv(\"HOME\");\n\tacmeshell = getenv(\"acmeshell\");\n\tif(acmeshell && *acmeshell == '\\0')\n\t\tacmeshell = nil;\n\tp = getenv(\"tabstop\");\n\tif(p != nil){\n\t\tmaxtab = strtoul(p, nil, 0);\n\t\tfree(p);\n\t}\n\tif(maxtab == 0)\n\t\tmaxtab = 4;\n\tif(loadfile)\n\t\trowloadfonts(loadfile);\n\tputenv(\"font\", fontnames[0]);\n\tsnarffd = open(\"/dev/snarf\", OREAD|OCEXEC);\n/*\n\tif(cputype){\n\t\tsprint(buf, \"/acme/bin/%s\", cputype);\n\t\tbind(buf, \"/bin\", MBEFORE);\n\t}\n\tbind(\"/acme/bin\", \"/bin\", MBEFORE);\n*/\n\tgetwd(wdir, sizeof wdir);\n\n/*\n\tif(geninitdraw(nil, derror, fontnames[0], \"acme\", nil, Refnone) < 0){\n\t\tfprint(2, \"acme: can't open display: %r\\n\");\n\t\tthreadexitsall(\"geninitdraw\");\n\t}\n*/\n\tif(initdraw(derror, fontnames[0], \"acme\") < 0){\n\t\tfprint(2, \"acme: can't open display: %r\\n\");\n\t\tthreadexitsall(\"initdraw\");\n\t}\n\n\td = display;\n\tfont = d->defaultfont;\n/*assert(font); */\n\n\treffont.f = font;\n\treffonts[0] = &reffont;\n\tincref(&reffont.ref);\t/* one to hold up 'font' variable */\n\tincref(&reffont.ref);\t/* one to hold up reffonts[0] */\n\tfontcache = emalloc(sizeof(Reffont*));\n\tnfontcache = 1;\n\tfontcache[0] = &reffont;\n\n\ticoninit();\n\ttimerinit();\n\trxinit();\n\n\tcwait = threadwaitchan();\n\tccommand = chancreate(sizeof(Command**), 0);\n\tckill = chancreate(sizeof(Rune*), 0);\n\tcxfidalloc = chancreate(sizeof(Xfid*), 0);\n\tcxfidfree = chancreate(sizeof(Xfid*), 0);\n\tcnewwindow = chancreate(sizeof(Channel*), 0);\n\tcerr = chancreate(sizeof(char*), 0);\n\tcedit = chancreate(sizeof(int), 0);\n\tcexit = chancreate(sizeof(int), 0);\n\tcwarn = chancreate(sizeof(void*), 1);\n\tif(cwait==nil || ccommand==nil || ckill==nil || cxfidalloc==nil || cxfidfree==nil || cerr==nil || cexit==nil || cwarn==nil){\n\t\tfprint(2, \"acme: can't create initial channels: %r\\n\");\n\t\tthreadexitsall(\"channels\");\n\t}\n\tchansetname(ccommand, \"ccommand\");\n\tchansetname(ckill, \"ckill\");\n\tchansetname(cxfidalloc, \"cxfidalloc\");\n\tchansetname(cxfidfree, \"cxfidfree\");\n\tchansetname(cnewwindow, \"cnewwindow\");\n\tchansetname(cerr, \"cerr\");\n\tchansetname(cedit, \"cedit\");\n\tchansetname(cexit, \"cexit\");\n\tchansetname(cwarn, \"cwarn\");\n\n\tmousectl = initmouse(nil, screen);\n\tif(mousectl == nil){\n\t\tfprint(2, \"acme: can't initialize mouse: %r\\n\");\n\t\tthreadexitsall(\"mouse\");\n\t}\n\tmouse = &mousectl->m;\n\tkeyboardctl = initkeyboard(nil);\n\tif(keyboardctl == nil){\n\t\tfprint(2, \"acme: can't initialize keyboard: %r\\n\");\n\t\tthreadexitsall(\"keyboard\");\n\t}\n\tmainpid = getpid();\n\tstartplumbing();\n/*\n\tplumbeditfd = plumbopen(\"edit\", OREAD|OCEXEC);\n\tif(plumbeditfd < 0)\n\t\tfprint(2, \"acme: can't initialize plumber: %r\\n\");\n\telse{\n\t\tcplumb = chancreate(sizeof(Plumbmsg*), 0);\n\t\tthreadcreate(plumbproc, nil, STACK);\n\t}\n\tplumbsendfd = plumbopen(\"send\", OWRITE|OCEXEC);\n*/\n\n\tfsysinit();\n\n\t#define\tWPERCOL\t8\n\tdisk = diskinit();\n\tif(!loadfile || !rowload(&row, loadfile, TRUE)){\n\t\trowinit(&row, screen->clipr);\n\t\tif(ncol < 0){\n\t\t\tif(argc == 0)\n\t\t\t\tncol = 2;\n\t\t\telse{\n\t\t\t\tncol = (argc+(WPERCOL-1))/WPERCOL;\n\t\t\t\tif(ncol < 2)\n\t\t\t\t\tncol = 2;\n\t\t\t}\n\t\t}\n\t\tif(ncol == 0)\n\t\t\tncol = 2;\n\t\tfor(i=0; i<ncol; i++){\n\t\t\tc = rowadd(&row, nil, -1);\n\t\t\tif(c==nil && i==0)\n\t\t\t\terror(\"initializing columns\");\n\t\t}\n\t\tc = row.col[row.ncol-1];\n\t\tif(argc == 0)\n\t\t\treadfile(c, wdir);\n\t\telse\n\t\t\tfor(i=0; i<argc; i++){\n\t\t\t\tp = utfrrune(argv[i], '/');\n\t\t\t\tif((p!=nil && strcmp(p, \"/guide\")==0) || i/WPERCOL>=row.ncol)\n\t\t\t\t\treadfile(c, argv[i]);\n\t\t\t\telse\n\t\t\t\t\treadfile(row.col[i/WPERCOL], argv[i]);\n\t\t\t}\n\t}\n\tflushimage(display, 1);\n\n\tacmeerrorinit();\n\tthreadcreate(keyboardthread, nil, STACK);\n\tthreadcreate(mousethread, nil, STACK);\n\tthreadcreate(waitthread, nil, STACK);\n\tthreadcreate(xfidallocthread, nil, STACK);\n\tthreadcreate(newwindowthread, nil, STACK);\n/*\tthreadcreate(shutdownthread, nil, STACK); */\n\tthreadnotify(shutdown, 1);\n\trecvul(cexit);\n\tkillprocs();\n\tthreadexitsall(nil);\n}\n\nvoid\nreadfile(Column *c, char *s)\n{\n\tWindow *w;\n\tRune rb[256];\n\tint nr;\n\tRunestr rs;\n\n\tw = coladd(c, nil, nil, -1);\n\tif(s[0] != '/')\n\t\trunesnprint(rb, sizeof rb, \"%s/%s\", wdir, s);\n\telse\n\t\trunesnprint(rb, sizeof rb, \"%s\", s);\n\tnr = runestrlen(rb);\n\trs = cleanrname(runestr(rb, nr));\n\twinsetname(w, rs.r, rs.nr);\n\ttextload(&w->body, 0, s, 1);\n\tw->body.file->mod = FALSE;\n\tw->dirty = FALSE;\n\twinsettag(w);\n\twinresize(w, w->r, FALSE, TRUE);\n\ttextscrdraw(&w->body);\n\ttextsetselect(&w->tag, w->tag.file->b.nc, w->tag.file->b.nc);\n\txfidlog(w, \"new\");\n}\n\nchar *ignotes[] = {\n\t\"sys: write on closed pipe\",\n\t\"sys: ttin\",\n\t\"sys: ttou\",\n\t\"sys: tstp\",\n\tnil\n};\n\nchar *oknotes[] ={\n\t\"delete\",\n\t\"hangup\",\n\t\"kill\",\n\t\"exit\",\n\tnil\n};\n\nint\tdumping;\n\nstatic int\nshutdown(void *v, char *msg)\n{\n\tint i;\n\n\tUSED(v);\n\n\tfor(i=0; ignotes[i]; i++)\n\t\tif(strncmp(ignotes[i], msg, strlen(ignotes[i])) == 0)\n\t\t\treturn 1;\n\n\tkillprocs();\n\tif(!dumping && strcmp(msg, \"kill\")!=0 && strcmp(msg, \"exit\")!=0 && getpid()==mainpid){\n\t\tdumping = TRUE;\n\t\trowdump(&row, nil);\n\t}\n\tfor(i=0; oknotes[i]; i++)\n\t\tif(strncmp(oknotes[i], msg, strlen(oknotes[i])) == 0)\n\t\t\tthreadexitsall(msg);\n\tprint(\"acme: %s\\n\", msg);\n\treturn 0;\n}\n\n/*\nvoid\nshutdownthread(void *v)\n{\n\tchar *msg;\n\tChannel *c;\n\n\tUSED(v);\n\n\tthreadsetname(\"shutdown\");\n\tc = threadnotechan();\n\twhile((msg = recvp(c)) != nil)\n\t\tshutdown(nil, msg);\n}\n*/\n\nvoid\nkillprocs(void)\n{\n\tCommand *c;\n\n\tfsysclose();\n/*\tif(display) */\n/*\t\tflushimage(display, 1); */\n\n\tfor(c=command; c; c=c->next)\n\t\tpostnote(PNGROUP, c->pid, \"hangup\");\n}\n\nstatic int errorfd;\nint erroutfd;\n\nvoid\nacmeerrorproc(void *v)\n{\n\tchar *buf;\n\tint n;\n\n\tUSED(v);\n\tthreadsetname(\"acmeerrorproc\");\n\tbuf = emalloc(8192+1);\n\twhile((n=read(errorfd, buf, 8192)) >= 0){\n\t\tbuf[n] = '\\0';\n\t\tsendp(cerr, estrdup(buf));\n\t}\n}\n\nvoid\nacmeerrorinit(void)\n{\n\tint pfd[2];\n\n\tif(pipe(pfd) < 0)\n\t\terror(\"can't create pipe\");\n#if 0\n\tsprint(acmeerrorfile, \"/srv/acme.%s.%d\", getuser(), mainpid);\n\tfd = create(acmeerrorfile, OWRITE, 0666);\n\tif(fd < 0){\n\t\tremove(acmeerrorfile);\n  \t\tfd = create(acmeerrorfile, OWRITE, 0666);\n\t\tif(fd < 0)\n\t\t\terror(\"can't create acmeerror file\");\n\t}\n\tsprint(buf, \"%d\", pfd[0]);\n\twrite(fd, buf, strlen(buf));\n\tclose(fd);\n\t/* reopen pfd[1] close on exec */\n\tsprint(buf, \"/fd/%d\", pfd[1]);\n\terrorfd = open(buf, OREAD|OCEXEC);\n#endif\n\tfcntl(pfd[0], F_SETFD, FD_CLOEXEC);\n\tfcntl(pfd[1], F_SETFD, FD_CLOEXEC);\n\terroutfd = pfd[0];\n\terrorfd = pfd[1];\n\tif(errorfd < 0)\n\t\terror(\"can't re-open acmeerror file\");\n\tproccreate(acmeerrorproc, nil, STACK);\n}\n\n/*\nvoid\nplumbproc(void *v)\n{\n\tPlumbmsg *m;\n\n\tUSED(v);\n\tthreadsetname(\"plumbproc\");\n\tfor(;;){\n\t\tm = threadplumbrecv(plumbeditfd);\n\t\tif(m == nil)\n\t\t\tthreadexits(nil);\n\t\tsendp(cplumb, m);\n\t}\n}\n*/\n\nvoid\nkeyboardthread(void *v)\n{\n\tRune r;\n\tTimer *timer;\n\tText *t;\n\tenum { KTimer, KKey, NKALT };\n\tstatic Alt alts[NKALT+1];\n\n\tUSED(v);\n\talts[KTimer].c = nil;\n\talts[KTimer].v = nil;\n\talts[KTimer].op = CHANNOP;\n\talts[KKey].c = keyboardctl->c;\n\talts[KKey].v = &r;\n\talts[KKey].op = CHANRCV;\n\talts[NKALT].op = CHANEND;\n\n\ttimer = nil;\n\ttypetext = nil;\n\tthreadsetname(\"keyboardthread\");\n\tfor(;;){\n\t\tswitch(alt(alts)){\n\t\tcase KTimer:\n\t\t\ttimerstop(timer);\n\t\t\tt = typetext;\n\t\t\tif(t!=nil && t->what==Tag){\n\t\t\t\twinlock(t->w, 'K');\n\t\t\t\twincommit(t->w, t);\n\t\t\t\twinunlock(t->w);\n\t\t\t\tflushimage(display, 1);\n\t\t\t}\n\t\t\talts[KTimer].c = nil;\n\t\t\talts[KTimer].op = CHANNOP;\n\t\t\tbreak;\n\t\tcase KKey:\n\t\tcasekeyboard:\n\t\t\ttypetext = rowtype(&row, r, mouse->xy);\n\t\t\tt = typetext;\n\t\t\tif(t!=nil && t->col!=nil && !(r==Kdown || r==Kleft || r==Kright))\t/* scrolling doesn't change activecol */\n\t\t\t\tactivecol = t->col;\n\t\t\tif(t!=nil && t->w!=nil)\n\t\t\t\tt->w->body.file->curtext = &t->w->body;\n\t\t\tif(timer != nil)\n\t\t\t\ttimercancel(timer);\n\t\t\tif(t!=nil && t->what==Tag) {\n\t\t\t\ttimer = timerstart(500);\n\t\t\t\talts[KTimer].c = timer->c;\n\t\t\t\talts[KTimer].op = CHANRCV;\n\t\t\t}else{\n\t\t\t\ttimer = nil;\n\t\t\t\talts[KTimer].c = nil;\n\t\t\t\talts[KTimer].op = CHANNOP;\n\t\t\t}\n\t\t\tif(nbrecv(keyboardctl->c, &r) > 0)\n\t\t\t\tgoto casekeyboard;\n\t\t\tflushimage(display, 1);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nvoid\nmousethread(void *v)\n{\n\tText *t, *argt;\n\tint but;\n\tuint q0, q1;\n\tWindow *w;\n\tPlumbmsg *pm;\n\tMouse m;\n\tchar *act;\n\tenum { MResize, MMouse, MPlumb, MWarnings, NMALT };\n\tstatic Alt alts[NMALT+1];\n\n\tUSED(v);\n\tthreadsetname(\"mousethread\");\n\talts[MResize].c = mousectl->resizec;\n\talts[MResize].v = nil;\n\talts[MResize].op = CHANRCV;\n\talts[MMouse].c = mousectl->c;\n\talts[MMouse].v = &mousectl->m;\n\talts[MMouse].op = CHANRCV;\n\talts[MPlumb].c = cplumb;\n\talts[MPlumb].v = &pm;\n\talts[MPlumb].op = CHANRCV;\n\talts[MWarnings].c = cwarn;\n\talts[MWarnings].v = nil;\n\talts[MWarnings].op = CHANRCV;\n\tif(cplumb == nil)\n\t\talts[MPlumb].op = CHANNOP;\n\talts[NMALT].op = CHANEND;\n\n\tfor(;;){\n\t\tqlock(&row.lk);\n\t\tflushwarnings();\n\t\tqunlock(&row.lk);\n\t\tflushimage(display, 1);\n\t\tswitch(alt(alts)){\n\t\tcase MResize:\n\t\t\tif(getwindow(display, Refnone) < 0)\n\t\t\t\terror(\"attach to window\");\n\t\t\tdraw(screen, screen->r, display->white, nil, ZP);\n\t\t\ticoninit();\n\t\t\tscrlresize();\n\t\t\trowresize(&row, screen->clipr);\n\t\t\tbreak;\n\t\tcase MPlumb:\n\t\t\tif(strcmp(pm->type, \"text\") == 0){\n\t\t\t\tact = plumblookup(pm->attr, \"action\");\n\t\t\t\tif(act==nil || strcmp(act, \"showfile\")==0)\n\t\t\t\t\tplumblook(pm);\n\t\t\t\telse if(strcmp(act, \"showdata\")==0)\n\t\t\t\t\tplumbshow(pm);\n\t\t\t}\n\t\t\tplumbfree(pm);\n\t\t\tbreak;\n\t\tcase MWarnings:\n\t\t\tbreak;\n\t\tcase MMouse:\n\t\t\t/*\n\t\t\t * Make a copy so decisions are consistent; mousectl changes\n\t\t\t * underfoot.  Can't just receive into m because this introduces\n\t\t\t * another race; see /sys/src/libdraw/mouse.c.\n\t\t\t */\n\t\t\tm = mousectl->m;\n\t\t\tqlock(&row.lk);\n\t\t\tt = rowwhich(&row, m.xy);\n\n\t\t\tif((t!=mousetext && t!=nil && t->w!=nil) &&\n\t\t\t\t(mousetext==nil || mousetext->w==nil || t->w->id!=mousetext->w->id)) {\n\t\t\t\txfidlog(t->w, \"focus\");\n\t\t\t}\n\n\t\t\tif(t!=mousetext && mousetext!=nil && mousetext->w!=nil){\n\t\t\t\twinlock(mousetext->w, 'M');\n\t\t\t\tmousetext->eq0 = ~0;\n\t\t\t\twincommit(mousetext->w, mousetext);\n\t\t\t\twinunlock(mousetext->w);\n\t\t\t}\n\t\t\tmousetext = t;\n\t\t\tif(t == nil)\n\t\t\t\tgoto Continue;\n\t\t\tw = t->w;\n\t\t\tif(t==nil || m.buttons==0)\n\t\t\t\tgoto Continue;\n\t\t\tbut = 0;\n\t\t\tif(m.buttons == 1)\n\t\t\t\tbut = 1;\n\t\t\telse if(m.buttons == 2)\n\t\t\t\tbut = 2;\n\t\t\telse if(m.buttons == 4)\n\t\t\t\tbut = 3;\n\t\t\tbarttext = t;\n\t\t\tif(t->what==Body && ptinrect(m.xy, t->scrollr)){\n\t\t\t\tif(but){\n\t\t\t\t\tif(swapscrollbuttons){\n\t\t\t\t\t\tif(but == 1)\n\t\t\t\t\t\t\tbut = 3;\n\t\t\t\t\t\telse if(but == 3)\n\t\t\t\t\t\t\tbut = 1;\n\t\t\t\t\t}\n\t\t\t\t\twinlock(w, 'M');\n\t\t\t\t\tt->eq0 = ~0;\n\t\t\t\t\ttextscroll(t, but);\n\t\t\t\t\twinunlock(w);\n\t\t\t\t}\n\t\t\t\tgoto Continue;\n\t\t\t}\n\t\t\t/* scroll buttons, wheels, etc. */\n\t\t\tif(w != nil && (m.buttons & (8|16))){\n\t\t\t\tif(m.buttons & 8)\n\t\t\t\t\tbut = Kscrolloneup;\n\t\t\t\telse\n\t\t\t\t\tbut = Kscrollonedown;\n\t\t\t\twinlock(w, 'M');\n\t\t\t\tt->eq0 = ~0;\n\t\t\t\ttexttype(t, but);\n\t\t\t\twinunlock(w);\n\t\t\t\tgoto Continue;\n\t\t\t}\n\t\t\tif(ptinrect(m.xy, t->scrollr)){\n\t\t\t\tif(but){\n\t\t\t\t\tif(t->what == Columntag)\n\t\t\t\t\t\trowdragcol(&row, t->col, but);\n\t\t\t\t\telse if(t->what == Tag){\n\t\t\t\t\t\tcoldragwin(t->col, t->w, but);\n\t\t\t\t\t\tif(t->w)\n\t\t\t\t\t\t\tbarttext = &t->w->body;\n\t\t\t\t\t}\n\t\t\t\t\tif(t->col)\n\t\t\t\t\t\tactivecol = t->col;\n\t\t\t\t}\n\t\t\t\tgoto Continue;\n\t\t\t}\n\t\t\tif(m.buttons){\n\t\t\t\tif(w)\n\t\t\t\t\twinlock(w, 'M');\n\t\t\t\tt->eq0 = ~0;\n\t\t\t\tif(w)\n\t\t\t\t\twincommit(w, t);\n\t\t\t\telse\n\t\t\t\t\ttextcommit(t, TRUE);\n\t\t\t\tif(m.buttons & 1){\n\t\t\t\t\ttextselect(t);\n\t\t\t\t\tif(w)\n\t\t\t\t\t\twinsettag(w);\n\t\t\t\t\targtext = t;\n\t\t\t\t\tseltext = t;\n\t\t\t\t\tif(t->col)\n\t\t\t\t\t\tactivecol = t->col;\t/* button 1 only */\n\t\t\t\t\tif(t->w!=nil && t==&t->w->body)\n\t\t\t\t\t\tactivewin = t->w;\n\t\t\t\t}else if(m.buttons & 2){\n\t\t\t\t\tif(textselect2(t, &q0, &q1, &argt))\n\t\t\t\t\t\texecute(t, q0, q1, FALSE, argt);\n\t\t\t\t}else if(m.buttons & 4){\n\t\t\t\t\tif(textselect3(t, &q0, &q1))\n\t\t\t\t\t\tlook3(t, q0, q1, FALSE);\n\t\t\t\t}\n\t\t\t\tif(w)\n\t\t\t\t\twinunlock(w);\n\t\t\t\tgoto Continue;\n\t\t\t}\n    Continue:\n\t\t\tqunlock(&row.lk);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n/*\n * There is a race between process exiting and our finding out it was ever created.\n * This structure keeps a list of processes that have exited we haven't heard of.\n */\ntypedef struct Pid Pid;\nstruct Pid\n{\n\tint\tpid;\n\tchar\tmsg[ERRMAX];\n\tPid\t*next;\n};\n\nvoid\nwaitthread(void *v)\n{\n\tWaitmsg *w;\n\tCommand *c, *lc;\n\tuint pid;\n\tint found, ncmd;\n\tRune *cmd;\n\tchar *err;\n\tText *t;\n\tPid *pids, *p, *lastp;\n\tenum { WErr, WKill, WWait, WCmd, NWALT };\n\tAlt alts[NWALT+1];\n\n\tUSED(v);\n\tthreadsetname(\"waitthread\");\n\tpids = nil;\n\talts[WErr].c = cerr;\n\talts[WErr].v = &err;\n\talts[WErr].op = CHANRCV;\n\talts[WKill].c = ckill;\n\talts[WKill].v = &cmd;\n\talts[WKill].op = CHANRCV;\n\talts[WWait].c = cwait;\n\talts[WWait].v = &w;\n\talts[WWait].op = CHANRCV;\n\talts[WCmd].c = ccommand;\n\talts[WCmd].v = &c;\n\talts[WCmd].op = CHANRCV;\n\talts[NWALT].op = CHANEND;\n\n\tcommand = nil;\n\tfor(;;){\n\t\tswitch(alt(alts)){\n\t\tcase WErr:\n\t\t\tqlock(&row.lk);\n\t\t\twarning(nil, \"%s\", err);\n\t\t\tfree(err);\n\t\t\tflushimage(display, 1);\n\t\t\tqunlock(&row.lk);\n\t\t\tbreak;\n\t\tcase WKill:\n\t\t\tfound = FALSE;\n\t\t\tncmd = runestrlen(cmd);\n\t\t\tfor(c=command; c; c=c->next){\n\t\t\t\t/* -1 for blank */\n\t\t\t\tif(runeeq(c->name, c->nname-1, cmd, ncmd) == TRUE){\n\t\t\t\t\tif(postnote(PNGROUP, c->pid, \"kill\") < 0)\n\t\t\t\t\t\twarning(nil, \"kill %S: %r\\n\", cmd);\n\t\t\t\t\tfound = TRUE;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!found)\n\t\t\t\twarning(nil, \"Kill: no process %S\\n\", cmd);\n\t\t\tfree(cmd);\n\t\t\tbreak;\n\t\tcase WWait:\n\t\t\tpid = w->pid;\n\t\t\tlc = nil;\n\t\t\tfor(c=command; c; c=c->next){\n\t\t\t\tif(c->pid == pid){\n\t\t\t\t\tif(lc)\n\t\t\t\t\t\tlc->next = c->next;\n\t\t\t\t\telse\n\t\t\t\t\t\tcommand = c->next;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tlc = c;\n\t\t\t}\n\t\t\tqlock(&row.lk);\n\t\t\tt = &row.tag;\n\t\t\ttextcommit(t, TRUE);\n\t\t\tif(c == nil){\n\t\t\t\t/* helper processes use this exit status */\n\t\t\t\tif(strncmp(w->msg, \"libthread\", 9) != 0){\n\t\t\t\t\tp = emalloc(sizeof(Pid));\n\t\t\t\t\tp->pid = pid;\n\t\t\t\t\tstrncpy(p->msg, w->msg, sizeof(p->msg));\n\t\t\t\t\tp->next = pids;\n\t\t\t\t\tpids = p;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(search(t, c->name, c->nname)){\n\t\t\t\t\ttextdelete(t, t->q0, t->q1, TRUE);\n\t\t\t\t\ttextsetselect(t, 0, 0);\n\t\t\t\t}\n\t\t\t\tif(w->msg[0])\n\t\t\t\t\twarning(c->md, \"%.*S: exit %s\\n\", c->nname-1, c->name, w->msg);\n\t\t\t\tflushimage(display, 1);\n\t\t\t}\n\t\t\tqunlock(&row.lk);\n\t\t\tfree(w);\n    Freecmd:\n\t\t\tif(c){\n\t\t\t\tif(c->iseditcmd)\n\t\t\t\t\tsendul(cedit, 0);\n\t\t\t\tfree(c->text);\n\t\t\t\tfree(c->name);\n\t\t\t\tfsysdelid(c->md);\n\t\t\t\tfree(c);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase WCmd:\n\t\t\t/* has this command already exited? */\n\t\t\tlastp = nil;\n\t\t\tfor(p=pids; p!=nil; p=p->next){\n\t\t\t\tif(p->pid == c->pid){\n\t\t\t\t\tif(p->msg[0])\n\t\t\t\t\t\twarning(c->md, \"%s\\n\", p->msg);\n\t\t\t\t\tif(lastp == nil)\n\t\t\t\t\t\tpids = p->next;\n\t\t\t\t\telse\n\t\t\t\t\t\tlastp->next = p->next;\n\t\t\t\t\tfree(p);\n\t\t\t\t\tgoto Freecmd;\n\t\t\t\t}\n\t\t\t\tlastp = p;\n\t\t\t}\n\t\t\tc->next = command;\n\t\t\tcommand = c;\n\t\t\tqlock(&row.lk);\n\t\t\tt = &row.tag;\n\t\t\ttextcommit(t, TRUE);\n\t\t\ttextinsert(t, 0, c->name, c->nname, TRUE);\n\t\t\ttextsetselect(t, 0, 0);\n\t\t\tflushimage(display, 1);\n\t\t\tqunlock(&row.lk);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nvoid\nxfidallocthread(void *v)\n{\n\tXfid *xfree, *x;\n\tenum { Alloc, Free, N };\n\tstatic Alt alts[N+1];\n\n\tUSED(v);\n\tthreadsetname(\"xfidallocthread\");\n\talts[Alloc].c = cxfidalloc;\n\talts[Alloc].v = nil;\n\talts[Alloc].op = CHANRCV;\n\talts[Free].c = cxfidfree;\n\talts[Free].v = &x;\n\talts[Free].op = CHANRCV;\n\talts[N].op = CHANEND;\n\n\txfree = nil;\n\tfor(;;){\n\t\tswitch(alt(alts)){\n\t\tcase Alloc:\n\t\t\tx = xfree;\n\t\t\tif(x)\n\t\t\t\txfree = x->next;\n\t\t\telse{\n\t\t\t\tx = emalloc(sizeof(Xfid));\n\t\t\t\tx->c = chancreate(sizeof(void(*)(Xfid*)), 0);\n\t\t\t\tchansetname(x->c, \"xc%p\", x->c);\n\t\t\t\tx->arg = x;\n\t\t\t\tthreadcreate(xfidctl, x->arg, STACK);\n\t\t\t}\n\t\t\tsendp(cxfidalloc, x);\n\t\t\tbreak;\n\t\tcase Free:\n\t\t\tx->next = xfree;\n\t\t\txfree = x;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n/* this thread, in the main proc, allows fsysproc to get a window made without doing graphics */\nvoid\nnewwindowthread(void *v)\n{\n\tWindow *w;\n\n\tUSED(v);\n\tthreadsetname(\"newwindowthread\");\n\n\tfor(;;){\n\t\t/* only fsysproc is talking to us, so synchronization is trivial */\n\t\trecvp(cnewwindow);\n\t\tw = makenewwindow(nil);\n\t\twinsettag(w);\n\t\txfidlog(w, \"new\");\n\t\tsendp(cnewwindow, w);\n\t}\n}\n\nReffont*\nrfget(int fix, int save, int setfont, char *name)\n{\n\tReffont *r;\n\tFont *f;\n\tint i;\n\n\tr = nil;\n\tif(name == nil){\n\t\tname = fontnames[fix];\n\t\tr = reffonts[fix];\n\t}\n\tif(r == nil){\n\t\tfor(i=0; i<nfontcache; i++)\n\t\t\tif(strcmp(name, fontcache[i]->f->name) == 0){\n\t\t\t\tr = fontcache[i];\n\t\t\t\tgoto Found;\n\t\t\t}\n\t\tf = openfont(display, name);\n\t\tif(f == nil){\n\t\t\twarning(nil, \"can't open font file %s: %r\\n\", name);\n\t\t\treturn nil;\n\t\t}\n\t\tr = emalloc(sizeof(Reffont));\n\t\tr->f = f;\n\t\tfontcache = erealloc(fontcache, (nfontcache+1)*sizeof(Reffont*));\n\t\tfontcache[nfontcache++] = r;\n\t}\n    Found:\n\tif(save){\n\t\tincref(&r->ref);\n\t\tif(reffonts[fix])\n\t\t\trfclose(reffonts[fix]);\n\t\treffonts[fix] = r;\n\t\tif(name != fontnames[fix]){\n\t\t\tfree(fontnames[fix]);\n\t\t\tfontnames[fix] = estrdup(name);\n\t\t}\n\t}\n\tif(setfont){\n\t\treffont.f = r->f;\n\t\tincref(&r->ref);\n\t\trfclose(reffonts[0]);\n\t\tfont = r->f;\n\t\treffonts[0] = r;\n\t\tincref(&r->ref);\n\t\ticoninit();\n\t}\n\tincref(&r->ref);\n\treturn r;\n}\n\nvoid\nrfclose(Reffont *r)\n{\n\tint i;\n\n\tif(decref(&r->ref) == 0){\n\t\tfor(i=0; i<nfontcache; i++)\n\t\t\tif(r == fontcache[i])\n\t\t\t\tbreak;\n\t\tif(i >= nfontcache)\n\t\t\twarning(nil, \"internal error: can't find font in cache\\n\");\n\t\telse{\n\t\t\tnfontcache--;\n\t\t\tmemmove(fontcache+i, fontcache+i+1, (nfontcache-i)*sizeof(Reffont*));\n\t\t}\n\t\tfreefont(r->f);\n\t\tfree(r);\n\t}\n}\n\nCursor boxcursor = {\n\t{-7, -7},\n\t{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n\t 0xFF, 0xFF, 0xF8, 0x1F, 0xF8, 0x1F, 0xF8, 0x1F,\n\t 0xF8, 0x1F, 0xF8, 0x1F, 0xF8, 0x1F, 0xFF, 0xFF,\n\t 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF},\n\t{0x00, 0x00, 0x7F, 0xFE, 0x7F, 0xFE, 0x7F, 0xFE,\n\t 0x70, 0x0E, 0x70, 0x0E, 0x70, 0x0E, 0x70, 0x0E,\n\t 0x70, 0x0E, 0x70, 0x0E, 0x70, 0x0E, 0x70, 0x0E,\n\t 0x7F, 0xFE, 0x7F, 0xFE, 0x7F, 0xFE, 0x00, 0x00}\n};\n\nvoid\niconinit(void)\n{\n\tRectangle r;\n\tImage *tmp;\n\n\tif(tagcols[BACK] == nil) {\n\n\t\ttagcols[BACK]\t= allocimage(display, Rect(0,0,1,1), RGBA32, 1, C_TAGBG);\n\t\ttagcols[HIGH]\t= allocimage(display, Rect(0,0,1,1), RGBA32, 1, C_TAGHLBG);\n\t\ttagcols[BORD]\t= allocimage(display, Rect(0,0,1,1), RGBA32, 1, C_COLBUTTON);\n\t\ttagcols[TEXT]\t= allocimage(display, Rect(0,0,1,1), RGBA32, 1, C_TAGFG);\n\t\ttagcols[HTEXT]\t= allocimage(display, Rect(0,0,1,1), RGBA32, 1, C_TAGHLFG);\n\n\t\ttextcols[BACK] \t= allocimage(display, Rect(0,0,1,1), RGBA32, 1, C_TXTBG);\n\t\ttextcols[HIGH] \t= allocimage(display, Rect(0,0,1,1), RGBA32, 1, C_TXTHLBG);\n\t\ttextcols[BORD] \t= allocimage(display, Rect(0,0,1,1), RGBA32, 1, C_SCROLLBG);\n\t\ttextcols[TEXT] \t= allocimage(display, Rect(0,0,1,1), RGBA32, 1, C_TXTFG);\n\t\ttextcols[HTEXT] = allocimage(display, Rect(0,0,1,1), RGBA32, 1, C_TXTHLFG);\n\n\t}\n\n\tr = Rect(0, 0, Scrollwid+ButtonBorder, font->height+1);\n\tif(button && eqrect(r, button->r))\n\t\treturn;\n\n\tif(button){\n\t\tfreeimage(button);\n\t\tfreeimage(modbutton);\n\t\tfreeimage(colbutton);\n\t}\n\n\tbutton = allocimage(display, r, screen->chan, 0, DNofill);\n\tdraw(button, r, tagcols[BACK], nil, r.min);\n\tr.max.x -= ButtonBorder;\n\tborder(button, r, ButtonBorder, tagcols[BORD], ZP);\n\n\tr = button->r;\n\tmodbutton = allocimage(display, r, screen->chan, 0, DNofill);\n\tdraw(modbutton, r, tagcols[BACK], nil, r.min);\n\tr.max.x -= ButtonBorder;\n\tborder(modbutton, r, ButtonBorder, tagcols[BORD], ZP);\n\tr = insetrect(r, ButtonBorder);\n\ttmp = allocimage(display, Rect(0,0,1,1), RGBA32, 1, C_TMPBUTTON);\n\tdraw(modbutton, r, tmp, nil, ZP);\n\tfreeimage(tmp);\n\n\tr = button->r;\n\tcolbutton = allocimage(display, r, RGBA32, 1, C_WINBUTTON);\n\n\tbut2col = allocimage(display, r, screen->chan, 1, C_BUTTON2HL);\n\tbut3col = allocimage(display, r, screen->chan, 1, C_BUTTON3HL);\n}\n\n/*\n * /dev/snarf updates when the file is closed, so we must open our own\n * fd here rather than use snarffd\n */\n\n/* rio truncates larges snarf buffers, so this avoids using the\n * service if the string is huge */\n\n#define MAXSNARF 100*1024\n\nvoid\nacmeputsnarf(void)\n{\n\tint i, n;\n\tFmt f;\n\tchar *s;\n\n\tif(snarfbuf.nc==0)\n\t\treturn;\n\tif(snarfbuf.nc > MAXSNARF)\n\t\treturn;\n\n\tfmtstrinit(&f);\n\tfor(i=0; i<snarfbuf.nc; i+=n){\n\t\tn = snarfbuf.nc-i;\n\t\tif(n >= NSnarf)\n\t\t\tn = NSnarf;\n\t\tbufread(&snarfbuf, i, snarfrune, n);\n\t\tif(fmtprint(&f, \"%.*S\", n, snarfrune) < 0)\n\t\t\tbreak;\n\t}\n\ts = fmtstrflush(&f);\n\tif(s && s[0])\n\t\tputsnarf(s);\n\tfree(s);\n}\n\nvoid\nacmegetsnarf(void)\n{\n\tchar *s;\n\tint nb, nr, nulls, len;\n\tRune *r;\n\n\ts = getsnarf();\n\tif(s == nil || s[0]==0){\n\t\tfree(s);\n\t\treturn;\n\t}\n\n\tlen = strlen(s);\n\tr = runemalloc(len+1);\n\tcvttorunes(s, len, r, &nb, &nr, &nulls);\n\tbufreset(&snarfbuf);\n\tbufinsert(&snarfbuf, 0, r, nr);\n\tfree(r);\n\tfree(s);\n}\n\nint\nismtpt(char *file)\n{\n\tint n;\n\n\tif(mtpt == nil)\n\t\treturn 0;\n\n\t/* This is not foolproof, but it will stop a lot of them. */\n\tn = strlen(mtpt);\n\treturn strncmp(file, mtpt, n) == 0 && ((n > 0 && mtpt[n-1] == '/') || file[n] == '/' || file[n] == 0);\n}\n\nint\ntimefmt(Fmt *f)\n{\n\tTm *tm;\n\n\ttm = localtime(va_arg(f->args, ulong));\n\treturn fmtprint(f, \"%04d/%02d/%02d %02d:%02d:%02d\",\n\t\ttm->year+1900, tm->mon+1, tm->mday, tm->hour, tm->min, tm->sec);\n}\n", "source": "acme2k/src/cmd/acme/acme.c", "file_type": "c"}
{"text": "#include <u.h>\n#include <libc.h>\n#include <draw.h>\n#include <thread.h>\n#include <cursor.h>\n#include <mouse.h>\n#include <keyboard.h>\n#include <frame.h>\n#include <fcall.h>\n#include <bio.h>\n#include <plumb.h>\n#include <libsec.h>\n#include \"dat.h\"\n#include \"fns.h\"\n\nstatic Rune Lcolhdr[] = {\n\t'N', 'e', 'w', 'c', 'o', 'l', ' ',\n\t'K', 'i', 'l', 'l', ' ',\n\t'P', 'u', 't', 'a', 'l', 'l', ' ',\n\t'D', 'u', 'm', 'p', ' ',\n\t'E', 'x', 'i', 't', ' ',\n\t0\n};\n\nvoid\nrowinit(Row *row, Rectangle r)\n{\n\tRectangle r1;\n\tText *t;\n\n\tdraw(screen, r, display->white, nil, ZP);\n\trow->r = r;\n\trow->col = nil;\n\trow->ncol = 0;\n\tr1 = r;\n\tr1.max.y = r1.min.y + font->height;\n\tt = &row->tag;\n\ttextinit(t, fileaddtext(nil, t), r1, rfget(FALSE, FALSE, FALSE, nil), tagcols);\n\tt->what = Rowtag;\n\tt->row = row;\n\tt->w = nil;\n\tt->col = nil;\n\tr1.min.y = r1.max.y;\n\tr1.max.y += Border;\n\tdraw(screen, r1, display->black, nil, ZP);\n\ttextinsert(t, 0, Lcolhdr, 29, TRUE);\n\ttextsetselect(t, t->file->b.nc, t->file->b.nc);\n}\n\nColumn*\nrowadd(Row *row, Column *c, int x)\n{\n\tRectangle r, r1;\n\tColumn *d;\n\tint i;\n\n\td = nil;\n\tr = row->r;\n\tr.min.y = row->tag.fr.r.max.y+Border;\n\tif(x<r.min.x && row->ncol>0){\t/*steal 40% of last column by default */\n\t\td = row->col[row->ncol-1];\n\t\tx = d->r.min.x + 3*Dx(d->r)/5;\n\t}\n\t/* look for column we'll land on */\n\tfor(i=0; i<row->ncol; i++){\n\t\td = row->col[i];\n\t\tif(x < d->r.max.x)\n\t\t\tbreak;\n\t}\n\tif(row->ncol > 0){\n\t\tif(i < row->ncol)\n\t\t\ti++;\t/* new column will go after d */\n\t\tr = d->r;\n\t\tif(Dx(r) < 100)\n\t\t\treturn nil;\n\t\tdraw(screen, r, display->white, nil, ZP);\n\t\tr1 = r;\n\t\tr1.max.x = min(x-Border, r.max.x-50);\n\t\tif(Dx(r1) < 50)\n\t\t\tr1.max.x = r1.min.x+50;\n\t\tcolresize(d, r1);\n\t\tr1.min.x = r1.max.x;\n\t\tr1.max.x = r1.min.x+Border;\n\t\tdraw(screen, r1, display->black, nil, ZP);\n\t\tr.min.x = r1.max.x;\n\t}\n\tif(c == nil){\n\t\tc = emalloc(sizeof(Column));\n\t\tcolinit(c, r);\n\t\tincref(&reffont.ref);\n\t}else\n\t\tcolresize(c, r);\n\tc->row = row;\n\tc->tag.row = row;\n\trow->col = realloc(row->col, (row->ncol+1)*sizeof(Column*));\n\tmemmove(row->col+i+1, row->col+i, (row->ncol-i)*sizeof(Column*));\n\trow->col[i] = c;\n\trow->ncol++;\n\tclearmouse();\n\treturn c;\n}\n\nvoid\nrowresize(Row *row, Rectangle r)\n{\n\tint i, deltax;\n\tRectangle or, r1, r2;\n\tColumn *c;\n\n\tor = row->r;\n\tdeltax = r.min.x - or.min.x;\n\trow->r = r;\n\tr1 = r;\n\tr1.max.y = r1.min.y + font->height;\n\ttextresize(&row->tag, r1, TRUE);\n\tr1.min.y = r1.max.y;\n\tr1.max.y += Border;\n\tdraw(screen, r1, display->black, nil, ZP);\n\tr.min.y = r1.max.y;\n\tr1 = r;\n\tr1.max.x = r1.min.x;\n\tfor(i=0; i<row->ncol; i++){\n\t\tc = row->col[i];\n\t\tr1.min.x = r1.max.x;\n\t\t/* the test should not be necessary, but guarantee we don't lose a pixel */\n\t\tif(i == row->ncol-1)\n\t\t\tr1.max.x = r.max.x;\n\t\telse\n\t\t\tr1.max.x = (c->r.max.x-or.min.x)*Dx(r)/Dx(or) + deltax;\n\t\tif(i > 0){\n\t\t\tr2 = r1;\n\t\t\tr2.max.x = r2.min.x+Border;\n\t\t\tdraw(screen, r2, display->black, nil, ZP);\n\t\t\tr1.min.x = r2.max.x;\n\t\t}\n\t\tcolresize(c, r1);\n\t}\n}\n\nvoid\nrowdragcol(Row *row, Column *c, int _0)\n{\n\tRectangle r;\n\tint i, b, x;\n\tPoint p, op;\n\tColumn *d;\n\n\tUSED(_0);\n\n\tclearmouse();\n\tsetcursor(mousectl, &boxcursor);\n\tb = mouse->buttons;\n\top = mouse->xy;\n\twhile(mouse->buttons == b)\n\t\treadmouse(mousectl);\n\tsetcursor(mousectl, nil);\n\tif(mouse->buttons){\n\t\twhile(mouse->buttons)\n\t\t\treadmouse(mousectl);\n\t\treturn;\n\t}\n\n\tfor(i=0; i<row->ncol; i++)\n\t\tif(row->col[i] == c)\n\t\t\tgoto Found;\n\terror(\"can't find column\");\n\n  Found:\n\tp = mouse->xy;\n\tif((abs(p.x-op.x)<5 && abs(p.y-op.y)<5))\n\t\treturn;\n\tif((i>0 && p.x<row->col[i-1]->r.min.x) || (i<row->ncol-1 && p.x>c->r.max.x)){\n\t\t/* shuffle */\n\t\tx = c->r.min.x;\n\t\trowclose(row, c, FALSE);\n\t\tif(rowadd(row, c, p.x) == nil)\t/* whoops! */\n\t\tif(rowadd(row, c, x) == nil)\t\t/* WHOOPS! */\n\t\tif(rowadd(row, c, -1)==nil){\t\t/* shit! */\n\t\t\trowclose(row, c, TRUE);\n\t\t\treturn;\n\t\t}\n\t\tcolmousebut(c);\n\t\treturn;\n\t}\n\tif(i == 0)\n\t\treturn;\n\td = row->col[i-1];\n\tif(p.x < d->r.min.x+80+Scrollwid)\n\t\tp.x = d->r.min.x+80+Scrollwid;\n\tif(p.x > c->r.max.x-80-Scrollwid)\n\t\tp.x = c->r.max.x-80-Scrollwid;\n\tr = d->r;\n\tr.max.x = c->r.max.x;\n\tdraw(screen, r, display->white, nil, ZP);\n\tr.max.x = p.x;\n\tcolresize(d, r);\n\tr = c->r;\n\tr.min.x = p.x;\n\tr.max.x = r.min.x;\n\tr.max.x += Border;\n\tdraw(screen, r, display->black, nil, ZP);\n\tr.min.x = r.max.x;\n\tr.max.x = c->r.max.x;\n\tcolresize(c, r);\n\tcolmousebut(c);\n}\n\nvoid\nrowclose(Row *row, Column *c, int dofree)\n{\n\tRectangle r;\n\tint i;\n\n\tfor(i=0; i<row->ncol; i++)\n\t\tif(row->col[i] == c)\n\t\t\tgoto Found;\n\terror(\"can't find column\");\n  Found:\n\tr = c->r;\n\tif(dofree)\n\t\tcolcloseall(c);\n\trow->ncol--;\n\tmemmove(row->col+i, row->col+i+1, (row->ncol-i)*sizeof(Column*));\n\trow->col = realloc(row->col, row->ncol*sizeof(Column*));\n\tif(row->ncol == 0){\n\t\tdraw(screen, r, display->white, nil, ZP);\n\t\treturn;\n\t}\n\tif(i == row->ncol){\t\t/* extend last column right */\n\t\tc = row->col[i-1];\n\t\tr.min.x = c->r.min.x;\n\t\tr.max.x = row->r.max.x;\n\t}else{\t\t\t/* extend next window left */\n\t\tc = row->col[i];\n\t\tr.max.x = c->r.max.x;\n\t}\n\tdraw(screen, r, display->white, nil, ZP);\n\tcolresize(c, r);\n}\n\nColumn*\nrowwhichcol(Row *row, Point p)\n{\n\tint i;\n\tColumn *c;\n\n\tfor(i=0; i<row->ncol; i++){\n\t\tc = row->col[i];\n\t\tif(ptinrect(p, c->r))\n\t\t\treturn c;\n\t}\n\treturn nil;\n}\n\nText*\nrowwhich(Row *row, Point p)\n{\n\tColumn *c;\n\n\tif(ptinrect(p, row->tag.all))\n\t\treturn &row->tag;\n\tc = rowwhichcol(row, p);\n\tif(c)\n\t\treturn colwhich(c, p);\n\treturn nil;\n}\n\nText*\nrowtype(Row *row, Rune r, Point p)\n{\n\tWindow *w;\n\tText *t;\n\n\tif(r == 0)\n\t\tr = Runeerror;\n\n\tclearmouse();\n\tqlock(&row->lk);\n\tif(bartflag)\n\t\tt = barttext;\n\telse\n\t\tt = rowwhich(row, p);\n\tif(t!=nil && !(t->what==Tag && ptinrect(p, t->scrollr))){\n\t\tw = t->w;\n\t\tif(w == nil)\n\t\t\ttexttype(t, r);\n\t\telse{\n\t\t\twinlock(w, 'K');\n\t\t\twintype(w, t, r);\n\t\t\t/* Expand tag if necessary */\n\t\t\tif(t->what == Tag){\n\t\t\t\tt->w->tagsafe = FALSE;\n\t\t\t\tif(r == '\\n')\n\t\t\t\t\tt->w->tagexpand = TRUE;\n\t\t\t\twinresize(w, w->r, TRUE, TRUE);\n\t\t\t}\n\t\t\twinunlock(w);\n\t\t}\n\t}\n\tqunlock(&row->lk);\n\treturn t;\n}\n\nint\nrowclean(Row *row)\n{\n\tint clean;\n\tint i;\n\n\tclean = TRUE;\n\tfor(i=0; i<row->ncol; i++)\n\t\tclean &= colclean(row->col[i]);\n\treturn clean;\n}\n\nvoid\nrowdump(Row *row, char *file)\n{\n\tint i, j, fd, m, n, dumped;\n\tuint q0, q1;\n\tBiobuf *b;\n\tchar *buf, *a, *fontname;\n\tRune *r;\n\tColumn *c;\n\tWindow *w, *w1;\n\tText *t;\n\n\tif(row->ncol == 0)\n\t\treturn;\n\tbuf = fbufalloc();\n\tif(file == nil){\n\t\tif(home == nil){\n\t\t\twarning(nil, \"can't find file for dump: $home not defined\\n\");\n\t\t\tgoto Rescue;\n\t\t}\n\t\tsprint(buf, \"%s/acme.dump\", home);\n\t\tfile = buf;\n\t}\n\tfd = create(file, OWRITE, 0600);\n\tif(fd < 0){\n\t\twarning(nil, \"can't open %s: %r\\n\", file);\n\t\tgoto Rescue;\n\t}\n\tb = emalloc(sizeof(Biobuf));\n\tBinit(b, fd, OWRITE);\n\tr = fbufalloc();\n\tBprint(b, \"%s\\n\", wdir);\n\tBprint(b, \"%s\\n\", fontnames[0]);\n\tBprint(b, \"%s\\n\", fontnames[1]);\n\tfor(i=0; i<row->ncol; i++){\n\t\tc = row->col[i];\n\t\tBprint(b, \"%11.7f\", 100.0*(c->r.min.x-row->r.min.x)/Dx(row->r));\n\t\tif(i == row->ncol-1)\n\t\t\tBputc(b, '\\n');\n\t\telse\n\t\t\tBputc(b, ' ');\n\t}\n\tfor(i=0; i<row->ncol; i++){\n\t\tc = row->col[i];\n\t\tfor(j=0; j<c->nw; j++)\n\t\t\tc->w[j]->body.file->dumpid = 0;\n\t}\n\tm = min(RBUFSIZE, row->tag.file->b.nc);\n\tbufread(&row->tag.file->b, 0, r, m);\n\tn = 0;\n\twhile(n<m && r[n]!='\\n')\n\t\tn++;\n\tBprint(b, \"w %.*S\\n\", n, r);\n\tfor(i=0; i<row->ncol; i++){\n\t\tc = row->col[i];\n\t\tm = min(RBUFSIZE, c->tag.file->b.nc);\n\t\tbufread(&c->tag.file->b, 0, r, m);\n\t\tn = 0;\n\t\twhile(n<m && r[n]!='\\n')\n\t\t\tn++;\n\t\tBprint(b, \"c%11d %.*S\\n\", i, n, r);\n\t}\n\tfor(i=0; i<row->ncol; i++){\n\t\tc = row->col[i];\n\t\tfor(j=0; j<c->nw; j++){\n\t\t\tw = c->w[j];\n\t\t\twincommit(w, &w->tag);\n\t\t\tt = &w->body;\n\t\t\t/* windows owned by others get special treatment */\n\t\t\tif(w->nopen[QWevent] > 0)\n\t\t\t\tif(w->dumpstr == nil)\n\t\t\t\t\tcontinue;\n\t\t\t/* zeroxes of external windows are tossed */\n\t\t\tif(t->file->ntext > 1)\n\t\t\t\tfor(n=0; n<t->file->ntext; n++){\n\t\t\t\t\tw1 = t->file->text[n]->w;\n\t\t\t\t\tif(w == w1)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif(w1->nopen[QWevent])\n\t\t\t\t\t\tgoto Continue2;\n\t\t\t\t}\n\t\t\tfontname = \"\";\n\t\t\tif(t->reffont->f != font)\n\t\t\t\tfontname = t->reffont->f->name;\n\t\t\tif(t->file->nname)\n\t\t\t\ta = runetobyte(t->file->name, t->file->nname);\n\t\t\telse\n\t\t\t\ta = emalloc(1);\n\t\t\tif(t->file->dumpid){\n\t\t\t\tdumped = FALSE;\n\t\t\t\tBprint(b, \"x%11d %11d %11d %11d %11.7f %s\\n\", i, t->file->dumpid,\n\t\t\t\t\tw->body.q0, w->body.q1,\n\t\t\t\t\t100.0*(w->r.min.y-c->r.min.y)/Dy(c->r),\n\t\t\t\t\tfontname);\n\t\t\t}else if(w->dumpstr){\n\t\t\t\tdumped = FALSE;\n\t\t\t\tBprint(b, \"e%11d %11d %11d %11d %11.7f %s\\n\", i, t->file->dumpid,\n\t\t\t\t\t0, 0,\n\t\t\t\t\t100.0*(w->r.min.y-c->r.min.y)/Dy(c->r),\n\t\t\t\t\tfontname);\n\t\t\t}else if((w->dirty==FALSE && access(a, 0)==0) || w->isdir){\n\t\t\t\tdumped = FALSE;\n\t\t\t\tt->file->dumpid = w->id;\n\t\t\t\tBprint(b, \"f%11d %11d %11d %11d %11.7f %s\\n\", i, w->id,\n\t\t\t\t\tw->body.q0, w->body.q1,\n\t\t\t\t\t100.0*(w->r.min.y-c->r.min.y)/Dy(c->r),\n\t\t\t\t\tfontname);\n\t\t\t}else{\n\t\t\t\tdumped = TRUE;\n\t\t\t\tt->file->dumpid = w->id;\n\t\t\t\tBprint(b, \"F%11d %11d %11d %11d %11.7f %11d %s\\n\", i, j,\n\t\t\t\t\tw->body.q0, w->body.q1,\n\t\t\t\t\t100.0*(w->r.min.y-c->r.min.y)/Dy(c->r),\n\t\t\t\t\tw->body.file->b.nc, fontname);\n\t\t\t}\n\t\t\tfree(a);\n\t\t\twinctlprint(w, buf, 0);\n\t\t\tBwrite(b, buf, strlen(buf));\n\t\t\tm = min(RBUFSIZE, w->tag.file->b.nc);\n\t\t\tbufread(&w->tag.file->b, 0, r, m);\n\t\t\tn = 0;\n\t\t\twhile(n<m && r[n]!='\\n')\n\t\t\t\tn++;\n\t\t\tBprint(b, \"%.*S\\n\", n, r);\n\t\t\tif(dumped){\n\t\t\t\tq0 = 0;\n\t\t\t\tq1 = t->file->b.nc;\n\t\t\t\twhile(q0 < q1){\n\t\t\t\t\tn = q1 - q0;\n\t\t\t\t\tif(n > BUFSIZE/UTFmax)\n\t\t\t\t\t\tn = BUFSIZE/UTFmax;\n\t\t\t\t\tbufread(&t->file->b, q0, r, n);\n\t\t\t\t\tBprint(b, \"%.*S\", n, r);\n\t\t\t\t\tq0 += n;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(w->dumpstr){\n\t\t\t\tif(w->dumpdir)\n\t\t\t\t\tBprint(b, \"%s\\n%s\\n\", w->dumpdir, w->dumpstr);\n\t\t\t\telse\n\t\t\t\t\tBprint(b, \"\\n%s\\n\", w->dumpstr);\n\t\t\t}\n    Continue2:;\n\t\t}\n\t}\n\tBterm(b);\n\tclose(fd);\n\tfree(b);\n\tfbuffree(r);\n\n   Rescue:\n\tfbuffree(buf);\n}\n\nstatic\nchar*\nrdline(Biobuf *b, int *linep)\n{\n\tchar *l;\n\n\tl = Brdline(b, '\\n');\n\tif(l)\n\t\t(*linep)++;\n\treturn l;\n}\n\n/*\n * Get font names from load file so we don't load fonts we won't use\n */\nvoid\nrowloadfonts(char *file)\n{\n\tint i;\n\tBiobuf *b;\n\tchar *l;\n\n\tb = Bopen(file, OREAD);\n\tif(b == nil)\n\t\treturn;\n\t/* current directory */\n\tl = Brdline(b, '\\n');\n\tif(l == nil)\n\t\tgoto Return;\n\t/* global fonts */\n\tfor(i=0; i<2; i++){\n\t\tl = Brdline(b, '\\n');\n\t\tif(l == nil)\n\t\t\tgoto Return;\n\t\tl[Blinelen(b)-1] = 0;\n\t\tif(*l && strcmp(l, fontnames[i])!=0){\n\t\t\tfree(fontnames[i]);\n\t\t\tfontnames[i] = estrdup(l);\n\t\t}\n\t}\n    Return:\n\tBterm(b);\n}\n\nint\nrowload(Row *row, char *file, int initing)\n{\n\tint i, j, line, y, nr, nfontr, n, ns, ndumped, dumpid, x, fd, done;\n\tdouble percent;\n\tBiobuf *b, *bout;\n\tchar *buf, *l, *t, *fontname;\n\tRune *r, *fontr;\n\tint rune;\n\tColumn *c, *c1, *c2;\n\tuint q0, q1;\n\tRectangle r1, r2;\n\tWindow *w;\n\n\tbuf = fbufalloc();\n\tif(file == nil){\n\t\tif(home == nil){\n\t\t\twarning(nil, \"can't find file for load: $home not defined\\n\");\n\t\t\tgoto Rescue1;\n\t\t}\n\t\tsprint(buf, \"%s/acme.dump\", home);\n\t\tfile = buf;\n\t}\n\tb = Bopen(file, OREAD);\n\tif(b == nil){\n\t\twarning(nil, \"can't open load file %s: %r\\n\", file);\n\t\tgoto Rescue1;\n\t}\n\t/* current directory */\n\tline = 0;\n\tl = rdline(b, &line);\n\tif(l == nil)\n\t\tgoto Rescue2;\n\tl[Blinelen(b)-1] = 0;\n\tif(chdir(l) < 0){\n\t\twarning(nil, \"can't chdir %s\\n\", l);\n\t\tgoto Rescue2;\n\t}\n\t/* global fonts */\n\tfor(i=0; i<2; i++){\n\t\tl = rdline(b, &line);\n\t\tif(l == nil)\n\t\t\tgoto Rescue2;\n\t\tl[Blinelen(b)-1] = 0;\n\t\tif(*l && strcmp(l, fontnames[i])!=0)\n\t\t\trfget(i, TRUE, i==0 && initing, l);\n\t}\n\tif(initing && row->ncol==0)\n\t\trowinit(row, screen->clipr);\n\tl = rdline(b, &line);\n\tif(l == nil)\n\t\tgoto Rescue2;\n\tj = Blinelen(b)/12;\n\tif(j<=0 || j>10)\n\t\tgoto Rescue2;\n\tfor(i=0; i<j; i++){\n\t\tpercent = atof(l+i*12);\n\t\tif(percent<0 || percent>=100)\n\t\t\tgoto Rescue2;\n\t\tx = row->r.min.x+percent*Dx(row->r)/100+0.5;\n\t\tif(i < row->ncol){\n\t\t\tif(i == 0)\n\t\t\t\tcontinue;\n\t\t\tc1 = row->col[i-1];\n\t\t\tc2 = row->col[i];\n\t\t\tr1 = c1->r;\n\t\t\tr2 = c2->r;\n\t\t\tif(x<Border)\n\t\t\t\tx = Border;\n\t\t\tr1.max.x = x-Border;\n\t\t\tr2.min.x = x;\n\t\t\tif(Dx(r1) < 50 || Dx(r2) < 50)\n\t\t\t\tcontinue;\n\t\t\tdraw(screen, Rpt(r1.min, r2.max), display->white, nil, ZP);\n\t\t\tcolresize(c1, r1);\n\t\t\tcolresize(c2, r2);\n\t\t\tr2.min.x = x-Border;\n\t\t\tr2.max.x = x;\n\t\t\tdraw(screen, r2, display->black, nil, ZP);\n\t\t}\n\t\tif(i >= row->ncol)\n\t\t\trowadd(row, nil, x);\n\t}\n\tdone = 0;\n\twhile(!done){\n\t\tl = rdline(b, &line);\n\t\tif(l == nil)\n\t\t\tbreak;\n\t\tswitch(l[0]){\n\t\tcase 'c':\n\t\t\tl[Blinelen(b)-1] = 0;\n\t\t\ti = atoi(l+1+0*12);\n\t\t\tr = bytetorune(l+1*12, &nr);\n\t\t\tns = -1;\n\t\t\tfor(n=0; n<nr; n++){\n\t\t\t\tif(r[n] == '/')\n\t\t\t\t\tns = n;\n\t\t\t\tif(r[n] == ' ')\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttextdelete(&row->col[i]->tag, 0, row->col[i]->tag.file->b.nc, TRUE);\n\t\t\ttextinsert(&row->col[i]->tag, 0, r+n+1, nr-(n+1), TRUE);\n\t\t\tbreak;\n\t\tcase 'w':\n\t\t\tl[Blinelen(b)-1] = 0;\n\t\t\tr = bytetorune(l+2, &nr);\n\t\t\tns = -1;\n\t\t\tfor(n=0; n<nr; n++){\n\t\t\t\tif(r[n] == '/')\n\t\t\t\t\tns = n;\n\t\t\t\tif(r[n] == ' ')\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttextdelete(&row->tag, 0, row->tag.file->b.nc, TRUE);\n\t\t\ttextinsert(&row->tag, 0, r, nr, TRUE);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdone = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(;;){\n\t\tif(l == nil)\n\t\t\tbreak;\n\t\tdumpid = 0;\n\t\tswitch(l[0]){\n\t\tcase 'e':\n\t\t\tif(Blinelen(b) < 1+5*12+1)\n\t\t\t\tgoto Rescue2;\n\t\t\tl = rdline(b, &line);\t/* ctl line; ignored */\n\t\t\tif(l == nil)\n\t\t\t\tgoto Rescue2;\n\t\t\tl = rdline(b, &line);\t/* directory */\n\t\t\tif(l == nil)\n\t\t\t\tgoto Rescue2;\n\t\t\tl[Blinelen(b)-1] = 0;\n\t\t\tif(*l == '\\0'){\n\t\t\t\tif(home == nil)\n\t\t\t\t\tr = bytetorune(\"./\", &nr);\n\t\t\t\telse{\n\t\t\t\t\tt = emalloc(strlen(home)+1+1);\n\t\t\t\t\tsprint(t, \"%s/\", home);\n\t\t\t\t\tr = bytetorune(t, &nr);\n\t\t\t\t\tfree(t);\n\t\t\t\t}\n\t\t\t}else\n\t\t\t\tr = bytetorune(l, &nr);\n\t\t\tl = rdline(b, &line);\t/* command */\n\t\t\tif(l == nil)\n\t\t\t\tgoto Rescue2;\n\t\t\tt = emalloc(Blinelen(b)+1);\n\t\t\tmemmove(t, l, Blinelen(b));\n\t\t\trun(nil, t, r, nr, TRUE, nil, nil, FALSE);\n\t\t\t/* r is freed in run() */\n\t\t\tgoto Nextline;\n\t\tcase 'f':\n\t\t\tif(Blinelen(b) < 1+5*12+1)\n\t\t\t\tgoto Rescue2;\n\t\t\tfontname = l+1+5*12;\n\t\t\tndumped = -1;\n\t\t\tbreak;\n\t\tcase 'F':\n\t\t\tif(Blinelen(b) < 1+6*12+1)\n\t\t\t\tgoto Rescue2;\n\t\t\tfontname = l+1+6*12;\n\t\t\tndumped = atoi(l+1+5*12+1);\n\t\t\tbreak;\n\t\tcase 'x':\n\t\t\tif(Blinelen(b) < 1+5*12+1)\n\t\t\t\tgoto Rescue2;\n\t\t\tfontname = l+1+5*12;\n\t\t\tndumped = -1;\n\t\t\tdumpid = atoi(l+1+1*12);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto Rescue2;\n\t\t}\n\t\tl[Blinelen(b)-1] = 0;\n\t\tfontr = nil;\n\t\tnfontr = 0;\n\t\tif(*fontname)\n\t\t\tfontr = bytetorune(fontname, &nfontr);\n\t\ti = atoi(l+1+0*12);\n\t\tj = atoi(l+1+1*12);\n\t\tq0 = atoi(l+1+2*12);\n\t\tq1 = atoi(l+1+3*12);\n\t\tpercent = atof(l+1+4*12);\n\t\tif(i<0 || i>10)\n\t\t\tgoto Rescue2;\n\t\tif(i > row->ncol)\n\t\t\ti = row->ncol;\n\t\tc = row->col[i];\n\t\ty = c->r.min.y+(percent*Dy(c->r))/100+0.5;\n\t\tif(y<c->r.min.y || y>=c->r.max.y)\n\t\t\ty = -1;\n\t\tif(dumpid == 0)\n\t\t\tw = coladd(c, nil, nil, y);\n\t\telse\n\t\t\tw = coladd(c, nil, lookid(dumpid, TRUE), y);\n\t\tif(w == nil)\n\t\t\tgoto Nextline;\n\t\tw->dumpid = j;\n\t\tl = rdline(b, &line);\n\t\tif(l == nil)\n\t\t\tgoto Rescue2;\n\t\tl[Blinelen(b)-1] = 0;\n\t\tr = bytetorune(l+5*12, &nr);\n\t\tns = -1;\n\t\tfor(n=0; n<nr; n++){\n\t\t\tif(r[n] == '/')\n\t\t\t\tns = n;\n\t\t\tif(r[n] == ' ')\n\t\t\t\tbreak;\n\t\t}\n\t\tif(dumpid == 0)\n\t\t\twinsetname(w, r, n);\n\t\tfor(; n<nr; n++)\n\t\t\tif(r[n] == '|')\n\t\t\t\tbreak;\n\t\twincleartag(w);\n\t\ttextinsert(&w->tag, w->tag.file->b.nc, r+n+1, nr-(n+1), TRUE);\n\t\tif(ndumped >= 0){\n\t\t\t/* simplest thing is to put it in a file and load that */\n\t\t\tsprint(buf, \"/tmp/d%d.%.4sacme\", getpid(), getuser());\n\t\t\tfd = create(buf, OWRITE, 0600);\n\t\t\tif(fd < 0){\n\t\t\t\tfree(r);\n\t\t\t\twarning(nil, \"can't create temp file: %r\\n\");\n\t\t\t\tgoto Rescue2;\n\t\t\t}\n\t\t\tbout = emalloc(sizeof(Biobuf));\n\t\t\tBinit(bout, fd, OWRITE);\n\t\t\tfor(n=0; n<ndumped; n++){\n\t\t\t\trune = Bgetrune(b);\n\t\t\t\tif(rune == '\\n')\n\t\t\t\t\tline++;\n\t\t\t\tif(rune == Beof){\n\t\t\t\t\tfree(r);\n\t\t\t\t\tBterm(bout);\n\t\t\t\t\tfree(bout);\n\t\t\t\t\tclose(fd);\n\t\t\t\t\tremove(buf);\n\t\t\t\t\tgoto Rescue2;\n\t\t\t\t}\n\t\t\t\tBputrune(bout, rune);\n\t\t\t}\n\t\t\tBterm(bout);\n\t\t\tfree(bout);\n\t\t\ttextload(&w->body, 0, buf, 1);\n\t\t\tremove(buf);\n\t\t\tclose(fd);\n\t\t\tw->body.file->mod = TRUE;\n\t\t\tfor(n=0; n<w->body.file->ntext; n++)\n\t\t\t\tw->body.file->text[n]->w->dirty = TRUE;\n\t\t\twinsettag(w);\n\t\t}else if(dumpid==0 && r[ns+1]!='+' && r[ns+1]!='-')\n\t\t\tget(&w->body, nil, nil, FALSE, XXX, nil, 0);\n\t\tif(fontr){\n\t\t\tfontx(&w->body, nil, nil, 0, 0, fontr, nfontr);\n\t\t\tfree(fontr);\n\t\t}\n\t\tfree(r);\n\t\tif(q0>w->body.file->b.nc || q1>w->body.file->b.nc || q0>q1)\n\t\t\tq0 = q1 = 0;\n\t\ttextshow(&w->body, q0, q1, 1);\n\t\tw->maxlines = min(w->body.fr.nlines, max(w->maxlines, w->body.fr.maxlines));\n\t\txfidlog(w, \"new\");\nNextline:\n\t\tl = rdline(b, &line);\n\t}\n\tBterm(b);\n\tfbuffree(buf);\n\treturn TRUE;\n\nRescue2:\n\twarning(nil, \"bad load file %s:%d\\n\", file, line);\n\tBterm(b);\nRescue1:\n\tfbuffree(buf);\n\treturn FALSE;\n}\n\nvoid\nallwindows(void (*f)(Window*, void*), void *arg)\n{\n\tint i, j;\n\tColumn *c;\n\n\tfor(i=0; i<row.ncol; i++){\n\t\tc = row.col[i];\n\t\tfor(j=0; j<c->nw; j++)\n\t\t\t(*f)(c->w[j], arg);\n\t}\n}\n", "source": "acme2k/src/cmd/acme/rows.c", "file_type": "c"}
{"text": "#include <u.h>\n#include <libc.h>\n#include <draw.h>\n#include <thread.h>\n#include <cursor.h>\n#include <mouse.h>\n#include <keyboard.h>\n#include <frame.h>\n#include <fcall.h>\n#include <plumb.h>\n#include <libsec.h>\n#include \"dat.h\"\n#include \"fns.h\"\n\nstatic\tint\tsfd;\n\nenum\n{\n\tNhash\t= 16,\n\tDEBUG\t= 0\n};\n\nstatic\tFid\t*fids[Nhash];\n\nFid\t*newfid(int);\n\nstatic\tXfid*\tfsysflush(Xfid*, Fid*);\nstatic\tXfid*\tfsysauth(Xfid*, Fid*);\nstatic\tXfid*\tfsysversion(Xfid*, Fid*);\nstatic\tXfid*\tfsysattach(Xfid*, Fid*);\nstatic\tXfid*\tfsyswalk(Xfid*, Fid*);\nstatic\tXfid*\tfsysopen(Xfid*, Fid*);\nstatic\tXfid*\tfsyscreate(Xfid*, Fid*);\nstatic\tXfid*\tfsysread(Xfid*, Fid*);\nstatic\tXfid*\tfsyswrite(Xfid*, Fid*);\nstatic\tXfid*\tfsysclunk(Xfid*, Fid*);\nstatic\tXfid*\tfsysremove(Xfid*, Fid*);\nstatic\tXfid*\tfsysstat(Xfid*, Fid*);\nstatic\tXfid*\tfsyswstat(Xfid*, Fid*);\n\nXfid* \t(*fcall[Tmax])(Xfid*, Fid*);\n\nstatic void\ninitfcall(void)\n{\n\tfcall[Tflush]\t= fsysflush;\n\tfcall[Tversion]\t= fsysversion;\n\tfcall[Tauth]\t= fsysauth;\n\tfcall[Tattach]\t= fsysattach;\n\tfcall[Twalk]\t= fsyswalk;\n\tfcall[Topen]\t= fsysopen;\n\tfcall[Tcreate]\t= fsyscreate;\n\tfcall[Tread]\t= fsysread;\n\tfcall[Twrite]\t= fsyswrite;\n\tfcall[Tclunk]\t= fsysclunk;\n\tfcall[Tremove]= fsysremove;\n\tfcall[Tstat]\t= fsysstat;\n\tfcall[Twstat]\t= fsyswstat;\n}\n\nchar Eperm[] = \"permission denied\";\nchar Eexist[] = \"file does not exist\";\nchar Enotdir[] = \"not a directory\";\n\nDirtab dirtab[]=\n{\n\t{ \".\",\t\t\tQTDIR,\tQdir,\t\t0500|DMDIR },\n\t{ \"acme\",\t\tQTDIR,\tQacme,\t0500|DMDIR },\n\t{ \"cons\",\t\tQTFILE,\tQcons,\t0600 },\n\t{ \"consctl\",\tQTFILE,\tQconsctl,\t0000 },\n\t{ \"draw\",\t\tQTDIR,\tQdraw,\t0000|DMDIR },\t/* to suppress graphics progs started in acme */\n\t{ \"editout\",\tQTFILE,\tQeditout,\t0200 },\n\t{ \"index\",\t\tQTFILE,\tQindex,\t0400 },\n\t{ \"label\",\t\tQTFILE,\tQlabel,\t0600 },\n\t{ \"log\",\t\tQTFILE,\tQlog,\t0400 },\n\t{ \"new\",\t\tQTDIR,\tQnew,\t0500|DMDIR },\n\t{ nil, }\n};\n\nDirtab dirtabw[]=\n{\n\t{ \".\",\t\t\tQTDIR,\t\tQdir,\t\t\t0500|DMDIR },\n\t{ \"addr\",\t\tQTFILE,\t\tQWaddr,\t\t0600 },\n\t{ \"body\",\t\tQTAPPEND,\tQWbody,\t\t0600|DMAPPEND },\n\t{ \"ctl\",\t\tQTFILE,\t\tQWctl,\t\t0600 },\n\t{ \"data\",\t\tQTFILE,\t\tQWdata,\t\t0600 },\n\t{ \"editout\",\tQTFILE,\t\tQWeditout,\t0200 },\n\t{ \"errors\",\t\tQTFILE,\t\tQWerrors,\t\t0200 },\n\t{ \"event\",\t\tQTFILE,\t\tQWevent,\t\t0600 },\n\t{ \"rdsel\",\t\tQTFILE,\t\tQWrdsel,\t\t0400 },\n\t{ \"wrsel\",\t\tQTFILE,\t\tQWwrsel,\t\t0200 },\n\t{ \"tag\",\t\tQTAPPEND,\tQWtag,\t\t0600|DMAPPEND },\n\t{ \"xdata\",\t\tQTFILE,\t\tQWxdata,\t\t0600 },\n\t{ nil, }\n};\n\ntypedef struct Mnt Mnt;\nstruct Mnt\n{\n\tQLock\tlk;\n\tint\t\tid;\n\tMntdir\t*md;\n};\n\nMnt\tmnt;\n\nXfid*\trespond(Xfid*, Fcall*, char*);\nint\t\tdostat(int, Dirtab*, uchar*, int, uint);\nuint\tgetclock(void);\n\nchar\t*user = \"Wile E. Coyote\";\nstatic int closing = 0;\nint\tmessagesize = Maxblock+IOHDRSZ;\t/* good start */\n\nvoid\tfsysproc(void *);\n\nvoid\nfsysinit(void)\n{\n\tint p[2];\n\tchar *u;\n\n\tinitfcall();\n\tif(pipe(p) < 0)\n\t\terror(\"can't create pipe\");\n\tif(post9pservice(p[0], \"acme\", mtpt) < 0)\n\t\terror(\"can't post service\");\n\tsfd = p[1];\n\tfmtinstall('F', fcallfmt);\n\tif((u = getuser()) != nil)\n\t\tuser = estrdup(u);\n\tproccreate(fsysproc, nil, STACK);\n}\n\nvoid\nfsysproc(void *v)\n{\n\tint n;\n\tXfid *x;\n\tFid *f;\n\tFcall t;\n\tuchar *buf;\n\n\tthreadsetname(\"fsysproc\");\n\n\tUSED(v);\n\tx = nil;\n\tfor(;;){\n\t\tbuf = emalloc(messagesize+UTFmax);\t/* overflow for appending partial rune in xfidwrite */\n\t\tn = read9pmsg(sfd, buf, messagesize);\n\t\tif(n <= 0){\n\t\t\tif(closing)\n\t\t\t\tbreak;\n\t\t\terror(\"i/o error on server channel\");\n\t\t}\n\t\tif(x == nil){\n\t\t\tsendp(cxfidalloc, nil);\n\t\t\tx = recvp(cxfidalloc);\n\t\t}\n\t\tx->buf = buf;\n\t\tif(convM2S(buf, n, &x->fcall) != n)\n\t\t\terror(\"convert error in convM2S\");\n\t\tif(DEBUG)\n\t\t\tfprint(2, \"%F\\n\", &x->fcall);\n\t\tif(fcall[x->fcall.type] == nil)\n\t\t\tx = respond(x, &t, \"bad fcall type\");\n\t\telse{\n\t\t\tswitch(x->fcall.type){\n\t\t\tcase Tversion:\n\t\t\tcase Tauth:\n\t\t\tcase Tflush:\n\t\t\t\tf = nil;\n\t\t\t\tbreak;\n\t\t\tcase Tattach:\n\t\t\t\tf = newfid(x->fcall.fid);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tf = newfid(x->fcall.fid);\n\t\t\t\tif(!f->busy){\n\t\t\t\t\tx->f = f;\n\t\t\t\t\tx = respond(x, &t, \"fid not in use\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tx->f = f;\n\t\t\tx  = (*fcall[x->fcall.type])(x, f);\n\t\t}\n\t}\n}\n\nMntdir*\nfsysaddid(Rune *dir, int ndir, Rune **incl, int nincl)\n{\n\tMntdir *m;\n\tint id;\n\n\tqlock(&mnt.lk);\n\tid = ++mnt.id;\n\tm = emalloc(sizeof *m);\n\tm->id = id;\n\tm->dir =  dir;\n\tm->ref = 1;\t/* one for Command, one will be incremented in attach */\n\tm->ndir = ndir;\n\tm->next = mnt.md;\n\tm->incl = incl;\n\tm->nincl = nincl;\n\tmnt.md = m;\n\tqunlock(&mnt.lk);\n\treturn m;\n}\n\nvoid\nfsysincid(Mntdir *m)\n{\n\tqlock(&mnt.lk);\n\tm->ref++;\n\tqunlock(&mnt.lk);\n}\n\nvoid\nfsysdelid(Mntdir *idm)\n{\n\tMntdir *m, *prev;\n\tint i;\n\tchar buf[64];\n\n\tif(idm == nil)\n\t\treturn;\n\tqlock(&mnt.lk);\n\tif(--idm->ref > 0){\n\t\tqunlock(&mnt.lk);\n\t\treturn;\n\t}\n\tprev = nil;\n\tfor(m=mnt.md; m; m=m->next){\n\t\tif(m == idm){\n\t\t\tif(prev)\n\t\t\t\tprev->next = m->next;\n\t\t\telse\n\t\t\t\tmnt.md = m->next;\n\t\t\tfor(i=0; i<m->nincl; i++)\n\t\t\t\tfree(m->incl[i]);\n\t\t\tfree(m->incl);\n\t\t\tfree(m->dir);\n\t\t\tfree(m);\n\t\t\tqunlock(&mnt.lk);\n\t\t\treturn;\n\t\t}\n\t\tprev = m;\n\t}\n\tqunlock(&mnt.lk);\n\tsprint(buf, \"fsysdelid: can't find id %d\\n\", idm->id);\n\tsendp(cerr, estrdup(buf));\n}\n\n/*\n * Called only in exec.c:/^run(), from a different FD group\n */\nMntdir*\nfsysmount(Rune *dir, int ndir, Rune **incl, int nincl)\n{\n\treturn fsysaddid(dir, ndir, incl, nincl);\n}\n\nvoid\nfsysclose(void)\n{\n\tclosing = 1;\n\t/*\n\t * apparently this is not kosher on openbsd.\n\t * perhaps because fsysproc is reading from sfd right now,\n\t * the close hangs indefinitely.\n\tclose(sfd);\n\t */\n}\n\nXfid*\nrespond(Xfid *x, Fcall *t, char *err)\n{\n\tint n;\n\n\tif(err){\n\t\tt->type = Rerror;\n\t\tt->ename = err;\n\t}else\n\t\tt->type = x->fcall.type+1;\n\tt->fid = x->fcall.fid;\n\tt->tag = x->fcall.tag;\n\tif(x->buf == nil)\n\t\tx->buf = emalloc(messagesize);\n\tn = convS2M(t, x->buf, messagesize);\n\tif(n <= 0)\n\t\terror(\"convert error in convS2M\");\n\tif(write(sfd, x->buf, n) != n)\n\t\terror(\"write error in respond\");\n\tfree(x->buf);\n\tx->buf = nil;\n\tif(DEBUG)\n\t\tfprint(2, \"r: %F\\n\", t);\n\treturn x;\n}\n\nstatic\nXfid*\nfsysversion(Xfid *x, Fid *f)\n{\n\tFcall t;\n\n\tUSED(f);\n\tif(x->fcall.msize < 256)\n\t\treturn respond(x, &t, \"version: message size too small\");\n\tmessagesize = x->fcall.msize;\n\tt.msize = messagesize;\n\tif(strncmp(x->fcall.version, \"9P2000\", 6) != 0)\n\t\treturn respond(x, &t, \"unrecognized 9P version\");\n\tt.version = \"9P2000\";\n\treturn respond(x, &t, nil);\n}\n\nstatic\nXfid*\nfsysauth(Xfid *x, Fid *f)\n{\n\tFcall t;\n\n\tUSED(f);\n\treturn respond(x, &t, \"acme: authentication not required\");\n}\n\nstatic\nXfid*\nfsysflush(Xfid *x, Fid *f)\n{\n\tUSED(f);\n\tsendp(x->c, (void*)xfidflush);\n\treturn nil;\n}\n\nstatic\nXfid*\nfsysattach(Xfid *x, Fid *f)\n{\n\tFcall t;\n\tint id;\n\tMntdir *m;\n\tchar buf[128];\n\n\tif(strcmp(x->fcall.uname, user) != 0)\n\t\treturn respond(x, &t, Eperm);\n\tf->busy = TRUE;\n\tf->open = FALSE;\n\tf->qid.path = Qdir;\n\tf->qid.type = QTDIR;\n\tf->qid.vers = 0;\n\tf->dir = dirtab;\n\tf->nrpart = 0;\n\tf->w = nil;\n\tt.qid = f->qid;\n\tf->mntdir = nil;\n\tid = atoi(x->fcall.aname);\n\tqlock(&mnt.lk);\n\tfor(m=mnt.md; m; m=m->next)\n\t\tif(m->id == id){\n\t\t\tf->mntdir = m;\n\t\t\tm->ref++;\n\t\t\tbreak;\n\t\t}\n\tif(m == nil && x->fcall.aname[0]){\n\t\tsnprint(buf, sizeof buf, \"unknown id '%s' in attach\", x->fcall.aname);\n\t\tsendp(cerr, estrdup(buf));\n\t}\n\tqunlock(&mnt.lk);\n\treturn respond(x, &t, nil);\n}\n\nstatic\nXfid*\nfsyswalk(Xfid *x, Fid *f)\n{\n\tFcall t;\n\tint c, i, j, id;\n\tQid q;\n\tuchar type;\n\tulong path;\n\tFid *nf;\n\tDirtab *d, *dir;\n\tWindow *w;\n\tchar *err;\n\n\tnf = nil;\n\tw = nil;\n\tif(f->open)\n\t\treturn respond(x, &t, \"walk of open file\");\n\tif(x->fcall.fid != x->fcall.newfid){\n\t\tnf = newfid(x->fcall.newfid);\n\t\tif(nf->busy)\n\t\t\treturn respond(x, &t, \"newfid already in use\");\n\t\tnf->busy = TRUE;\n\t\tnf->open = FALSE;\n\t\tnf->mntdir = f->mntdir;\n\t\tif(f->mntdir)\n\t\t\tf->mntdir->ref++;\n\t\tnf->dir = f->dir;\n\t\tnf->qid = f->qid;\n\t\tnf->w = f->w;\n\t\tnf->nrpart = 0;\t/* not open, so must be zero */\n\t\tif(nf->w)\n\t\t\tincref(&nf->w->ref);\n\t\tf = nf;\t/* walk f */\n\t}\n\n\tt.nwqid = 0;\n\terr = nil;\n\tdir = nil;\n\tid = WIN(f->qid);\n\tq = f->qid;\n\n\tif(x->fcall.nwname > 0){\n\t\tfor(i=0; i<x->fcall.nwname; i++){\n\t\t\tif((q.type & QTDIR) == 0){\n\t\t\t\terr = Enotdir;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif(strcmp(x->fcall.wname[i], \"..\") == 0){\n\t\t\t\ttype = QTDIR;\n\t\t\t\tpath = Qdir;\n\t\t\t\tid = 0;\n\t\t\t\tif(w){\n\t\t\t\t\twinclose(w);\n\t\t\t\t\tw = nil;\n\t\t\t\t}\n    Accept:\n\t\t\t\tif(i == MAXWELEM){\n\t\t\t\t\terr = \"name too long\";\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tq.type = type;\n\t\t\t\tq.vers = 0;\n\t\t\t\tq.path = QID(id, path);\n\t\t\t\tt.wqid[t.nwqid++] = q;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* is it a numeric name? */\n\t\t\tfor(j=0; (c=x->fcall.wname[i][j]); j++)\n\t\t\t\tif(c<'0' || '9'<c)\n\t\t\t\t\tgoto Regular;\n\t\t\t/* yes: it's a directory */\n\t\t\tif(w)\t/* name has form 27/23; get out before losing w */\n\t\t\t\tbreak;\n\t\t\tid = atoi(x->fcall.wname[i]);\n\t\t\tqlock(&row.lk);\n\t\t\tw = lookid(id, FALSE);\n\t\t\tif(w == nil){\n\t\t\t\tqunlock(&row.lk);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tincref(&w->ref);\t/* we'll drop reference at end if there's an error */\n\t\t\tpath = Qdir;\n\t\t\ttype = QTDIR;\n\t\t\tqunlock(&row.lk);\n\t\t\tdir = dirtabw;\n\t\t\tgoto Accept;\n\t\n    Regular:\n\t\t\tif(strcmp(x->fcall.wname[i], \"new\") == 0){\n\t\t\t\tif(w)\n\t\t\t\t\terror(\"w set in walk to new\");\n\t\t\t\tsendp(cnewwindow, nil);\t/* signal newwindowthread */\n\t\t\t\tw = recvp(cnewwindow);\t/* receive new window */\n\t\t\t\tincref(&w->ref);\n\t\t\t\ttype = QTDIR;\n\t\t\t\tpath = QID(w->id, Qdir);\n\t\t\t\tid = w->id;\n\t\t\t\tdir = dirtabw;\n\t\t\t\tgoto Accept;\n\t\t\t}\n\n\t\t\tif(id == 0)\n\t\t\t\td = dirtab;\n\t\t\telse\n\t\t\t\td = dirtabw;\n\t\t\td++;\t/* skip '.' */\n\t\t\tfor(; d->name; d++)\n\t\t\t\tif(strcmp(x->fcall.wname[i], d->name) == 0){\n\t\t\t\t\tpath = d->qid;\n\t\t\t\t\ttype = d->type;\n\t\t\t\t\tdir = d;\n\t\t\t\t\tgoto Accept;\n\t\t\t\t}\n\n\t\t\tbreak;\t/* file not found */\n\t\t}\n\n\t\tif(i==0 && err == nil)\n\t\t\terr = Eexist;\n\t}\n\n\tif(err!=nil || t.nwqid<x->fcall.nwname){\n\t\tif(nf){\n\t\t\tnf->busy = FALSE;\n\t\t\tfsysdelid(nf->mntdir);\n\t\t}\n\t}else if(t.nwqid  == x->fcall.nwname){\n\t\tif(w){\n\t\t\tf->w = w;\n\t\t\tw = nil;\t/* don't drop the reference */\n\t\t}\n\t\tif(dir)\n\t\t\tf->dir = dir;\n\t\tf->qid = q;\n\t}\n\n\tif(w != nil)\n\t\twinclose(w);\n\n\treturn respond(x, &t, err);\n}\n\nstatic\nXfid*\nfsysopen(Xfid *x, Fid *f)\n{\n\tFcall t;\n\tint m;\n\n\t/* can't truncate anything, so just disregard */\n\tx->fcall.mode &= ~(OTRUNC|OCEXEC);\n\t/* can't execute or remove anything */\n\tif(x->fcall.mode==OEXEC || (x->fcall.mode&ORCLOSE))\n\t\tgoto Deny;\n\tswitch(x->fcall.mode){\n\tdefault:\n\t\tgoto Deny;\n\tcase OREAD:\n\t\tm = 0400;\n\t\tbreak;\n\tcase OWRITE:\n\t\tm = 0200;\n\t\tbreak;\n\tcase ORDWR:\n\t\tm = 0600;\n\t\tbreak;\n\t}\n\tif(((f->dir->perm&~(DMDIR|DMAPPEND))&m) != m)\n\t\tgoto Deny;\n\n\tsendp(x->c, (void*)xfidopen);\n\treturn nil;\n\n    Deny:\n\treturn respond(x, &t, Eperm);\n}\n\nstatic\nXfid*\nfsyscreate(Xfid *x, Fid *f)\n{\n\tFcall t;\n\n\tUSED(f);\n\treturn respond(x, &t, Eperm);\n}\n\nstatic\nint\nidcmp(const void *a, const void *b)\n{\n\treturn *(int*)a - *(int*)b;\n}\n\nstatic\nXfid*\nfsysread(Xfid *x, Fid *f)\n{\n\tFcall t;\n\tuchar *b;\n\tint i, id, n, o, e, j, k, *ids, nids;\n\tDirtab *d, dt;\n\tColumn *c;\n\tuint clock, len;\n\tchar buf[16];\n\n\tif(f->qid.type & QTDIR){\n\t\tif(FILE(f->qid) == Qacme){\t/* empty dir */\n\t\t\tt.data = nil;\n\t\t\tt.count = 0;\n\t\t\trespond(x, &t, nil);\n\t\t\treturn x;\n\t\t}\n\t\to = x->fcall.offset;\n\t\te = x->fcall.offset+x->fcall.count;\n\t\tclock = getclock();\n\t\tb = emalloc(messagesize);\n\t\tid = WIN(f->qid);\n\t\tn = 0;\n\t\tif(id > 0)\n\t\t\td = dirtabw;\n\t\telse\n\t\t\td = dirtab;\n\t\td++;\t/* first entry is '.' */\n\t\tfor(i=0; d->name!=nil && i<e; i+=len){\n\t\t\tlen = dostat(WIN(x->f->qid), d, b+n, x->fcall.count-n, clock);\n\t\t\tif(len <= BIT16SZ)\n\t\t\t\tbreak;\n\t\t\tif(i >= o)\n\t\t\t\tn += len;\n\t\t\td++;\n\t\t}\n\t\tif(id == 0){\n\t\t\tqlock(&row.lk);\n\t\t\tnids = 0;\n\t\t\tids = nil;\n\t\t\tfor(j=0; j<row.ncol; j++){\n\t\t\t\tc = row.col[j];\n\t\t\t\tfor(k=0; k<c->nw; k++){\n\t\t\t\t\tids = realloc(ids, (nids+1)*sizeof(int));\n\t\t\t\t\tids[nids++] = c->w[k]->id;\n\t\t\t\t}\n\t\t\t}\n\t\t\tqunlock(&row.lk);\n\t\t\tqsort(ids, nids, sizeof ids[0], idcmp);\n\t\t\tj = 0;\n\t\t\tdt.name = buf;\n\t\t\tfor(; j<nids && i<e; i+=len){\n\t\t\t\tk = ids[j];\n\t\t\t\tsprint(dt.name, \"%d\", k);\n\t\t\t\tdt.qid = QID(k, Qdir);\n\t\t\t\tdt.type = QTDIR;\n\t\t\t\tdt.perm = DMDIR|0700;\n\t\t\t\tlen = dostat(k, &dt, b+n, x->fcall.count-n, clock);\n\t\t\t\tif(len == 0)\n\t\t\t\t\tbreak;\n\t\t\t\tif(i >= o)\n\t\t\t\t\tn += len;\n\t\t\t\tj++;\n\t\t\t}\n\t\t\tfree(ids);\n\t\t}\n\t\tt.data = (char*)b;\n\t\tt.count = n;\n\t\trespond(x, &t, nil);\n\t\tfree(b);\n\t\treturn x;\n\t}\n\tsendp(x->c, (void*)xfidread);\n\treturn nil;\n}\n\nstatic\nXfid*\nfsyswrite(Xfid *x, Fid *f)\n{\n\tUSED(f);\n\tsendp(x->c, (void*)xfidwrite);\n\treturn nil;\n}\n\nstatic\nXfid*\nfsysclunk(Xfid *x, Fid *f)\n{\n\tfsysdelid(f->mntdir);\n\tsendp(x->c, (void*)xfidclose);\n\treturn nil;\n}\n\nstatic\nXfid*\nfsysremove(Xfid *x, Fid *f)\n{\n\tFcall t;\n\n\tUSED(f);\n\treturn respond(x, &t, Eperm);\n}\n\nstatic\nXfid*\nfsysstat(Xfid *x, Fid *f)\n{\n\tFcall t;\n\n\tt.stat = emalloc(messagesize-IOHDRSZ);\n\tt.nstat = dostat(WIN(x->f->qid), f->dir, t.stat, messagesize-IOHDRSZ, getclock());\n\tx = respond(x, &t, nil);\n\tfree(t.stat);\n\treturn x;\n}\n\nstatic\nXfid*\nfsyswstat(Xfid *x, Fid *f)\n{\n\tFcall t;\n\n\tUSED(f);\n\treturn respond(x, &t, Eperm);\n}\n\nFid*\nnewfid(int fid)\n{\n\tFid *f, *ff, **fh;\n\n\tff = nil;\n\tfh = &fids[fid&(Nhash-1)];\n\tfor(f=*fh; f; f=f->next)\n\t\tif(f->fid == fid)\n\t\t\treturn f;\n\t\telse if(ff==nil && f->busy==FALSE)\n\t\t\tff = f;\n\tif(ff){\n\t\tff->fid = fid;\n\t\treturn ff;\n\t}\n\tf = emalloc(sizeof *f);\n\tf->fid = fid;\n\tf->next = *fh;\n\t*fh = f;\n\treturn f;\n}\n\nuint\ngetclock(void)\n{\n\treturn time(0);\n}\n\nint\ndostat(int id, Dirtab *dir, uchar *buf, int nbuf, uint clock)\n{\n\tDir d;\n\n\td.qid.path = QID(id, dir->qid);\n\td.qid.vers = 0;\n\td.qid.type = dir->type;\n\td.mode = dir->perm;\n\td.length = 0;\t/* would be nice to do better */\n\td.name = dir->name;\n\td.uid = user;\n\td.gid = user;\n\td.muid = user;\n\td.atime = clock;\n\td.mtime = clock;\n\treturn convD2M(&d, buf, nbuf);\n}\n", "source": "acme2k/src/cmd/acme/fsys.c", "file_type": "c"}
{"text": "#include <u.h>\n#include <libc.h>\n#include <draw.h>\n#include <thread.h>\n#include <cursor.h>\n#include <mouse.h>\n#include <keyboard.h>\n#include <frame.h>\n#include <fcall.h>\n#include <plumb.h>\n#include <libsec.h>\n#include \"dat.h\"\n#include \"fns.h\"\n\nstatic Rune Lheader[] = {\n\t'N', 'e', 'w', ' ',\n\t'C', 'u', 't', ' ',\n\t'P', 'a', 's', 't', 'e', ' ',\n\t'S', 'n', 'a', 'r', 'f', ' ',\n\t'S', 'o', 'r', 't', ' ',\n\t'Z', 'e', 'r', 'o', 'x', ' ',\n\t'D', 'e', 'l', 'c', 'o', 'l', ' ',\n\t0\n};\n\nvoid\ncolinit(Column *c, Rectangle r)\n{\n\tRectangle r1;\n\tText *t;\n\n\tdraw(screen, r, display->white, nil, ZP);\n\tc->r = r;\n\tc->w = nil;\n\tc->nw = 0;\n\tt = &c->tag;\n\tt->w = nil;\n\tt->col = c;\n\tr1 = r;\n\tr1.max.y = r1.min.y + font->height;\n\ttextinit(t, fileaddtext(nil, t), r1, &reffont, tagcols);\n\tt->what = Columntag;\n\tr1.min.y = r1.max.y;\n\tr1.max.y += Border;\n\tdraw(screen, r1, display->black, nil, ZP);\n\ttextinsert(t, 0, Lheader, 38, TRUE);\n\ttextsetselect(t, t->file->b.nc, t->file->b.nc);\n\tdraw(screen, t->scrollr, colbutton, nil, colbutton->r.min);\n\tc->safe = TRUE;\n}\n\nWindow*\ncoladd(Column *c, Window *w, Window *clone, int y)\n{\n\tRectangle r, r1;\n\tWindow *v;\n\tint i, j, minht, ymax, buggered;\n\n\tv = nil;\n\tr = c->r;\n\tr.min.y = c->tag.fr.r.max.y+Border;\n\tif(y<r.min.y && c->nw>0){\t/* steal half of last window by default */\n\t\tv = c->w[c->nw-1];\n\t\ty = v->body.fr.r.min.y+Dy(v->body.fr.r)/2;\n\t}\n\t/* look for window we'll land on */\n\tfor(i=0; i<c->nw; i++){\n\t\tv = c->w[i];\n\t\tif(y < v->r.max.y)\n\t\t\tbreak;\n\t}\n\tbuggered = 0;\n\tif(c->nw > 0){\n\t\tif(i < c->nw)\n\t\t\ti++;\t/* new window will go after v */\n\t\t/*\n\t\t * if landing window (v) is too small, grow it first.\n\t\t */\n\t\tminht = v->tag.fr.font->height+Border+1;\n\t\tj = 0;\n\t\twhile(!c->safe || v->body.fr.maxlines<=3 || Dy(v->body.all) <= minht){\n\t\t\tif(++j > 10){\n\t\t\t\tbuggered = 1;\t/* too many windows in column */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcolgrow(c, v, 1);\n\t\t}\n\n\t\t/*\n\t\t * figure out where to split v to make room for w\n\t\t */\n\t\t\n\t\t/* new window stops where next window begins */\n\t\tif(i < c->nw)\n\t\t\tymax = c->w[i]->r.min.y-Border;\n\t\telse\n\t\t\tymax = c->r.max.y;\n\t\t\n\t\t/* new window must start after v's tag ends */\n\t\ty = max(y, v->tagtop.max.y+Border);\n\t\t\n\t\t/* new window must start early enough to end before ymax */\n\t\ty = min(y, ymax - minht);\n\t\t\n\t\t/* if y is too small, too many windows in column */\n\t\tif(y < v->tagtop.max.y+Border)\n\t\t\tbuggered = 1;\n\n\t\t/*\n\t\t * resize & redraw v\n\t\t */\n\t\tr = v->r;\n\t\tr.max.y = ymax;\n\t\tdraw(screen, r, textcols[BACK], nil, ZP);\n\t\tr1 = r;\n\t\ty = min(y, ymax-(v->tag.fr.font->height*v->taglines+v->body.fr.font->height+Border+1));\n\t\tr1.max.y = min(y, v->body.fr.r.min.y+v->body.fr.nlines*v->body.fr.font->height);\n\t\tr1.min.y = winresize(v, r1, FALSE, FALSE);\n\t\tr1.max.y = r1.min.y+Border;\n\t\tdraw(screen, r1, display->black, nil, ZP);\n\t\t\n\t\t/*\n\t\t * leave r with w's coordinates\n\t\t */\n\t\tr.min.y = r1.max.y;\n\t}\n\tif(w == nil){\n\t\tw = emalloc(sizeof(Window));\n\t\tw->col = c;\n\t\tdraw(screen, r, textcols[BACK], nil, ZP);\n\t\twininit(w, clone, r);\n\t}else{\n\t\tw->col = c;\n\t\twinresize(w, r, FALSE, TRUE);\n\t}\n\tw->tag.col = c;\n\tw->tag.row = c->row;\n\tw->body.col = c;\n\tw->body.row = c->row;\n\tc->w = realloc(c->w, (c->nw+1)*sizeof(Window*));\n\tmemmove(c->w+i+1, c->w+i, (c->nw-i)*sizeof(Window*));\n\tc->nw++;\n\tc->w[i] = w;\n\tc->safe = TRUE;\n\t\n\t/* if there were too many windows, redraw the whole column */\n\tif(buggered)\n\t\tcolresize(c, c->r);\n\n\tsavemouse(w);\n\t/* near the button, but in the body */\n\tmoveto(mousectl, addpt(w->tag.scrollr.max, Pt(3, 3)));\n\tbarttext = &w->body;\n\treturn w;\n}\n\nvoid\ncolclose(Column *c, Window *w, int dofree)\n{\n\tRectangle r;\n\tint i, didmouse, up;\n\n\t/* w is locked */\n\tif(!c->safe)\n\t\tcolgrow(c, w, 1);\n\tfor(i=0; i<c->nw; i++)\n\t\tif(c->w[i] == w)\n\t\t\tgoto Found;\n\terror(\"can't find window\");\n  Found:\n\tr = w->r;\n\tw->tag.col = nil;\n\tw->body.col = nil;\n\tw->col = nil;\n\tdidmouse = restoremouse(w);\n\tif(dofree){\n\t\twindelete(w);\n\t\twinclose(w);\n\t}\n\tc->nw--;\n\tmemmove(c->w+i, c->w+i+1, (c->nw-i)*sizeof(Window*));\n\tc->w = realloc(c->w, c->nw*sizeof(Window*));\n\tif(c->nw == 0){\n\t\tdraw(screen, r, display->white, nil, ZP);\n\t\treturn;\n\t}\n\tup = 0;\n\tif(i == c->nw){\t\t/* extend last window down */\n\t\tw = c->w[i-1];\n\t\tr.min.y = w->r.min.y;\n\t\tr.max.y = c->r.max.y;\n\t}else{\t\t\t/* extend next window up */\n\t\tup = 1;\n\t\tw = c->w[i];\n\t\tr.max.y = w->r.max.y;\n\t}\n\tdraw(screen, r, textcols[BACK], nil, ZP);\n\tif(c->safe) {\n\t\tif(!didmouse && up)\n\t\t\tw->showdel = TRUE;\n\t\twinresize(w, r, FALSE, TRUE);\n\t\tif(!didmouse && up)\n\t\t\tmovetodel(w);\n\t}\n}\n\nvoid\ncolcloseall(Column *c)\n{\n\tint i;\n\tWindow *w;\n\n\tif(c == activecol)\n\t\tactivecol = nil;\n\ttextclose(&c->tag);\n\tfor(i=0; i<c->nw; i++){\n\t\tw = c->w[i];\n\t\twinclose(w);\n\t}\n\tc->nw = 0;\n\tfree(c->w);\n\tfree(c);\n\tclearmouse();\n}\n\nvoid\ncolmousebut(Column *c)\n{\n\tmoveto(mousectl, divpt(addpt(c->tag.scrollr.min, c->tag.scrollr.max), 2));\n}\n\nvoid\ncolresize(Column *c, Rectangle r)\n{\n\tint i;\n\tRectangle r1, r2;\n\tWindow *w;\n\n\tclearmouse();\n\tr1 = r;\n\tr1.max.y = r1.min.y + c->tag.fr.font->height;\n\ttextresize(&c->tag, r1, TRUE);\n\tdraw(screen, c->tag.scrollr, colbutton, nil, colbutton->r.min);\n\tr1.min.y = r1.max.y;\n\tr1.max.y += Border;\n\tdraw(screen, r1, display->black, nil, ZP);\n\tr1.max.y = r.max.y;\n\tfor(i=0; i<c->nw; i++){\n\t\tw = c->w[i];\n\t\tw->maxlines = 0;\n\t\tif(i == c->nw-1)\n\t\t\tr1.max.y = r.max.y;\n\t\telse\n\t\t\tr1.max.y = r1.min.y+(Dy(w->r)+Border)*Dy(r)/Dy(c->r);\n\t\tr1.max.y = max(r1.max.y, r1.min.y + Border+font->height);\n\t\tr2 = r1;\n\t\tr2.max.y = r2.min.y+Border;\n\t\tdraw(screen, r2, display->black, nil, ZP);\n\t\tr1.min.y = r2.max.y;\n\t\tr1.min.y = winresize(w, r1, FALSE, i==c->nw-1);\n\t}\n\tc->r = r;\n}\n\nstatic\nint\ncolcmp(const void *a, const void *b)\n{\n\tRune *r1, *r2;\n\tint i, nr1, nr2;\n\n\tr1 = (*(Window**)a)->body.file->name;\n\tnr1 = (*(Window**)a)->body.file->nname;\n\tr2 = (*(Window**)b)->body.file->name;\n\tnr2 = (*(Window**)b)->body.file->nname;\n\tfor(i=0; i<nr1 && i<nr2; i++){\n\t\tif(*r1 != *r2)\n\t\t\treturn *r1-*r2;\n\t\tr1++;\n\t\tr2++;\n\t}\n\treturn nr1-nr2;\n}\n\nvoid\ncolsort(Column *c)\n{\n\tint i, y;\n\tRectangle r, r1, *rp;\n\tWindow **wp, *w;\n\n\tif(c->nw == 0)\n\t\treturn;\n\tclearmouse();\n\trp = emalloc(c->nw*sizeof(Rectangle));\n\twp = emalloc(c->nw*sizeof(Window*));\n\tmemmove(wp, c->w, c->nw*sizeof(Window*));\n\tqsort(wp, c->nw, sizeof(Window*), colcmp);\n\tfor(i=0; i<c->nw; i++)\n\t\trp[i] = wp[i]->r;\n\tr = c->r;\n\tr.min.y = c->tag.fr.r.max.y;\n\tdraw(screen, r, textcols[BACK], nil, ZP);\n\ty = r.min.y;\n\tfor(i=0; i<c->nw; i++){\n\t\tw = wp[i];\n\t\tr.min.y = y;\n\t\tif(i == c->nw-1)\n\t\t\tr.max.y = c->r.max.y;\n\t\telse\n\t\t\tr.max.y = r.min.y+Dy(w->r)+Border;\n\t\tr1 = r;\n\t\tr1.max.y = r1.min.y+Border;\n\t\tdraw(screen, r1, display->black, nil, ZP);\n\t\tr.min.y = r1.max.y;\n\t\ty = winresize(w, r, FALSE, i==c->nw-1);\n\t}\n\tfree(rp);\n\tfree(c->w);\n\tc->w = wp;\n}\n\nvoid\ncolgrow(Column *c, Window *w, int but)\n{\n\tRectangle r, cr;\n\tint i, j, k, l, y1, y2, *nl, *ny, tot, nnl, onl, dnl, h;\n\tWindow *v;\n\n\tfor(i=0; i<c->nw; i++)\n\t\tif(c->w[i] == w)\n\t\t\tgoto Found;\n\terror(\"can't find window\");\n\n  Found:\n\tcr = c->r;\n\tif(but < 0){\t/* make sure window fills its own space properly */\n\t\tr = w->r;\n\t\tif(i==c->nw-1 || c->safe==FALSE)\n\t\t\tr.max.y = cr.max.y;\n\t\telse\n\t\t\tr.max.y = c->w[i+1]->r.min.y - Border;\n\t\twinresize(w, r, FALSE, TRUE);\n\t\treturn;\n\t}\n\tcr.min.y = c->w[0]->r.min.y;\n\tif(but == 3){\t/* full size */\n\t\tif(i != 0){\n\t\t\tv = c->w[0];\n\t\t\tc->w[0] = w;\n\t\t\tc->w[i] = v;\n\t\t}\n\t\tdraw(screen, cr, textcols[BACK], nil, ZP);\n\t\twinresize(w, cr, FALSE, TRUE);\n\t\tfor(i=1; i<c->nw; i++)\n\t\t\tc->w[i]->body.fr.maxlines = 0;\n\t\tc->safe = FALSE;\n\t\treturn;\n\t}\n\t/* store old #lines for each window */\n\tonl = w->body.fr.maxlines;\n\tnl = emalloc(c->nw * sizeof(int));\n\tny = emalloc(c->nw * sizeof(int));\n\ttot = 0;\n\tfor(j=0; j<c->nw; j++){\n\t\tl = c->w[j]->taglines-1 + c->w[j]->body.fr.maxlines;\n\t\tnl[j] = l;\n\t\ttot += l;\n\t}\n\t/* approximate new #lines for this window */\n\tif(but == 2){\t/* as big as can be */\n\t\tmemset(nl, 0, c->nw * sizeof(int));\n\t\tgoto Pack;\n\t}\n\tnnl = min(onl + max(min(5, w->taglines-1+w->maxlines), onl/2), tot);\n\tif(nnl < w->taglines-1+w->maxlines)\n\t\tnnl = (w->taglines-1+w->maxlines + nnl)/2;\n\tif(nnl == 0)\n\t\tnnl = 2;\n\tdnl = nnl - onl;\n\t/* compute new #lines for each window */\n\tfor(k=1; k<c->nw; k++){\n\t\t/* prune from later window */\n\t\tj = i+k;\n\t\tif(j<c->nw && nl[j]){\n\t\t\tl = min(dnl, max(1, nl[j]/2));\n\t\t\tnl[j] -= l;\n\t\t\tnl[i] += l;\n\t\t\tdnl -= l;\n\t\t}\n\t\t/* prune from earlier window */\n\t\tj = i-k;\n\t\tif(j>=0 && nl[j]){\n\t\t\tl = min(dnl, max(1, nl[j]/2));\n\t\t\tnl[j] -= l;\n\t\t\tnl[i] += l;\n\t\t\tdnl -= l;\n\t\t}\n\t}\n    Pack:\n\t/* pack everyone above */\n\ty1 = cr.min.y;\n\tfor(j=0; j<i; j++){\n\t\tv = c->w[j];\n\t\tr = v->r;\n\t\tr.min.y = y1;\n\t\tr.max.y = y1+Dy(v->tagtop);\n\t\tif(nl[j])\n\t\t\tr.max.y += 1 + nl[j]*v->body.fr.font->height;\n\t\tr.min.y = winresize(v, r, c->safe, FALSE);\n\t\tr.max.y += Border;\n\t\tdraw(screen, r, display->black, nil, ZP);\n\t\ty1 = r.max.y;\n\t}\n\t/* scan to see new size of everyone below */\n\ty2 = c->r.max.y;\n\tfor(j=c->nw-1; j>i; j--){\n\t\tv = c->w[j];\n\t\tr = v->r;\n\t\tr.min.y = y2-Dy(v->tagtop);\n\t\tif(nl[j])\n\t\t\tr.min.y -= 1 + nl[j]*v->body.fr.font->height;\n\t\tr.min.y -= Border;\n\t\tny[j] = r.min.y;\n\t\ty2 = r.min.y;\n\t}\n\t/* compute new size of window */\n\tr = w->r;\n\tr.min.y = y1;\n\tr.max.y = y2;\n\th = w->body.fr.font->height;\n\tif(Dy(r) < Dy(w->tagtop)+1+h+Border)\n\t\tr.max.y = r.min.y + Dy(w->tagtop)+1+h+Border;\n\t/* draw window */\n\tr.max.y = winresize(w, r, c->safe, TRUE);\n\tif(i < c->nw-1){\n\t\tr.min.y = r.max.y;\n\t\tr.max.y += Border;\n\t\tdraw(screen, r, display->black, nil, ZP);\n\t\tfor(j=i+1; j<c->nw; j++)\n\t\t\tny[j] -= (y2-r.max.y);\n\t}\n\t/* pack everyone below */\n\ty1 = r.max.y;\n\tfor(j=i+1; j<c->nw; j++){\n\t\tv = c->w[j];\n\t\tr = v->r;\n\t\tr.min.y = y1;\n\t\tr.max.y = y1+Dy(v->tagtop);\n\t\tif(nl[j])\n\t\t\tr.max.y += 1 + nl[j]*v->body.fr.font->height;\n\t\ty1 = winresize(v, r, c->safe, j==c->nw-1);\n\t\tif(j < c->nw-1){\t/* no border on last window */\n\t\t\tr.min.y = y1;\n\t\t\tr.max.y += Border;\n\t\t\tdraw(screen, r, display->black, nil, ZP);\n\t\t\ty1 = r.max.y;\n\t\t}\n\t}\n\tfree(nl);\n\tfree(ny);\n\tc->safe = TRUE;\n\twinmousebut(w);\n}\n\nvoid\ncoldragwin(Column *c, Window *w, int but)\n{\n\tRectangle r;\n\tint i, b;\n\tPoint p, op;\n\tWindow *v;\n\tColumn *nc;\n\n\tclearmouse();\n\tsetcursor(mousectl, &boxcursor);\n\tb = mouse->buttons;\n\top = mouse->xy;\n\twhile(mouse->buttons == b)\n\t\treadmouse(mousectl);\n\tsetcursor(mousectl, nil);\n\tif(mouse->buttons){\n\t\twhile(mouse->buttons)\n\t\t\treadmouse(mousectl);\n\t\treturn;\n\t}\n\n\tfor(i=0; i<c->nw; i++)\n\t\tif(c->w[i] == w)\n\t\t\tgoto Found;\n\terror(\"can't find window\");\n\n  Found:\n\tif(w->tagexpand)\t/* force recomputation of window tag size */\n\t\tw->taglines = 1;\n\tp = mouse->xy;\n\tif(abs(p.x-op.x)<5 && abs(p.y-op.y)<5){\n\t\tcolgrow(c, w, but);\n\t\twinmousebut(w);\n\t\treturn;\n\t}\n\t/* is it a flick to the right? */\n\tif(abs(p.y-op.y)<10 && p.x>op.x+30 && rowwhichcol(c->row, p)==c)\n\t\tp.x = op.x+Dx(w->r);\t/* yes: toss to next column */\n\tnc = rowwhichcol(c->row, p);\n\tif(nc!=nil && nc!=c){\n\t\tcolclose(c, w, FALSE);\n\t\tcoladd(nc, w, nil, p.y);\n\t\twinmousebut(w);\n\t\treturn;\n\t}\n\tif(i==0 && c->nw==1)\n\t\treturn;\t\t\t/* can't do it */\n\tif((i>0 && p.y<c->w[i-1]->r.min.y) || (i<c->nw-1 && p.y>w->r.max.y)\n\t|| (i==0 && p.y>w->r.max.y)){\n\t\t/* shuffle */\n\t\tcolclose(c, w, FALSE);\n\t\tcoladd(c, w, nil, p.y);\n\t\twinmousebut(w);\n\t\treturn;\n\t}\n\tif(i == 0)\n\t\treturn;\n\tv = c->w[i-1];\n\tif(p.y < v->tagtop.max.y)\n\t\tp.y = v->tagtop.max.y;\n\tif(p.y > w->r.max.y-Dy(w->tagtop)-Border)\n\t\tp.y = w->r.max.y-Dy(w->tagtop)-Border;\n\tr = v->r;\n\tr.max.y = p.y;\n\tif(r.max.y > v->body.fr.r.min.y){\n\t\tr.max.y -= (r.max.y-v->body.fr.r.min.y)%v->body.fr.font->height;\n\t\tif(v->body.fr.r.min.y == v->body.fr.r.max.y)\n\t\t\tr.max.y++;\n\t}\n\tr.min.y = winresize(v, r, c->safe, FALSE);\n\tr.max.y = r.min.y+Border;\n\tdraw(screen, r, display->black, nil, ZP);\n\tr.min.y = r.max.y;\n\tif(i == c->nw-1)\n\t\tr.max.y = c->r.max.y;\n\telse\n\t\tr.max.y = c->w[i+1]->r.min.y-Border;\n\twinresize(w, r, c->safe, TRUE);\n\tc->safe = TRUE;\n\twinmousebut(w);\n}\n\nText*\ncolwhich(Column *c, Point p)\n{\n\tint i;\n\tWindow *w;\n\n\tif(!ptinrect(p, c->r))\n\t\treturn nil;\n\tif(ptinrect(p, c->tag.all))\n\t\treturn &c->tag;\n\tfor(i=0; i<c->nw; i++){\n\t\tw = c->w[i];\n\t\tif(ptinrect(p, w->r)){\n\t\t\tif(ptinrect(p, w->tagtop) || ptinrect(p, w->tag.all))\n\t\t\t\treturn &w->tag;\n\t\t\t/* exclude partial line at bottom */\n\t\t\tif(p.x >= w->body.scrollr.max.x && p.y >= w->body.fr.r.max.y)\n\t\t\t\treturn nil;\n\t\t\treturn &w->body;\n\t\t}\n\t}\n\treturn nil;\n}\n\nint\ncolclean(Column *c)\n{\n\tint i, clean;\n\n\tclean = TRUE;\n\tfor(i=0; i<c->nw; i++)\n\t\tclean &= winclean(c->w[i], TRUE);\n\treturn clean;\n}\n", "source": "acme2k/src/cmd/acme/cols.c", "file_type": "c"}
{"text": "#include <u.h>\n#include <libc.h>\n#include <draw.h>\n#include <thread.h>\n#include <cursor.h>\n#include <mouse.h>\n#include <keyboard.h>\n#include <frame.h>\n#include <fcall.h>\n#include <regexp.h>\n#include <9pclient.h>\n#include <plumb.h>\n#include <libsec.h>\n#include \"dat.h\"\n#include \"fns.h\"\n\nCFid *plumbsendfid;\nCFid *plumbeditfid;\n\nWindow*\topenfile(Text*, Expand*);\n\nint\tnuntitled;\n\nvoid\nplumbthread(void *v)\n{\n\tCFid *fid;\n\tPlumbmsg *m;\n\tTimer *t;\n\n\tUSED(v);\n\tthreadsetname(\"plumbproc\");\n\t\n\t/*\n\t * Loop so that if plumber is restarted, acme need not be.\n\t */\n\tfor(;;){\n\t\t/*\n\t\t * Connect to plumber.\n\t\t */\n\t\tplumbunmount();\n\t\twhile((fid = plumbopenfid(\"edit\", OREAD|OCEXEC)) == nil){\n\t\t\tt = timerstart(2000);\n\t\t\trecv(t->c, nil);\n\t\t\ttimerstop(t);\n\t\t}\n\t\tplumbeditfid = fid;\n\t\tplumbsendfid = plumbopenfid(\"send\", OWRITE|OCEXEC);\n\t\n\t\t/*\n\t\t * Relay messages.\n\t\t */\n\t\tfor(;;){\n\t\t\tm = plumbrecvfid(plumbeditfid);\n\t\t\tif(m == nil)\n\t\t\t\tbreak;\n\t\t\tsendp(cplumb, m);\n\t\t}\n\n\t\t/*\n\t\t * Lost connection.\n\t\t */\n\t\tfid = plumbsendfid;\n\t\tplumbsendfid = nil;\n\t\tfsclose(fid);\n\n\t\tfid = plumbeditfid;\n\t\tplumbeditfid = nil;\n\t\tfsclose(fid);\n\t}\n}\n\nvoid\nstartplumbing(void)\n{\n\tcplumb = chancreate(sizeof(Plumbmsg*), 0);\n\tchansetname(cplumb, \"cplumb\");\n\tthreadcreate(plumbthread, nil, STACK);\n}\n\n\nvoid\nlook3(Text *t, uint q0, uint q1, int external)\n{\n\tint n, c, f, expanded;\n\tText *ct;\n\tExpand e;\n\tRune *r;\n\tuint p;\n\tPlumbmsg *m;\n\tRunestr dir;\n\tchar buf[32];\n\n\tct = seltext;\n\tif(ct == nil)\n\t\tseltext = t;\n\texpanded = expand(t, q0, q1, &e);\n\tif(!external && t->w!=nil && t->w->nopen[QWevent]>0){\n\t\t/* send alphanumeric expansion to external client */\n\t\tif(expanded == FALSE)\n\t\t\treturn;\n\t\tf = 0;\n\t\tif((e.u.at!=nil && t->w!=nil) || (e.nname>0 && lookfile(e.name, e.nname)!=nil))\n\t\t\tf = 1;\t\t/* acme can do it without loading a file */\n\t\tif(q0!=e.q0 || q1!=e.q1)\n\t\t\tf |= 2;\t/* second (post-expand) message follows */\n\t\tif(e.nname)\n\t\t\tf |= 4;\t/* it's a file name */\n\t\tc = 'l';\n\t\tif(t->what == Body)\n\t\t\tc = 'L';\n\t\tn = q1-q0;\n\t\tif(n <= EVENTSIZE){\n\t\t\tr = runemalloc(n);\n\t\t\tbufread(&t->file->b, q0, r, n);\n\t\t\twinevent(t->w, \"%c%d %d %d %d %.*S\\n\", c, q0, q1, f, n, n, r);\n\t\t\tfree(r);\n\t\t}else\n\t\t\twinevent(t->w, \"%c%d %d %d 0 \\n\", c, q0, q1, f, n);\n\t\tif(q0==e.q0 && q1==e.q1)\n\t\t\treturn;\n\t\tif(e.nname){\n\t\t\tn = e.nname;\n\t\t\tif(e.a1 > e.a0)\n\t\t\t\tn += 1+(e.a1-e.a0);\n\t\t\tr = runemalloc(n);\n\t\t\trunemove(r, e.name, e.nname);\n\t\t\tif(e.a1 > e.a0){\n\t\t\t\tr[e.nname] = ':';\n\t\t\t\tbufread(&e.u.at->file->b, e.a0, r+e.nname+1, e.a1-e.a0);\n\t\t\t}\n\t\t}else{\n\t\t\tn = e.q1 - e.q0;\n\t\t\tr = runemalloc(n);\n\t\t\tbufread(&t->file->b, e.q0, r, n);\n\t\t}\n\t\tf &= ~2;\n\t\tif(n <= EVENTSIZE)\n\t\t\twinevent(t->w, \"%c%d %d %d %d %.*S\\n\", c, e.q0, e.q1, f, n, n, r);\n\t\telse\n\t\t\twinevent(t->w, \"%c%d %d %d 0 \\n\", c, e.q0, e.q1, f, n);\n\t\tfree(r);\n\t\tgoto Return;\n\t}\n\tif(plumbsendfid != nil){\n\t\t/* send whitespace-delimited word to plumber */\n\t\tm = emalloc(sizeof(Plumbmsg));\n\t\tm->src = estrdup(\"acme\");\n\t\tm->dst = nil;\n\t\tdir = dirname(t, nil, 0);\n\t\tif(dir.nr==1 && dir.r[0]=='.'){\t/* sigh */\n\t\t\tfree(dir.r);\n\t\t\tdir.r = nil;\n\t\t\tdir.nr = 0;\n\t\t}\n\t\tif(dir.nr == 0)\n\t\t\tm->wdir = estrdup(wdir);\n\t\telse\n\t\t\tm->wdir = runetobyte(dir.r, dir.nr);\n\t\tfree(dir.r);\n\t\tm->type = estrdup(\"text\");\n\t\tm->attr = nil;\n\t\tbuf[0] = '\\0';\n\t\tif(q1 == q0){\n\t\t\tif(t->q1>t->q0 && t->q0<=q0 && q0<=t->q1){\n\t\t\t\tq0 = t->q0;\n\t\t\t\tq1 = t->q1;\n\t\t\t}else{\n\t\t\t\tp = q0;\n\t\t\t\twhile(q0>0 && (c=tgetc(t, q0-1))!=' ' && c!='\\t' && c!='\\n')\n\t\t\t\t\tq0--;\n\t\t\t\twhile(q1<t->file->b.nc && (c=tgetc(t, q1))!=' ' && c!='\\t' && c!='\\n')\n\t\t\t\t\tq1++;\n\t\t\t\tif(q1 == q0){\n\t\t\t\t\tplumbfree(m);\n\t\t\t\t\tgoto Return;\n\t\t\t\t}\n\t\t\t\tsprint(buf, \"click=%d\", p-q0);\n\t\t\t\tm->attr = plumbunpackattr(buf);\n\t\t\t}\n\t\t}\n\t\tr = runemalloc(q1-q0);\n\t\tbufread(&t->file->b, q0, r, q1-q0);\n\t\tm->data = runetobyte(r, q1-q0);\n\t\tm->ndata = strlen(m->data);\n\t\tfree(r);\n\t\tif(m->ndata<messagesize-1024 && plumbsendtofid(plumbsendfid, m) >= 0){\n\t\t\tplumbfree(m);\n\t\t\tgoto Return;\n\t\t}\n\t\tplumbfree(m);\n\t\t/* plumber failed to match; fall through */\n\t}\n\n\t/* interpret alphanumeric string ourselves */\n\tif(expanded == FALSE)\n\t\treturn;\n\tif(e.name || e.u.at)\n\t\topenfile(t, &e);\n\telse{\n\t\tif(t->w == nil)\n\t\t\treturn;\n\t\tct = &t->w->body;\n\t\tif(t->w != ct->w)\n\t\t\twinlock(ct->w, 'M');\n\t\tif(t == ct)\n\t\t\ttextsetselect(ct, e.q1, e.q1);\n\t\tn = e.q1 - e.q0;\n\t\tr = runemalloc(n);\n\t\tbufread(&t->file->b, e.q0, r, n);\n\t\tif(search(ct, r, n) && e.jump)\n\t\t\tmoveto(mousectl, addpt(frptofchar(&ct->fr, ct->fr.p0), Pt(4, ct->fr.font->height-4)));\n\t\tif(t->w != ct->w)\n\t\t\twinunlock(ct->w);\n\t\tfree(r);\n\t}\n\n   Return:\n\tfree(e.name);\n\tfree(e.bname);\n}\n\nint\nplumbgetc(void *a, uint n)\n{\n\tRune *r;\n\n\tr = a;\n\tif(n>runestrlen(r))\n\t\treturn 0;\n\treturn r[n];\n}\n\nvoid\nplumblook(Plumbmsg *m)\n{\n\tExpand e;\n\tchar *addr;\n\n\tif(m->ndata >= BUFSIZE){\n\t\twarning(nil, \"insanely long file name (%d bytes) in plumb message (%.32s...)\\n\", m->ndata, m->data);\n\t\treturn;\n\t}\n\te.q0 = 0;\n\te.q1 = 0;\n\tif(m->data[0] == '\\0')\n\t\treturn;\n\te.u.ar = nil;\n\te.bname = m->data;\n\te.name = bytetorune(e.bname, &e.nname);\n\te.jump = TRUE;\n\te.a0 = 0;\n\te.a1 = 0;\n\taddr = plumblookup(m->attr, \"addr\");\n\tif(addr != nil){\n\t\te.u.ar = bytetorune(addr, &e.a1);\n\t\te.agetc = plumbgetc;\n\t}\n\tdrawtopwindow();\n\topenfile(nil, &e);\n\tfree(e.name);\n\tfree(e.u.at);\n}\n\nvoid\nplumbshow(Plumbmsg *m)\n{\n\tWindow *w;\n\tRune rb[256], *r;\n\tint nb, nr;\n\tRunestr rs;\n\tchar *name, *p, namebuf[16];\n\n\tdrawtopwindow();\n\tw = makenewwindow(nil);\n\tname = plumblookup(m->attr, \"filename\");\n\tif(name == nil){\n\t\tname = namebuf;\n\t\tnuntitled++;\n\t\tsnprint(namebuf, sizeof namebuf, \"Untitled-%d\", nuntitled);\n\t}\n\tp = nil;\n\tif(name[0]!='/' && m->wdir!=nil && m->wdir[0]!='\\0'){\n\t\tnb = strlen(m->wdir) + 1 + strlen(name) + 1;\n\t\tp = emalloc(nb);\n\t\tsnprint(p, nb, \"%s/%s\", m->wdir, name);\n\t\tname = p;\n\t}\n\tcvttorunes(name, strlen(name), rb, &nb, &nr, nil);\n\tfree(p);\n\trs = cleanrname(runestr(rb, nr));\n\twinsetname(w, rs.r, rs.nr);\n\tr = runemalloc(m->ndata);\n\tcvttorunes(m->data, m->ndata, r, &nb, &nr, nil);\n\ttextinsert(&w->body, 0, r, nr, TRUE);\n\tfree(r);\n\tw->body.file->mod = FALSE;\n\tw->dirty = FALSE;\n\twinsettag(w);\n\ttextscrdraw(&w->body);\n\ttextsetselect(&w->tag, w->tag.file->b.nc, w->tag.file->b.nc);\n\txfidlog(w, \"new\");\n}\n\nint\nsearch(Text *ct, Rune *r, uint n)\n{\n\tuint q, nb, maxn;\n\tint around;\n\tRune *s, *b, *c;\n\n\tif(n==0 || n>ct->file->b.nc)\n\t\treturn FALSE;\n\tif(2*n > RBUFSIZE){\n\t\twarning(nil, \"string too long\\n\");\n\t\treturn FALSE;\n\t}\n\tmaxn = max(2*n, RBUFSIZE);\n\ts = fbufalloc();\n\tb = s;\n\tnb = 0;\n\tb[nb] = 0;\n\taround = 0;\n\tq = ct->q1;\n\tfor(;;){\n\t\tif(q >= ct->file->b.nc){\n\t\t\tq = 0;\n\t\t\taround = 1;\n\t\t\tnb = 0;\n\t\t\tb[nb] = 0;\n\t\t}\n\t\tif(nb > 0){\n\t\t\tc = runestrchr(b, r[0]);\n\t\t\tif(c == nil){\n\t\t\t\tq += nb;\n\t\t\t\tnb = 0;\n\t\t\t\tb[nb] = 0;\n\t\t\t\tif(around && q>=ct->q1)\n\t\t\t\t\tbreak;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tq += (c-b);\n\t\t\tnb -= (c-b);\n\t\t\tb = c;\n\t\t}\n\t\t/* reload if buffer covers neither string nor rest of file */\n\t\tif(nb<n && nb!=ct->file->b.nc-q){\n\t\t\tnb = ct->file->b.nc-q;\n\t\t\tif(nb >= maxn)\n\t\t\t\tnb = maxn-1;\n\t\t\tbufread(&ct->file->b, q, s, nb);\n\t\t\tb = s;\n\t\t\tb[nb] = '\\0';\n\t\t}\n\t\t/* this runeeq is fishy but the null at b[nb] makes it safe */\n\t\tif(runeeq(b, n, r, n)==TRUE){\n\t\t\tif(ct->w){\n\t\t\t\ttextshow(ct, q, q+n, 1);\n\t\t\t\twinsettag(ct->w);\n\t\t\t}else{\n\t\t\t\tct->q0 = q;\n\t\t\t\tct->q1 = q+n;\n\t\t\t}\n\t\t\tseltext = ct;\n\t\t\tfbuffree(s);\n\t\t\treturn TRUE;\n\t\t}\n\t\t--nb;\n\t\tb++;\n\t\tq++;\n\t\tif(around && q>=ct->q1)\n\t\t\tbreak;\n\t}\n\tfbuffree(s);\n\treturn FALSE;\n}\n\nint\nisfilec(Rune r)\n{\n\tstatic Rune Lx[] = { '.', '-', '+', '/', ':', 0 };\n\tif(isalnum(r))\n\t\treturn TRUE;\n\tif(runestrchr(Lx, r))\n\t\treturn TRUE;\n\treturn FALSE;\n}\n\n/* Runestr wrapper for cleanname */\nRunestr\ncleanrname(Runestr rs)\n{\n\tchar *s;\n\tint nb, nulls;\n\n\ts = runetobyte(rs.r, rs.nr);\n\tcleanname(s);\n\tcvttorunes(s, strlen(s), rs.r, &nb, &rs.nr, &nulls);\n\tfree(s);\n\treturn rs;\n}\n\nRunestr\nincludefile(Rune *dir, Rune *file, int nfile)\n{\n\tint m, n;\n\tchar *a;\n\tRune *r;\n\tstatic Rune Lslash[] = { '/', 0 };\n\n\tm = runestrlen(dir);\n\ta = emalloc((m+1+nfile)*UTFmax+1);\n\tsprint(a, \"%S/%.*S\", dir, nfile, file);\n\tn = access(a, 0);\n\tfree(a);\n\tif(n < 0)\n\t\treturn runestr(nil, 0);\n\tr = runemalloc(m+1+nfile);\n\trunemove(r, dir, m);\n\trunemove(r+m, Lslash, 1);\n\trunemove(r+m+1, file, nfile);\n\tfree(file);\n\treturn cleanrname(runestr(r, m+1+nfile));\n}\n\nstatic\tRune\t*objdir;\n\nRunestr\nincludename(Text *t, Rune *r, int n)\n{\n\tWindow *w;\n\tchar buf[128];\n\tRune Lsysinclude[] = { '/', 's', 'y', 's', '/', 'i', 'n', 'c', 'l', 'u', 'd', 'e', 0 };\n\tRune Lusrinclude[] = { '/', 'u', 's', 'r', '/', 'i', 'n', 'c', 'l', 'u', 'd', 'e', 0 };\n\tRune Lusrlocalinclude[] = { '/', 'u', 's', 'r', '/', 'l', 'o', 'c', 'a', 'l', \n\t\t\t'/', 'i', 'n', 'c', 'l', 'u', 'd', 'e', 0 };\n\tRune Lusrlocalplan9include[] = { '/', 'u', 's', 'r', '/', 'l', 'o', 'c', 'a', 'l', \n\t\t\t'/', 'p', 'l', 'a', 'n', '9', '/', 'i', 'n', 'c', 'l', 'u', 'd', 'e', 0 };\n\tRunestr file;\n\tint i;\n\n\tif(objdir==nil && objtype!=nil){\n\t\tsprint(buf, \"/%s/include\", objtype);\n\t\tobjdir = bytetorune(buf, &i);\n\t\tobjdir = runerealloc(objdir, i+1);\n\t\tobjdir[i] = '\\0';\t\n\t}\n\n\tw = t->w;\n\tif(n==0 || r[0]=='/' || w==nil)\n\t\tgoto Rescue;\n\tif(n>2 && r[0]=='.' && r[1]=='/')\n\t\tgoto Rescue;\n\tfile.r = nil;\n\tfile.nr = 0;\n\tfor(i=0; i<w->nincl && file.r==nil; i++)\n\t\tfile = includefile(w->incl[i], r, n);\n\n\tif(file.r == nil)\n\t\tfile = includefile(Lsysinclude, r, n);\n\tif(file.r == nil)\n\t\tfile = includefile(Lusrlocalplan9include, r, n);\n\tif(file.r == nil)\n\t\tfile = includefile(Lusrlocalinclude, r, n);\n\tif(file.r == nil)\n\t\tfile = includefile(Lusrinclude, r, n);\n\tif(file.r==nil && objdir!=nil)\n\t\tfile = includefile(objdir, r, n);\n\tif(file.r == nil)\n\t\tgoto Rescue;\n\treturn file;\n\n    Rescue:\n\treturn runestr(r, n);\n}\n\nRunestr\ndirname(Text *t, Rune *r, int n)\n{\n\tRune *b, c;\n\tuint m, nt;\n\tint slash;\n\tRunestr tmp;\n\n\tb = nil;\n\tif(t==nil || t->w==nil)\n\t\tgoto Rescue;\n\tnt = t->w->tag.file->b.nc;\n\tif(nt == 0)\n\t\tgoto Rescue;\n\tif(n>=1 && r[0]=='/')\n\t\tgoto Rescue;\n\tb = runemalloc(nt+n+1);\n\tbufread(&t->w->tag.file->b, 0, b, nt);\n\tslash = -1;\n\tfor(m=0; m<nt; m++){\n\t\tc = b[m];\n\t\tif(c == '/')\n\t\t\tslash = m;\n\t\tif(c==' ' || c=='\\t')\n\t\t\tbreak;\n\t}\n\tif(slash < 0)\n\t\tgoto Rescue;\n\trunemove(b+slash+1, r, n);\n\tfree(r);\n\treturn cleanrname(runestr(b, slash+1+n));\n\n    Rescue:\n\tfree(b);\n\ttmp = runestr(r, n);\n\tif(r)\n\t\treturn cleanrname(tmp);\n\treturn tmp;\n}\n\nint\nexpandfile(Text *t, uint q0, uint q1, Expand *e)\n{\n\tint i, n, nname, colon, eval;\n\tuint amin, amax;\n\tRune *r, c;\n\tWindow *w;\n\tRunestr rs;\n\n\tamax = q1;\n\tif(q1 == q0){\n\t\tcolon = -1;\n\t\twhile(q1<t->file->b.nc && isfilec(c=textreadc(t, q1))){\n\t\t\tif(c == ':'){\n\t\t\t\tcolon = q1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tq1++;\n\t\t}\n\t\twhile(q0>0 && (isfilec(c=textreadc(t, q0-1)) || isaddrc(c) || isregexc(c))){\n\t\t\tq0--;\n\t\t\tif(colon<0 && c==':')\n\t\t\t\tcolon = q0;\n\t\t}\n\t\t/*\n\t\t * if it looks like it might begin file: , consume address chars after :\n\t\t * otherwise terminate expansion at :\n\t\t */\n\t\tif(colon >= 0){\n\t\t\tq1 = colon;\n\t\t\tif(colon<t->file->b.nc-1 && isaddrc(textreadc(t, colon+1))){\n\t\t\t\tq1 = colon+1;\n\t\t\t\twhile(q1<t->file->b.nc && isaddrc(textreadc(t, q1)))\n\t\t\t\t\tq1++;\n\t\t\t}\n\t\t}\n\t\tif(q1 > q0)\n\t\t\tif(colon >= 0){\t/* stop at white space */\n\t\t\t\tfor(amax=colon+1; amax<t->file->b.nc; amax++)\n\t\t\t\t\tif((c=textreadc(t, amax))==' ' || c=='\\t' || c=='\\n')\n\t\t\t\t\t\tbreak;\n\t\t\t}else\n\t\t\t\tamax = t->file->b.nc;\n\t}\n\tamin = amax;\n\te->q0 = q0;\n\te->q1 = q1;\n\tn = q1-q0;\n\tif(n == 0)\n\t\treturn FALSE;\n\t/* see if it's a file name */\n\tr = runemalloc(n);\n\tbufread(&t->file->b, q0, r, n);\n\t/* first, does it have bad chars? */\n\tnname = -1;\n\tfor(i=0; i<n; i++){\n\t\tc = r[i];\n\t\tif(c==':' && nname<0){\n\t\t\tif(q0+i+1<t->file->b.nc && (i==n-1 || isaddrc(textreadc(t, q0+i+1))))\n\t\t\t\tamin = q0+i;\n\t\t\telse\n\t\t\t\tgoto Isntfile;\n\t\t\tnname = i;\n\t\t}\n\t}\n\tif(nname == -1)\n\t\tnname = n;\n\tfor(i=0; i<nname; i++)\n\t\tif(!isfilec(r[i]))\n\t\t\tgoto Isntfile;\n\t/*\n\t * See if it's a file name in <>, and turn that into an include\n\t * file name if so.  Should probably do it for \"\" too, but that's not\n\t * restrictive enough syntax and checking for a #include earlier on the\n\t * line would be silly.\n\t */\n\tif(q0>0 && textreadc(t, q0-1)=='<' && q1<t->file->b.nc && textreadc(t, q1)=='>'){\n\t\trs = includename(t, r, nname);\n\t\tr = rs.r;\n\t\tnname = rs.nr;\n\t}\n\telse if(amin == q0)\n\t\tgoto Isfile;\n\telse{\n\t\trs = dirname(t, r, nname);\n\t\tr = rs.r;\n\t\tnname = rs.nr;\n\t}\n\te->bname = runetobyte(r, nname);\n\t/* if it's already a window name, it's a file */\n\tw = lookfile(r, nname);\n\tif(w != nil)\n\t\tgoto Isfile;\n\t/* if it's the name of a file, it's a file */\n\tif(ismtpt(e->bname) || access(e->bname, 0) < 0){\n\t\tfree(e->bname);\n\t\te->bname = nil;\n\t\tgoto Isntfile;\n\t}\n\n  Isfile:\n\te->name = r;\n\te->nname = nname;\n\te->u.at = t;\n\te->a0 = amin+1;\n\teval = FALSE;\n\taddress(TRUE, nil, range(-1,-1), range(0,0), t, e->a0, amax, tgetc, &eval, (uint*)&e->a1);\n\treturn TRUE;\n\n   Isntfile:\n\tfree(r);\n\treturn FALSE;\n}\n\nint\nexpand(Text *t, uint q0, uint q1, Expand *e)\n{\n\tmemset(e, 0, sizeof *e);\n\te->agetc = tgetc;\n\t/* if in selection, choose selection */\n\te->jump = TRUE;\n\tif(q1==q0 && t->q1>t->q0 && t->q0<=q0 && q0<=t->q1){\n\t\tq0 = t->q0;\n\t\tq1 = t->q1;\n\t\tif(t->what == Tag)\n\t\t\te->jump = FALSE;\n\t}\n\n\tif(expandfile(t, q0, q1, e))\n\t\treturn TRUE;\n\n\tif(q0 == q1){\n\t\twhile(q1<t->file->b.nc && isalnum(textreadc(t, q1)))\n\t\t\tq1++;\n\t\twhile(q0>0 && isalnum(textreadc(t, q0-1)))\n\t\t\tq0--;\n\t}\n\te->q0 = q0;\n\te->q1 = q1;\n\treturn q1 > q0;\n}\n\nWindow*\nlookfile(Rune *s, int n)\n{\n\tint i, j, k;\n\tWindow *w;\n\tColumn *c;\n\tText *t;\n\n\t/* avoid terminal slash on directories */\n\tif(n>1 && s[n-1] == '/')\n\t\t--n;\n\tfor(j=0; j<row.ncol; j++){\n\t\tc = row.col[j];\n\t\tfor(i=0; i<c->nw; i++){\n\t\t\tw = c->w[i];\n\t\t\tt = &w->body;\n\t\t\tk = t->file->nname;\n\t\t\tif(k>1 && t->file->name[k-1] == '/')\n\t\t\t\tk--;\n\t\t\tif(runeeq(t->file->name, k, s, n)){\n\t\t\t\tw = w->body.file->curtext->w;\n\t\t\t\tif(w->col != nil)\t/* protect against race deleting w */\n\t\t\t\t\treturn w;\n\t\t\t}\n\t\t}\n\t}\n\treturn nil;\n}\n\nWindow*\nlookid(int id, int dump)\n{\n\tint i, j;\n\tWindow *w;\n\tColumn *c;\n\n\tfor(j=0; j<row.ncol; j++){\n\t\tc = row.col[j];\n\t\tfor(i=0; i<c->nw; i++){\n\t\t\tw = c->w[i];\n\t\t\tif(dump && w->dumpid == id)\n\t\t\t\treturn w;\n\t\t\tif(!dump && w->id == id)\n\t\t\t\treturn w;\n\t\t}\n\t}\n\treturn nil;\n}\n\n\nWindow*\nopenfile(Text *t, Expand *e)\n{\n\tRange r;\n\tWindow *w, *ow;\n\tint eval, i, n;\n\tRune *rp;\n\tRunestr rs;\n\tuint dummy;\n\n\tr.q0 = 0;\n\tr.q1 = 0;\n\tif(e->nname == 0){\n\t\tw = t->w;\n\t\tif(w == nil)\n\t\t\treturn nil;\n\t}else{\n\t\tw = lookfile(e->name, e->nname);\n\t\tif(w == nil && e->name[0] != '/'){\n\t\t\t/*\n\t\t\t * Unrooted path in new window.\n\t\t\t * This can happen if we type a pwd-relative path\n\t\t\t * in the topmost tag or the column tags.  \n\t\t\t * Most of the time plumber takes care of these,\n\t\t\t * but plumber might not be running or might not\n\t\t\t * be configured to accept plumbed directories.\n\t\t\t * Make the name a full path, just like we would if\n\t\t\t * opening via the plumber.\n\t\t\t */\n\t\t\tn = utflen(wdir)+1+e->nname+1;\n\t\t\trp = runemalloc(n);\n\t\t\trunesnprint(rp, n, \"%s/%.*S\", wdir, e->nname, e->name);\n\t\t\trs = cleanrname(runestr(rp, n-1));\n\t\t\tfree(e->name);\n\t\t\te->name = rs.r;\n\t\t\te->nname = rs.nr;\n\t\t\tw = lookfile(e->name, e->nname);\n\t\t}\n\t}\n\tif(w){\n\t\tt = &w->body;\n\t\tif(!t->col->safe && t->fr.maxlines==0) /* window is obscured by full-column window */\n\t\t\tcolgrow(t->col, t->col->w[0], 1);\n\t}else{\n\t\tow = nil;\n\t\tif(t)\n\t\t\tow = t->w;\n\t\tw = makenewwindow(t);\n\t\tt = &w->body;\n\t\twinsetname(w, e->name, e->nname);\n\t\tif(textload(t, 0, e->bname, 1) >= 0)\n\t\t\tt->file->unread = FALSE;\n\t\tt->file->mod = FALSE;\n\t\tt->w->dirty = FALSE;\n\t\twinsettag(t->w);\n\t\ttextsetselect(&t->w->tag, t->w->tag.file->b.nc, t->w->tag.file->b.nc);\n\t\tif(ow != nil){\n\t\t\tfor(i=ow->nincl; --i>=0; ){\n\t\t\t\tn = runestrlen(ow->incl[i]);\n\t\t\t\trp = runemalloc(n);\n\t\t\t\trunemove(rp, ow->incl[i], n);\n\t\t\t\twinaddincl(w, rp, n);\n\t\t\t}\n\t\t\tw->autoindent = ow->autoindent;\n\t\t}else\n\t\t\tw->autoindent = globalautoindent;\n\t\txfidlog(w, \"new\");\n\t}\n\tif(e->a1 == e->a0)\n\t\teval = FALSE;\n\telse{\n\t\teval = TRUE;\n\t\tr = address(TRUE, t, range(-1,-1), range(t->q0, t->q1), e->u.at, e->a0, e->a1, e->agetc, &eval, &dummy);\n\t\tif(r.q0 > r.q1) {\n\t\t\teval = FALSE;\n\t\t\twarning(nil, \"addresses out of order\\n\");\n\t\t}\n\t\tif(eval == FALSE)\n\t\t\te->jump = FALSE;\t/* don't jump if invalid address */\n\t}\n\tif(eval == FALSE){\n\t\tr.q0 = t->q0;\n\t\tr.q1 = t->q1;\n\t}\n\ttextshow(t, r.q0, r.q1, 1);\n\twinsettag(t->w);\n\tseltext = t;\n\tif(e->jump)\n\t\tmoveto(mousectl, addpt(frptofchar(&t->fr, t->fr.p0), Pt(4, font->height-4)));\n\treturn w;\n}\n\nvoid\nnew(Text *et, Text *t, Text *argt, int flag1, int flag2, Rune *arg, int narg)\n{\n\tint ndone;\n\tRune *a, *f;\n\tint na, nf;\n\tExpand e;\n\tRunestr rs;\n\tWindow *w;\n\n\tgetarg(argt, FALSE, TRUE, &a, &na);\n\tif(a){\n\t\tnew(et, t, nil, flag1, flag2, a, na);\n\t\tif(narg == 0)\n\t\t\treturn;\n\t}\n\t/* loop condition: *arg is not a blank */\n\tfor(ndone=0; ; ndone++){\n\t\ta = findbl(arg, narg, &na);\n\t\tif(a == arg){\n\t\t\tif(ndone==0 && et->col!=nil) {\n\t\t\t\tw = coladd(et->col, nil, nil, -1);\n\t\t\t\twinsettag(w);\n\t\t\t\txfidlog(w, \"new\");\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tnf = narg-na;\n\t\tf = runemalloc(nf);\n\t\trunemove(f, arg, nf);\n\t\trs = dirname(et, f, nf);\n\t\tmemset(&e, 0, sizeof e);\n\t\te.name = rs.r;\n\t\te.nname = rs.nr;\n\t\te.bname = runetobyte(rs.r, rs.nr);\n\t\te.jump = TRUE;\n\t\topenfile(et, &e);\n\t\tfree(e.name);\n\t\tfree(e.bname);\n\t\targ = skipbl(a, na, &narg);\n\t}\n}\n", "source": "acme2k/src/cmd/acme/look.c", "file_type": "c"}
{"text": "#include <u.h>\n#include <libc.h>\n#include <draw.h>\n#include <thread.h>\n#include <cursor.h>\n#include <mouse.h>\n#include <keyboard.h>\n#include <frame.h>\n#include <fcall.h>\n#include <plumb.h>\n#include <libsec.h>\n#include \"dat.h\"\n#include \"edit.h\"\n#include \"fns.h\"\n\nint\tGlooping;\nint\tnest;\nchar\tEnoname[] = \"no file name given\";\n\nAddress\taddr;\nFile\t*menu;\nRangeset\tsel;\nextern\tText*\tcurtext;\nRune\t*collection;\nint\tncollection;\n\nint\tappend(File*, Cmd*, long);\nint\tpdisplay(File*);\nvoid\tpfilename(File*);\nvoid\tlooper(File*, Cmd*, int);\nvoid\tfilelooper(Cmd*, int);\nvoid\tlinelooper(File*, Cmd*);\nAddress\tlineaddr(long, Address, int);\nint\tfilematch(File*, String*);\nFile\t*tofile(String*);\nRune*\tcmdname(File *f, String *s, int);\nvoid\trunpipe(Text*, int, Rune*, int, int);\n\nvoid\nclearcollection(void)\n{\n\tfree(collection);\n\tcollection = nil;\n\tncollection = 0;\n}\n\nvoid\nresetxec(void)\n{\n\tGlooping = nest = 0;\n\tclearcollection();\n}\n\nvoid\nmkaddr(Address *a, File *f)\n{\n\ta->r.q0 = f->curtext->q0;\n\ta->r.q1 = f->curtext->q1;\n\ta->f = f;\n}\n\nint\ncmdexec(Text *t, Cmd *cp)\n{\n\tint i;\n\tAddr *ap;\n\tFile *f;\n\tWindow *w;\n\tAddress dot;\n\n\tif(t == nil)\n\t\tw = nil;\n\telse\n\t\tw = t->w;\n\tif(w==nil && (cp->addr==0 || cp->addr->type!='\"') &&\n\t    !utfrune(\"bBnqUXY!\", cp->cmdc) &&\n\t    !(cp->cmdc=='D' && cp->u.text))\n\t\tediterror(\"no current window\");\n\ti = cmdlookup(cp->cmdc);\t/* will be -1 for '{' */\n\tf = nil;\n\tif(t && t->w){\n\t\tt = &t->w->body;\n\t\tf = t->file;\n\t\tf->curtext = t;\n\t}\n\tif(i>=0 && cmdtab[i].defaddr != aNo){\n\t\tif((ap=cp->addr)==0 && cp->cmdc!='\\n'){\n\t\t\tcp->addr = ap = newaddr();\n\t\t\tap->type = '.';\n\t\t\tif(cmdtab[i].defaddr == aAll)\n\t\t\t\tap->type = '*';\n\t\t}else if(ap && ap->type=='\"' && ap->next==0 && cp->cmdc!='\\n'){\n\t\t\tap->next = newaddr();\n\t\t\tap->next->type = '.';\n\t\t\tif(cmdtab[i].defaddr == aAll)\n\t\t\t\tap->next->type = '*';\n\t\t}\n\t\tif(cp->addr){\t/* may be false for '\\n' (only) */\n\t\t\tstatic Address none = {0,0,nil};\n\t\t\tif(f){\n\t\t\t\tmkaddr(&dot, f);\n\t\t\t\taddr = cmdaddress(ap, dot, 0);\n\t\t\t}else\t/* a \" */\n\t\t\t\taddr = cmdaddress(ap, none, 0);\n\t\t\tf = addr.f;\n\t\t\tt = f->curtext;\n\t\t}\n\t}\n\tswitch(cp->cmdc){\n\tcase '{':\n\t\tmkaddr(&dot, f);\n\t\tif(cp->addr != nil)\n\t\t\tdot = cmdaddress(cp->addr, dot, 0);\n\t\tfor(cp = cp->u.cmd; cp; cp = cp->next){\n\t\t\tif(dot.r.q1 > t->file->b.nc)\n\t\t\t\tediterror(\"dot extends past end of buffer during { command\");\n\t\t\tt->q0 = dot.r.q0;\n\t\t\tt->q1 = dot.r.q1;\n\t\t\tcmdexec(t, cp);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tif(i < 0)\n\t\t\tediterror(\"unknown command %c in cmdexec\", cp->cmdc);\n\t\ti = (*cmdtab[i].fn)(t, cp);\n\t\treturn i;\n\t}\n\treturn 1;\n}\n\nchar*\nedittext(Window *w, int q, Rune *r, int nr)\n{\n\tFile *f;\n\n\tf = w->body.file;\n\tswitch(editing){\n\tcase Inactive:\n\t\treturn \"permission denied\";\n\tcase Inserting:\n\t\teloginsert(f, q, r, nr);\n\t\treturn nil;\n\tcase Collecting:\n\t\tcollection = runerealloc(collection, ncollection+nr+1);\n\t\trunemove(collection+ncollection, r, nr);\n\t\tncollection += nr;\n\t\tcollection[ncollection] = '\\0';\n\t\treturn nil;\n\tdefault:\n\t\treturn \"unknown state in edittext\";\n\t}\n}\n\n/* string is known to be NUL-terminated */\nRune*\nfilelist(Text *t, Rune *r, int nr)\n{\n\tif(nr == 0)\n\t\treturn nil;\n\tr = skipbl(r, nr, &nr);\n\tif(r[0] != '<')\n\t\treturn runestrdup(r);\n\t/* use < command to collect text */\n\tclearcollection();\n\trunpipe(t, '<', r+1, nr-1, Collecting);\n\treturn collection;\n}\n\nint\na_cmd(Text *t, Cmd *cp)\n{\n\treturn append(t->file, cp, addr.r.q1);\n}\n\nint\nb_cmd(Text *t, Cmd *cp)\n{\n\tFile *f;\n\n\tUSED(t);\n\tf = tofile(cp->u.text);\n\tif(nest == 0)\n\t\tpfilename(f);\n\tcurtext = f->curtext;\n\treturn TRUE;\n}\n\nint\nB_cmd(Text *t, Cmd *cp)\n{\n\tRune *list, *r, *s;\n\tint nr;\n\n\tlist = filelist(t, cp->u.text->r, cp->u.text->n);\n\tif(list == nil)\n\t\tediterror(Enoname);\n\tr = list;\n\tnr = runestrlen(r);\n\tr = skipbl(r, nr, &nr);\n\tif(nr == 0)\n\t\tnew(t, t, nil, 0, 0, r, 0);\n\telse while(nr > 0){\n\t\ts = findbl(r, nr, &nr);\n\t\t*s = '\\0';\n\t\tnew(t, t, nil, 0, 0, r, runestrlen(r));\n\t\tif(nr > 0)\n\t\t\tr = skipbl(s+1, nr-1, &nr);\n\t}\n\tclearcollection();\n\treturn TRUE;\n}\n\nint\nc_cmd(Text *t, Cmd *cp)\n{\n\telogreplace(t->file, addr.r.q0, addr.r.q1, cp->u.text->r, cp->u.text->n);\n\tt->q0 = addr.r.q0;\n\tt->q1 = addr.r.q1;\n\treturn TRUE;\n}\n\nint\nd_cmd(Text *t, Cmd *cp)\n{\n\tUSED(cp);\n\tif(addr.r.q1 > addr.r.q0)\n\t\telogdelete(t->file, addr.r.q0, addr.r.q1);\n\tt->q0 = addr.r.q0;\n\tt->q1 = addr.r.q0;\n\treturn TRUE;\n}\n\nvoid\nD1(Text *t)\n{\n\tif(t->w->body.file->ntext>1 || winclean(t->w, FALSE))\n\t\tcolclose(t->col, t->w, TRUE);\n}\n\nint\nD_cmd(Text *t, Cmd *cp)\n{\n\tRune *list, *r, *s, *n;\n\tint nr, nn;\n\tWindow *w;\n\tRunestr dir, rs;\n\tchar buf[128];\n\n\tlist = filelist(t, cp->u.text->r, cp->u.text->n);\n\tif(list == nil){\n\t\tD1(t);\n\t\treturn TRUE;\n\t}\n\tdir = dirname(t, nil, 0);\n\tr = list;\n\tnr = runestrlen(r);\n\tr = skipbl(r, nr, &nr);\n\tdo{\n\t\ts = findbl(r, nr, &nr);\n\t\t*s = '\\0';\n\t\t/* first time through, could be empty string, meaning delete file empty name */\n\t\tnn = runestrlen(r);\n\t\tif(r[0]=='/' || nn==0 || dir.nr==0){\n\t\t\trs.r = runestrdup(r);\n\t\t\trs.nr = nn;\n\t\t}else{\n\t\t\tn = runemalloc(dir.nr+1+nn);\n\t\t\trunemove(n, dir.r, dir.nr);\n\t\t\tn[dir.nr] = '/';\n\t\t\trunemove(n+dir.nr+1, r, nn);\n\t\t\trs = cleanrname(runestr(n, dir.nr+1+nn));\n\t\t}\n\t\tw = lookfile(rs.r, rs.nr);\n\t\tif(w == nil){\n\t\t\tsnprint(buf, sizeof buf, \"no such file %.*S\", rs.nr, rs.r);\n\t\t\tfree(rs.r);\n\t\t\tediterror(buf);\n\t\t}\n\t\tfree(rs.r);\n\t\tD1(&w->body);\n\t\tif(nr > 0)\n\t\t\tr = skipbl(s+1, nr-1, &nr);\n\t}while(nr > 0);\n\tclearcollection();\n\tfree(dir.r);\n\treturn TRUE;\n}\n\nstatic int\nreadloader(void *v, uint q0, Rune *r, int nr)\n{\n\tif(nr > 0)\n\t\teloginsert(v, q0, r, nr);\n\treturn 0;\n}\n\nint\ne_cmd(Text *t, Cmd *cp)\n{\n\tRune *name;\n\tFile *f;\n\tint i, isdir, q0, q1, fd, nulls, samename, allreplaced;\n\tchar *s, tmp[128];\n\tDir *d;\n\n\tf = t->file;\n\tq0 = addr.r.q0;\n\tq1 = addr.r.q1;\n\tif(cp->cmdc == 'e'){\n\t\tif(winclean(t->w, TRUE)==FALSE)\n\t\t\tediterror(\"\");\t/* winclean generated message already */\n\t\tq0 = 0;\n\t\tq1 = f->b.nc;\n\t}\n\tallreplaced = (q0==0 && q1==f->b.nc);\n\tname = cmdname(f, cp->u.text, cp->cmdc=='e');\n\tif(name == nil)\n\t\tediterror(Enoname);\n\ti = runestrlen(name);\n\tsamename = runeeq(name, i, t->file->name, t->file->nname);\n\ts = runetobyte(name, i);\n\tfree(name);\n\tfd = open(s, OREAD);\n\tif(fd < 0){\n\t\tsnprint(tmp, sizeof tmp, \"can't open %s: %r\", s);\n\t\tfree(s);\n\t\tediterror(tmp);\n\t}\n\td = dirfstat(fd);\n\tisdir = (d!=nil && (d->qid.type&QTDIR));\n\tfree(d);\n\tif(isdir){\n\t\tclose(fd);\n\t\tsnprint(tmp, sizeof tmp, \"%s is a directory\", s);\n\t\tfree(s);\n\t\tediterror(tmp);\n\t}\n\telogdelete(f, q0, q1);\n\tnulls = 0;\n\tloadfile(fd, q1, &nulls, readloader, f, nil);\n\tfree(s);\n\tclose(fd);\n\tif(nulls)\n\t\twarning(nil, \"%s: NUL bytes elided\\n\", s);\n\telse if(allreplaced && samename)\n\t\tf->editclean = TRUE;\n\treturn TRUE;\n}\n\nstatic Rune Lempty[] = { 0 };\nint\nf_cmd(Text *t, Cmd *cp)\n{\n\tRune *name;\n\tString *str;\n\tString empty;\n\n\tif(cp->u.text == nil){\n\t\tempty.n = 0;\n\t\tempty.r = Lempty;\n\t\tstr = &empty;\n\t}else\n\t\tstr = cp->u.text;\n\tname = cmdname(t->file, str, TRUE);\n\tfree(name);\n\tpfilename(t->file);\n\treturn TRUE;\n}\n\nint\ng_cmd(Text *t, Cmd *cp)\n{\n\tif(t->file != addr.f){\n\t\twarning(nil, \"internal error: g_cmd f!=addr.f\\n\");\n\t\treturn FALSE;\n\t}\n\tif(rxcompile(cp->re->r) == FALSE)\n\t\tediterror(\"bad regexp in g command\");\n\tif(rxexecute(t, nil, addr.r.q0, addr.r.q1, &sel) ^ cp->cmdc=='v'){\n\t\tt->q0 = addr.r.q0;\n\t\tt->q1 = addr.r.q1;\n\t\treturn cmdexec(t, cp->u.cmd);\n\t}\n\treturn TRUE;\n}\n\nint\ni_cmd(Text *t, Cmd *cp)\n{\n\treturn append(t->file, cp, addr.r.q0);\n}\n\nvoid\ncopy(File *f, Address addr2)\n{\n\tlong p;\n\tint ni;\n\tRune *buf;\n\n\tbuf = fbufalloc();\n\tfor(p=addr.r.q0; p<addr.r.q1; p+=ni){\n\t\tni = addr.r.q1-p;\n\t\tif(ni > RBUFSIZE)\n\t\t\tni = RBUFSIZE;\n\t\tbufread(&f->b, p, buf, ni);\n\t\teloginsert(addr2.f, addr2.r.q1, buf, ni);\n\t}\n\tfbuffree(buf);\n}\n\nvoid\nmove(File *f, Address addr2)\n{\n\tif(addr.f!=addr2.f || addr.r.q1<=addr2.r.q0){\n\t\telogdelete(f, addr.r.q0, addr.r.q1);\n\t\tcopy(f, addr2);\n\t}else if(addr.r.q0 >= addr2.r.q1){\n\t\tcopy(f, addr2);\n\t\telogdelete(f, addr.r.q0, addr.r.q1);\n\t}else if(addr.r.q0==addr2.r.q0 && addr.r.q1==addr2.r.q1){\n\t\t; /* move to self; no-op */\n\t}else\n\t\tediterror(\"move overlaps itself\");\n}\n\nint\nm_cmd(Text *t, Cmd *cp)\n{\n\tAddress dot, addr2;\n\n\tmkaddr(&dot, t->file);\n\taddr2 = cmdaddress(cp->u.mtaddr, dot, 0);\n\tif(cp->cmdc == 'm')\n\t\tmove(t->file, addr2);\n\telse\n\t\tcopy(t->file, addr2);\n\treturn TRUE;\n}\n\nint\np_cmd(Text *t, Cmd *cp)\n{\n\tUSED(cp);\n\treturn pdisplay(t->file);\n}\n\nint\ns_cmd(Text *t, Cmd *cp)\n{\n\tint i, j, k, c, m, n, nrp, didsub;\n\tlong p1, op, delta;\n\tString *buf;\n\tRangeset *rp;\n\tchar *err;\n\tRune *rbuf;\n\n\tn = cp->num;\n\top= -1;\n\tif(rxcompile(cp->re->r) == FALSE)\n\t\tediterror(\"bad regexp in s command\");\n\tnrp = 0;\n\trp = nil;\n\tdelta = 0;\n\tdidsub = FALSE;\n\tfor(p1 = addr.r.q0; p1<=addr.r.q1 && rxexecute(t, nil, p1, addr.r.q1, &sel); ){\n\t\tif(sel.r[0].q0 == sel.r[0].q1){\t/* empty match? */\n\t\t\tif(sel.r[0].q0 == op){\n\t\t\t\tp1++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tp1 = sel.r[0].q1+1;\n\t\t}else\n\t\t\tp1 = sel.r[0].q1;\n\t\top = sel.r[0].q1;\n\t\tif(--n>0)\n\t\t\tcontinue;\n\t\tnrp++;\n\t\trp = erealloc(rp, nrp*sizeof(Rangeset));\n\t\trp[nrp-1] = sel;\n\t}\n\trbuf = fbufalloc();\n\tbuf = allocstring(0);\n\tfor(m=0; m<nrp; m++){\n\t\tbuf->n = 0;\n\t\tbuf->r[0] = '\\0';\n\t\tsel = rp[m];\n\t\tfor(i = 0; i<cp->u.text->n; i++)\n\t\t\tif((c = cp->u.text->r[i])=='\\\\' && i<cp->u.text->n-1){\n\t\t\t\tc = cp->u.text->r[++i];\n\t\t\t\tif('1'<=c && c<='9') {\n\t\t\t\t\tj = c-'0';\n\t\t\t\t\tif(sel.r[j].q1-sel.r[j].q0>RBUFSIZE){\n\t\t\t\t\t\terr = \"replacement string too long\";\n\t\t\t\t\t\tgoto Err;\n\t\t\t\t\t}\n\t\t\t\t\tbufread(&t->file->b, sel.r[j].q0, rbuf, sel.r[j].q1-sel.r[j].q0);\n\t\t\t\t\tfor(k=0; k<sel.r[j].q1-sel.r[j].q0; k++)\n\t\t\t\t\t\tStraddc(buf, rbuf[k]);\n\t\t\t\t}else\n\t\t\t\t \tStraddc(buf, c);\n\t\t\t}else if(c!='&')\n\t\t\t\tStraddc(buf, c);\n\t\t\telse{\n\t\t\t\tif(sel.r[0].q1-sel.r[0].q0>RBUFSIZE){\n\t\t\t\t\terr = \"right hand side too long in substitution\";\n\t\t\t\t\tgoto Err;\n\t\t\t\t}\n\t\t\t\tbufread(&t->file->b, sel.r[0].q0, rbuf, sel.r[0].q1-sel.r[0].q0);\n\t\t\t\tfor(k=0; k<sel.r[0].q1-sel.r[0].q0; k++)\n\t\t\t\t\tStraddc(buf, rbuf[k]);\n\t\t\t}\n\t\telogreplace(t->file, sel.r[0].q0, sel.r[0].q1,  buf->r, buf->n);\n\t\tdelta -= sel.r[0].q1-sel.r[0].q0;\n\t\tdelta += buf->n;\n\t\tdidsub = 1;\n\t\tif(!cp->flag)\n\t\t\tbreak;\n\t}\n\tfree(rp);\n\tfreestring(buf);\n\tfbuffree(rbuf);\n\tif(!didsub && nest==0)\n\t\tediterror(\"no substitution\");\n\tt->q0 = addr.r.q0;\n\tt->q1 = addr.r.q1;\n\treturn TRUE;\n\nErr:\n\tfree(rp);\n\tfreestring(buf);\n\tfbuffree(rbuf);\n\tediterror(err);\n\treturn FALSE;\n}\n\nint\nu_cmd(Text *t, Cmd *cp)\n{\n\tint n, oseq, flag;\n\n\tn = cp->num;\n\tflag = TRUE;\n\tif(n < 0){\n\t\tn = -n;\n\t\tflag = FALSE;\n\t}\n\toseq = -1;\n\twhile(n-->0 && t->file->seq!=oseq){\n\t\toseq = t->file->seq;\n\t\tundo(t, nil, nil, flag, 0, nil, 0);\n\t}\n\treturn TRUE;\n}\n\nint\nw_cmd(Text *t, Cmd *cp)\n{\n\tRune *r;\n\tFile *f;\n\n\tf = t->file;\n\tif(f->seq == seq)\n\t\tediterror(\"can't write file with pending modifications\");\n\tr = cmdname(f, cp->u.text, FALSE);\n\tif(r == nil)\n\t\tediterror(\"no name specified for 'w' command\");\n\tputfile(f, addr.r.q0, addr.r.q1, r, runestrlen(r));\n\t/* r is freed by putfile */\n\treturn TRUE;\n}\n\nint\nx_cmd(Text *t, Cmd *cp)\n{\n\tif(cp->re)\n\t\tlooper(t->file, cp, cp->cmdc=='x');\n\telse\n\t\tlinelooper(t->file, cp);\n\treturn TRUE;\n}\n\nint\nX_cmd(Text *t, Cmd *cp)\n{\n\tUSED(t);\n\n\tfilelooper(cp, cp->cmdc=='X');\n\treturn TRUE;\n}\n\nvoid\nrunpipe(Text *t, int cmd, Rune *cr, int ncr, int state)\n{\n\tRune *r, *s;\n\tint n;\n\tRunestr dir;\n\tWindow *w;\n\tQLock *q;\n\n\tr = skipbl(cr, ncr, &n);\n\tif(n == 0)\n\t\tediterror(\"no command specified for %c\", cmd);\n\tw = nil;\n\tif(state == Inserting){\n\t\tw = t->w;\n\t\tt->q0 = addr.r.q0;\n\t\tt->q1 = addr.r.q1;\n\t\tif(cmd == '<' || cmd=='|')\n\t\t\telogdelete(t->file, t->q0, t->q1);\n\t}\n\ts = runemalloc(n+2);\n\ts[0] = cmd;\n\trunemove(s+1, r, n);\n\tn++;\n\tdir.r = nil;\n\tdir.nr = 0;\n\tif(t != nil)\n\t\tdir = dirname(t, nil, 0);\n\tif(dir.nr==1 && dir.r[0]=='.'){\t/* sigh */\n\t\tfree(dir.r);\n\t\tdir.r = nil;\n\t\tdir.nr = 0;\n\t}\n\tediting = state;\n\tif(t!=nil && t->w!=nil)\n\t\tincref(&t->w->ref);\t/* run will decref */\n\trun(w, runetobyte(s, n), dir.r, dir.nr, TRUE, nil, nil, TRUE);\n\tfree(s);\n\tif(t!=nil && t->w!=nil)\n\t\twinunlock(t->w);\n\tqunlock(&row.lk);\n\trecvul(cedit);\n\t/*\n\t * The editoutlk exists only so that we can tell when\n\t * the editout file has been closed.  It can get closed *after*\n\t * the process exits because, since the process cannot be \n\t * connected directly to editout (no 9P kernel support), \n\t * the process is actually connected to a pipe to another\n\t * process (arranged via 9pserve) that reads from the pipe\n\t * and then writes the data in the pipe to editout using\n\t * 9P transactions.  This process might still have a couple\n\t * writes left to copy after the original process has exited.\n\t */\n\tif(w)\n\t\tq = &w->editoutlk;\n\telse\n\t\tq = &editoutlk;\n\tqlock(q);\t/* wait for file to close */\n\tqunlock(q);\n\tqlock(&row.lk);\n\tediting = Inactive;\n\tif(t!=nil && t->w!=nil)\n\t\twinlock(t->w, 'M');\n}\n\nint\npipe_cmd(Text *t, Cmd *cp)\n{\n\trunpipe(t, cp->cmdc, cp->u.text->r, cp->u.text->n, Inserting);\n\treturn TRUE;\n}\n\nlong\nnlcount(Text *t, long q0, long q1, long *pnr)\n{\n\tlong nl, start;\n\tRune *buf;\n\tint i, nbuf;\n\n\tbuf = fbufalloc();\n\tnbuf = 0;\n\ti = nl = 0;\n\tstart = q0;\n\twhile(q0 < q1){\n\t\tif(i == nbuf){\n\t\t\tnbuf = q1-q0;\n\t\t\tif(nbuf > RBUFSIZE)\n\t\t\t\tnbuf = RBUFSIZE;\n\t\t\tbufread(&t->file->b, q0, buf, nbuf);\n\t\t\ti = 0;\n\t\t}\n\t\tif(buf[i++] == '\\n') {\n\t\t\tstart = q0+1;\n\t\t\tnl++;\n\t\t}\n\t\tq0++;\n\t}\n\tfbuffree(buf);\n\tif(pnr != nil)\n\t\t*pnr = q0 - start;\n\treturn nl;\n}\n\nenum {\n\tPosnLine = 0,\n\tPosnChars = 1,\n\tPosnLineChars = 2,\n};\n\nvoid\nprintposn(Text *t, int mode)\n{\n\tlong l1, l2, r1, r2;\n\n\tif (t != nil && t->file != nil && t->file->name != nil)\n\t\twarning(nil, \"%.*S:\", t->file->nname, t->file->name);\n\t\n\tswitch(mode) {\n\tcase PosnChars:\n\t\twarning(nil, \"#%d\", addr.r.q0);\n\t\tif(addr.r.q1 != addr.r.q0)\n\t\t\twarning(nil, \",#%d\", addr.r.q1);\n\t\twarning(nil, \"\\n\");\n\t\treturn;\n\t\n\tdefault:\n\tcase PosnLine:\n\t\tl1 = 1+nlcount(t, 0, addr.r.q0, nil);\n\t\tl2 = l1+nlcount(t, addr.r.q0, addr.r.q1, nil);\n\t\t/* check if addr ends with '\\n' */\n\t\tif(addr.r.q1>0 && addr.r.q1>addr.r.q0 && textreadc(t, addr.r.q1-1)=='\\n')\n\t\t\t--l2;\n\t\twarning(nil, \"%lud\", l1);\n\t\tif(l2 != l1)\n\t\t\twarning(nil, \",%lud\", l2);\n\t\twarning(nil, \"\\n\");\n\t\treturn;\n\n\tcase PosnLineChars:\n\t\tl1 = 1+nlcount(t, 0, addr.r.q0, &r1);\n\t\tl2 = l1+nlcount(t, addr.r.q0, addr.r.q1, &r2);\n\t\tif(l2 == l1)\n\t\t\tr2 += r1;\n\t\twarning(nil, \"%lud+#%d\", l1, r1);\n\t\tif(l2 != l1)\n\t\t\twarning(nil, \",%lud+#%d\", l2, r2);\n\t\twarning(nil, \"\\n\");\n\t\treturn;\n\t}\n}\n\nint\neq_cmd(Text *t, Cmd *cp)\n{\n\tint mode;\n\n\tswitch(cp->u.text->n){\n\tcase 0:\n\t\tmode = PosnLine;\n\t\tbreak;\n\tcase 1:\n\t\tif(cp->u.text->r[0] == '#'){\n\t\t\tmode = PosnChars;\n\t\t\tbreak;\n\t\t}\n\t\tif(cp->u.text->r[0] == '+'){\n\t\t\tmode = PosnLineChars;\n\t\t\tbreak;\n\t\t}\n\tdefault:\n\t\tSET(mode);\n\t\tediterror(\"newline expected\");\n\t}\n\tprintposn(t, mode);\n\treturn TRUE;\n}\n\nint\nnl_cmd(Text *t, Cmd *cp)\n{\n\tAddress a;\n\tFile *f;\n\n\tf = t->file;\n\tif(cp->addr == 0){\n\t\t/* First put it on newline boundaries */\n\t\tmkaddr(&a, f);\n\t\taddr = lineaddr(0, a, -1);\n\t\ta = lineaddr(0, a, 1);\n\t\taddr.r.q1 = a.r.q1;\n\t\tif(addr.r.q0==t->q0 && addr.r.q1==t->q1){\n\t\t\tmkaddr(&a, f);\n\t\t\taddr = lineaddr(1, a, 1);\n\t\t}\n\t}\n\ttextshow(t, addr.r.q0, addr.r.q1, 1);\n\treturn TRUE;\n}\n\nint\nappend(File *f, Cmd *cp, long p)\n{\n\tif(cp->u.text->n > 0)\n\t\teloginsert(f, p, cp->u.text->r, cp->u.text->n);\n\tf->curtext->q0 = p;\n\tf->curtext->q1 = p;\n\treturn TRUE;\n}\n\nint\npdisplay(File *f)\n{\n\tlong p1, p2;\n\tint np;\n\tRune *buf;\n\n\tp1 = addr.r.q0;\n\tp2 = addr.r.q1;\n\tif(p2 > f->b.nc)\n\t\tp2 = f->b.nc;\n\tbuf = fbufalloc();\n\twhile(p1 < p2){\n\t\tnp = p2-p1;\n\t\tif(np>RBUFSIZE-1)\n\t\t\tnp = RBUFSIZE-1;\n\t\tbufread(&f->b, p1, buf, np);\n\t\tbuf[np] = '\\0';\n\t\twarning(nil, \"%S\", buf);\n\t\tp1 += np;\n\t}\n\tfbuffree(buf);\n\tf->curtext->q0 = addr.r.q0;\n\tf->curtext->q1 = addr.r.q1;\n\treturn TRUE;\n}\n\nvoid\npfilename(File *f)\n{\n\tint dirty;\n\tWindow *w;\n\n\tw = f->curtext->w;\n\t/* same check for dirty as in settag, but we know ncache==0 */\n\tdirty = !w->isdir && !w->isscratch && f->mod;\n\twarning(nil, \"%c%c%c %.*S\\n\", \" '\"[dirty],\n\t\t'+', \" .\"[curtext!=nil && curtext->file==f], f->nname, f->name);\n}\n\nvoid\nloopcmd(File *f, Cmd *cp, Range *rp, long nrp)\n{\n\tlong i;\n\n\tfor(i=0; i<nrp; i++){\n\t\tf->curtext->q0 = rp[i].q0;\n\t\tf->curtext->q1 = rp[i].q1;\n\t\tcmdexec(f->curtext, cp);\n\t}\n}\n\nvoid\nlooper(File *f, Cmd *cp, int xy)\n{\n\tlong p, op, nrp;\n\tRange r, tr;\n\tRange *rp;\n\n\tr = addr.r;\n\top= xy? -1 : r.q0;\n\tnest++;\n\tif(rxcompile(cp->re->r) == FALSE)\n\t\tediterror(\"bad regexp in %c command\", cp->cmdc);\n\tnrp = 0;\n\trp = nil;\n\tfor(p = r.q0; p<=r.q1; ){\n\t\tif(!rxexecute(f->curtext, nil, p, r.q1, &sel)){ /* no match, but y should still run */\n\t\t\tif(xy || op>r.q1)\n\t\t\t\tbreak;\n\t\t\ttr.q0 = op, tr.q1 = r.q1;\n\t\t\tp = r.q1+1;\t/* exit next loop */\n\t\t}else{\n\t\t\tif(sel.r[0].q0==sel.r[0].q1){\t/* empty match? */\n\t\t\t\tif(sel.r[0].q0==op){\n\t\t\t\t\tp++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tp = sel.r[0].q1+1;\n\t\t\t}else\n\t\t\t\tp = sel.r[0].q1;\n\t\t\tif(xy)\n\t\t\t\ttr = sel.r[0];\n\t\t\telse\n\t\t\t\ttr.q0 = op, tr.q1 = sel.r[0].q0;\n\t\t}\n\t\top = sel.r[0].q1;\n\t\tnrp++;\n\t\trp = erealloc(rp, nrp*sizeof(Range));\n\t\trp[nrp-1] = tr;\n\t}\n\tloopcmd(f, cp->u.cmd, rp, nrp);\n\tfree(rp);\n\t--nest;\n}\n\nvoid\nlinelooper(File *f, Cmd *cp)\n{\n\tlong nrp, p;\n\tRange r, linesel;\n\tAddress a, a3;\n\tRange *rp;\n\n\tnest++;\n\tnrp = 0;\n\trp = nil;\n\tr = addr.r;\n\ta3.f = f;\n\ta3.r.q0 = a3.r.q1 = r.q0;\n\ta = lineaddr(0, a3, 1);\n\tlinesel = a.r;\n\tfor(p = r.q0; p<r.q1; p = a3.r.q1){\n\t\ta3.r.q0 = a3.r.q1;\n\t\tif(p!=r.q0 || linesel.q1==p){\n\t\t\ta = lineaddr(1, a3, 1);\n\t\t\tlinesel = a.r;\n\t\t}\n\t\tif(linesel.q0 >= r.q1)\n\t\t\tbreak;\n\t\tif(linesel.q1 >= r.q1)\n\t\t\tlinesel.q1 = r.q1;\n\t\tif(linesel.q1 > linesel.q0)\n\t\t\tif(linesel.q0>=a3.r.q1 && linesel.q1>a3.r.q1){\n\t\t\t\ta3.r = linesel;\n\t\t\t\tnrp++;\n\t\t\t\trp = erealloc(rp, nrp*sizeof(Range));\n\t\t\t\trp[nrp-1] = linesel;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\tbreak;\n\t}\n\tloopcmd(f, cp->u.cmd, rp, nrp);\n\tfree(rp);\n\t--nest;\n}\n\nstruct Looper\n{\n\tCmd *cp;\n\tint\tXY;\n\tWindow\t**w;\n\tint\tnw;\n} loopstruct;\t/* only one; X and Y can't nest */\n\nvoid\nalllooper(Window *w, void *v)\n{\n\tText *t;\n\tstruct Looper *lp;\n\tCmd *cp;\n\n\tlp = v;\n\tcp = lp->cp;\n/*\tif(w->isscratch || w->isdir) */\n/*\t\treturn; */\n\tt = &w->body;\n\t/* only use this window if it's the current window for the file */\n\tif(t->file->curtext != t)\n\t\treturn;\n/*\tif(w->nopen[QWevent] > 0) */\n/*\t\treturn; */\n\t/* no auto-execute on files without names */\n\tif(cp->re==nil && t->file->nname==0)\n\t\treturn;\n\tif(cp->re==nil || filematch(t->file, cp->re)==lp->XY){\n\t\tlp->w = erealloc(lp->w, (lp->nw+1)*sizeof(Window*));\n\t\tlp->w[lp->nw++] = w;\n\t}\n}\n\nvoid\nalllocker(Window *w, void *v)\n{\n\tif(v)\n\t\tincref(&w->ref);\n\telse\n\t\twinclose(w);\n}\n\nvoid\nfilelooper(Cmd *cp, int XY)\n{\n\tint i;\n\n\tif(Glooping++)\n\t\tediterror(\"can't nest %c command\", \"YX\"[XY]);\n\tnest++;\n\n\tloopstruct.cp = cp;\n\tloopstruct.XY = XY;\n\tif(loopstruct.w)\t/* error'ed out last time */\n\t\tfree(loopstruct.w);\n\tloopstruct.w = nil;\n\tloopstruct.nw = 0;\n\tallwindows(alllooper, &loopstruct);\n\t/*\n\t * add a ref to all windows to keep safe windows accessed by X\n\t * that would not otherwise have a ref to hold them up during\n\t * the shenanigans.  note this with globalincref so that any\n\t * newly created windows start with an extra reference.\n\t */\n\tallwindows(alllocker, (void*)1);\n\tglobalincref = 1;\n\tfor(i=0; i<loopstruct.nw; i++)\n\t\tcmdexec(&loopstruct.w[i]->body, cp->u.cmd);\n\tallwindows(alllocker, (void*)0);\n\tglobalincref = 0;\n\tfree(loopstruct.w);\n\tloopstruct.w = nil;\n\n\t--Glooping;\n\t--nest;\n}\n\nvoid\nnextmatch(File *f, String *r, long p, int sign)\n{\n\tif(rxcompile(r->r) == FALSE)\n\t\tediterror(\"bad regexp in command address\");\n\tif(sign >= 0){\n\t\tif(!rxexecute(f->curtext, nil, p, 0x7FFFFFFFL, &sel))\n\t\t\tediterror(\"no match for regexp\");\n\t\tif(sel.r[0].q0==sel.r[0].q1 && sel.r[0].q0==p){\n\t\t\tif(++p>f->b.nc)\n\t\t\t\tp = 0;\n\t\t\tif(!rxexecute(f->curtext, nil, p, 0x7FFFFFFFL, &sel))\n\t\t\t\tediterror(\"address\");\n\t\t}\n\t}else{\n\t\tif(!rxbexecute(f->curtext, p, &sel))\n\t\t\tediterror(\"no match for regexp\");\n\t\tif(sel.r[0].q0==sel.r[0].q1 && sel.r[0].q1==p){\n\t\t\tif(--p<0)\n\t\t\t\tp = f->b.nc;\n\t\t\tif(!rxbexecute(f->curtext, p, &sel))\n\t\t\t\tediterror(\"address\");\n\t\t}\n\t}\n}\n\nFile\t*matchfile(String*);\nAddress\tcharaddr(long, Address, int);\nAddress\tlineaddr(long, Address, int);\n\nAddress\ncmdaddress(Addr *ap, Address a, int sign)\n{\n\tFile *f = a.f;\n\tAddress a1, a2;\n\n\tdo{\n\t\tswitch(ap->type){\n\t\tcase 'l':\n\t\tcase '#':\n\t\t\ta = (*(ap->type=='#'?charaddr:lineaddr))(ap->num, a, sign);\n\t\t\tbreak;\n\n\t\tcase '.':\n\t\t\tmkaddr(&a, f);\n\t\t\tbreak;\n\n\t\tcase '$':\n\t\t\ta.r.q0 = a.r.q1 = f->b.nc;\n\t\t\tbreak;\n\n\t\tcase '\\'':\nediterror(\"can't handle '\");\n/*\t\t\ta.r = f->mark; */\n\t\t\tbreak;\n\n\t\tcase '?':\n\t\t\tsign = -sign;\n\t\t\tif(sign == 0)\n\t\t\t\tsign = -1;\n\t\t\t/* fall through */\n\t\tcase '/':\n\t\t\tnextmatch(f, ap->u.re, sign>=0? a.r.q1 : a.r.q0, sign);\n\t\t\ta.r = sel.r[0];\n\t\t\tbreak;\n\n\t\tcase '\"':\n\t\t\tf = matchfile(ap->u.re);\n\t\t\tmkaddr(&a, f);\n\t\t\tbreak;\n\n\t\tcase '*':\n\t\t\ta.r.q0 = 0, a.r.q1 = f->b.nc;\n\t\t\treturn a;\n\n\t\tcase ',':\n\t\tcase ';':\n\t\t\tif(ap->u.left)\n\t\t\t\ta1 = cmdaddress(ap->u.left, a, 0);\n\t\t\telse\n\t\t\t\ta1.f = a.f, a1.r.q0 = a1.r.q1 = 0;\n\t\t\tif(ap->type == ';'){\n\t\t\t\tf = a1.f;\n\t\t\t\ta = a1;\n\t\t\t\tf->curtext->q0 = a1.r.q0;\n\t\t\t\tf->curtext->q1 = a1.r.q1;\n\t\t\t}\n\t\t\tif(ap->next)\n\t\t\t\ta2 = cmdaddress(ap->next, a, 0);\n\t\t\telse\n\t\t\t\ta2.f = a.f, a2.r.q0 = a2.r.q1 = f->b.nc;\n\t\t\tif(a1.f != a2.f)\n\t\t\t\tediterror(\"addresses in different files\");\n\t\t\ta.f = a1.f, a.r.q0 = a1.r.q0, a.r.q1 = a2.r.q1;\n\t\t\tif(a.r.q1 < a.r.q0)\n\t\t\t\tediterror(\"addresses out of order\");\n\t\t\treturn a;\n\n\t\tcase '+':\n\t\tcase '-':\n\t\t\tsign = 1;\n\t\t\tif(ap->type == '-')\n\t\t\t\tsign = -1;\n\t\t\tif(ap->next==0 || ap->next->type=='+' || ap->next->type=='-')\n\t\t\t\ta = lineaddr(1L, a, sign);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terror(\"cmdaddress\");\n\t\t\treturn a;\n\t\t}\n\t}while(ap = ap->next);\t/* assign = */\n\treturn a;\n}\n\nstruct Tofile{\n\tFile\t\t*f;\n\tString\t*r;\n};\n\nvoid\nalltofile(Window *w, void *v)\n{\n\tText *t;\n\tstruct Tofile *tp;\n\n\ttp = v;\n\tif(tp->f != nil)\n\t\treturn;\n\tif(w->isscratch || w->isdir)\n\t\treturn;\n\tt = &w->body;\n\t/* only use this window if it's the current window for the file */\n\tif(t->file->curtext != t)\n\t\treturn;\n/*\tif(w->nopen[QWevent] > 0) */\n/*\t\treturn; */\n\tif(runeeq(tp->r->r, tp->r->n, t->file->name, t->file->nname))\n\t\ttp->f = t->file;\n}\n\nFile*\ntofile(String *r)\n{\n\tstruct Tofile t;\n\tString rr;\n\n\trr.r = skipbl(r->r, r->n, &rr.n);\n\tt.f = nil;\n\tt.r = &rr;\n\tallwindows(alltofile, &t);\n\tif(t.f == nil)\n\t\tediterror(\"no such file\\\"%S\\\"\", rr.r);\n\treturn t.f;\n}\n\nvoid\nallmatchfile(Window *w, void *v)\n{\n\tstruct Tofile *tp;\n\tText *t;\n\n\ttp = v;\n\tif(w->isscratch || w->isdir)\n\t\treturn;\n\tt = &w->body;\n\t/* only use this window if it's the current window for the file */\n\tif(t->file->curtext != t)\n\t\treturn;\n/*\tif(w->nopen[QWevent] > 0) */\n/*\t\treturn; */\n\tif(filematch(w->body.file, tp->r)){\n\t\tif(tp->f != nil)\n\t\t\tediterror(\"too many files match \\\"%S\\\"\", tp->r->r);\n\t\ttp->f = w->body.file;\n\t}\n}\n\nFile*\nmatchfile(String *r)\n{\n\tstruct Tofile tf;\n\n\ttf.f = nil;\n\ttf.r = r;\n\tallwindows(allmatchfile, &tf);\n\n\tif(tf.f == nil)\n\t\tediterror(\"no file matches \\\"%S\\\"\", r->r);\n\treturn tf.f;\n}\n\nint\nfilematch(File *f, String *r)\n{\n\tchar *buf;\n\tRune *rbuf;\n\tWindow *w;\n\tint match, i, dirty;\n\tRangeset s;\n\n\t/* compile expr first so if we get an error, we haven't allocated anything */\n\tif(rxcompile(r->r) == FALSE)\n\t\tediterror(\"bad regexp in file match\");\n\tbuf = fbufalloc();\n\tw = f->curtext->w;\n\t/* same check for dirty as in settag, but we know ncache==0 */\n\tdirty = !w->isdir && !w->isscratch && f->mod;\n\tsnprint(buf, BUFSIZE, \"%c%c%c %.*S\\n\", \" '\"[dirty],\n\t\t'+', \" .\"[curtext!=nil && curtext->file==f], f->nname, f->name);\n\trbuf = bytetorune(buf, &i);\n\tfbuffree(buf);\n\tmatch = rxexecute(nil, rbuf, 0, i, &s);\n\tfree(rbuf);\n\treturn match;\n}\n\nAddress\ncharaddr(long l, Address addr, int sign)\n{\n\tif(sign == 0)\n\t\taddr.r.q0 = addr.r.q1 = l;\n\telse if(sign < 0)\n\t\taddr.r.q1 = addr.r.q0 -= l;\n\telse if(sign > 0)\n\t\taddr.r.q0 = addr.r.q1 += l;\n\tif(addr.r.q0<0 || addr.r.q1>addr.f->b.nc)\n\t\tediterror(\"address out of range\");\n\treturn addr;\n}\n\nAddress\nlineaddr(long l, Address addr, int sign)\n{\n\tint n;\n\tint c;\n\tFile *f = addr.f;\n\tAddress a;\n\tlong p;\n\n\ta.f = f;\n\tif(sign >= 0){\n\t\tif(l == 0){\n\t\t\tif(sign==0 || addr.r.q1==0){\n\t\t\t\ta.r.q0 = a.r.q1 = 0;\n\t\t\t\treturn a;\n\t\t\t}\n\t\t\ta.r.q0 = addr.r.q1;\n\t\t\tp = addr.r.q1-1;\n\t\t}else{\n\t\t\tif(sign==0 || addr.r.q1==0){\n\t\t\t\tp = 0;\n\t\t\t\tn = 1;\n\t\t\t}else{\n\t\t\t\tp = addr.r.q1-1;\n\t\t\t\tn = textreadc(f->curtext, p++)=='\\n';\n\t\t\t}\n\t\t\twhile(n < l){\n\t\t\t\tif(p >= f->b.nc)\n\t\t\t\t\tediterror(\"address out of range\");\n\t\t\t\tif(textreadc(f->curtext, p++) == '\\n')\n\t\t\t\t\tn++;\n\t\t\t}\n\t\t\ta.r.q0 = p;\n\t\t}\n\t\twhile(p < f->b.nc && textreadc(f->curtext, p++)!='\\n')\n\t\t\t;\n\t\ta.r.q1 = p;\n\t}else{\n\t\tp = addr.r.q0;\n\t\tif(l == 0)\n\t\t\ta.r.q1 = addr.r.q0;\n\t\telse{\n\t\t\tfor(n = 0; n<l; ){\t/* always runs once */\n\t\t\t\tif(p == 0){\n\t\t\t\t\tif(++n != l)\n\t\t\t\t\t\tediterror(\"address out of range\");\n\t\t\t\t}else{\n\t\t\t\t\tc = textreadc(f->curtext, p-1);\n\t\t\t\t\tif(c != '\\n' || ++n != l)\n\t\t\t\t\t\tp--;\n\t\t\t\t}\n\t\t\t}\n\t\t\ta.r.q1 = p;\n\t\t\tif(p > 0)\n\t\t\t\tp--;\n\t\t}\n\t\twhile(p > 0 && textreadc(f->curtext, p-1)!='\\n')\t/* lines start after a newline */\n\t\t\tp--;\n\t\ta.r.q0 = p;\n\t}\n\treturn a;\n}\n\nstruct Filecheck\n{\n\tFile\t*f;\n\tRune\t*r;\n\tint nr;\n};\n\nvoid\nallfilecheck(Window *w, void *v)\n{\n\tstruct Filecheck *fp;\n\tFile *f;\n\n\tfp = v;\n\tf = w->body.file;\n\tif(w->body.file == fp->f)\n\t\treturn;\n\tif(runeeq(fp->r, fp->nr, f->name, f->nname))\n\t\twarning(nil, \"warning: duplicate file name \\\"%.*S\\\"\\n\", fp->nr, fp->r);\n}\n\nRune*\ncmdname(File *f, String *str, int set)\n{\n\tRune *r, *s;\n\tint n;\n\tstruct Filecheck fc;\n\tRunestr newname;\n\n\tr = nil;\n\tn = str->n;\n\ts = str->r;\n\tif(n == 0){\n\t\t/* no name; use existing */\n\t\tif(f->nname == 0)\n\t\t\treturn nil;\n\t\tr = runemalloc(f->nname+1);\n\t\trunemove(r, f->name, f->nname);\n\t\treturn r;\n\t}\n\ts = skipbl(s, n, &n);\n\tif(n == 0)\n\t\tgoto Return;\n\n\tif(s[0] == '/'){\n\t\tr = runemalloc(n+1);\n\t\trunemove(r, s, n);\n\t}else{\n\t\tnewname = dirname(f->curtext, runestrdup(s), n);\n\t\tn = newname.nr;\n\t\tr = runemalloc(n+1);\t/* NUL terminate */\n\t\trunemove(r, newname.r, n);\n\t\tfree(newname.r);\n\t}\n\tfc.f = f;\n\tfc.r = r;\n\tfc.nr = n;\n\tallwindows(allfilecheck, &fc);\n\tif(f->nname == 0)\n\t\tset = TRUE;\n\n    Return:\n\tif(set && !runeeq(r, n, f->name, f->nname)){\n\t\tfilemark(f);\n\t\tf->mod = TRUE;\n\t\tf->curtext->w->dirty = TRUE;\n\t\twinsetname(f->curtext->w, r, n);\n\t}\n\treturn r;\n}\n", "source": "acme2k/src/cmd/acme/ecmd.c", "file_type": "c"}
{"text": "#include <u.h>\n#include <libc.h>\n#include <bio.h>\n#include <draw.h>\n#include <thread.h>\n#include <cursor.h>\n#include <mouse.h>\n#include <keyboard.h>\n#include <frame.h>\n#include <fcall.h>\n#include <plumb.h>\n#include <libsec.h>\n#include <9pclient.h>\n#include \"dat.h\"\n#include \"fns.h\"\n\nBuffer\tsnarfbuf;\n\n/*\n * These functions get called as:\n *\n *\tfn(et, t, argt, flag1, flag1, flag2, s, n);\n *\n * Where the arguments are:\n *\n *\tet: the Text* in which the executing event (click) occurred\n *\tt: the Text* containing the current selection (Edit, Cut, Snarf, Paste)\n *\targt: the Text* containing the argument for a 2-1 click.\n *\te->flag1: from Exectab entry\n * \te->flag2: from Exectab entry\n *\ts: the command line remainder (e.g., \"x\" if executing \"Dump x\")\n *\tn: length of s  (s is *not* NUL-terminated)\n */\n\nvoid doabort(Text*, Text*, Text*, int, int, Rune*, int);\nvoid\tdel(Text*, Text*, Text*, int, int, Rune*, int);\nvoid\tdelcol(Text*, Text*, Text*, int, int, Rune*, int);\nvoid\tdotfiles(Text*, Text*, Text*, int, int, Rune*, int);\nvoid\tdump(Text*, Text*, Text*, int, int, Rune*, int);\nvoid\tedit(Text*, Text*, Text*, int, int, Rune*, int);\nvoid\txexit(Text*, Text*, Text*, int, int, Rune*, int);\nvoid\tfontx(Text*, Text*, Text*, int, int, Rune*, int);\nvoid\tget(Text*, Text*, Text*, int, int, Rune*, int);\nvoid\tid(Text*, Text*, Text*, int, int, Rune*, int);\nvoid\tincl(Text*, Text*, Text*, int, int, Rune*, int);\nvoid\tindent(Text*, Text*, Text*, int, int, Rune*, int);\nvoid\txkill(Text*, Text*, Text*, int, int, Rune*, int);\nvoid\tlocal(Text*, Text*, Text*, int, int, Rune*, int);\nvoid\tlook(Text*, Text*, Text*, int, int, Rune*, int);\nvoid\tnewcol(Text*, Text*, Text*, int, int, Rune*, int);\nvoid\tpaste(Text*, Text*, Text*, int, int, Rune*, int);\nvoid\tput(Text*, Text*, Text*, int, int, Rune*, int);\nvoid\tputall(Text*, Text*, Text*, int, int, Rune*, int);\nvoid\tsendx(Text*, Text*, Text*, int, int, Rune*, int);\nvoid\tsort(Text*, Text*, Text*, int, int, Rune*, int);\nvoid\ttab(Text*, Text*, Text*, int, int, Rune*, int);\nvoid\tzeroxx(Text*, Text*, Text*, int, int, Rune*, int);\n\ntypedef struct Exectab Exectab;\nstruct Exectab\n{\n\tRune\t*name;\n\tvoid\t(*fn)(Text*, Text*, Text*, int, int, Rune*, int);\n\tint\t\tmark;\n\tint\t\tflag1;\n\tint\t\tflag2;\n};\n\nstatic Rune LAbort[] = { 'A', 'b', 'o', 'r', 't', 0 };\nstatic Rune LCut[] = { 'C', 'u', 't', 0 };\nstatic Rune LDel[] = { 'D', 'e', 'l', 0 };\nstatic Rune LDelcol[] = { 'D', 'e', 'l', 'c', 'o', 'l', 0 };\nstatic Rune LDelete[] = { 'D', 'e', 'l', 'e', 't', 'e', 0 };\nstatic Rune LDump[] = { 'D', 'u', 'm', 'p', 0 };\nstatic Rune LEdit[] = { 'E', 'd', 'i', 't', 0 };\nstatic Rune LExit[] = { 'E', 'x', 'i', 't', 0 };\nstatic Rune LFont[] = { 'F', 'o', 'n', 't', 0 };\nstatic Rune LGet[] = { 'G', 'e', 't', 0 };\nstatic Rune LID[] = { 'I', 'D', 0 };\nstatic Rune LIncl[] = { 'I', 'n', 'c', 'l', 0 };\nstatic Rune LIndent[] = { 'I', 'n', 'd', 'e', 'n', 't', 0 };\nstatic Rune LKill[] = { 'K', 'i', 'l', 'l', 0 };\nstatic Rune LLoad[] = { 'L', 'o', 'a', 'd', 0 };\nstatic Rune LLocal[] = { 'L', 'o', 'c', 'a', 'l', 0 };\nstatic Rune LLook[] = { 'L', 'o', 'o', 'k', 0 };\nstatic Rune LNew[] = { 'N', 'e', 'w', 0 };\nstatic Rune LNewcol[] = { 'N', 'e', 'w', 'c', 'o', 'l', 0 };\nstatic Rune LPaste[] = { 'P', 'a', 's', 't', 'e', 0 };\nstatic Rune LPut[] = { 'P', 'u', 't', 0 };\nstatic Rune LPutall[] = { 'P', 'u', 't', 'a', 'l', 'l', 0 };\nstatic Rune LRedo[] = { 'R', 'e', 'd', 'o', 0 };\nstatic Rune LSend[] = { 'S', 'e', 'n', 'd', 0 };\nstatic Rune LSnarf[] = { 'S', 'n', 'a', 'r', 'f', 0 };\nstatic Rune LSort[] = { 'S', 'o', 'r', 't', 0 };\nstatic Rune LTab[] = { 'T', 'a', 'b', 0 };\nstatic Rune LUndo[] = { 'U', 'n', 'd', 'o', 0 };\nstatic Rune LZerox[] = { 'Z', 'e', 'r', 'o', 'x', 0 };\n\nExectab exectab[] = {\n\t{ LAbort,\t\tdoabort,\tFALSE,\tXXX,\t\tXXX,\t\t},\n\t{ LCut,\t\tcut,\t\tTRUE,\tTRUE,\tTRUE\t},\n\t{ LDel,\t\tdel,\t\tFALSE,\tFALSE,\tXXX\t\t},\n\t{ LDelcol,\t\tdelcol,\tFALSE,\tXXX,\t\tXXX\t\t},\n\t{ LDelete,\t\tdel,\t\tFALSE,\tTRUE,\tXXX\t\t},\n\t{ LDump,\t\tdump,\tFALSE,\tTRUE,\tXXX\t\t},\n\t{ LEdit,\t\tedit,\t\tFALSE,\tXXX,\t\tXXX\t\t},\n\t{ LExit,\t\txexit,\tFALSE,\tXXX,\t\tXXX\t\t},\n\t{ LFont,\t\tfontx,\tFALSE,\tXXX,\t\tXXX\t\t},\n\t{ LGet,\t\tget,\t\tFALSE,\tTRUE,\tXXX\t\t},\n\t{ LID,\t\tid,\t\tFALSE,\tXXX,\t\tXXX\t\t},\n\t{ LIncl,\t\tincl,\t\tFALSE,\tXXX,\t\tXXX\t\t},\n\t{ LIndent,\t\tindent,\tFALSE,\tXXX,\t\tXXX\t\t},\n\t{ LKill,\t\txkill,\t\tFALSE,\tXXX,\t\tXXX\t\t},\n\t{ LLoad,\t\tdump,\tFALSE,\tFALSE,\tXXX\t\t},\n\t{ LLocal,\t\tlocal,\tFALSE,\tXXX,\t\tXXX\t\t},\n\t{ LLook,\t\tlook,\t\tFALSE,\tXXX,\t\tXXX\t\t},\n\t{ LNew,\t\tnew,\t\tFALSE,\tXXX,\t\tXXX\t\t},\n\t{ LNewcol,\tnewcol,\tFALSE,\tXXX,\t\tXXX\t\t},\n\t{ LPaste,\t\tpaste,\tTRUE,\tTRUE,\tXXX\t\t},\n\t{ LPut,\t\tput,\t\tFALSE,\tXXX,\t\tXXX\t\t},\n\t{ LPutall,\t\tputall,\tFALSE,\tXXX,\t\tXXX\t\t},\n\t{ LRedo,\t\tundo,\tFALSE,\tFALSE,\tXXX\t\t},\n\t{ LSend,\t\tsendx,\tTRUE,\tXXX,\t\tXXX\t\t},\n\t{ LSnarf,\t\tcut,\t\tFALSE,\tTRUE,\tFALSE\t},\n\t{ LSort,\t\tsort,\t\tFALSE,\tXXX,\t\tXXX\t\t},\n\t{ LTab,\t\ttab,\t\tFALSE,\tXXX,\t\tXXX\t\t},\n\t{ LUndo,\t\tundo,\tFALSE,\tTRUE,\tXXX\t\t},\n\t{ LZerox,\t\tzeroxx,\tFALSE,\tXXX,\t\tXXX\t\t},\n\t{ nil, \t\t\t0,\t\t0,\t\t0,\t\t0\t\t}\n};\n\nExectab*\nlookup(Rune *r, int n)\n{\n\tExectab *e;\n\tint nr;\n\n\tr = skipbl(r, n, &n);\n\tif(n == 0)\n\t\treturn nil;\n\tfindbl(r, n, &nr);\n\tnr = n-nr;\n\tfor(e=exectab; e->name; e++)\n\t\tif(runeeq(r, nr, e->name, runestrlen(e->name)) == TRUE)\n\t\t\treturn e;\n\treturn nil;\n}\n\nint\nisexecc(int c)\n{\n\tif(isfilec(c))\n\t\treturn 1;\n\treturn c=='<' || c=='|' || c=='>';\n}\n\nvoid\nexecute(Text *t, uint aq0, uint aq1, int external, Text *argt)\n{\n\tuint q0, q1;\n\tRune *r, *s;\n\tchar *b, *a, *aa;\n\tExectab *e;\n\tint c, n, f;\n\tRunestr dir;\n\n\tq0 = aq0;\n\tq1 = aq1;\n\tif(q1 == q0){\t/* expand to find word (actually file name) */\n\t\t/* if in selection, choose selection */\n\t\tif(t->q1>t->q0 && t->q0<=q0 && q0<=t->q1){\n\t\t\tq0 = t->q0;\n\t\t\tq1 = t->q1;\n\t\t}else{\n\t\t\twhile(q1<t->file->b.nc && isexecc(c=textreadc(t, q1)) && c!=':')\n\t\t\t\tq1++;\n\t\t\twhile(q0>0 && isexecc(c=textreadc(t, q0-1)) && c!=':')\n\t\t\t\tq0--;\n\t\t\tif(q1 == q0)\n\t\t\t\treturn;\n\t\t}\n\t}\n\tr = runemalloc(q1-q0);\n\tbufread(&t->file->b, q0, r, q1-q0);\n\te = lookup(r, q1-q0);\n\tif(!external && t->w!=nil && t->w->nopen[QWevent]>0){\n\t\tf = 0;\n\t\tif(e)\n\t\t\tf |= 1;\n\t\tif(q0!=aq0 || q1!=aq1){\n\t\t\tbufread(&t->file->b, aq0, r, aq1-aq0);\n\t\t\tf |= 2;\n\t\t}\n\t\taa = getbytearg(argt, TRUE, TRUE, &a);\n\t\tif(a){\t\n\t\t\tif(strlen(a) > EVENTSIZE){\t/* too big; too bad */\n\t\t\t\tfree(aa);\n\t\t\t\tfree(a);\n\t\t\t\twarning(nil, \"argument string too long\\n\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tf |= 8;\n\t\t}\n\t\tc = 'x';\n\t\tif(t->what == Body)\n\t\t\tc = 'X';\n\t\tn = aq1-aq0;\n\t\tif(n <= EVENTSIZE)\n\t\t\twinevent(t->w, \"%c%d %d %d %d %.*S\\n\", c, aq0, aq1, f, n, n, r);\n\t\telse\n\t\t\twinevent(t->w, \"%c%d %d %d 0 \\n\", c, aq0, aq1, f, n);\n\t\tif(q0!=aq0 || q1!=aq1){\n\t\t\tn = q1-q0;\n\t\t\tbufread(&t->file->b, q0, r, n);\n\t\t\tif(n <= EVENTSIZE)\n\t\t\t\twinevent(t->w, \"%c%d %d 0 %d %.*S\\n\", c, q0, q1, n, n, r);\n\t\t\telse\n\t\t\t\twinevent(t->w, \"%c%d %d 0 0 \\n\", c, q0, q1, n);\n\t\t}\n\t\tif(a){\n\t\t\twinevent(t->w, \"%c0 0 0 %d %s\\n\", c, utflen(a), a);\n\t\t\tif(aa)\n\t\t\t\twinevent(t->w, \"%c0 0 0 %d %s\\n\", c, utflen(aa), aa);\n\t\t\telse\n\t\t\t\twinevent(t->w, \"%c0 0 0 0 \\n\", c);\n\t\t}\n\t\tfree(r);\n\t\tfree(aa);\n\t\tfree(a);\n\t\treturn;\n\t}\n\tif(e){\n\t\tif(e->mark && seltext!=nil)\n\t\tif(seltext->what == Body){\n\t\t\tseq++;\n\t\t\tfilemark(seltext->w->body.file);\n\t\t}\n\t\ts = skipbl(r, q1-q0, &n);\n\t\ts = findbl(s, n, &n);\n\t\ts = skipbl(s, n, &n);\n\t\t(*e->fn)(t, seltext, argt, e->flag1, e->flag2, s, n);\n\t\tfree(r);\n\t\treturn;\n\t}\n\n\tb = runetobyte(r, q1-q0);\n\tfree(r);\n\tdir = dirname(t, nil, 0);\n\tif(dir.nr==1 && dir.r[0]=='.'){\t/* sigh */\n\t\tfree(dir.r);\n\t\tdir.r = nil;\n\t\tdir.nr = 0;\n\t}\n\taa = getbytearg(argt, TRUE, TRUE, &a);\n\tif(t->w)\n\t\tincref(&t->w->ref);\n\trun(t->w, b, dir.r, dir.nr, TRUE, aa, a, FALSE);\n}\n\nchar*\nprintarg(Text *argt, uint q0, uint q1)\n{\n\tchar *buf;\n\n\tif(argt->what!=Body || argt->file->name==nil)\n\t\treturn nil;\n\tbuf = emalloc(argt->file->nname+32);\n\tif(q0 == q1)\n\t\tsprint(buf, \"%.*S:#%d\", argt->file->nname, argt->file->name, q0);\n\telse\n\t\tsprint(buf, \"%.*S:#%d,#%d\", argt->file->nname, argt->file->name, q0, q1);\n\treturn buf;\n}\n\nchar*\ngetarg(Text *argt, int doaddr, int dofile, Rune **rp, int *nrp)\n{\n\tint n;\n\tExpand e;\n\tchar *a;\n\n\t*rp = nil;\n\t*nrp = 0;\n\tif(argt == nil)\n\t\treturn nil;\n\ta = nil;\n\ttextcommit(argt, TRUE);\n\tif(expand(argt, argt->q0, argt->q1, &e)){\n\t\tfree(e.bname);\n\t\tif(e.nname && dofile){\n\t\t\te.name = runerealloc(e.name, e.nname+1);\n\t\t\tif(doaddr)\n\t\t\t\ta = printarg(argt, e.q0, e.q1);\n\t\t\t*rp = e.name;\n\t\t\t*nrp = e.nname;\n\t\t\treturn a;\n\t\t}\n\t\tfree(e.name);\n\t}else{\n\t\te.q0 = argt->q0;\n\t\te.q1 = argt->q1;\n\t}\n\tn = e.q1 - e.q0;\n\t*rp = runemalloc(n+1);\n\tbufread(&argt->file->b, e.q0, *rp, n);\n\tif(doaddr)\n\t\ta = printarg(argt, e.q0, e.q1);\n\t*nrp = n;\n\treturn a;\n}\n\nchar*\ngetbytearg(Text *argt, int doaddr, int dofile, char **bp)\n{\n\tRune *r;\n\tint n;\n\tchar *aa;\n\n\t*bp = nil;\n\taa = getarg(argt, doaddr, dofile, &r, &n);\n\tif(r == nil)\n\t\treturn nil;\n\t*bp = runetobyte(r, n);\n\tfree(r);\n\treturn aa;\n}\n\nvoid\ndoabort(Text *__0, Text *_0, Text *_1, int _2, int _3, Rune *_4, int _5)\n{\n\tstatic int n;\n\n\tUSED(__0);\n\tUSED(_0);\n\tUSED(_1);\n\tUSED(_2);\n\tUSED(_3);\n\tUSED(_4);\n\tUSED(_5);\n\n\tif(n++ == 0)\n\t\twarning(nil, \"executing Abort again will call abort()\\n\");\n\telse\n\t\tabort();\n}\n\nvoid\nnewcol(Text *et, Text *_0, Text *_1, int _2, int _3, Rune *_4, int _5)\n{\n\tColumn *c;\n\tWindow *w;\n\n\tUSED(_0);\n\tUSED(_1);\n\tUSED(_2);\n\tUSED(_3);\n\tUSED(_4);\n\tUSED(_5);\n\n\tc = rowadd(et->row, nil, -1);\n\tif(c) {\n\t\tw = coladd(c, nil, nil, -1);\n\t\twinsettag(w);\n\t\txfidlog(w, \"new\");\n\t}\n}\n\nvoid\ndelcol(Text *et, Text *_0, Text *_1, int _2, int _3, Rune *_4, int _5)\n{\n\tint i;\n\tColumn *c;\n\tWindow *w;\n\n\tUSED(_0);\n\tUSED(_1);\n\tUSED(_2);\n\tUSED(_3);\n\tUSED(_4);\n\tUSED(_5);\n\n\tc = et->col;\n\tif(c==nil || colclean(c)==0)\n\t\treturn;\n\tfor(i=0; i<c->nw; i++){\n\t\tw = c->w[i];\n\t\tif(w->nopen[QWevent]+w->nopen[QWaddr]+w->nopen[QWdata]+w->nopen[QWxdata] > 0){\n\t\t\twarning(nil, \"can't delete column; %.*S is running an external command\\n\", w->body.file->nname, w->body.file->name);\n\t\t\treturn;\n\t\t}\n\t}\n\trowclose(et->col->row, et->col, TRUE);\n}\n\nvoid\ndel(Text *et, Text *_0, Text *_1, int flag1, int _2, Rune *_3, int _4)\n{\n\tUSED(_0);\n\tUSED(_1);\n\tUSED(_2);\n\tUSED(_3);\n\tUSED(_4);\n\n\tif(et->col==nil || et->w == nil)\n\t\treturn;\n\tif(flag1 || et->w->body.file->ntext>1 || winclean(et->w, FALSE))\n\t\tcolclose(et->col, et->w, TRUE);\n}\n\nvoid\nsort(Text *et, Text *_0, Text *_1, int _2, int _3, Rune *_4, int _5)\n{\n\tUSED(_0);\n\tUSED(_1);\n\tUSED(_2);\n\tUSED(_3);\n\tUSED(_4);\n\tUSED(_5);\n\n\tif(et->col)\n\t\tcolsort(et->col);\n}\n\nuint\nseqof(Window *w, int isundo)\n{\n\t/* if it's undo, see who changed with us */\n\tif(isundo)\n\t\treturn w->body.file->seq;\n\t/* if it's redo, see who we'll be sync'ed up with */\n\treturn fileredoseq(w->body.file);\n}\n\nvoid\nundo(Text *et, Text *_0, Text *_1, int flag1, int _2, Rune *_3, int _4)\n{\n\tint i, j;\n\tColumn *c;\n\tWindow *w;\n\tuint seq;\n\n\tUSED(_0);\n\tUSED(_1);\n\tUSED(_2);\n\tUSED(_3);\n\tUSED(_4);\n\n\tif(et==nil || et->w== nil)\n\t\treturn;\n\tseq = seqof(et->w, flag1);\n\tif(seq == 0){\n\t\t/* nothing to undo */\n\t\treturn;\n\t}\n\t/*\n\t * Undo the executing window first. Its display will update. other windows\n\t * in the same file will not call show() and jump to a different location in the file.\n\t * Simultaneous changes to other files will be chaotic, however.\n\t */\n\twinundo(et->w, flag1);\n\tfor(i=0; i<row.ncol; i++){\n\t\tc = row.col[i];\n\t\tfor(j=0; j<c->nw; j++){\n\t\t\tw = c->w[j];\n\t\t\tif(w == et->w)\n\t\t\t\tcontinue;\n\t\t\tif(seqof(w, flag1) == seq)\n\t\t\t\twinundo(w, flag1);\n\t\t}\n\t}\n}\n\nchar*\ngetname(Text *t, Text *argt, Rune *arg, int narg, int isput)\n{\n\tchar *s;\n\tRune *r;\n\tint i, n, promote;\n\tRunestr dir;\n\n\tgetarg(argt, FALSE, TRUE, &r, &n);\n\tpromote = FALSE;\n\tif(r == nil)\n\t\tpromote = TRUE;\n\telse if(isput){\n\t\t/* if are doing a Put, want to synthesize name even for non-existent file */\n\t\t/* best guess is that file name doesn't contain a slash */\n\t\tpromote = TRUE;\n\t\tfor(i=0; i<n; i++)\n\t\t\tif(r[i] == '/'){\n\t\t\t\tpromote = FALSE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif(promote){\n\t\t\tt = argt;\n\t\t\targ = r;\n\t\t\tnarg = n;\n\t\t}\n\t}\n\tif(promote){\n\t\tn = narg;\n\t\tif(n <= 0){\n\t\t\ts = runetobyte(t->file->name, t->file->nname);\n\t\t\treturn s;\n\t\t}\n\t\t/* prefix with directory name if necessary */\n\t\tdir.r = nil;\n\t\tdir.nr = 0;\n\t\tif(n>0 && arg[0]!='/'){\n\t\t\tdir = dirname(t, nil, 0);\n\t\t\tif(dir.nr==1 && dir.r[0]=='.'){\t/* sigh */\n\t\t\t\tfree(dir.r);\n\t\t\t\tdir.r = nil;\n\t\t\t\tdir.nr = 0;\n\t\t\t}\n\t\t}\n\t\tif(dir.r){\n\t\t\tr = runemalloc(dir.nr+n+1);\n\t\t\trunemove(r, dir.r, dir.nr);\n\t\t\tfree(dir.r);\n\t\t\tif(dir.nr>0 && r[dir.nr]!='/' && n>0 && arg[0]!='/')\n\t\t\t\tr[dir.nr++] = '/';\n\t\t\trunemove(r+dir.nr, arg, n);\n\t\t\tn += dir.nr;\n\t\t}else{\n\t\t\tr = runemalloc(n+1);\n\t\t\trunemove(r, arg, n);\n\t\t}\n\t}\n\ts = runetobyte(r, n);\n\tfree(r);\n\tif(strlen(s) == 0){\n\t\tfree(s);\n\t\ts = nil;\n\t}\n\treturn s;\n}\n\nvoid\nzeroxx(Text *et, Text *t, Text *_1, int _2, int _3, Rune *_4, int _5)\n{\n\tWindow *nw;\n\tint c, locked;\n\n\tUSED(_1);\n\tUSED(_2);\n\tUSED(_3);\n\tUSED(_4);\n\tUSED(_5);\n\n\tlocked = FALSE;\n\tif(t!=nil && t->w!=nil && t->w!=et->w){\n\t\tlocked = TRUE;\n\t\tc = 'M';\n\t\tif(et->w)\n\t\t\tc = et->w->owner;\n\t\twinlock(t->w, c);\n\t}\n\tif(t == nil)\n\t\tt = et;\n\tif(t==nil || t->w==nil)\n\t\treturn;\n\tt = &t->w->body;\n\tif(t->w->isdir)\n\t\twarning(nil, \"%.*S is a directory; Zerox illegal\\n\", t->file->nname, t->file->name);\n\telse{\n\t\tnw = coladd(t->w->col, nil, t->w, -1);\n\t\t/* ugly: fix locks so w->unlock works */\n\t\twinlock1(nw, t->w->owner);\n\t\txfidlog(nw, \"zerox\");\n\t}\n\tif(locked)\n\t\twinunlock(t->w);\n}\n\ntypedef struct TextAddr TextAddr;\nstruct TextAddr {\n\tlong lorigin; // line+rune for origin\n\tlong rorigin;\n\tlong lq0; // line+rune for q0\n\tlong rq0;\n\tlong lq1; // line+rune for q1\n\tlong rq1;\n};\n\nvoid\nget(Text *et, Text *t, Text *argt, int flag1, int _0, Rune *arg, int narg)\n{\n\tchar *name;\n\tRune *r;\n\tint i, n, dirty, samename, isdir;\n\tTextAddr *addr, *a;\n\tWindow *w;\n\tText *u;\n\tDir *d;\n\tlong q0, q1;\n\n\tUSED(_0);\n\n\tif(flag1)\n\t\tif(et==nil || et->w==nil)\n\t\t\treturn;\n\tif(!et->w->isdir && (et->w->body.file->b.nc>0 && !winclean(et->w, TRUE)))\n\t\treturn;\n\tw = et->w;\n\tt = &w->body;\n\tname = getname(t, argt, arg, narg, FALSE);\n\tif(name == nil){\n\t\twarning(nil, \"no file name\\n\");\n\t\treturn;\n\t}\n\tif(t->file->ntext>1){\n\t\td = dirstat(name);\n\t\tisdir = (d!=nil && (d->qid.type & QTDIR));\n\t\tfree(d);\n\t\tif(isdir){\n\t\t\twarning(nil, \"%s is a directory; can't read with multiple windows on it\\n\", name);\n\t\t\treturn;\n\t\t}\n\t}\n\taddr = emalloc((t->file->ntext)*sizeof(TextAddr));\n\tfor(i=0; i<t->file->ntext; i++) {\n\t\ta = &addr[i];\n\t\tu = t->file->text[i];\n\t\ta->lorigin = nlcount(u, 0, u->org, &a->rorigin);\n\t\ta->lq0 = nlcount(u, 0, u->q0, &a->rq0);\n\t\ta->lq1 = nlcount(u, u->q0, u->q1, &a->rq1);\n\t}\n\tr = bytetorune(name, &n);\n\tfor(i=0; i<t->file->ntext; i++){\n\t\tu = t->file->text[i];\n\t\t/* second and subsequent calls with zero an already empty buffer, but OK */\n\t\ttextreset(u);\n\t\twindirfree(u->w);\n\t}\n\tsamename = runeeq(r, n, t->file->name, t->file->nname);\n\ttextload(t, 0, name, samename);\n\tif(samename){\n\t\tt->file->mod = FALSE;\n\t\tdirty = FALSE;\n\t}else{\n\t\tt->file->mod = TRUE;\n\t\tdirty = TRUE;\n\t}\n\tfor(i=0; i<t->file->ntext; i++)\n\t\tt->file->text[i]->w->dirty = dirty;\n\tfree(name);\n\tfree(r);\n\twinsettag(w);\n\tt->file->unread = FALSE;\n\tfor(i=0; i<t->file->ntext; i++){\n\t\tu = t->file->text[i];\n\t\ttextsetselect(&u->w->tag, u->w->tag.file->b.nc, u->w->tag.file->b.nc);\n\t\tif(samename) {\n\t\t\ta = &addr[i];\n\t\t\t// warning(nil, \"%d %d %d %d %d %d\\n\", a->lorigin, a->rorigin, a->lq0, a->rq0, a->lq1, a->rq1);\n\t\t\tq0 = nlcounttopos(u, 0, a->lq0, a->rq0);\n\t\t\tq1 = nlcounttopos(u, q0, a->lq1, a->rq1);\n\t\t\ttextsetselect(u, q0, q1);\n\t\t\tq0 = nlcounttopos(u, 0, a->lorigin, a->rorigin);\n\t\t\ttextsetorigin(u, q0, FALSE);\n\t\t}\n\t\ttextscrdraw(u);\n\t}\n\tfree(addr);\n\txfidlog(w, \"get\");\n}\n\nstatic void\nchecksha1(char *name, File *f, Dir *d)\n{\n\tint fd, n;\n\tDigestState *h;\n\tuchar out[20];\n\tuchar *buf;\n\t\n\tfd = open(name, OREAD);\n\tif(fd < 0)\n\t\treturn;\n\th = sha1(nil, 0, nil, nil);\n\tbuf = emalloc(8192);\n\twhile((n = read(fd, buf, 8192)) > 0)\n\t\tsha1(buf, n, nil, h);\n\tfree(buf);\n\tclose(fd);\n\tsha1(nil, 0, out, h);\n\tif(memcmp(out, f->sha1, sizeof out) == 0) {\n\t\tf->dev = d->dev;\n\t\tf->qidpath = d->qid.path;\n\t\tf->mtime = d->mtime;\n\t}\n}\t\n\nvoid\nputfile(File *f, int q0, int q1, Rune *namer, int nname)\n{\n\tuint n, m;\n\tRune *r;\n\tBiobuf *b;\n\tchar *s, *name;\n\tint i, fd, q;\n\tDir *d, *d1;\n\tWindow *w;\n\tint isapp;\n\tDigestState *h;\n\n\tw = f->curtext->w;\n\tname = runetobyte(namer, nname);\n\td = dirstat(name);\n\tif(d!=nil && runeeq(namer, nname, f->name, f->nname)){\n\t\tif(f->dev!=d->dev || f->qidpath!=d->qid.path || f->mtime != d->mtime)\n\t\t\tchecksha1(name, f, d);\n\t\tif(f->dev!=d->dev || f->qidpath!=d->qid.path || f->mtime != d->mtime) {\n\t\t\tif(f->unread)\n\t\t\t\twarning(nil, \"%s not written; file already exists\\n\", name);\n\t\t\telse\n\t\t\t\twarning(nil, \"%s modified%s%s since last read\\n\\twas %t; now %t\\n\", name, d->muid[0]?\" by \":\"\", d->muid, f->mtime, d->mtime);\n\t\t\tf->dev = d->dev;\n\t\t\tf->qidpath = d->qid.path;\n\t\t\tf->mtime = d->mtime;\n\t\t\tgoto Rescue1;\n\t\t}\n\t}\n\tfd = create(name, OWRITE, 0666);\n\tif(fd < 0){\n\t\twarning(nil, \"can't create file %s: %r\\n\", name);\n\t\tgoto Rescue1;\n\t}\n\t// Use bio in order to force the writes to be large and\n\t// block-aligned (bio's default is 8K). This is not strictly\n\t// necessary; it works around some buggy underlying\n\t// file systems that mishandle unaligned writes.\n\t// https://codereview.appspot.com/89550043/\n\tb = emalloc(sizeof *b);\n\tBinit(b, fd, OWRITE);\n\tr = fbufalloc();\n\ts = fbufalloc();\n\tfree(d);\n\td = dirfstat(fd);\n\th = sha1(nil, 0, nil, nil);\n\tisapp = (d!=nil && d->length>0 && (d->qid.type&QTAPPEND));\n\tif(isapp){\n\t\twarning(nil, \"%s not written; file is append only\\n\", name);\n\t\tgoto Rescue2;\n\t}\n\n\tfor(q=q0; q<q1; q+=n){\n\t\tn = q1 - q;\n\t\tif(n > BUFSIZE/UTFmax)\n\t\t\tn = BUFSIZE/UTFmax;\n\t\tbufread(&f->b, q, r, n);\n\t\tm = snprint(s, BUFSIZE+1, \"%.*S\", n, r);\n\t\tsha1((uchar*)s, m, nil, h);\n\t\tif(Bwrite(b, s, m) != m){\n\t\t\twarning(nil, \"can't write file %s: %r\\n\", name);\n\t\t\tgoto Rescue2;\n\t\t}\n\t}\n\tif(Bflush(b) < 0) {\n\t\twarning(nil, \"can't write file %s: %r\\n\", name);\n\t\tgoto Rescue2;\n\t}\n\tBterm(b);\n\tfree(b);\n\tb = nil;\n\tif(runeeq(namer, nname, f->name, f->nname)){\n\t\tif(q0!=0 || q1!=f->b.nc){\n\t\t\tf->mod = TRUE;\n\t\t\tw->dirty = TRUE;\n\t\t\tf->unread = TRUE;\n\t\t}else{\n\t\t\t// In case the file is on NFS, reopen the fd\n\t\t\t// before dirfstat to cause the attribute cache\n\t\t\t// to be updated (otherwise the mtime in the\n\t\t\t// dirfstat below will be stale and not match\n\t\t\t// what NFS sees).  The file is already written,\n\t\t\t// so this should be a no-op when not on NFS.\n\t\t\t// Opening for OWRITE (but no truncation)\n\t\t\t// in case we don't have read permission.\n\t\t\t// (The create above worked, so we probably\n\t\t\t// still have write permission.)\n\t\t\tclose(fd);\n\t\t\tfd = open(name, OWRITE);\n\n\t\t\td1 = dirfstat(fd);\n\t\t\tif(d1 != nil){\n\t\t\t\tfree(d);\n\t\t\t\td = d1;\n\t\t\t}\n\t\t\tf->qidpath = d->qid.path;\n\t\t\tf->dev = d->dev;\n\t\t\tf->mtime = d->mtime;\n\t\t\tsha1(nil, 0, f->sha1, h);\n\t\t\th = nil;\n\t\t\tf->mod = FALSE;\n\t\t\tw->dirty = FALSE;\n\t\t\tf->unread = FALSE;\n\t\t}\n\t\tfor(i=0; i<f->ntext; i++){\n\t\t\tf->text[i]->w->putseq = f->seq;\n\t\t\tf->text[i]->w->dirty = w->dirty;\n\t\t}\n\t}\n\tfbuffree(s);\n\tfbuffree(r);\n\tfree(h);\n\tfree(d);\n\tfree(namer);\n\tfree(name);\n\tclose(fd);\n\twinsettag(w);\n\treturn;\n\n    Rescue2:\n\tif(b != nil) {\n\t\tBterm(b);\n\t\tfree(b);\n\t}\n\tfree(h);\n\tfbuffree(s);\n\tfbuffree(r);\n\tclose(fd);\n\t/* fall through */\n\n    Rescue1:\n\tfree(d);\n\tfree(namer);\n\tfree(name);\n}\n\nvoid\nput(Text *et, Text *_0, Text *argt, int _1, int _2, Rune *arg, int narg)\n{\n\tint nname;\n\tRune  *namer;\n\tWindow *w;\n\tFile *f;\n\tchar *name;\n\n\tUSED(_0);\n\tUSED(_1);\n\tUSED(_2);\n\n\tif(et==nil || et->w==nil || et->w->isdir)\n\t\treturn;\n\tw = et->w;\n\tf = w->body.file;\n\tname = getname(&w->body, argt, arg, narg, TRUE);\n\tif(name == nil){\n\t\twarning(nil, \"no file name\\n\");\n\t\treturn;\n\t}\n\tnamer = bytetorune(name, &nname);\n\tputfile(f, 0, f->b.nc, namer, nname);\n\txfidlog(w, \"put\");\n\tfree(name);\n}\n\nvoid\ndump(Text *_0, Text *_1, Text *argt, int isdump, int _2, Rune *arg, int narg)\n{\n\tchar *name;\n\n\tUSED(_0);\n\tUSED(_1);\n\tUSED(_2);\n\n\tif(narg)\n\t\tname = runetobyte(arg, narg);\n\telse\n\t\tgetbytearg(argt, FALSE, TRUE, &name);\n\tif(isdump)\n\t\trowdump(&row, name);\n\telse\n\t\trowload(&row, name, FALSE);\n\tfree(name);\n}\n\nvoid\ncut(Text *et, Text *t, Text *_0, int dosnarf, int docut, Rune *_2, int _3)\n{\n\tuint q0, q1, n, locked, c;\n\tRune *r;\n\n\tUSED(_0);\n\tUSED(_2);\n\tUSED(_3);\n\n\t/*\n\t * if not executing a mouse chord (et != t) and snarfing (dosnarf)\n\t * and executed Cut or Snarf in window tag (et->w != nil),\n\t * then use the window body selection or the tag selection\n\t * or do nothing at all.\n\t */\n\tif(et!=t && dosnarf && et->w!=nil){\n\t\tif(et->w->body.q1>et->w->body.q0){\n\t\t\tt = &et->w->body;\n\t\t\tif(docut)\n\t\t\t\tfilemark(t->file);\t/* seq has been incremented by execute */\n\t\t}else if(et->w->tag.q1>et->w->tag.q0)\n\t\t\tt = &et->w->tag;\n\t\telse\n\t\t\tt = nil;\n\t}\n\tif(t == nil)\t/* no selection */\n\t\treturn;\n\n\tlocked = FALSE;\n\tif(t->w!=nil && et->w!=t->w){\n\t\tlocked = TRUE;\n\t\tc = 'M';\n\t\tif(et->w)\n\t\t\tc = et->w->owner;\n\t\twinlock(t->w, c);\n\t}\n\tif(t->q0 == t->q1){\n\t\tif(locked)\n\t\t\twinunlock(t->w);\n\t\treturn;\n\t}\n\tif(dosnarf){\n\t\tq0 = t->q0;\n\t\tq1 = t->q1;\n\t\tbufdelete(&snarfbuf, 0, snarfbuf.nc);\n\t\tr = fbufalloc();\n\t\twhile(q0 < q1){\n\t\t\tn = q1 - q0;\n\t\t\tif(n > RBUFSIZE)\n\t\t\t\tn = RBUFSIZE;\n\t\t\tbufread(&t->file->b, q0, r, n);\n\t\t\tbufinsert(&snarfbuf, snarfbuf.nc, r, n);\n\t\t\tq0 += n;\n\t\t}\n\t\tfbuffree(r);\n\t\tacmeputsnarf();\n\t}\n\tif(docut){\n\t\ttextdelete(t, t->q0, t->q1, TRUE);\n\t\ttextsetselect(t, t->q0, t->q0);\n\t\tif(t->w){\n\t\t\ttextscrdraw(t);\n\t\t\twinsettag(t->w);\n\t\t}\n\t}else if(dosnarf)\t/* Snarf command */\n\t\targtext = t;\n\tif(locked)\n\t\twinunlock(t->w);\n}\n\nvoid\npaste(Text *et, Text *t, Text *_0, int selectall, int tobody, Rune *_1, int _2)\n{\n\tint c;\n\tuint q, q0, q1, n;\n\tRune *r;\n\n\tUSED(_0);\n\tUSED(_1);\n\tUSED(_2);\n\n\t/* if(tobody), use body of executing window  (Paste or Send command) */\n\tif(tobody && et!=nil && et->w!=nil){\n\t\tt = &et->w->body;\n\t\tfilemark(t->file);\t/* seq has been incremented by execute */\n\t}\n\tif(t == nil)\n\t\treturn;\n\n\tacmegetsnarf();\n\tif(t==nil || snarfbuf.nc==0)\n\t\treturn;\n\tif(t->w!=nil && et->w!=t->w){\n\t\tc = 'M';\n\t\tif(et->w)\n\t\t\tc = et->w->owner;\n\t\twinlock(t->w, c);\n\t}\n\tcut(t, t, nil, FALSE, TRUE, nil, 0);\n\tq = 0;\n\tq0 = t->q0;\n\tq1 = t->q0+snarfbuf.nc;\n\tr = fbufalloc();\n\twhile(q0 < q1){\n\t\tn = q1 - q0;\n\t\tif(n > RBUFSIZE)\n\t\t\tn = RBUFSIZE;\n\t\tif(r == nil)\n\t\t\tr = runemalloc(n);\n\t\tbufread(&snarfbuf, q, r, n);\n\t\ttextinsert(t, q0, r, n, TRUE);\n\t\tq += n;\n\t\tq0 += n;\n\t}\n\tfbuffree(r);\n\tif(selectall)\n\t\ttextsetselect(t, t->q0, q1);\n\telse\n\t\ttextsetselect(t, q1, q1);\n\tif(t->w){\n\t\ttextscrdraw(t);\n\t\twinsettag(t->w);\n\t}\n\tif(t->w!=nil && et->w!=t->w)\n\t\twinunlock(t->w);\n}\n\nvoid\nlook(Text *et, Text *t, Text *argt, int _0, int _1, Rune *arg, int narg)\n{\n\tRune *r;\n\tint n;\n\n\tUSED(_0);\n\tUSED(_1);\n\n\tif(et && et->w){\n\t\tt = &et->w->body;\n\t\tif(narg > 0){\n\t\t\tsearch(t, arg, narg);\n\t\t\treturn;\n\t\t}\n\t\tgetarg(argt, FALSE, FALSE, &r, &n);\n\t\tif(r == nil){\n\t\t\tn = t->q1-t->q0;\n\t\t\tr = runemalloc(n);\n\t\t\tbufread(&t->file->b, t->q0, r, n);\n\t\t}\n\t\tsearch(t, r, n);\n\t\tfree(r);\n\t}\n}\n\nstatic Rune Lnl[] = { '\\n', 0 };\n\nvoid\nsendx(Text *et, Text *t, Text *_0, int _1, int _2, Rune *_3, int _4)\n{\n\tUSED(_0);\n\tUSED(_1);\n\tUSED(_2);\n\tUSED(_3);\n\tUSED(_4);\n\n\tif(et->w==nil)\n\t\treturn;\n\tt = &et->w->body;\n\tif(t->q0 != t->q1)\n\t\tcut(t, t, nil, TRUE, FALSE, nil, 0);\n\ttextsetselect(t, t->file->b.nc, t->file->b.nc);\n\tpaste(t, t, nil, TRUE, TRUE, nil, 0);\n\tif(textreadc(t, t->file->b.nc-1) != '\\n'){\n\t\ttextinsert(t, t->file->b.nc, Lnl, 1, TRUE);\n\t\ttextsetselect(t, t->file->b.nc, t->file->b.nc);\n\t}\n\tt->iq1 = t->q1;\n\ttextshow(t, t->q1, t->q1, 1);\n}\n\nvoid\nedit(Text *et, Text *_0, Text *argt, int _1, int _2, Rune *arg, int narg)\n{\n\tRune *r;\n\tint len;\n\n\tUSED(_0);\n\tUSED(_1);\n\tUSED(_2);\n\n\tif(et == nil)\n\t\treturn;\n\tgetarg(argt, FALSE, TRUE, &r, &len);\n\tseq++;\n\tif(r != nil){\n\t\teditcmd(et, r, len);\n\t\tfree(r);\n\t}else\n\t\teditcmd(et, arg, narg);\n}\n\nvoid\nxexit(Text *et, Text *_0, Text *_1, int _2, int _3, Rune *_4, int _5)\n{\n\tUSED(et);\n\tUSED(_0);\n\tUSED(_1);\n\tUSED(_2);\n\tUSED(_3);\n\tUSED(_4);\n\tUSED(_5);\n\n\tif(rowclean(&row)){\n\t\tsendul(cexit, 0);\n\t\tthreadexits(nil);\n\t}\n}\n\nvoid\nputall(Text *et, Text *_0, Text *_1, int _2, int _3, Rune *_4, int _5)\n{\n\tint i, j, e;\n\tWindow *w;\n\tColumn *c;\n\tchar *a;\n\n\tUSED(et);\n\tUSED(_0);\n\tUSED(_1);\n\tUSED(_2);\n\tUSED(_3);\n\tUSED(_4);\n\tUSED(_5);\n\n\tfor(i=0; i<row.ncol; i++){\n\t\tc = row.col[i];\n\t\tfor(j=0; j<c->nw; j++){\n\t\t\tw = c->w[j];\n\t\t\tif(w->isscratch || w->isdir || w->body.file->nname==0)\n\t\t\t\tcontinue;\n\t\t\tif(w->nopen[QWevent] > 0)\n\t\t\t\tcontinue;\n\t\t\ta = runetobyte(w->body.file->name, w->body.file->nname);\n\t\t\te = access(a, 0);\n\t\t\tif(w->body.file->mod || w->body.ncache)\n\t\t\t\tif(e < 0)\n\t\t\t\t\twarning(nil, \"no auto-Put of %s: %r\\n\", a);\n\t\t\t\telse{\n\t\t\t\t\twincommit(w, &w->body);\n\t\t\t\t\tput(&w->body, nil, nil, XXX, XXX, nil, 0);\n\t\t\t\t}\n\t\t\tfree(a);\n\t\t}\n\t}\n}\n\n\nvoid\nid(Text *et, Text *_0, Text *_1, int _2, int _3, Rune *_4, int _5)\n{\n\tUSED(_0);\n\tUSED(_1);\n\tUSED(_2);\n\tUSED(_3);\n\tUSED(_4);\n\tUSED(_5);\n\n\tif(et && et->w)\n\t\twarning(nil, \"/mnt/acme/%d/\\n\", et->w->id);\n}\n\nvoid\nlocal(Text *et, Text *_0, Text *argt, int _1, int _2, Rune *arg, int narg)\n{\n\tchar *a, *aa;\n\tRunestr dir;\n\n\tUSED(_0);\n\tUSED(_1);\n\tUSED(_2);\n\n\taa = getbytearg(argt, TRUE, TRUE, &a);\n\n\tdir = dirname(et, nil, 0);\n\tif(dir.nr==1 && dir.r[0]=='.'){\t/* sigh */\n\t\tfree(dir.r);\n\t\tdir.r = nil;\n\t\tdir.nr = 0;\n\t}\n\trun(nil, runetobyte(arg, narg), dir.r, dir.nr, FALSE, aa, a, FALSE);\n}\n\nvoid\nxkill(Text *_0, Text *_1, Text *argt, int _2, int _3, Rune *arg, int narg)\n{\n\tRune *a, *cmd, *r;\n\tint na;\n\n\tUSED(_0);\n\tUSED(_1);\n\tUSED(_2);\n\tUSED(_3);\n\n\tgetarg(argt, FALSE, FALSE, &r, &na);\n\tif(r)\n\t\txkill(nil, nil, nil, 0, 0, r, na);\n\t/* loop condition: *arg is not a blank */\n\tfor(;;){\n\t\ta = findbl(arg, narg, &na);\n\t\tif(a == arg)\n\t\t\tbreak;\n\t\tcmd = runemalloc(narg-na+1);\n\t\trunemove(cmd, arg, narg-na);\n\t\tsendp(ckill, cmd);\n\t\targ = skipbl(a, na, &narg);\n\t}\n}\n\nstatic Rune Lfix[] = { 'f', 'i', 'x', 0 };\nstatic Rune Lvar[] = { 'v', 'a', 'r', 0 };\n\nvoid\nfontx(Text *et, Text *t, Text *argt, int _0, int _1, Rune *arg, int narg)\n{\n\tRune *a, *r, *flag, *file;\n\tint na, nf;\n\tchar *aa;\n\tReffont *newfont;\n\tDirlist *dp;\n\tint i, fix;\n\n\tUSED(_0);\n\tUSED(_1);\n\n\tif(et==nil || et->w==nil)\n\t\treturn;\n\tt = &et->w->body;\n\tflag = nil;\n\tfile = nil;\n\t/* loop condition: *arg is not a blank */\n\tnf = 0;\n\tfor(;;){\n\t\ta = findbl(arg, narg, &na);\n\t\tif(a == arg)\n\t\t\tbreak;\n\t\tr = runemalloc(narg-na+1);\n\t\trunemove(r, arg, narg-na);\n\t\tif(runeeq(r, narg-na, Lfix, 3) || runeeq(r, narg-na, Lvar, 3)){\n\t\t\tfree(flag);\n\t\t\tflag = r;\n\t\t}else{\n\t\t\tfree(file);\n\t\t\tfile = r;\n\t\t\tnf = narg-na;\n\t\t}\n\t\targ = skipbl(a, na, &narg);\n\t}\n\tgetarg(argt, FALSE, TRUE, &r, &na);\n\tif(r)\n\t\tif(runeeq(r, na, Lfix, 3) || runeeq(r, na, Lvar, 3)){\n\t\t\tfree(flag);\n\t\t\tflag = r;\n\t\t}else{\n\t\t\tfree(file);\n\t\t\tfile = r;\n\t\t\tnf = na;\n\t\t}\n\tfix = 1;\n\tif(flag)\n\t\tfix = runeeq(flag, runestrlen(flag), Lfix, 3);\n\telse if(file == nil){\n\t\tnewfont = rfget(FALSE, FALSE, FALSE, nil);\n\t\tif(newfont)\n\t\t\tfix = strcmp(newfont->f->name, t->fr.font->name)==0;\n\t}\n\tif(file){\n\t\taa = runetobyte(file, nf);\n\t\tnewfont = rfget(fix, flag!=nil, FALSE, aa);\n\t\tfree(aa);\n\t}else\n\t\tnewfont = rfget(fix, FALSE, FALSE, nil);\n\tif(newfont){\n\t\tdraw(screen, t->w->r, textcols[BACK], nil, ZP);\n\t\trfclose(t->reffont);\n\t\tt->reffont = newfont;\n\t\tt->fr.font = newfont->f;\n\t\tfrinittick(&t->fr);\n\t\tif(t->w->isdir){\n\t\t\tt->all.min.x++;\t/* force recolumnation; disgusting! */\n\t\t\tfor(i=0; i<t->w->ndl; i++){\n\t\t\t\tdp = t->w->dlp[i];\n\t\t\t\taa = runetobyte(dp->r, dp->nr);\n\t\t\t\tdp->wid = stringwidth(newfont->f, aa);\n\t\t\t\tfree(aa);\n\t\t\t}\n\t\t}\n\t\t/* avoid shrinking of window due to quantization */\n\t\tcolgrow(t->w->col, t->w, -1);\n\t}\n\tfree(file);\n\tfree(flag);\n}\n\nvoid\nincl(Text *et, Text *_0, Text *argt, int _1, int _2, Rune *arg, int narg)\n{\n\tRune *a, *r;\n\tWindow *w;\n\tint na, n, len;\n\n\tUSED(_0);\n\tUSED(_1);\n\tUSED(_2);\n\n\tif(et==nil || et->w==nil)\n\t\treturn;\n\tw = et->w;\n\tn = 0;\n\tgetarg(argt, FALSE, TRUE, &r, &len);\n\tif(r){\n\t\tn++;\n\t\twinaddincl(w, r, len);\n\t}\n\t/* loop condition: *arg is not a blank */\n\tfor(;;){\n\t\ta = findbl(arg, narg, &na);\n\t\tif(a == arg)\n\t\t\tbreak;\n\t\tr = runemalloc(narg-na+1);\n\t\trunemove(r, arg, narg-na);\n\t\tn++;\n\t\twinaddincl(w, r, narg-na);\n\t\targ = skipbl(a, na, &narg);\n\t}\n\tif(n==0 && w->nincl){\n\t\tfor(n=w->nincl; --n>=0; )\n\t\t\twarning(nil, \"%S \", w->incl[n]);\n\t\twarning(nil, \"\\n\");\n\t}\n}\n\nstatic Rune LON[] = { 'O', 'N', 0 };\nstatic Rune LOFF[] = { 'O', 'F', 'F', 0 };\nstatic Rune Lon[] = { 'o', 'n', 0 };\n\nenum {\n\tIGlobal = -2,\n\tIError = -1,\n\tIon = 0,\n\tIoff = 1\n};\n\nstatic int\nindentval(Rune *s, int n)\n{\n\tif(n < 2)\n\t\treturn IError;\n\tif(runestrncmp(s, LON, n) == 0){\n\t\tglobalautoindent = TRUE;\n\t\twarning(nil, \"Indent ON\\n\");\n\t\treturn IGlobal;\n\t}\n\tif(runestrncmp(s, LOFF, n) == 0){\n\t\tglobalautoindent = FALSE;\n\t\twarning(nil, \"Indent OFF\\n\");\n\t\treturn IGlobal;\n\t}\n\treturn runestrncmp(s, Lon, n) == 0;\n}\n\nstatic void\nfixindent(Window *w, void *arg)\n{\n\tUSED(arg);\n\tw->autoindent = globalautoindent;\n}\n\nvoid\nindent(Text *et, Text *_0, Text *argt, int _1, int _2, Rune *arg, int narg)\n{\n\tRune *a, *r;\n\tWindow *w;\n\tint na, len, autoindent;\n\n\tUSED(_0);\n\tUSED(_1);\n\tUSED(_2);\n\n\tw = nil;\n\tif(et!=nil && et->w!=nil)\n\t\tw = et->w;\n\tautoindent = IError;\n\tgetarg(argt, FALSE, TRUE, &r, &len);\n\tif(r!=nil && len>0)\n\t\tautoindent = indentval(r, len);\n\telse{\n\t\ta = findbl(arg, narg, &na);\n\t\tif(a != arg)\n\t\t\tautoindent = indentval(arg, narg-na);\n\t}\n\tif(autoindent == IGlobal)\n\t\tallwindows(fixindent, nil);\n\telse if(w != nil && autoindent >= 0)\n\t\tw->autoindent = autoindent;\n}\n\nvoid\ntab(Text *et, Text *_0, Text *argt, int _1, int _2, Rune *arg, int narg)\n{\n\tRune *a, *r;\n\tWindow *w;\n\tint na, len, tab;\n\tchar *p;\n\n\tUSED(_0);\n\tUSED(_1);\n\tUSED(_2);\n\n\tif(et==nil || et->w==nil)\n\t\treturn;\n\tw = et->w;\n\tgetarg(argt, FALSE, TRUE, &r, &len);\n\ttab = 0;\n\tif(r!=nil && len>0){\n\t\tp = runetobyte(r, len);\n\t\tif('0'<=p[0] && p[0]<='9')\n\t\t\ttab = atoi(p);\n\t\tfree(p);\n\t}else{\n\t\ta = findbl(arg, narg, &na);\n\t\tif(a != arg){\n\t\t\tp = runetobyte(arg, narg-na);\n\t\t\tif('0'<=p[0] && p[0]<='9')\n\t\t\t\ttab = atoi(p);\n\t\t\tfree(p);\n\t\t}\n\t}\n\tif(tab > 0){\n\t\tif(w->body.tabstop != tab){\n\t\t\tw->body.tabstop = tab;\n\t\t\twinresize(w, w->r, FALSE, TRUE);\n\t\t}\n\t}else\n\t\twarning(nil, \"%.*S: Tab %d\\n\", w->body.file->nname, w->body.file->name, w->body.tabstop);\n}\n\nvoid\nrunproc(void *argvp)\n{\n\t/* args: */\n\t\tWindow *win;\n\t\tchar *s;\n\t\tRune *rdir;\n\t\tint ndir;\n\t\tint newns;\n\t\tchar *argaddr;\n\t\tchar *arg;\n\t\tCommand *c;\n\t\tChannel *cpid;\n\t\tint iseditcmd;\n\t/* end of args */\n\tchar *e, *t, *name, *filename, *dir, **av, *news;\n\tRune r, **incl;\n\tint ac, w, inarg, i, n, fd, nincl, winid;\n\tint sfd[3];\n\tint pipechar;\n\tchar buf[512];\n\tint ret;\n\t/*static void *parg[2]; */\n\tchar *rcarg[4];\n\tvoid **argv;\n\tCFsys *fs;\n\tchar *shell;\n\n\tthreadsetname(\"runproc\");\n\n\targv = argvp;\n\twin = argv[0];\n\ts = argv[1];\n\trdir = argv[2];\n\tndir = (uintptr)argv[3];\n\tnewns = (uintptr)argv[4];\n\targaddr = argv[5];\n\targ = argv[6];\n\tc = argv[7];\n\tcpid = argv[8];\n\tiseditcmd = (uintptr)argv[9];\n\tfree(argv);\n\n\tt = s;\n\twhile(*t==' ' || *t=='\\n' || *t=='\\t')\n\t\tt++;\n\tfor(e=t; *e; e++)\n\t\tif(*e==' ' || *e=='\\n' || *e=='\\t' )\n\t\t\tbreak;\n\tname = emalloc((e-t)+2);\n\tmemmove(name, t, e-t);\n\tname[e-t] = 0;\n\te = utfrrune(name, '/');\n\tif(e)\n\t\tmemmove(name, e+1, strlen(e+1)+1);\t/* strcpy but overlaps */\n\tstrcat(name, \" \");\t/* add blank here for ease in waittask */\n\tc->name = bytetorune(name, &c->nname);\n\tfree(name);\n\tpipechar = 0;\n\tif(*t=='<' || *t=='|' || *t=='>')\n\t\tpipechar = *t++;\n\tc->iseditcmd = iseditcmd;\n\tc->text = s;\n\tif(newns){\n\t\tnincl = 0;\n\t\tincl = nil;\n\t\tif(win){\n\t\t\tfilename = smprint(\"%.*S\", win->body.file->nname, win->body.file->name);\n\t\t\tnincl = win->nincl;\n\t\t\tif(nincl > 0){\n\t\t\t\tincl = emalloc(nincl*sizeof(Rune*));\n\t\t\t\tfor(i=0; i<nincl; i++){\n\t\t\t\t\tn = runestrlen(win->incl[i]);\n\t\t\t\t\tincl[i] = runemalloc(n+1);\n\t\t\t\t\trunemove(incl[i], win->incl[i], n);\n\t\t\t\t}\n\t\t\t}\n\t\t\twinid = win->id;\n\t\t}else{\n\t\t\tfilename = nil;\n\t\t\twinid = 0;\n\t\t\tif(activewin)\n\t\t\t\twinid = activewin->id;\n\t\t}\n\t\trfork(RFNAMEG|RFENVG|RFFDG|RFNOTEG);\n\t\tsprint(buf, \"%d\", winid);\n\t\tputenv(\"winid\", buf);\n\n\t\tif(filename){\n\t\t\tputenv(\"%\", filename);\n\t\t\tputenv(\"samfile\", filename);\n\t\t\tfree(filename);\n\t\t}\n\t\tc->md = fsysmount(rdir, ndir, incl, nincl);\n\t\tif(c->md == nil){\n\t\t\tfprint(2, \"child: can't allocate mntdir: %r\\n\");\n\t\t\tthreadexits(\"fsysmount\");\n\t\t}\n\t\tsprint(buf, \"%d\", c->md->id);\n\t\tif((fs = nsmount(\"acme\", buf)) == nil){\n\t\t\tfprint(2, \"child: can't mount acme: %r\\n\");\n\t\t\tfsysdelid(c->md);\n\t\t\tc->md = nil;\n\t\t\tthreadexits(\"nsmount\");\n\t\t}\n\t\tif(winid>0 && (pipechar=='|' || pipechar=='>')){\n\t\t\tsprint(buf, \"%d/rdsel\", winid);\n\t\t\tsfd[0] = fsopenfd(fs, buf, OREAD);\n\t\t}else\n\t\t\tsfd[0] = open(\"/dev/null\", OREAD);\n\t\tif((winid>0 || iseditcmd) && (pipechar=='|' || pipechar=='<')){\n\t\t\tif(iseditcmd){\n\t\t\t\tif(winid > 0)\n\t\t\t\t\tsprint(buf, \"%d/editout\", winid);\n\t\t\t\telse\n\t\t\t\t\tsprint(buf, \"editout\");\n\t\t\t}else\n\t\t\t\tsprint(buf, \"%d/wrsel\", winid);\n\t\t\tsfd[1] = fsopenfd(fs, buf, OWRITE);\n\t\t\tsfd[2] = fsopenfd(fs, \"cons\", OWRITE);\n\t\t}else{\n\t\t\tsfd[1] = fsopenfd(fs, \"cons\", OWRITE);\n\t\t\tsfd[2] = sfd[1];\n\t\t}\n\t\tfsunmount(fs);\n\t}else{\n\t\trfork(RFFDG|RFNOTEG);\n\t\tfsysclose();\n\t\tsfd[0] = open(\"/dev/null\", OREAD);\n\t\tsfd[1] = open(\"/dev/null\", OWRITE);\n\t\tsfd[2] = dup(erroutfd, -1);\n\t}\n\tif(win)\n\t\twinclose(win);\n\n\tif(argaddr)\n\t\tputenv(\"acmeaddr\", argaddr);\n\tif(acmeshell != nil)\n\t\tgoto Hard;\n\tif(strlen(t) > sizeof buf-10)\t/* may need to print into stack */\n\t\tgoto Hard;\n\tinarg = FALSE;\n\tfor(e=t; *e; e+=w){\n\t\tw = chartorune(&r, e);\n\t\tif(r==' ' || r=='\\t')\n\t\t\tcontinue;\n\t\tif(r < ' ')\n\t\t\tgoto Hard;\n\t\tif(utfrune(\"#;&|^$=`'{}()<>[]*?^~`/\", r))\n\t\t\tgoto Hard;\n\t\tinarg = TRUE;\n\t}\n\tif(!inarg)\n\t\tgoto Fail;\n\n\tac = 0;\n\tav = nil;\n\tinarg = FALSE;\n\tfor(e=t; *e; e+=w){\n\t\tw = chartorune(&r, e);\n\t\tif(r==' ' || r=='\\t'){\n\t\t\tinarg = FALSE;\n\t\t\t*e = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif(!inarg){\n\t\t\tinarg = TRUE;\n\t\t\tav = realloc(av, (ac+1)*sizeof(char**));\n\t\t\tav[ac++] = e;\n\t\t}\n\t}\n\tav = realloc(av, (ac+2)*sizeof(char**));\n\tav[ac++] = arg;\n\tav[ac] = nil;\n\tc->av = av;\n\n\tdir = nil;\n\tif(rdir != nil)\n\t\tdir = runetobyte(rdir, ndir);\n\tret = threadspawnd(sfd, av[0], av, dir);\n\tfree(dir);\n\tif(ret >= 0){\n\t\tif(cpid)\n\t\t\tsendul(cpid, ret);\n\t\tthreadexits(\"\");\n\t}\n/* libthread uses execvp so no need to do this */\n#if 0\n\te = av[0];\n\tif(e[0]=='/' || (e[0]=='.' && e[1]=='/'))\n\t\tgoto Fail;\n\tif(cputype){\n\t\tsprint(buf, \"%s/%s\", cputype, av[0]);\n\t\tprocexec(cpid, sfd, buf, av);\n\t}\n\tsprint(buf, \"/bin/%s\", av[0]);\n\tprocexec(cpid, sfd, buf, av);\n#endif\n\tgoto Fail;\n\nHard:\n\t/*\n\t * ugly: set path = (. $cputype /bin)\n\t * should honor $path if unusual.\n\t */\n\tif(cputype){\n\t\tn = 0;\n\t\tmemmove(buf+n, \".\", 2);\n\t\tn += 2;\n\t\ti = strlen(cputype)+1;\n\t\tmemmove(buf+n, cputype, i);\n\t\tn += i;\n\t\tmemmove(buf+n, \"/bin\", 5);\n\t\tn += 5;\n\t\tfd = create(\"/env/path\", OWRITE, 0666);\n\t\twrite(fd, buf, n);\n\t\tclose(fd);\n\t}\n\n\tif(arg){\n\t\tnews = emalloc(strlen(t) + 1 + 1 + strlen(arg) + 1 + 1);\n\t\tif(news){\n\t\t\tsprint(news, \"%s '%s'\", t, arg);\t/* BUG: what if quote in arg? */\n\t\t\tfree(s);\n\t\t\tt = news;\n\t\t\tc->text = news;\n\t\t}\n\t}\n\tdir = nil;\n\tif(rdir != nil)\n\t\tdir = runetobyte(rdir, ndir);\n\tshell = acmeshell;\n\tif(shell == nil)\n\t\tshell = \"rc\";\n\trcarg[0] = shell;\n\trcarg[1] = \"-c\";\n\trcarg[2] = t;\n\trcarg[3] = nil;\n\tret = threadspawnd(sfd, rcarg[0], rcarg, dir);\n\tfree(dir);\n\tif(ret >= 0){\n\t\tif(cpid)\n\t\t\tsendul(cpid, ret);\n\t\tthreadexits(nil);\n\t}\n\twarning(nil, \"exec %s: %r\\n\", shell);\n\n   Fail:\n\t/* threadexec hasn't happened, so send a zero */\n\tclose(sfd[0]);\n\tclose(sfd[1]);\n\tif(sfd[2] != sfd[1])\n\t\tclose(sfd[2]);\n\tsendul(cpid, 0);\n\tthreadexits(nil);\n}\n\nvoid\nrunwaittask(void *v)\n{\n\tCommand *c;\n\tChannel *cpid;\n\tvoid **a;\n\n\tthreadsetname(\"runwaittask\");\n\ta = v;\n\tc = a[0];\n\tcpid = a[1];\n\tfree(a);\n\tdo\n\t\tc->pid = recvul(cpid);\n\twhile(c->pid == ~0);\n\tfree(c->av);\n\tif(c->pid != 0)\t/* successful exec */\n\t\tsendp(ccommand, c);\n\telse{\n\t\tif(c->iseditcmd)\n\t\t\tsendul(cedit, 0);\n\t\tfree(c->name);\n\t\tfree(c->text);\n\t\tfree(c);\n\t}\n\tchanfree(cpid);\n}\n\nvoid\nrun(Window *win, char *s, Rune *rdir, int ndir, int newns, char *argaddr, char *xarg, int iseditcmd)\n{\n\tvoid **arg;\n\tCommand *c;\n\tChannel *cpid;\n\n\tif(s == nil)\n\t\treturn;\n\n\targ = emalloc(10*sizeof(void*));\n\tc = emalloc(sizeof *c);\n\tcpid = chancreate(sizeof(ulong), 0);\n\tchansetname(cpid, \"cpid %s\", s);\n\targ[0] = win;\n\targ[1] = s;\n\targ[2] = rdir;\n\targ[3] = (void*)(uintptr)ndir;\n\targ[4] = (void*)(uintptr)newns;\n\targ[5] = argaddr;\n\targ[6] = xarg;\n\targ[7] = c;\n\targ[8] = cpid;\n\targ[9] = (void*)(uintptr)iseditcmd;\n\tthreadcreate(runproc, arg, STACK);\n\t/* mustn't block here because must be ready to answer mount() call in run() */\n\targ = emalloc(2*sizeof(void*));\n\targ[0] = c;\n\targ[1] = cpid;\n\tthreadcreate(runwaittask, arg, STACK);\n}\n", "source": "acme2k/src/cmd/acme/exec.c", "file_type": "c"}
{"text": "#include <u.h>\n#include <libc.h>\n#include <draw.h>\n#include <thread.h>\n#include <cursor.h>\n#include <mouse.h>\n#include <keyboard.h>\n#include <frame.h>\n#include <fcall.h>\n#include <plumb.h>\n#include <libsec.h>\n#include \"dat.h\"\n#include \"fns.h\"\n\nenum\n{\n\tNone = 0,\n\tFore = '+',\n\tBack = '-'\n};\n\nenum\n{\n\tChar,\n\tLine\n};\n\nint\nisaddrc(int r)\n{\n\tif(r && utfrune(\"0123456789+-/$.#,;?\", r)!=nil)\n\t\treturn TRUE;\n\treturn FALSE;\n}\n\n/*\n * quite hard: could be almost anything but white space, but we are a little conservative,\n * aiming for regular expressions of alphanumerics and no white space\n */\nint\nisregexc(int r)\n{\n\tif(r == 0)\n\t\treturn FALSE;\n\tif(isalnum(r))\n\t\treturn TRUE;\n\tif(utfrune(\"^+-.*?#,;[]()$\", r)!=nil)\n\t\treturn TRUE;\n\treturn FALSE;\n}\n\n// nlcounttopos starts at q0 and advances nl lines,\n// being careful not to walk past the end of the text,\n// and then nr chars, being careful not to walk past\n// the end of the current line.\n// It returns the final position.\nlong\nnlcounttopos(Text *t, long q0, long nl, long nr)\n{\n\twhile(nl > 0 && q0 < t->file->b.nc) {\n\t\tif(textreadc(t, q0++) == '\\n')\n\t\t\tnl--;\n\t}\n\tif(nl > 0)\n\t\treturn q0;\n\twhile(nr > 0 && q0 < t->file->b.nc && textreadc(t, q0) != '\\n') {\n\t\tq0++;\n\t\tnr--;\n\t}\n\treturn q0;\n}\n\nRange\nnumber(uint showerr, Text *t, Range r, int line, int dir, int size, int *evalp)\n{\n\tuint q0, q1;\n\n\tif(size == Char){\n\t\tif(dir == Fore)\n\t\t\tline = r.q1+line;\n\t\telse if(dir == Back){\n\t\t\tif(r.q0==0 && line>0)\n\t\t\t\tr.q0 = t->file->b.nc;\n\t\t\tline = r.q0 - line;\n\t\t}\n\t\tif(line<0 || line>t->file->b.nc)\n\t\t\tgoto Rescue;\n\t\t*evalp = TRUE;\n\t\treturn range(line, line);\n\t}\n\tq0 = r.q0;\n\tq1 = r.q1;\n\tswitch(dir){\n\tcase None:\n\t\tq0 = 0;\n\t\tq1 = 0;\n\tForward:\n\t\twhile(line>0 && q1<t->file->b.nc)\n\t\t\tif(textreadc(t, q1++) == '\\n' || q1==t->file->b.nc)\n\t\t\t\tif(--line > 0)\n\t\t\t\t\tq0 = q1;\n\t\tif(line==1 && q1==t->file->b.nc) // 6 goes to end of 5-line file\n\t\t\tbreak;\n\t\tif(line > 0)\n\t\t\tgoto Rescue;\n\t\tbreak;\n\tcase Fore:\n\t\tif(q1 > 0)\n\t\t\twhile(q1<t->file->b.nc && textreadc(t, q1-1) != '\\n')\n\t\t\t\tq1++;\n\t\tq0 = q1;\n\t\tgoto Forward;\n\tcase Back:\n\t\tif(q0 < t->file->b.nc)\n\t\t\twhile(q0>0 && textreadc(t, q0-1)!='\\n')\n\t\t\t\tq0--;\n\t\tq1 = q0;\n\t\twhile(line>0 && q0>0){\n\t\t\tif(textreadc(t, q0-1) == '\\n'){\n\t\t\t\tif(--line >= 0)\n\t\t\t\t\tq1 = q0;\n\t\t\t}\n\t\t\t--q0;\n\t\t}\n\t\t/* :1-1 is :0 = #0, but :1-2 is an error */\n\t\tif(line > 1)\n\t\t\tgoto Rescue;\n\t\twhile(q0>0 && textreadc(t, q0-1)!='\\n')\n\t\t\t--q0;\n\t}\n\t*evalp = TRUE;\n\treturn range(q0, q1);\n\n    Rescue:\n\tif(showerr)\n\t\twarning(nil, \"address out of range\\n\");\n\t*evalp = FALSE;\n\treturn r;\n}\n\n\nRange\nregexp(uint showerr, Text *t, Range lim, Range r, Rune *pat, int dir, int *foundp)\n{\n\tint found;\n\tRangeset sel;\n\tint q;\n\n\tif(pat[0] == '\\0' && rxnull()){\n\t\tif(showerr)\n\t\t\twarning(nil, \"no previous regular expression\\n\");\n\t\t*foundp = FALSE;\n\t\treturn r;\n\t}\n\tif(pat[0] && rxcompile(pat) == FALSE){\n\t\t*foundp = FALSE;\n\t\treturn r;\n\t}\n\tif(dir == Back)\n\t\tfound = rxbexecute(t, r.q0, &sel);\n\telse{\n\t\tif(lim.q0 < 0)\n\t\t\tq = Infinity;\n\t\telse\n\t\t\tq = lim.q1;\n\t\tfound = rxexecute(t, nil, r.q1, q, &sel);\n\t}\n\tif(!found && showerr)\n\t\twarning(nil, \"no match for regexp\\n\");\n\t*foundp = found;\n\treturn sel.r[0];\n}\n\nRange\naddress(uint showerr, Text *t, Range lim, Range ar, void *a, uint q0, uint q1, int (*getc)(void*, uint),  int *evalp, uint *qp)\n{\n\tint dir, size, npat;\n\tint prevc, c, nc, n;\n\tuint q;\n\tRune *pat;\n\tRange r, nr;\n\n\tr = ar;\n\tq = q0;\n\tdir = None;\n\tsize = Line;\n\tc = 0;\n\twhile(q < q1){\n\t\tprevc = c;\n\t\tc = (*getc)(a, q++);\n\t\tswitch(c){\n\t\tdefault:\n\t\t\t*qp = q-1;\n\t\t\treturn r;\n\t\tcase ';':\n\t\t\tar = r;\n\t\t\t/* fall through */\n\t\tcase ',':\n\t\t\tif(prevc == 0)\t/* lhs defaults to 0 */\n\t\t\t\tr.q0 = 0;\n\t\t\tif(q>=q1 && t!=nil && t->file!=nil)\t/* rhs defaults to $ */\n\t\t\t\tr.q1 = t->file->b.nc;\n\t\t\telse{\n\t\t\t\tnr = address(showerr, t, lim, ar, a, q, q1, getc, evalp, &q);\n\t\t\t\tr.q1 = nr.q1;\n\t\t\t}\n\t\t\t*qp = q;\n\t\t\treturn r;\n\t\tcase '+':\n\t\tcase '-':\n\t\t\tif(*evalp && (prevc=='+' || prevc=='-'))\n\t\t\t\tif((nc=(*getc)(a, q))!='#' && nc!='/' && nc!='?')\n\t\t\t\t\tr = number(showerr, t, r, 1, prevc, Line, evalp);\t/* do previous one */\n\t\t\tdir = c;\n\t\t\tbreak;\n\t\tcase '.':\n\t\tcase '$':\n\t\t\tif(q != q0+1){\n\t\t\t\t*qp = q-1;\n\t\t\t\treturn r;\n\t\t\t}\n\t\t\tif(*evalp)\n\t\t\t\tif(c == '.')\n\t\t\t\t\tr = ar;\n\t\t\t\telse\n\t\t\t\t\tr = range(t->file->b.nc, t->file->b.nc);\n\t\t\tif(q < q1)\n\t\t\t\tdir = Fore;\n\t\t\telse\n\t\t\t\tdir = None;\n\t\t\tbreak;\n\t\tcase '#':\n\t\t\tif(q==q1 || (c=(*getc)(a, q++))<'0' || '9'<c){\n\t\t\t\t*qp = q-1;\n\t\t\t\treturn r;\n\t\t\t}\n\t\t\tsize = Char;\n\t\t\t/* fall through */\n\t\tcase '0': case '1': case '2': case '3': case '4':\n\t\tcase '5': case '6': case '7': case '8': case '9':\n\t\t\tn = c -'0';\n\t\t\twhile(q<q1){\n\t\t\t\tc = (*getc)(a, q++);\n\t\t\t\tif(c<'0' || '9'<c){\n\t\t\t\t\tq--;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tn = n*10+(c-'0');\n\t\t\t}\n\t\t\tif(*evalp)\n\t\t\t\tr = number(showerr, t, r, n, dir, size, evalp);\n\t\t\tdir = None;\n\t\t\tsize = Line;\n\t\t\tbreak;\n\t\tcase '?':\n\t\t\tdir = Back;\n\t\t\t/* fall through */\n\t\tcase '/':\n\t\t\tnpat = 0;\n\t\t\tpat = nil;\n\t\t\twhile(q<q1){\n\t\t\t\tc = (*getc)(a, q++);\n\t\t\t\tswitch(c){\n\t\t\t\tcase '\\n':\n\t\t\t\t\t--q;\n\t\t\t\t\tgoto out;\n\t\t\t\tcase '\\\\':\n\t\t\t\t\tpat = runerealloc(pat, npat+1);\n\t\t\t\t\tpat[npat++] = c;\n\t\t\t\t\tif(q == q1)\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\tc = (*getc)(a, q++);\n\t\t\t\t\tbreak;\n\t\t\t\tcase '/':\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tpat = runerealloc(pat, npat+1);\n\t\t\t\tpat[npat++] = c;\n\t\t\t}\n\t\t    out:\n\t\t\tpat = runerealloc(pat, npat+1);\n\t\t\tpat[npat] = 0;\n\t\t\tif(*evalp)\n\t\t\t\tr = regexp(showerr, t, lim, r, pat, dir, evalp);\n\t\t\tfree(pat);\n\t\t\tdir = None;\n\t\t\tsize = Line;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(*evalp && dir != None)\n\t\tr = number(showerr, t, r, 1, dir, Line, evalp);\t/* do previous one */\n\t*qp = q;\n\treturn r;\n}\n", "source": "acme2k/src/cmd/acme/addr.c", "file_type": "c"}
{"text": "#include <u.h>\n#include <libc.h>\n#include <draw.h>\n#include <thread.h>\n#include <cursor.h>\n#include <mouse.h>\n#include <keyboard.h>\n#include <frame.h>\n#include <fcall.h>\n#include <plumb.h>\n#include <libsec.h>\n#include \"dat.h\"\n#include \"fns.h\"\n\nint\twinid;\n\nvoid\nwininit(Window *w, Window *clone, Rectangle r)\n{\n\tRectangle r1, br;\n\tFile *f;\n\tReffont *rf;\n\tRune *rp;\n\tint nc;\n\n\tw->tag.w = w;\n\tw->taglines = 1;\n\tw->tagexpand = TRUE;\n\tw->body.w = w;\n\tw->id = ++winid;\n\tincref(&w->ref);\n\tif(globalincref)\n\t\tincref(&w->ref);\n\tw->ctlfid = ~0;\n\tw->utflastqid = -1;\n\tr1 = r;\n\n\tw->tagtop = r;\n\tw->tagtop.max.y = r.min.y + font->height;\n\tr1.max.y = r1.min.y + w->taglines*font->height;\n\n\tincref(&reffont.ref);\n\tf = fileaddtext(nil, &w->tag);\n\ttextinit(&w->tag, f, r1, &reffont, tagcols);\n\tw->tag.what = Tag;\n\t/* tag is a copy of the contents, not a tracked image */\n\tif(clone){\n\t\ttextdelete(&w->tag, 0, w->tag.file->b.nc, TRUE);\n\t\tnc = clone->tag.file->b.nc;\n\t\trp = runemalloc(nc);\n\t\tbufread(&clone->tag.file->b, 0, rp, nc);\n\t\ttextinsert(&w->tag, 0, rp, nc, TRUE);\n\t\tfree(rp);\n\t\tfilereset(w->tag.file);\n\t\ttextsetselect(&w->tag, nc, nc);\n\t}\n\tr1 = r;\n\tr1.min.y += w->taglines*font->height + 1;\n\tif(r1.max.y < r1.min.y)\n\t\tr1.max.y = r1.min.y;\n\tf = nil;\n\tif(clone){\n\t\tf = clone->body.file;\n\t\tw->body.org = clone->body.org;\n\t\tw->isscratch = clone->isscratch;\n\t\trf = rfget(FALSE, FALSE, FALSE, clone->body.reffont->f->name);\n\t}else\n\t\trf = rfget(FALSE, FALSE, FALSE, nil);\n\tf = fileaddtext(f, &w->body);\n\tw->body.what = Body;\n\ttextinit(&w->body, f, r1, rf, textcols);\n\tr1.min.y -= 1;\n\tr1.max.y = r1.min.y+1;\n\tdraw(screen, r1, tagcols[BORD], nil, ZP);\n\ttextscrdraw(&w->body);\n\tw->r = r;\n\tbr.min = w->tag.scrollr.min;\n\tbr.max.x = br.min.x + Dx(button->r);\n\tbr.max.y = br.min.y + Dy(button->r);\n\tdraw(screen, br, button, nil, button->r.min);\n\tw->filemenu = TRUE;\n\tw->maxlines = w->body.fr.maxlines;\n\tw->autoindent = globalautoindent;\n\tif(clone){\n\t\tw->dirty = clone->dirty;\n\t\tw->autoindent = clone->autoindent;\n\t\ttextsetselect(&w->body, clone->body.q0, clone->body.q1);\n\t\twinsettag(w);\n\t}\n}\n\n/*\n * Draw the appropriate button.\n */\nvoid\nwindrawbutton(Window *w)\n{\n\tImage *b;\n\tRectangle br;\n\t\n\tb = button;\n\tif(!w->isdir && !w->isscratch && (w->body.file->mod || w->body.ncache))\n\t\tb = modbutton;\n\tbr.min = w->tag.scrollr.min;\n\tbr.max.x = br.min.x + Dx(b->r);\n\tbr.max.y = br.min.y + Dy(b->r);\n\tdraw(screen, br, b, nil, b->r.min);\n}\n\nint\ndelrunepos(Window *w)\n{\n\tint n;\n\tRune rune;\n\t\n\tfor(n=0; n<w->tag.file->b.nc; n++) {\n\t\tbufread(&w->tag.file->b, n, &rune, 1);\n\t\tif(rune == ' ')\n\t\t\tbreak;\n\t}\n\tn += 2;\n\tif(n >= w->tag.file->b.nc)\n\t\treturn -1;\n\treturn n;\n}\n\nvoid\nmovetodel(Window *w)\n{\n\tint n;\n\t\n\tn = delrunepos(w);\n\tif(n < 0)\n\t\treturn;\n\tmoveto(mousectl, addpt(frptofchar(&w->tag.fr, n), Pt(4, w->tag.fr.font->height-4)));\n}\n\n/*\n * Compute number of tag lines required\n * to display entire tag text.\n */\nint\nwintaglines(Window *w, Rectangle r)\n{\n\tint n;\n\tRune rune;\n\tPoint p;\n\n\tif(!w->tagexpand && !w->showdel)\n\t\treturn 1;\n\tw->showdel = FALSE;\n\tw->tag.fr.noredraw = 1;\n\ttextresize(&w->tag, r, TRUE);\n\tw->tag.fr.noredraw = 0;\n\tw->tagsafe = FALSE;\n\t\n\tif(!w->tagexpand) {\n\t\t/* use just as many lines as needed to show the Del */\n\t\tn = delrunepos(w);\n\t\tif(n < 0)\n\t\t\treturn 1;\n\t\tp = subpt(frptofchar(&w->tag.fr, n), w->tag.fr.r.min);\n\t\treturn 1 + p.y / w->tag.fr.font->height;\n\t}\n\t\t\n\t/* can't use more than we have */\n\tif(w->tag.fr.nlines >= w->tag.fr.maxlines)\n\t\treturn w->tag.fr.maxlines;\n\n\t/* if tag ends with \\n, include empty line at end for typing */\n\tn = w->tag.fr.nlines;\n\tif(w->tag.file->b.nc > 0){\n\t\tbufread(&w->tag.file->b, w->tag.file->b.nc-1, &rune, 1);\n\t\tif(rune == '\\n')\n\t\t\tn++;\n\t}\n\tif(n == 0)\n\t\tn = 1;\n\treturn n;\n}\n\nint\nwinresize(Window *w, Rectangle r, int safe, int keepextra)\n{\n\tint oy, y, mouseintag, mouseinbody;\n\tPoint p;\n\tRectangle r1;\n\n\tmouseintag = ptinrect(mouse->xy, w->tag.all);\n\tmouseinbody = ptinrect(mouse->xy, w->body.all);\n\n\t/* tagtop is first line of tag */\n\tw->tagtop = r;\n\tw->tagtop.max.y = r.min.y+font->height;\n\n\tr1 = r;\n\tr1.max.y = min(r.max.y, r1.min.y + w->taglines*font->height);\n\n\t/* If needed, recompute number of lines in tag. */\n\tif(!safe || !w->tagsafe || !eqrect(w->tag.all, r1)){\n\t\tw->taglines = wintaglines(w, r);\n\t\tr1.max.y = min(r.max.y, r1.min.y + w->taglines*font->height);\n\t}\n\n\t/* If needed, resize & redraw tag. */\n\ty = r1.max.y;\n\tif(!safe || !w->tagsafe || !eqrect(w->tag.all, r1)){\n\t\ttextresize(&w->tag, r1, TRUE);\n\t\ty = w->tag.fr.r.max.y;\n\t\twindrawbutton(w);\n\t\tw->tagsafe = TRUE;\n\n\t\t/* If mouse is in tag, pull up as tag closes. */\n\t\tif(mouseintag && !ptinrect(mouse->xy, w->tag.all)){\n\t\t\tp = mouse->xy;\n\t\t\tp.y = w->tag.all.max.y-3;\n\t\t\tmoveto(mousectl, p);\n\t\t}\n\n\t\t/* If mouse is in body, push down as tag expands. */\n\t\tif(mouseinbody && ptinrect(mouse->xy, w->tag.all)){\n\t\t\tp = mouse->xy;\n\t\t\tp.y = w->tag.all.max.y+3;\n\t\t\tmoveto(mousectl, p);\n\t\t}\n\t}\n\t\n\t/* If needed, resize & redraw body. */\n\tr1 = r;\n\tr1.min.y = y;\n\tif(!safe || !eqrect(w->body.all, r1)){\n\t\toy = y;\n\t\tif(y+1+w->body.fr.font->height <= r.max.y){\t/* room for one line */\n\t\t\tr1.min.y = y;\n\t\t\tr1.max.y = y+1;\n\t\t\tdraw(screen, r1, tagcols[BORD], nil, ZP);\n\t\t\ty++;\n\t\t\tr1.min.y = min(y, r.max.y);\n\t\t\tr1.max.y = r.max.y;\n\t\t}else{\n\t\t\tr1.min.y = y;\n\t\t\tr1.max.y = y;\n\t\t}\n\t\ty = textresize(&w->body, r1, keepextra);\n\t\tw->r = r;\n\t\tw->r.max.y = y;\n\t\ttextscrdraw(&w->body);\n\t\tw->body.all.min.y = oy;\n\t}\n\tw->maxlines = min(w->body.fr.nlines, max(w->maxlines, w->body.fr.maxlines));\n\treturn w->r.max.y;\n}\n\nvoid\nwinlock1(Window *w, int owner)\n{\n\tincref(&w->ref);\n\tqlock(&w->lk);\n\tw->owner = owner;\n}\n\nvoid\nwinlock(Window *w, int owner)\n{\n\tint i;\n\tFile *f;\n\n\tf = w->body.file;\n\tfor(i=0; i<f->ntext; i++)\n\t\twinlock1(f->text[i]->w, owner);\n}\n\nvoid\nwinunlock(Window *w)\n{\n\tint i;\n\tFile *f;\n\n\t/*\n\t * subtle: loop runs backwards to avoid tripping over\n\t * winclose indirectly editing f->text and freeing f\n\t * on the last iteration of the loop.\n\t */\n\tf = w->body.file;\n\tfor(i=f->ntext-1; i>=0; i--){\n\t\tw = f->text[i]->w;\n\t\tw->owner = 0;\n\t\tqunlock(&w->lk);\n\t\twinclose(w);\n\t}\n}\n\nvoid\nwinmousebut(Window *w)\n{\n\tmoveto(mousectl, addpt(w->tag.scrollr.min, \n\t\tdivpt(Pt(Dx(w->tag.scrollr), font->height), 2)));\n}\n\nvoid\nwindirfree(Window *w)\n{\n\tint i;\n\tDirlist *dl;\n\n\tif(w->isdir){\n\t\tfor(i=0; i<w->ndl; i++){\n\t\t\tdl = w->dlp[i];\n\t\t\tfree(dl->r);\n\t\t\tfree(dl);\n\t\t}\n\t\tfree(w->dlp);\n\t}\n\tw->dlp = nil;\n\tw->ndl = 0;\n}\n\nvoid\nwinclose(Window *w)\n{\n\tint i;\n\n\tif(decref(&w->ref) == 0){\n\t\txfidlog(w, \"del\");\n\t\twindirfree(w);\n\t\ttextclose(&w->tag);\n\t\ttextclose(&w->body);\n\t\tif(activewin == w)\n\t\t\tactivewin = nil;\n\t\tfor(i=0; i<w->nincl; i++)\n\t\t\tfree(w->incl[i]);\n\t\tfree(w->incl);\n\t\tfree(w->events);\n\t\tfree(w);\n\t}\n}\n\nvoid\nwindelete(Window *w)\n{\n\tXfid *x;\n\n\tx = w->eventx;\n\tif(x){\n\t\tw->nevents = 0;\n\t\tfree(w->events);\n\t\tw->events = nil;\n\t\tw->eventx = nil;\n\t\tsendp(x->c, nil);\t/* wake him up */\n\t}\n}\n\nvoid\nwinundo(Window *w, int isundo)\n{\n\tText *body;\n\tint i;\n\tFile *f;\n\tWindow *v;\n\n\tw->utflastqid = -1;\n\tbody = &w->body;\n\tfileundo(body->file, isundo, &body->q0, &body->q1);\n\ttextshow(body, body->q0, body->q1, 1);\n\tf = body->file;\n\tfor(i=0; i<f->ntext; i++){\n\t\tv = f->text[i]->w;\n\t\tv->dirty = (f->seq != v->putseq);\n\t\tif(v != w){\n\t\t\tv->body.q0 = v->body.fr.p0+v->body.org;\n\t\t\tv->body.q1 = v->body.fr.p1+v->body.org;\n\t\t}\n\t}\n\twinsettag(w);\n}\n\nvoid\nwinsetname(Window *w, Rune *name, int n)\n{\n\tText *t;\n\tWindow *v;\n\tint i;\n\tstatic Rune Lslashguide[] = { '/', 'g', 'u', 'i', 'd', 'e', 0 };\n\tstatic Rune Lpluserrors[] = { '+', 'E', 'r', 'r', 'o', 'r', 's', 0 };\n\n\tt = &w->body;\n\tif(runeeq(t->file->name, t->file->nname, name, n) == TRUE)\n\t\treturn;\n\tw->isscratch = FALSE;\n\tif(n>=6 && runeeq(Lslashguide, 6, name+(n-6), 6))\n\t\tw->isscratch = TRUE;\n\telse if(n>=7 && runeeq(Lpluserrors, 7, name+(n-7), 7))\n\t\tw->isscratch = TRUE;\n\tfilesetname(t->file, name, n);\n\tfor(i=0; i<t->file->ntext; i++){\n\t\tv = t->file->text[i]->w;\n\t\twinsettag(v);\n\t\tv->isscratch = w->isscratch;\n\t}\n}\n\nvoid\nwintype(Window *w, Text *t, Rune r)\n{\n\tint i;\n\n\ttexttype(t, r);\n\tif(t->what == Body)\n\t\tfor(i=0; i<t->file->ntext; i++)\n\t\t\ttextscrdraw(t->file->text[i]);\n\twinsettag(w);\n}\n\nvoid\nwincleartag(Window *w)\n{\n\tint i, n;\n\tRune *r;\n\n\t/* w must be committed */\n\tn = w->tag.file->b.nc;\n\tr = runemalloc(n);\n\tbufread(&w->tag.file->b, 0, r, n);\n\tfor(i=0; i<n; i++)\n\t\tif(r[i]==' ' || r[i]=='\\t')\n\t\t\tbreak;\n\tfor(; i<n; i++)\n\t\tif(r[i] == '|')\n\t\t\tbreak;\n\tif(i == n)\n\t\treturn;\n\ti++;\n\ttextdelete(&w->tag, i, n, TRUE);\n\tfree(r);\n\tw->tag.file->mod = FALSE;\n\tif(w->tag.q0 > i)\n\t\tw->tag.q0 = i;\n\tif(w->tag.q1 > i)\n\t\tw->tag.q1 = i;\n\ttextsetselect(&w->tag, w->tag.q0, w->tag.q1);\n}\n\nvoid\nwinsettag1(Window *w)\n{\n\tint i, j, k, n, bar, dirty, resize;\n\tRune *new, *old, *r;\n\tuint q0, q1;\n\tstatic Rune Ldelsnarf[] = { ' ', 'D', 'e', 'l', ' ',\n\t\t'S', 'n', 'a', 'r', 'f', 0 };\n\tstatic Rune Lundo[] = { ' ', 'U', 'n', 'd', 'o', 0 };\n\tstatic Rune Lredo[] = { ' ', 'R', 'e', 'd', 'o', 0 };\n\tstatic Rune Lget[] = { ' ', 'G', 'e', 't', 0 };\n\tstatic Rune Lput[] = { ' ', 'P', 'u', 't', 0 };\n\tstatic Rune Llook[] = { ' ', 'L', 'o', 'o', 'k', ' ', 0 };\n\tstatic Rune Lpipe[] = { ' ', '|', 0 };\n\n\t/* there are races that get us here with stuff in the tag cache, so we take extra care to sync it */\n\tif(w->tag.ncache!=0 || w->tag.file->mod)\n\t\twincommit(w, &w->tag);\t/* check file name; also guarantees we can modify tag contents */\n\told = runemalloc(w->tag.file->b.nc+1);\n\tbufread(&w->tag.file->b, 0, old, w->tag.file->b.nc);\n\told[w->tag.file->b.nc] = '\\0';\n\tfor(i=0; i<w->tag.file->b.nc; i++)\n\t\tif(old[i]==' ' || old[i]=='\\t')\n\t\t\tbreak;\n\tif(runeeq(old, i, w->body.file->name, w->body.file->nname) == FALSE){\n\t\ttextdelete(&w->tag, 0, i, TRUE);\n\t\ttextinsert(&w->tag, 0, w->body.file->name, w->body.file->nname, TRUE);\n\t\tfree(old);\n\t\told = runemalloc(w->tag.file->b.nc+1);\n\t\tbufread(&w->tag.file->b, 0, old, w->tag.file->b.nc);\n\t\told[w->tag.file->b.nc] = '\\0';\n\t}\n\n\t/* compute the text for the whole tag, replacing current only if it differs */\n\tnew = runemalloc(w->body.file->nname+100);\n\ti = 0;\n\trunemove(new+i, w->body.file->name, w->body.file->nname);\n\ti += w->body.file->nname;\n\trunemove(new+i, Ldelsnarf, 10);\n\ti += 10;\n\tif(w->filemenu){\n\t\tif(w->body.needundo || w->body.file->delta.nc>0 || w->body.ncache){\n\t\t\trunemove(new+i, Lundo, 5);\n\t\t\ti += 5;\n\t\t}\n\t\tif(w->body.file->epsilon.nc > 0){\n\t\t\trunemove(new+i, Lredo, 5);\n\t\t\ti += 5;\n\t\t}\n\t\tdirty = w->body.file->nname && (w->body.ncache || w->body.file->seq!=w->putseq);\n\t\tif(!w->isdir && dirty){\n\t\t\trunemove(new+i, Lput, 4);\n\t\t\ti += 4;\n\t\t}\n\t}\n\tif(w->isdir){\n\t\trunemove(new+i, Lget, 4);\n\t\ti += 4;\n\t}\n\trunemove(new+i, Lpipe, 2);\n\ti += 2;\n\tr = runestrchr(old, '|');\n\tif(r)\n\t\tk = r-old+1;\n\telse{\n\t\tk = w->tag.file->b.nc;\n\t\tif(w->body.file->seq == 0){\n\t\t\trunemove(new+i, Llook, 6);\n\t\t\ti += 6;\n\t\t}\n\t}\n\tnew[i] = 0;\n\n\t/* replace tag if the new one is different */\n\tresize = 0;\n\tif(runeeq(new, i, old, k) == FALSE){\n\t\tresize = 1;\n\t\tn = k;\n\t\tif(n > i)\n\t\t\tn = i;\n\t\tfor(j=0; j<n; j++)\n\t\t\tif(old[j] != new[j])\n\t\t\t\tbreak;\n\t\tq0 = w->tag.q0;\n\t\tq1 = w->tag.q1;\n\t\ttextdelete(&w->tag, j, k, TRUE);\n\t\ttextinsert(&w->tag, j, new+j, i-j, TRUE);\n\t\t/* try to preserve user selection */\n\t\tr = runestrchr(old, '|');\n\t\tif(r){\n\t\t\tbar = r-old;\n\t\t\tif(q0 > bar){\n\t\t\t\tbar = (runestrchr(new, '|')-new)-bar;\n\t\t\t\tw->tag.q0 = q0+bar;\n\t\t\t\tw->tag.q1 = q1+bar;\n\t\t\t}\n\t\t}\n\t}\n\tfree(old);\n\tfree(new);\n\tw->tag.file->mod = FALSE;\n\tn = w->tag.file->b.nc+w->tag.ncache;\n\tif(w->tag.q0 > n)\n\t\tw->tag.q0 = n;\n\tif(w->tag.q1 > n)\n\t\tw->tag.q1 = n;\n\ttextsetselect(&w->tag, w->tag.q0, w->tag.q1);\n\twindrawbutton(w);\n\tif(resize){\n\t\tw->tagsafe = 0;\n\t\twinresize(w, w->r, TRUE, TRUE);\n\t}\n}\n\nvoid\nwinsettag(Window *w)\n{\n\tint i;\n\tFile *f;\n\tWindow *v;\n\n\tf = w->body.file;\n\tfor(i=0; i<f->ntext; i++){\n\t\tv = f->text[i]->w;\n\t\tif(v->col->safe || v->body.fr.maxlines>0)\n\t\t\twinsettag1(v);\n\t}\n}\n\nvoid\nwincommit(Window *w, Text *t)\n{\n\tRune *r;\n\tint i;\n\tFile *f;\n\n\ttextcommit(t, TRUE);\n\tf = t->file;\n\tif(f->ntext > 1)\n\t\tfor(i=0; i<f->ntext; i++)\n\t\t\ttextcommit(f->text[i], FALSE);\t/* no-op for t */\n\tif(t->what == Body)\n\t\treturn;\n\tr = runemalloc(w->tag.file->b.nc);\n\tbufread(&w->tag.file->b, 0, r, w->tag.file->b.nc);\n\tfor(i=0; i<w->tag.file->b.nc; i++)\n\t\tif(r[i]==' ' || r[i]=='\\t')\n\t\t\tbreak;\n\tif(runeeq(r, i, w->body.file->name, w->body.file->nname) == FALSE){\n\t\tseq++;\n\t\tfilemark(w->body.file);\n\t\tw->body.file->mod = TRUE;\n\t\tw->dirty = TRUE;\n\t\twinsetname(w, r, i);\n\t\twinsettag(w);\n\t}\n\tfree(r);\n}\n\nvoid\nwinaddincl(Window *w, Rune *r, int n)\n{\n\tchar *a;\n\tDir *d;\n\tRunestr rs;\n\n\ta = runetobyte(r, n);\n\td = dirstat(a);\n\tif(d == nil){\n\t\tif(a[0] == '/')\n\t\t\tgoto Rescue;\n\t\trs = dirname(&w->body, r, n);\n\t\tr = rs.r;\n\t\tn = rs.nr;\n\t\tfree(a);\n\t\ta = runetobyte(r, n);\n\t\td = dirstat(a);\n\t\tif(d == nil)\n\t\t\tgoto Rescue;\n\t\tr = runerealloc(r, n+1);\n\t\tr[n] = 0;\n\t}\n\tfree(a);\n\tif((d->qid.type&QTDIR) == 0){\n\t\tfree(d);\n\t\twarning(nil, \"%s: not a directory\\n\", a);\n\t\tfree(r);\n\t\treturn;\n\t}\n\tfree(d);\n\tw->nincl++;\n\tw->incl = realloc(w->incl, w->nincl*sizeof(Rune*));\n\tmemmove(w->incl+1, w->incl, (w->nincl-1)*sizeof(Rune*));\n\tw->incl[0] = runemalloc(n+1);\n\trunemove(w->incl[0], r, n);\n\tfree(r);\n\treturn;\n\nRescue:\n\twarning(nil, \"%s: %r\\n\", a);\n\tfree(r);\n\tfree(a);\n\treturn;\n}\n\nint\nwinclean(Window *w, int conservative)\n{\n\tif(w->isscratch || w->isdir)\t/* don't whine if it's a guide file, error window, etc. */\n\t\treturn TRUE;\n\tif(!conservative && w->nopen[QWevent]>0)\n\t\treturn TRUE;\n\tif(w->dirty){\n\t\tif(w->body.file->nname)\n\t\t\twarning(nil, \"%.*S modified\\n\", w->body.file->nname, w->body.file->name);\n\t\telse{\n\t\t\tif(w->body.file->b.nc < 100)\t/* don't whine if it's too small */\n\t\t\t\treturn TRUE;\n\t\t\twarning(nil, \"unnamed file modified\\n\");\n\t\t}\n\t\tw->dirty = FALSE;\n\t\treturn FALSE;\n\t}\n\treturn TRUE;\n}\n\nchar*\nwinctlprint(Window *w, char *buf, int fonts)\n{\n\tsprint(buf, \"%11d %11d %11d %11d %11d \", w->id, w->tag.file->b.nc,\n\t\tw->body.file->b.nc, w->isdir, w->dirty);\n\tif(fonts)\n\t\treturn smprint(\"%s%11d %q %11d \", buf, Dx(w->body.fr.r), \n\t\t\tw->body.reffont->f->name, w->body.fr.maxtab);\n\treturn buf;\n}\n\nvoid\nwinevent(Window *w, char *fmt, ...)\n{\n\tint n;\n\tchar *b;\n\tXfid *x;\n\tva_list arg;\n\n\tif(w->nopen[QWevent] == 0)\n\t\treturn;\n\tif(w->owner == 0)\n\t\terror(\"no window owner\");\n\tva_start(arg, fmt);\n\tb = vsmprint(fmt, arg);\n\tva_end(arg);\n\tif(b == nil)\n\t\terror(\"vsmprint failed\");\n\tn = strlen(b);\n\tw->events = erealloc(w->events, w->nevents+1+n);\n\tw->events[w->nevents++] = w->owner;\n\tmemmove(w->events+w->nevents, b, n);\n\tfree(b);\n\tw->nevents += n;\n\tx = w->eventx;\n\tif(x){\n\t\tw->eventx = nil;\n\t\tsendp(x->c, nil);\n\t}\n}\n", "source": "acme2k/src/cmd/acme/wind.c", "file_type": "c"}
{"text": "#include <u.h>\n#include <libc.h>\n#include <draw.h>\n#include <thread.h>\n#include <cursor.h>\n#include <mouse.h>\n#include <keyboard.h>\n#include <frame.h>\n#include <fcall.h>\n#include <plumb.h>\n#include <libsec.h>\n#include \"dat.h\"\n#include \"fns.h\"\n\nRangeset\tsel;\nRune\t\t*lastregexp;\n\n/*\n * Machine Information\n */\ntypedef struct Inst Inst;\nstruct Inst\n{\n\tuint\ttype;\t/* < OPERATOR ==> literal, otherwise action */\n\tunion {\n\t\tint sid;\n\t\tint subid;\n\t\tint class;\n\t\tInst *other;\n\t\tInst *right;\n\t} u;\n\tunion{\n\t\tInst *left;\n\t\tInst *next;\n\t} u1;\n};\n\n#define\tNPROG\t1024\nInst\tprogram[NPROG];\nInst\t*progp;\nInst\t*startinst;\t/* First inst. of program; might not be program[0] */\nInst\t*bstartinst;\t/* same for backwards machine */\nChannel\t*rechan;\t/* chan(Inst*) */\n\ntypedef struct Ilist Ilist;\nstruct Ilist\n{\n\tInst\t*inst;\t\t/* Instruction of the thread */\n\tRangeset se;\n\tuint\tstartp;\t\t/* first char of match */\n};\n\n#define\tNLIST\t127\n\nIlist\t*tl, *nl;\t/* This list, next list */\nIlist\tlist[2][NLIST+1];\t/* +1 for trailing null */\nstatic\tRangeset sempty;\n\n/*\n * Actions and Tokens\n *\n *\t0x10000xx are operators, value == precedence\n *\t0x20000xx are tokens, i.e. operands for operators\n */\n#define\tOPERATOR\t0x1000000\t/* Bit set in all operators */\n#define\tSTART\t\t(OPERATOR+0)\t/* Start, used for marker on stack */\n#define\tRBRA\t\t(OPERATOR+1)\t/* Right bracket, ) */\n#define\tLBRA\t\t(OPERATOR+2)\t/* Left bracket, ( */\n#define\tOR\t\t(OPERATOR+3)\t/* Alternation, | */\n#define\tCAT\t\t(OPERATOR+4)\t/* Concatentation, implicit operator */\n#define\tSTAR\t\t(OPERATOR+5)\t/* Closure, * */\n#define\tPLUS\t\t(OPERATOR+6)\t/* a+ == aa* */\n#define\tQUEST\t\t(OPERATOR+7)\t/* a? == a|nothing, i.e. 0 or 1 a's */\n#define\tANY\t\t0x2000000\t/* Any character but newline, . */\n#define\tNOP\t\t(ANY+1)\t/* No operation, internal use only */\n#define\tBOL\t\t(ANY+2)\t/* Beginning of line, ^ */\n#define\tEOL\t\t(ANY+3)\t/* End of line, $ */\n#define\tCCLASS\t\t(ANY+4)\t/* Character class, [] */\n#define\tNCCLASS\t\t(ANY+5)\t/* Negated character class, [^] */\n#define\tEND\t\t(ANY+0x77)\t/* Terminate: match found */\n\n#define\tISATOR\t\tOPERATOR\n#define\tISAND\t\tANY\n\n#define\tQUOTED\t0x4000000\t/* Bit set for \\-ed lex characters */\n\n/*\n * Parser Information\n */\ntypedef struct Node Node;\nstruct Node\n{\n\tInst\t*first;\n\tInst\t*last;\n};\n\n#define\tNSTACK\t20\nNode\tandstack[NSTACK];\nNode\t*andp;\nint\tatorstack[NSTACK];\nint\t*atorp;\nint\tlastwasand;\t/* Last token was operand */\nint\tcursubid;\nint\tsubidstack[NSTACK];\nint\t*subidp;\nint\tbackwards;\nint\tnbra;\nRune\t*exprp;\t\t/* pointer to next character in source expression */\n#define\tDCLASS\t10\t/* allocation increment */\nint\tnclass;\t\t/* number active */\nint\tNclass;\t\t/* high water mark */\nRune\t**class;\nint\tnegateclass;\n\nint\taddinst(Ilist *l, Inst *inst, Rangeset *sep);\nvoid\tnewmatch(Rangeset*);\nvoid\tbnewmatch(Rangeset*);\nvoid\tpushand(Inst*, Inst*);\nvoid\tpushator(int);\nNode\t*popand(int);\nint\tpopator(void);\nvoid\tstartlex(Rune*);\nint\tlex(void);\nvoid\toperator(int);\nvoid\toperand(int);\nvoid\tevaluntil(int);\nvoid\toptimize(Inst*);\nvoid\tbldcclass(void);\n\nvoid\nrxinit(void)\n{\n\trechan = chancreate(sizeof(Inst*), 0);\n\tchansetname(rechan, \"rechan\");\n\tlastregexp = runemalloc(1);\n}\n\nvoid\nregerror(char *e)\n{\n\tlastregexp[0] = 0;\n\twarning(nil, \"regexp: %s\\n\", e);\n\tsendp(rechan, nil);\n\tthreadexits(nil);\n}\n\nInst *\nnewinst(int t)\n{\n\tif(progp >= &program[NPROG])\n\t\tregerror(\"expression too long\");\n\tprogp->type = t;\n\tprogp->u1.left = nil;\n\tprogp->u.right = nil;\n\treturn progp++;\n}\n\nvoid\nrealcompile(void *arg)\n{\n\tint token;\n\tRune *s;\n\n\tthreadsetname(\"regcomp\");\n\ts = arg;\n\tstartlex(s);\n\tatorp = atorstack;\n\tandp = andstack;\n\tsubidp = subidstack;\n\tcursubid = 0;\n\tlastwasand = FALSE;\n\t/* Start with a low priority operator to prime parser */\n\tpushator(START-1);\n\twhile((token=lex()) != END){\n\t\tif((token&ISATOR) == OPERATOR)\n\t\t\toperator(token);\n\t\telse\n\t\t\toperand(token);\n\t}\n\t/* Close with a low priority operator */\n\tevaluntil(START);\n\t/* Force END */\n\toperand(END);\n\tevaluntil(START);\n\tif(nbra)\n\t\tregerror(\"unmatched `('\");\n\t--andp;\t/* points to first and only operand */\n\tsendp(rechan, andp->first);\n\tthreadexits(nil);\n}\n\n/* r is null terminated */\nint\nrxcompile(Rune *r)\n{\n\tint i, nr;\n\tInst *oprogp;\n\n\tnr = runestrlen(r)+1;\n\tif(runeeq(lastregexp, runestrlen(lastregexp)+1, r, nr)==TRUE)\n\t\treturn TRUE;\n\tlastregexp[0] = 0;\n\tfor(i=0; i<nclass; i++)\n\t\tfree(class[i]);\n\tnclass = 0;\n\tprogp = program;\n\tbackwards = FALSE;\n\tbstartinst = nil;\n\tthreadcreate(realcompile, r, STACK);\n\tstartinst = recvp(rechan);\n\tif(startinst == nil)\n\t\treturn FALSE;\n\toptimize(program);\n\toprogp = progp;\n\tbackwards = TRUE;\n\tthreadcreate(realcompile, r, STACK);\n\tbstartinst = recvp(rechan);\n\tif(bstartinst == nil)\n\t\treturn FALSE;\n\toptimize(oprogp);\n\tlastregexp = runerealloc(lastregexp, nr);\n\trunemove(lastregexp, r, nr);\n\treturn TRUE;\n}\n\nvoid\noperand(int t)\n{\n\tInst *i;\n\tif(lastwasand)\n\t\toperator(CAT);\t/* catenate is implicit */\n\ti = newinst(t);\n\tif(t == CCLASS){\n\t\tif(negateclass)\n\t\t\ti->type = NCCLASS;\t/* UGH */\n\t\ti->u.class = nclass-1;\t\t/* UGH */\n\t}\n\tpushand(i, i);\n\tlastwasand = TRUE;\n}\n\nvoid\noperator(int t)\n{\n\tif(t==RBRA && --nbra<0)\n\t\tregerror(\"unmatched `)'\");\n\tif(t==LBRA){\n\t\tcursubid++;\t/* silently ignored */\n\t\tnbra++;\n\t\tif(lastwasand)\n\t\t\toperator(CAT);\n\t}else\n\t\tevaluntil(t);\n\tif(t!=RBRA)\n\t\tpushator(t);\n\tlastwasand = FALSE;\n\tif(t==STAR || t==QUEST || t==PLUS || t==RBRA)\n\t\tlastwasand = TRUE;\t/* these look like operands */\n}\n\nvoid\npushand(Inst *f, Inst *l)\n{\n\tif(andp >= &andstack[NSTACK])\n\t\terror(\"operand stack overflow\");\n\tandp->first = f;\n\tandp->last = l;\n\tandp++;\n}\n\nvoid\npushator(int t)\n{\n\tif(atorp >= &atorstack[NSTACK])\n\t\terror(\"operator stack overflow\");\n\t*atorp++=t;\n\tif(cursubid >= NRange)\n\t\t*subidp++= -1;\n\telse\n\t\t*subidp++=cursubid;\n}\n\nNode *\npopand(int op)\n{\n\tchar buf[64];\n\n\tif(andp <= &andstack[0])\n\t\tif(op){\n\t\t\tsprint(buf, \"missing operand for %c\", op);\n\t\t\tregerror(buf);\n\t\t}else\n\t\t\tregerror(\"malformed regexp\");\n\treturn --andp;\n}\n\nint\npopator()\n{\n\tif(atorp <= &atorstack[0])\n\t\terror(\"operator stack underflow\");\n\t--subidp;\n\treturn *--atorp;\n}\n\nvoid\nevaluntil(int pri)\n{\n\tNode *op1, *op2, *t;\n\tInst *inst1, *inst2;\n\n\twhile(pri==RBRA || atorp[-1]>=pri){\n\t\tswitch(popator()){\n\t\tcase LBRA:\n\t\t\top1 = popand('(');\n\t\t\tinst2 = newinst(RBRA);\n\t\t\tinst2->u.subid = *subidp;\n\t\t\top1->last->u1.next = inst2;\n\t\t\tinst1 = newinst(LBRA);\n\t\t\tinst1->u.subid = *subidp;\n\t\t\tinst1->u1.next = op1->first;\n\t\t\tpushand(inst1, inst2);\n\t\t\treturn;\t\t/* must have been RBRA */\n\t\tdefault:\n\t\t\terror(\"unknown regexp operator\");\n\t\t\tbreak;\n\t\tcase OR:\n\t\t\top2 = popand('|');\n\t\t\top1 = popand('|');\n\t\t\tinst2 = newinst(NOP);\n\t\t\top2->last->u1.next = inst2;\n\t\t\top1->last->u1.next = inst2;\n\t\t\tinst1 = newinst(OR);\n\t\t\tinst1->u.right = op1->first;\n\t\t\tinst1->u1.left = op2->first;\n\t\t\tpushand(inst1, inst2);\n\t\t\tbreak;\n\t\tcase CAT:\n\t\t\top2 = popand(0);\n\t\t\top1 = popand(0);\n\t\t\tif(backwards && op2->first->type!=END){\n\t\t\t\tt = op1;\n\t\t\t\top1 = op2;\n\t\t\t\top2 = t;\n\t\t\t}\n\t\t\top1->last->u1.next = op2->first;\n\t\t\tpushand(op1->first, op2->last);\n\t\t\tbreak;\n\t\tcase STAR:\n\t\t\top2 = popand('*');\n\t\t\tinst1 = newinst(OR);\n\t\t\top2->last->u1.next = inst1;\n\t\t\tinst1->u.right = op2->first;\n\t\t\tpushand(inst1, inst1);\n\t\t\tbreak;\n\t\tcase PLUS:\n\t\t\top2 = popand('+');\n\t\t\tinst1 = newinst(OR);\n\t\t\top2->last->u1.next = inst1;\n\t\t\tinst1->u.right = op2->first;\n\t\t\tpushand(op2->first, inst1);\n\t\t\tbreak;\n\t\tcase QUEST:\n\t\t\top2 = popand('?');\n\t\t\tinst1 = newinst(OR);\n\t\t\tinst2 = newinst(NOP);\n\t\t\tinst1->u1.left = inst2;\n\t\t\tinst1->u.right = op2->first;\n\t\t\top2->last->u1.next = inst2;\n\t\t\tpushand(inst1, inst2);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n\nvoid\noptimize(Inst *start)\n{\n\tInst *inst, *target;\n\n\tfor(inst=start; inst->type!=END; inst++){\n\t\ttarget = inst->u1.next;\n\t\twhile(target->type == NOP)\n\t\t\ttarget = target->u1.next;\n\t\tinst->u1.next = target;\n\t}\n}\n\nvoid\nstartlex(Rune *s)\n{\n\texprp = s;\n\tnbra = 0;\n}\n\n\nint\nlex(void){\n\tint c;\n\n\tc = *exprp++;\n\tswitch(c){\n\tcase '\\\\':\n\t\tif(*exprp)\n\t\t\tif((c= *exprp++)=='n')\n\t\t\t\tc='\\n';\n\t\tbreak;\n\tcase 0:\n\t\tc = END;\n\t\t--exprp;\t/* In case we come here again */\n\t\tbreak;\n\tcase '*':\n\t\tc = STAR;\n\t\tbreak;\n\tcase '?':\n\t\tc = QUEST;\n\t\tbreak;\n\tcase '+':\n\t\tc = PLUS;\n\t\tbreak;\n\tcase '|':\n\t\tc = OR;\n\t\tbreak;\n\tcase '.':\n\t\tc = ANY;\n\t\tbreak;\n\tcase '(':\n\t\tc = LBRA;\n\t\tbreak;\n\tcase ')':\n\t\tc = RBRA;\n\t\tbreak;\n\tcase '^':\n\t\tc = BOL;\n\t\tbreak;\n\tcase '$':\n\t\tc = EOL;\n\t\tbreak;\n\tcase '[':\n\t\tc = CCLASS;\n\t\tbldcclass();\n\t\tbreak;\n\t}\n\treturn c;\n}\n\nint\nnextrec(void)\n{\n\tif(exprp[0]==0 || (exprp[0]=='\\\\' && exprp[1]==0))\n\t\tregerror(\"malformed `[]'\");\n\tif(exprp[0] == '\\\\'){\n\t\texprp++;\n\t\tif(*exprp=='n'){\n\t\t\texprp++;\n\t\t\treturn '\\n';\n\t\t}\n\t\treturn *exprp++|QUOTED;\n\t}\n\treturn *exprp++;\n}\n\nvoid\nbldcclass(void)\n{\n\tint c1, c2, n, na;\n\tRune *classp;\n\n\tclassp = runemalloc(DCLASS);\n\tn = 0;\n\tna = DCLASS;\n\t/* we have already seen the '[' */\n\tif(*exprp == '^'){\n\t\tclassp[n++] = '\\n';\t/* don't match newline in negate case */\n\t\tnegateclass = TRUE;\n\t\texprp++;\n\t}else\n\t\tnegateclass = FALSE;\n\twhile((c1 = nextrec()) != ']'){\n\t\tif(c1 == '-'){\n    Error:\n\t\t\tfree(classp);\n\t\t\tregerror(\"malformed `[]'\");\n\t\t}\n\t\tif(n+4 >= na){\t\t/* 3 runes plus NUL */\n\t\t\tna += DCLASS;\n\t\t\tclassp = runerealloc(classp, na);\n\t\t}\n\t\tif(*exprp == '-'){\n\t\t\texprp++;\t/* eat '-' */\n\t\t\tif((c2 = nextrec()) == ']')\n\t\t\t\tgoto Error;\n\t\t\tclassp[n+0] = Runemax;\n\t\t\tclassp[n+1] = c1;\n\t\t\tclassp[n+2] = c2;\n\t\t\tn += 3;\n\t\t}else\n\t\t\tclassp[n++] = c1 & ~QUOTED;\n\t}\n\tclassp[n] = 0;\n\tif(nclass == Nclass){\n\t\tNclass += DCLASS;\n\t\tclass = realloc(class, Nclass*sizeof(Rune*));\n\t}\n\tclass[nclass++] = classp;\n}\n\nint\nclassmatch(int classno, int c, int negate)\n{\n\tRune *p;\n\n\tp = class[classno];\n\twhile(*p){\n\t\tif(*p == Runemax){\n\t\t\tif(p[1]<=c && c<=p[2])\n\t\t\t\treturn !negate;\n\t\t\tp += 3;\n\t\t}else if(*p++ == c)\n\t\t\treturn !negate;\n\t}\n\treturn negate;\n}\n\n/*\n * Note optimization in addinst:\n * \t*l must be pending when addinst called; if *l has been looked\n *\t\tat already, the optimization is a bug.\n */\nint\naddinst(Ilist *l, Inst *inst, Rangeset *sep)\n{\n\tIlist *p;\n\n\tfor(p = l; p->inst; p++){\n\t\tif(p->inst==inst){\n\t\t\tif((sep)->r[0].q0 < p->se.r[0].q0)\n\t\t\t\tp->se= *sep;\t/* this would be bug */\n\t\t\treturn 0;\t/* It's already there */\n\t\t}\n\t}\n\tp->inst = inst;\n\tp->se= *sep;\n\t(p+1)->inst = nil;\n\treturn 1;\n}\n\nint\nrxnull(void)\n{\n\treturn startinst==nil || bstartinst==nil;\n}\n\n/* either t!=nil or r!=nil, and we match the string in the appropriate place */\nint\nrxexecute(Text *t, Rune *r, uint startp, uint eof, Rangeset *rp)\n{\n\tint flag;\n\tInst *inst;\n\tIlist *tlp;\n\tuint p;\n\tint nnl, ntl;\n\tint nc, c;\n\tint wrapped;\n\tint startchar;\n\n\tflag = 0;\n\tp = startp;\n\tstartchar = 0;\n\twrapped = 0;\n\tnnl = 0;\n\tif(startinst->type<OPERATOR)\n\t\tstartchar = startinst->type;\n\tlist[0][0].inst = list[1][0].inst = nil;\n\tsel.r[0].q0 = -1;\n\tif(t != nil)\n\t\tnc = t->file->b.nc;\n\telse\n\t\tnc = runestrlen(r);\n\t/* Execute machine once for each character */\n\tfor(;;p++){\n\tdoloop:\n\t\tif(p>=eof || p>=nc){\n\t\t\tswitch(wrapped++){\n\t\t\tcase 0:\t\t/* let loop run one more click */\n\t\t\tcase 2:\n\t\t\t\tbreak;\n\t\t\tcase 1:\t\t/* expired; wrap to beginning */\n\t\t\t\tif(sel.r[0].q0>=0 || eof!=Infinity)\n\t\t\t\t\tgoto Return;\n\t\t\t\tlist[0][0].inst = list[1][0].inst = nil;\n\t\t\t\tp = 0;\n\t\t\t\tgoto doloop;\n\t\t\tdefault:\n\t\t\t\tgoto Return;\n\t\t\t}\n\t\t\tc = 0;\n\t\t}else{\n\t\t\tif(((wrapped && p>=startp) || sel.r[0].q0>0) && nnl==0)\n\t\t\t\tbreak;\n\t\t\tif(t != nil)\n\t\t\t\tc = textreadc(t, p);\n\t\t\telse\n\t\t\t\tc = r[p];\n\t\t}\n\t\t/* fast check for first char */\n\t\tif(startchar && nnl==0 && c!=startchar)\n\t\t\tcontinue;\n\t\ttl = list[flag];\n\t\tnl = list[flag^=1];\n\t\tnl->inst = nil;\n\t\tntl = nnl;\n\t\tnnl = 0;\n\t\tif(sel.r[0].q0<0 && (!wrapped || p<startp || startp==eof)){\n\t\t\t/* Add first instruction to this list */\n\t\t\tsempty.r[0].q0 = p;\n\t\t\tif(addinst(tl, startinst, &sempty))\n\t\t\tif(++ntl >= NLIST){\n\tOverflow:\n\t\t\t\twarning(nil, \"regexp list overflow\\n\");\n\t\t\t\tsel.r[0].q0 = -1;\n\t\t\t\tgoto Return;\n\t\t\t}\n\t\t}\n\t\t/* Execute machine until this list is empty */\n\t\tfor(tlp = tl; inst = tlp->inst; tlp++){\t/* assignment = */\n\tSwitchstmt:\n\t\t\tswitch(inst->type){\n\t\t\tdefault:\t/* regular character */\n\t\t\t\tif(inst->type==c){\n\tAddinst:\n\t\t\t\t\tif(addinst(nl, inst->u1.next, &tlp->se))\n\t\t\t\t\tif(++nnl >= NLIST)\n\t\t\t\t\t\tgoto Overflow;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase LBRA:\n\t\t\t\tif(inst->u.subid>=0)\n\t\t\t\t\ttlp->se.r[inst->u.subid].q0 = p;\n\t\t\t\tinst = inst->u1.next;\n\t\t\t\tgoto Switchstmt;\n\t\t\tcase RBRA:\n\t\t\t\tif(inst->u.subid>=0)\n\t\t\t\t\ttlp->se.r[inst->u.subid].q1 = p;\n\t\t\t\tinst = inst->u1.next;\n\t\t\t\tgoto Switchstmt;\n\t\t\tcase ANY:\n\t\t\t\tif(c!='\\n')\n\t\t\t\t\tgoto Addinst;\n\t\t\t\tbreak;\n\t\t\tcase BOL:\n\t\t\t\tif(p==0 || (t!=nil && textreadc(t, p-1)=='\\n') || (r!=nil && r[p-1]=='\\n')){\n\tStep:\n\t\t\t\t\tinst = inst->u1.next;\n\t\t\t\t\tgoto Switchstmt;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase EOL:\n\t\t\t\tif(c == '\\n')\n\t\t\t\t\tgoto Step;\n\t\t\t\tbreak;\n\t\t\tcase CCLASS:\n\t\t\t\tif(c>=0 && classmatch(inst->u.class, c, 0))\n\t\t\t\t\tgoto Addinst;\n\t\t\t\tbreak;\n\t\t\tcase NCCLASS:\n\t\t\t\tif(c>=0 && classmatch(inst->u.class, c, 1))\n\t\t\t\t\tgoto Addinst;\n\t\t\t\tbreak;\n\t\t\tcase OR:\n\t\t\t\t/* evaluate right choice later */\n\t\t\t\tif(addinst(tlp, inst->u.right, &tlp->se))\n\t\t\t\tif(++ntl >= NLIST)\n\t\t\t\t\tgoto Overflow;\n\t\t\t\t/* efficiency: advance and re-evaluate */\n\t\t\t\tinst = inst->u1.left;\n\t\t\t\tgoto Switchstmt;\n\t\t\tcase END:\t/* Match! */\n\t\t\t\ttlp->se.r[0].q1 = p;\n\t\t\t\tnewmatch(&tlp->se);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n    Return:\n\t*rp = sel;\n\treturn sel.r[0].q0 >= 0;\n}\n\nvoid\nnewmatch(Rangeset *sp)\n{\n\tif(sel.r[0].q0<0 || sp->r[0].q0<sel.r[0].q0 ||\n\t   (sp->r[0].q0==sel.r[0].q0 && sp->r[0].q1>sel.r[0].q1))\n\t\tsel = *sp;\n}\n\nint\nrxbexecute(Text *t, uint startp, Rangeset *rp)\n{\n\tint flag;\n\tInst *inst;\n\tIlist *tlp;\n\tint p;\n\tint nnl, ntl;\n\tint c;\n\tint wrapped;\n\tint startchar;\n\n\tflag = 0;\n\tnnl = 0;\n\twrapped = 0;\n\tp = startp;\n\tstartchar = 0;\n\tif(bstartinst->type<OPERATOR)\n\t\tstartchar = bstartinst->type;\n\tlist[0][0].inst = list[1][0].inst = nil;\n\tsel.r[0].q0= -1;\n\t/* Execute machine once for each character, including terminal NUL */\n\tfor(;;--p){\n\tdoloop:\n\t\tif(p <= 0){\n\t\t\tswitch(wrapped++){\n\t\t\tcase 0:\t\t/* let loop run one more click */\n\t\t\tcase 2:\n\t\t\t\tbreak;\n\t\t\tcase 1:\t\t/* expired; wrap to end */\n\t\t\t\tif(sel.r[0].q0>=0)\n\t\t\t\t\tgoto Return;\n\t\t\t\tlist[0][0].inst = list[1][0].inst = nil;\n\t\t\t\tp = t->file->b.nc;\n\t\t\t\tgoto doloop;\n\t\t\tcase 3:\n\t\t\tdefault:\n\t\t\t\tgoto Return;\n\t\t\t}\n\t\t\tc = 0;\n\t\t}else{\n\t\t\tif(((wrapped && p<=startp) || sel.r[0].q0>0) && nnl==0)\n\t\t\t\tbreak;\n\t\t\tc = textreadc(t, p-1);\n\t\t}\n\t\t/* fast check for first char */\n\t\tif(startchar && nnl==0 && c!=startchar)\n\t\t\tcontinue;\n\t\ttl = list[flag];\n\t\tnl = list[flag^=1];\n\t\tnl->inst = nil;\n\t\tntl = nnl;\n\t\tnnl = 0;\n\t\tif(sel.r[0].q0<0 && (!wrapped || p>startp)){\n\t\t\t/* Add first instruction to this list */\n\t\t\t/* the minus is so the optimizations in addinst work */\n\t\t\tsempty.r[0].q0 = -p;\n\t\t\tif(addinst(tl, bstartinst, &sempty))\n\t\t\tif(++ntl >= NLIST){\n\tOverflow:\n\t\t\t\twarning(nil, \"regexp list overflow\\n\");\n\t\t\t\tsel.r[0].q0 = -1;\n\t\t\t\tgoto Return;\n\t\t\t}\n\t\t}\n\t\t/* Execute machine until this list is empty */\n\t\tfor(tlp = tl; inst = tlp->inst; tlp++){\t/* assignment = */\n\tSwitchstmt:\n\t\t\tswitch(inst->type){\n\t\t\tdefault:\t/* regular character */\n\t\t\t\tif(inst->type == c){\n\tAddinst:\n\t\t\t\t\tif(addinst(nl, inst->u1.next, &tlp->se))\n\t\t\t\t\tif(++nnl >= NLIST)\n\t\t\t\t\t\tgoto Overflow;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase LBRA:\n\t\t\t\tif(inst->u.subid>=0)\n\t\t\t\t\ttlp->se.r[inst->u.subid].q0 = p;\n\t\t\t\tinst = inst->u1.next;\n\t\t\t\tgoto Switchstmt;\n\t\t\tcase RBRA:\n\t\t\t\tif(inst->u.subid >= 0)\n\t\t\t\t\ttlp->se.r[inst->u.subid].q1 = p;\n\t\t\t\tinst = inst->u1.next;\n\t\t\t\tgoto Switchstmt;\n\t\t\tcase ANY:\n\t\t\t\tif(c != '\\n')\n\t\t\t\t\tgoto Addinst;\n\t\t\t\tbreak;\n\t\t\tcase BOL:\n\t\t\t\tif(c=='\\n' || p==0){\n\tStep:\n\t\t\t\t\tinst = inst->u1.next;\n\t\t\t\t\tgoto Switchstmt;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase EOL:\n\t\t\t\tif(p<t->file->b.nc && textreadc(t, p)=='\\n')\n\t\t\t\t\tgoto Step;\n\t\t\t\tbreak;\n\t\t\tcase CCLASS:\n\t\t\t\tif(c>0 && classmatch(inst->u.class, c, 0))\n\t\t\t\t\tgoto Addinst;\n\t\t\t\tbreak;\n\t\t\tcase NCCLASS:\n\t\t\t\tif(c>0 && classmatch(inst->u.class, c, 1))\n\t\t\t\t\tgoto Addinst;\n\t\t\t\tbreak;\n\t\t\tcase OR:\n\t\t\t\t/* evaluate right choice later */\n\t\t\t\tif(addinst(tl, inst->u.right, &tlp->se))\n\t\t\t\tif(++ntl >= NLIST)\n\t\t\t\t\tgoto Overflow;\n\t\t\t\t/* efficiency: advance and re-evaluate */\n\t\t\t\tinst = inst->u1.left;\n\t\t\t\tgoto Switchstmt;\n\t\t\tcase END:\t/* Match! */\n\t\t\t\ttlp->se.r[0].q0 = -tlp->se.r[0].q0; /* minus sign */\n\t\t\t\ttlp->se.r[0].q1 = p;\n\t\t\t\tbnewmatch(&tlp->se);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n    Return:\n\t*rp = sel;\n\treturn sel.r[0].q0 >= 0;\n}\n\nvoid\nbnewmatch(Rangeset *sp)\n{\n        int  i;\n\n        if(sel.r[0].q0<0 || sp->r[0].q0>sel.r[0].q1 || (sp->r[0].q0==sel.r[0].q1 && sp->r[0].q1<sel.r[0].q0))\n                for(i = 0; i<NRange; i++){       /* note the reversal; q0<=q1 */\n                        sel.r[i].q0 = sp->r[i].q1;\n                        sel.r[i].q1 = sp->r[i].q0;\n                }\n}\n", "source": "acme2k/src/cmd/acme/regx.c", "file_type": "c"}
{"text": "#include <u.h>\n#include <libc.h>\n#include <draw.h>\n#include <thread.h>\n#include <cursor.h>\n#include <mouse.h>\n#include <keyboard.h>\n#include <frame.h>\n#include <fcall.h>\n#include <plumb.h>\n#include <libsec.h>\n#include \"dat.h\"\n#include \"fns.h\"\n\nstatic\tBlock\t*blist;\n\nint\ntempfile(void)\n{\n\tchar buf[128];\n\tint i, fd;\n\n\tsnprint(buf, sizeof buf, \"/tmp/X%d.%.4sacme\", getpid(), getuser());\n\tfor(i='A'; i<='Z'; i++){\n\t\tbuf[5] = i;\n\t\tif(access(buf, AEXIST) == 0)\n\t\t\tcontinue;\n\t\tfd = create(buf, ORDWR|ORCLOSE|OCEXEC, 0600);\n\t\tif(fd >= 0)\n\t\t\treturn fd;\n\t}\n\treturn -1;\n}\n\nDisk*\ndiskinit()\n{\n\tDisk *d;\n\n\td = emalloc(sizeof(Disk));\n\td->fd = tempfile();\n\tif(d->fd < 0){\n\t\tfprint(2, \"acme: can't create temp file: %r\\n\");\n\t\tthreadexitsall(\"diskinit\");\n\t}\n\treturn d;\n}\n\nstatic\nuint\nntosize(uint n, uint *ip)\n{\n\tuint size;\n\n\tif(n > Maxblock)\n\t\terror(\"internal error: ntosize\");\n\tsize = n;\n\tif(size & (Blockincr-1))\n\t\tsize += Blockincr - (size & (Blockincr-1));\n\t/* last bucket holds blocks of exactly Maxblock */\n\tif(ip)\n\t\t*ip = size/Blockincr;\n\treturn size * sizeof(Rune);\n}\n\nBlock*\ndisknewblock(Disk *d, uint n)\n{\n\tuint i, j, size;\n\tBlock *b;\n\n\tsize = ntosize(n, &i);\n\tb = d->free[i];\n\tif(b)\n\t\td->free[i] = b->u.next;\n\telse{\n\t\t/* allocate in chunks to reduce malloc overhead */\n\t\tif(blist == nil){\n\t\t\tblist = emalloc(100*sizeof(Block));\n\t\t\tfor(j=0; j<100-1; j++)\n\t\t\t\tblist[j].u.next = &blist[j+1];\n\t\t}\n\t\tb = blist;\n\t\tblist = b->u.next;\n\t\tb->addr = d->addr;\n\t\tif(d->addr+size < d->addr){\n\t\t\terror(\"temp file overflow\");\n\t\t}\n\t\td->addr += size;\n\t}\n\tb->u.n = n;\n\treturn b;\n}\n\nvoid\ndiskrelease(Disk *d, Block *b)\n{\n\tuint i;\n\n\tntosize(b->u.n, &i);\n\tb->u.next = d->free[i];\n\td->free[i] = b;\n}\n\nvoid\ndiskwrite(Disk *d, Block **bp, Rune *r, uint n)\n{\n\tint size, nsize;\n\tBlock *b;\n\n\tb = *bp;\n\tsize = ntosize(b->u.n, nil);\n\tnsize = ntosize(n, nil);\n\tif(size != nsize){\n\t\tdiskrelease(d, b);\n\t\tb = disknewblock(d, n);\n\t\t*bp = b;\n\t}\n\tif(pwrite(d->fd, r, n*sizeof(Rune), b->addr) != n*sizeof(Rune))\n\t\terror(\"write error to temp file\");\n\tb->u.n = n;\n}\n\nvoid\ndiskread(Disk *d, Block *b, Rune *r, uint n)\n{\n\tif(n > b->u.n)\n\t\terror(\"internal error: diskread\");\n\n\tntosize(b->u.n, nil);\n\tif(pread(d->fd, r, n*sizeof(Rune), b->addr) != n*sizeof(Rune))\n\t\terror(\"read error from temp file\");\n}\n", "source": "acme2k/src/cmd/acme/disk.c", "file_type": "c"}
{"text": "#include <u.h>\n#include <libc.h>\n#include <bio.h>\n#include <thread.h>\n#include <ctype.h>\n#include <9pclient.h>\n#include <plumb.h>\n#include \"dat.h\"\n\nenum\n{\n\tDIRCHUNK = 32*sizeof(Dir)\n};\n\nchar\tregexchars[] = \"\\\\/[].+?()*^$\";\nchar\tdeleted[] = \"(deleted)-\";\nchar\tdeletedrx[] = \"\\\\(deleted\\\\)-\";\nchar\tdeletedrx01[] = \"(\\\\(deleted\\\\)-)?\";\nchar\tdeletedaddr[] = \"-#0;/^\\\\(deleted\\\\)-/\";\n\nstruct{\n\tchar\t*type;\n\tchar\t*port;\n\tchar *suffix;\n} ports[] = {\n\t\"text/\",\t\t\t\"edit\",\t\".txt\", /* must be first for plumbport() */\n\t\"image/gif\",\t\t\"image\",\t\".gif\",\n\t\"image/jpeg\",\t\t\"image\",\t\".jpg\",\n\t\"image/jpeg\",\t\t\"image\",\t\".jpeg\",\n\t\"image/png\",\t\t\"image\",\t\".png\",\n\t\"application/postscript\",\t\"postscript\",\t\".ps\",\n\t\"application/pdf\",\t\"postscript\",\t\".pdf\",\n\t\"application/msword\",\t\"msword\",\t\".doc\",\n\t\"application/rtf\",\t\"msword\",\t\".rtf\",\n\tnil,\tnil\n};\n\nchar *goodtypes[] = {\n\t\"text\",\n\t\"text/plain\",\n\t\"message/rfc822\",\n\t\"text/richtext\",\n\t\"text/tab-separated-values\",\n\t\"application/octet-stream\",\n\tnil\n};\n\nchar *okheaders[] =\n{\n\t\"From:\",\n\t\"Date:\",\n\t\"To:\",\n\t\"CC:\",\n\t\"Subject:\",\n\tnil\n};\n\nchar *extraheaders[] =\n{\n\t\"Resent-From:\",\n\t\"Resent-To:\",\n\t\"Sort:\",\n\tnil\n};\n\nchar*\nline(char *data, char **pp)\n{\n\tchar *p, *q;\n\n\tfor(p=data; *p!='\\0' && *p!='\\n'; p++)\n\t\t;\n\tif(*p == '\\n')\n\t\t*pp = p+1;\n\telse\n\t\t*pp = p;\n\tq = emalloc(p-data + 1);\n\tmemmove(q, data, p-data);\n\treturn q;\n}\n\nstatic char*\nmkaddrs(char *t, char **colon)\n{\n\tint i, nf, inquote;\n\tchar **f, *s;\n\tFmt fmt;\n\t\n\tinquote = 0;\n\tnf = 2;\n\tfor(s=t; *s; s++){\n\t\tif(*s == '\\'')\n\t\t\tinquote = !inquote;\n\t\tif(*s == ' ' && !inquote)\n\t\t\tnf++;\n\t}\n\tf = emalloc(nf*sizeof f[0]);\n\tnf = tokenize(t, f, nf);\n\tif(colon){\n\t\tfmtstrinit(&fmt);\n\t\tfor(i=0; i+1<nf; i+=2){\n\t\t\tif(i > 0)\n\t\t\t\tfmtprint(&fmt, \", \");\n\t\t\tif(f[i][0] == 0 || strcmp(f[i], f[i+1]) == 0)\n\t\t\t\tfmtprint(&fmt, \"%s\", f[i+1]);\n\t\t\telse\n\t\t\t\tfmtprint(&fmt, \"%s <%s>\", f[i], f[i+1]);\n\t\t}\n\t\t*colon = fmtstrflush(&fmt);\n\t}\n\tfmtstrinit(&fmt);\n\tfor(i=0; i+1<nf; i+=2){\n\t\tif(i > 0)\n\t\t\tfmtprint(&fmt, \", \");\n\t\tfmtprint(&fmt, \"%s\", f[i+1]);\n\t}\n\tfree(f);\n\treturn fmtstrflush(&fmt);\n}\n\nint\nloadinfo(Message *m, char *dir)\n{\n\tint n;\n\tchar *data, *p, *s, *t;\n\n\tdata = readfile(dir, \"info\", &n);\n\tif(data == nil)\n\t\treturn 0;\n\t\n\tp = data;\n\twhile((s = line(p, &p)) != nil && *s != 0){\n\t\tt = strchr(s, ' ');\n\t\tif(t == nil)\n\t\t\tcontinue;\n\t\t*t++ = 0;\n\t\tif(strcmp(s, \"from\") == 0){\n\t\t\tfree(m->from);\n\t\t\tm->from = mkaddrs(t, &m->fromcolon);\n\t\t}else if(strcmp(s, \"sender\") == 0){\n\t\t\tfree(m->sender);\n\t\t\tm->sender = mkaddrs(t, nil);\n\t\t}else if(strcmp(s, \"to\") == 0){\n\t\t\tfree(m->to);\n\t\t\tm->to = mkaddrs(t, nil);\n\t\t}else if(strcmp(s, \"cc\") == 0){\n\t\t\tfree(m->cc);\n\t\t\tm->cc = mkaddrs(t, nil);\n\t\t}else if(strcmp(s, \"replyto\") == 0){\n\t\t\tfree(m->replyto);\n\t\t\tm->replyto = mkaddrs(t, nil);\n\t\t}else if(strcmp(s, \"subject\") == 0){\n\t\t\tfree(m->subject);\n\t\t\tm->subject = estrdup(t);\n\t\t}else if(strcmp(s, \"type\") == 0){\n\t\t\tfree(m->type);\n\t\t\tm->type = estrdup(t);\n\t\t}else if(strcmp(s, \"unixdate\") == 0 && (t=strchr(t, ' ')) != nil){\n\t\t\tfree(m->date);\n\t\t\tm->date = estrdup(t+1);\n\t\t}else if(strcmp(s, \"digest\") == 0){\n\t\t\tfree(m->digest);\n\t\t\tm->digest = estrdup(t);\n\t\t}else if(strcmp(s, \"filename\") == 0){\n\t\t\tfree(m->filename);\n\t\t\tm->filename = estrdup(t);\n\t\t}\n\t\tfree(s);\n\t}\n\tfree(s);\n\tfree(data);\n\tif(m->replyto == nil){\n\t\tif(m->sender)\n\t\t\tm->replyto = estrdup(m->sender);\n\t\telse if(m->from)\n\t\t\tm->replyto = estrdup(m->from);\n\t\telse\n\t\t\tm->replyto = estrdup(\"\");\n\t}\n\tif(m->from == nil)\n\t\tm->from = estrdup(\"\");\n\tif(m->to == nil)\n\t\tm->to = estrdup(\"\");\n\tif(m->cc == nil)\n\t\tm->cc = estrdup(\"\");\n\tif(m->subject == nil)\n\t\tm->subject = estrdup(\"\");\n\tif(m->type == nil)\n\t\tm->type = estrdup(\"\");\n\tif(m->date == nil)\n\t\tm->date = estrdup(\"\");\n\tif(m->disposition == nil)\n\t\tm->disposition = estrdup(\"\");\n\tif(m->filename == nil)\n\t\tm->filename = estrdup(\"\");\n\tif(m->digest == nil)\n\t\tm->digest = estrdup(\"\");\n\treturn 1;\n}\n\nint\nisnumeric(char *s)\n{\n\twhile(*s){\n\t\tif(!isdigit(*s))\n\t\t\treturn 0;\n\t\ts++;\n\t}\n\treturn 1;\n}\n\nCFid*\nmailopen(char *name, int mode)\n{\n\tif(strncmp(name, \"Mail/\", 5) != 0)\n\t\treturn nil;\n\treturn fsopen(mailfs, name+5, mode);\n}\n\nDir*\nloaddir(char *name, int *np)\n{\n\tCFid *fid;\n\tDir *dp;\n\n\tfid = mailopen(name, OREAD);\n\tif(fid == nil)\n\t\treturn nil;\n\t*np = fsdirreadall(fid, &dp);\n\tfsclose(fid);\n\treturn dp;\n}\n\nvoid\nreadmbox(Message *mbox, char *dir, char *subdir)\n{\n\tchar *name;\n\tDir *d, *dirp;\n\tint i, n;\n\n\tname = estrstrdup(dir, subdir);\n\tdirp = loaddir(name, &n);\n\tmbox->recursed = 1;\n\tif(dirp)\n\t\tfor(i=0; i<n; i++){\n\t\t\td = &dirp[i];\n\t\t\tif(isnumeric(d->name))\n\t\t\t\tmesgadd(mbox, name, d, nil);\n\t\t}\n\tfree(dirp);\n\tfree(name);\n}\n\n/* add message to box, in increasing numerical order */\nint\nmesgadd(Message *mbox, char *dir, Dir *d, char *digest)\n{\n\tMessage *m;\n\tchar *name;\n\tint loaded;\n\n\tm = emalloc(sizeof(Message));\n\tm->name = estrstrdup(d->name, \"/\");\n\tm->next = nil;\n\tm->prev = mbox->tail;\n\tm->level= mbox->level+1;\n\tm->recursed = 0;\n\tname = estrstrdup(dir, m->name);\n\tloaded = loadinfo(m, name);\n\tfree(name);\n\t/* if two upas/fs are running, we can get misled, so check digest before accepting message */\n\tif(loaded==0 || (digest!=nil && m->digest!=nil && strcmp(digest, m->digest)!=0)){\n\t\tmesgfreeparts(m);\n\t\tfree(m);\n\t\treturn 0;\n\t}\n\tif(mbox->tail != nil)\n\t\tmbox->tail->next = m;\n\tmbox->tail = m;\n\tif(mbox->head == nil)\n\t\tmbox->head = m;\n\n\tif (m->level != 1){\n\t\tm->recursed = 1;\n\t\treadmbox(m, dir, m->name); \n\t}\n\treturn 1;\n}\n\nint\nthisyear(char *year)\n{\n\tstatic char now[10];\n\tchar *s;\n\n\tif(now[0] == '\\0'){\n\t\ts = ctime(time(nil));\n\t\tstrcpy(now, s+24);\n\t}\n\treturn strncmp(year, now, 4) == 0;\n}\n\nchar*\nstripdate(char *as)\n{\n\tint n;\n\tchar *s, *fld[10];\n\n\tas = estrdup(as);\n\ts = estrdup(as);\n\tn = tokenize(s, fld, 10);\n\tif(n > 5){\n\t\tsprint(as, \"%.3s \", fld[0]);\t/* day */\n\t\t/* some dates have 19 Apr, some Apr 19 */\n\t\tif(strlen(fld[1])<4 && isnumeric(fld[1]))\n\t\t\tsprint(as+strlen(as), \"%.3s %.3s \", fld[1], fld[2]);\t/* date, month */\n\t\telse\n\t\t\tsprint(as+strlen(as), \"%.3s %.3s \", fld[2], fld[1]);\t/* date, month */\n\t\t/* do we use time or year?  depends on whether year matches this one */\n\t\tif(thisyear(fld[5])){\n\t\t\tif(strchr(fld[3], ':') != nil)\n\t\t\t\tsprint(as+strlen(as), \"%.5s \", fld[3]);\t/* time */\n\t\t\telse if(strchr(fld[4], ':') != nil)\n\t\t\t\tsprint(as+strlen(as), \"%.5s \", fld[4]);\t/* time */\n\t\t}else\n\t\t\tsprint(as+strlen(as), \"%.4s \", fld[5]);\t/* year */\n\t}\n\tfree(s);\n\treturn as;\n}\n\nchar*\nreadfile(char *dir, char *name, int *np)\n{\n\tchar *file, *data;\n\tint len;\n\tDir *d;\n\tCFid *fid;\n\tchar buf[1];\n\n\tif(np != nil)\n\t\t*np = 0;\n\tfile = estrstrdup(dir, name);\n\tfid = mailopen(file, OREAD);\n\tif(fid == nil)\n\t\treturn nil;\n\td = fsdirfstat(fid);\n\tif(d && d->length == 0){\n\t\t/* some files, e.g. body, are not loaded until we read them */\n\t\tfsread(fid, buf, 1);\n\t\tfsseek(fid, 0, 0);\n\t\tfree(d);\n\t\td = fsdirfstat(fid);\n\t}\t\n\tfree(file);\n\tlen = 0;\n\tif(d != nil)\n\t\tlen = d->length;\n\tfree(d);\n\tdata = emalloc(len+1);\n\tlen = fsreadn(fid, data, len);\n\tif(len <= 0){\n\t\tfsclose(fid);\n\t\tfree(data);\n\t\treturn nil;\n\t}\n\tfsclose(fid);\n\tif(np != nil)\n\t\t*np = len;\n\treturn data;\n}\n\nchar*\ninfo(Message *m, int ind, int ogf)\n{\n\tchar *i;\n\tint j, len, lens;\n\tchar *p;\n\tchar fmt[80], s[80];\n\n\tif (ogf)\n\t\tp=m->to;\n\telse\n\t\tp=m->fromcolon;\n\n\tif(ind==0 && shortmenu){\n\t\tlen = 30;\n\t\tlens = 30;\n\t\tif(shortmenu > 1){\n\t\t\tlen = 10;\n\t\t\tlens = 25;\n\t\t}\n\t\tif(ind==0 && m->subject[0]=='\\0'){\n\t\t\tsnprint(fmt, sizeof fmt, \" %%-%d.%ds\", len, len);\n\t\t\tsnprint(s, sizeof s, fmt, p);\n\t\t}else{\n\t\t\tsnprint(fmt, sizeof fmt, \" %%-%d.%ds  %%-%d.%ds\", len, len, lens, lens);\n\t\t\tsnprint(s, sizeof s, fmt, p, m->subject);\n\t\t}\n\t\ti = estrdup(s);\n\n\t\treturn i;\n\t} \n\n\ti = estrdup(\"\");\n\ti = eappend(i, \"\\t\", p);\n\ti = egrow(i, \"\\t\", stripdate(m->date));\n\tif(ind == 0){\n\t\tif(strcmp(m->type, \"text\")!=0 && strncmp(m->type, \"text/\", 5)!=0 && \n\t\t   strncmp(m->type, \"multipart/\", 10)!=0)\n\t\t\ti = egrow(i, \"\\t(\", estrstrdup(m->type, \")\"));\n\t}else if(strncmp(m->type, \"multipart/\", 10) != 0)\n\t\ti = egrow(i, \"\\t(\", estrstrdup(m->type, \")\"));\n\tif(m->subject[0] != '\\0'){\n\t\ti = eappend(i, \"\\n\", nil);\n\t\tfor(j=0; j<ind; j++)\n\t\t\ti = eappend(i, \"\\t\", nil);\n\t\ti = eappend(i, \"\\t\", m->subject);\n\t}\n\treturn i;\n}\n\nvoid\nmesgmenu0(Window *w, Message *mbox, char *realdir, char *dir, int ind, CFid *fd, int onlyone, int dotail)\n{\n\tint i;\n\tMessage *m;\n\tchar *name, *tmp;\n\tint ogf=0;\n\n\tif(strstr(realdir, \"outgoing\") != nil)\n\t\togf=1;\n\n\t/* show mail box in reverse order, pieces in forward order */\n\tif(ind > 0)\n\t\tm = mbox->head;\n\telse\n\t\tm = mbox->tail;\n\twhile(m != nil){\n\t\tfor(i=0; i<ind; i++)\n\t\t\tfsprint(fd, \"\\t\");\n\t\tif(ind != 0)\n\t\t\tfsprint(fd, \"  \");\n\t\tname = estrstrdup(dir, m->name);\n\t\ttmp = info(m, ind, ogf);\n\t\tfsprint(fd, \"%s%s\\n\", name, tmp);\n\t\tfree(tmp);\n\t\tif(dotail && m->tail)\n\t\t\tmesgmenu0(w, m, realdir, name, ind+1, fd, 0, dotail);\n\t\tfree(name);\n\t\tif(ind)\n\t\t\tm = m->next;\n\t\telse\n\t\t\tm = m->prev;\n\t\tif(onlyone)\n\t\t\tm = nil;\n\t}\n}\n\nvoid\nmesgmenu(Window *w, Message *mbox)\n{\n\twinopenbody(w, OWRITE);\n\tmesgmenu0(w, mbox, mbox->name, \"\", 0, w->body, 0, !shortmenu);\n\twinclosebody(w);\n}\n\n/* one new message has arrived, as mbox->tail */\nvoid\nmesgmenunew(Window *w, Message *mbox)\n{\n\tBiobuf *b;\n\n\twinselect(w, \"0\", 0);\n\tw->data = winopenfile(w, \"data\");\n\tb = emalloc(sizeof(Biobuf));\n\tmesgmenu0(w, mbox, mbox->name, \"\", 0, w->data, 1, !shortmenu);\n\tfree(b);\n\tif(!mbox->dirty)\n\t\twinclean(w);\n\t/* select tag line plus following indented lines, but not final newline (it's distinctive) */\n\twinselect(w, \"0/.*\\\\n((\\t.*\\\\n)*\\t.*)?/\", 1);\n\tfsclose(w->addr);\n\tfsclose(w->data);\n\tw->addr = nil;\n\tw->data = nil;\n}\n\nchar*\nname2regexp(char *prefix, char *s)\n{\n\tchar *buf, *p, *q;\n\n\tbuf = emalloc(strlen(prefix)+2*strlen(s)+50);\t/* leave room to append more */\n\tp = buf;\n\t*p++ = '0';\n\t*p++ = '/';\n\t*p++ = '^';\n\tstrcpy(p, prefix);\n\tp += strlen(prefix);\n\tfor(q=s; *q!='\\0'; q++){\n\t\tif(strchr(regexchars, *q) != nil)\n\t\t\t*p++ = '\\\\';\n\t\t*p++ = *q;\n\t}\n\t*p++ = '/';\n\t*p = '\\0';\n\treturn buf;\n}\n\nvoid\nmesgmenumarkdel(Window *w, Message *mbox, Message *m, int writeback)\n{\n\tchar *buf;\n\n\n\tif(m->deleted)\n\t\treturn;\n\tm->writebackdel = writeback;\n\tif(w->data == nil)\n\t\tw->data = winopenfile(w, \"data\");\n\tbuf = name2regexp(\"\", m->name);\n\tstrcat(buf, \"-#0\");\n\tif(winselect(w, buf, 1))\n\t\tfswrite(w->data, deleted, 10);\n\tfree(buf);\n\tfsclose(w->data);\n\tfsclose(w->addr);\n\tw->addr = nil;\n\tw->data = nil;\n\tmbox->dirty = 1;\n\tm->deleted = 1;\n}\n\nvoid\nmesgmenumarkundel(Window *w, Message *v, Message *m)\n{\n\tchar *buf;\n\n\tUSED(v);\n\tif(m->deleted == 0)\n\t\treturn;\n\tif(w->data == nil)\n\t\tw->data = winopenfile(w, \"data\");\n\tbuf = name2regexp(deletedrx, m->name);\n\tif(winselect(w, buf, 1))\n\t\tif(winsetaddr(w, deletedaddr, 1))\n\t\t\tfswrite(w->data, \"\", 0);\n\tfree(buf);\n\tfsclose(w->data);\n\tfsclose(w->addr);\n\tw->addr = nil;\n\tw->data = nil;\n\tm->deleted = 0;\n}\n\nvoid\nmesgmenudel(Window *w, Message *mbox, Message *m)\n{\n\tchar *buf;\n\n\tif(w->data ==nil)\n\t\tw->data = winopenfile(w, \"data\");\n\tbuf = name2regexp(deletedrx01, m->name);\n\tif(winsetaddr(w, buf, 1) && winsetaddr(w, \".,./.*\\\\n(\\t.*\\\\n)*/\", 1))\n\t\tfswrite(w->data, \"\", 0);\n\tfree(buf);\n\tfsclose(w->data);\n\tfsclose(w->addr);\n\tw->addr = nil;\n\tw->data = nil;\n/* assume caller knows best\tmbox->dirty = 1; */\n\tm->deleted = 1;\n}\n\nvoid\nmesgmenumark(Window *w, char *which, char *mark)\n{\n\tchar *buf;\n\n\tif(w->data == nil)\n\t\tw->data = winopenfile(w, \"data\");\n\tbuf = name2regexp(deletedrx01, which);\n\tif(winsetaddr(w, buf, 1) && winsetaddr(w, \"+0-#1\", 1))\t/* go to end of line */\n\t\tfswrite(w->data, mark, strlen(mark));\n\tfree(buf);\n\tfsclose(w->data);\n\tfsclose(w->addr);\n\tw->addr = nil;\n\tw->data = nil;\n\tif(!mbox.dirty)\n\t\twinclean(w);\n}\n\nvoid\nmesgfreeparts(Message *m)\n{\n\tfree(m->name);\n\tfree(m->replyname);\n\tfree(m->from);\n\tfree(m->to);\n\tfree(m->cc);\n\tfree(m->replyto);\n\tfree(m->date);\n\tfree(m->subject);\n\tfree(m->type);\n\tfree(m->disposition);\n\tfree(m->filename);\n\tfree(m->digest);\n}\n\nvoid\nmesgdel(Message *mbox, Message *m)\n{\n\tMessage *n, *next;\n\n\tif(m->opened)\n\t\terror(\"internal error: deleted message still open in mesgdel\\n\");\n\t/* delete subparts */\n\tfor(n=m->head; n!=nil; n=next){\n\t\tnext = n->next;\n\t\tmesgdel(m, n);\n\t}\n\t/* remove this message from list */\n\tif(m->next)\n\t\tm->next->prev = m->prev;\n\telse\n\t\tmbox->tail = m->prev;\n\tif(m->prev)\n\t\tm->prev->next = m->next;\n\telse\n\t\tmbox->head = m->next;\n\n\tmesgfreeparts(m);\n}\n\nint\nmesgsave(Message *m, char *s, int save)\n{\n\tint ofd, n, k, ret;\n\tchar *t, *raw, *unixheader, *all;\n\n\tif(save){\n\t\tif(fsprint(mbox.ctlfd, \"save %q %q\", s, m->name) < 0){\n\t\t\tfprint(2, \"Mail: can't save %s to %s: %r\\n\", m->name, s);\n\t\t\treturn 0;\n\t\t}\n\t\treturn 1;\n\t}\n\t\t\n\tt = estrstrdup(mbox.name, m->name);\n\traw = readfile(t, \"raw\", &n);\n\tunixheader = readfile(t, \"unixheader\", &k);\n\tif(raw==nil || unixheader==nil){\n\t\tfprint(2, \"Mail: can't read %s: %r\\n\", t);\n\t\tfree(t);\n\t\treturn 0;\n\t}\n\tfree(t);\n\n\tall = emalloc(n+k+1);\n\tmemmove(all, unixheader, k);\n\tmemmove(all+k, raw, n);\n\tmemmove(all+k+n, \"\\n\", 1);\n\tn = k+n+1;\n\tfree(unixheader);\n\tfree(raw);\n\tret = 1;\n\ts = estrdup(s);\n\tif(s[0] != '/')\n\t\ts = egrow(estrdup(mailboxdir), \"/\", s);\n\tofd = open(s, OWRITE);\n\tif(ofd < 0){\n\t\tfprint(2, \"Mail: can't open %s: %r\\n\", s);\n\t\tret = 0;\n\t}else if(seek(ofd, 0LL, 2)<0 || write(ofd, all, n)!=n){\n\t\tfprint(2, \"Mail: save failed: can't write %s: %r\\n\", s);\n\t\tret = 0;\n\t}\n\tfree(all);\n\tclose(ofd);\n\tfree(s);\n\treturn ret;\n}\n\nint\nmesgcommand(Message *m, char *cmd)\n{\n\tchar *s;\n\tchar *args[10];\n\tint save, ok, ret, nargs;\n\n\ts = cmd;\n\tret = 1;\n\tnargs = tokenize(s, args, nelem(args));\n\tif(nargs == 0)\n\t\treturn 0;\n\tif(strcmp(args[0], \"Post\") == 0){\n\t\tmesgsend(m);\n\t\tgoto Return;\n\t}\n\tif(strncmp(args[0], \"Save\", 4) == 0 || strncmp(args[0], \"Write\", 5) == 0){\n\t\tif(m->isreply)\n\t\t\tgoto Return;\n\t\tsave = args[0][0]=='S';\n\t\tif(save)\n\t\t\ts = estrdup(\"\\t[saved\");\n\t\telse\n\t\t\ts = estrdup(\"\\t[wrote\");\n\t\tif(nargs==1 || strcmp(args[1], \"\")==0){\n\t\t\tok = mesgsave(m, \"stored\", save);\n\t\t}else{\n\t\t\tok = mesgsave(m, args[1], save);\n\t\t\ts = eappend(s, \" \", args[1]);\n\t\t}\n\t\tif(ok){\n\t\t\ts = egrow(s, \"]\", nil);\n\t\t\tmesgmenumark(mbox.w, m->name, s);\n\t\t}\n\t\tfree(s);\n\t\tgoto Return;\n\t}\n\tif(strcmp(args[0], \"Reply\")==0){\n\t\tif(nargs>=2 && strcmp(args[1], \"all\")==0)\n\t\t\tmkreply(m, \"Replyall\", nil, nil, nil);\n\t\telse\n\t\t\tmkreply(m, \"Reply\", nil, nil, nil);\n\t\tgoto Return;\n\t}\n\tif(strcmp(args[0], \"Q\") == 0){\n\t\ts = winselection(m->w);\t/* will be freed by mkreply */\n\t\tif(nargs>=3 && strcmp(args[1], \"Reply\")==0 && strcmp(args[2], \"all\")==0)\n\t\t\tmkreply(m, \"QReplyall\", nil, nil, s);\n\t\telse\n\t\t\tmkreply(m, \"QReply\", nil, nil, s);\n\t\tgoto Return;\n\t}\n\tif(strcmp(args[0], \"Del\") == 0){\n\t\tif(windel(m->w, 0)){\n\t\t\twindecref(m->w);\n\t\t\tm->w = nil;\n\t\t\tif(m->isreply)\n\t\t\t\tdelreply(m);\n\t\t\telse{\n\t\t\t\tm->opened = 0;\n\t\t\t\tm->tagposted = 0;\n\t\t\t}\n\t\t\tfree(cmd);\n\t\t\tthreadexits(nil);\n\t\t}\n\t\tgoto Return;\n\t}\n\tif(strcmp(args[0], \"Delmesg\") == 0){\n\t\tif(!m->isreply){\n\t\t\tmesgmenumarkdel(wbox, &mbox, m, 1);\n\t\t\tfree(cmd);\t/* mesgcommand might not return */\n\t\t\tmesgcommand(m, estrdup(\"Del\"));\n\t\t\treturn 1;\n\t\t}\n\t\tgoto Return;\n\t}\n\tif(strcmp(args[0], \"UnDelmesg\") == 0){\n\t\tif(!m->isreply && m->deleted)\n\t\t\tmesgmenumarkundel(wbox, &mbox, m);\n\t\tgoto Return;\n\t}\n/*\tif(strcmp(args[0], \"Headers\") == 0){ */\n/*\t\tm->showheaders(); */\n/*\t\treturn True; */\n/*\t} */\n\n\tret = 0;\n\n    Return:\n\tfree(cmd);\n\treturn ret;\n}\n\nvoid\nmesgtagpost(Message *m)\n{\n\tif(m->tagposted)\n\t\treturn;\n\twintagwrite(m->w, \" Post\", 5);\n\tm->tagposted = 1;\n}\n\n/* need to expand selection more than default word */\n#pragma varargck argpos eval 2\n\nlong\neval(Window *w, char *s, ...)\n{\n\tchar buf[64];\n\tva_list arg;\n\n\tva_start(arg, s);\n\tvsnprint(buf, sizeof buf, s, arg);\n\tva_end(arg);\n\n\tif(winsetaddr(w, buf, 1)==0)\n\t\treturn -1;\n\n\tif(fspread(w->addr, buf, 24, 0) != 24)\n\t\treturn -1;\n\treturn strtol(buf, 0, 10);\n}\n\nint\nisemail(char *s)\n{\n\tint nat;\n\n\tnat = 0;\n\tfor(; *s; s++)\n\t\tif(*s == '@')\n\t\t\tnat++;\n\t\telse if(!isalpha(*s) && !isdigit(*s) && !strchr(\"_.-+/\", *s))\n\t\t\treturn 0;\n\treturn nat==1;\n}\n\nchar addrdelim[] =  \"/[ \\t\\\\n<>()\\\\[\\\\]]/\";\nchar*\nexpandaddr(Window *w, Event *e)\n{\n\tchar *s;\n\tlong q0, q1;\n\n\tif(e->q0 != e->q1)\t/* cannot happen */\n\t\treturn nil;\n\n\tq0 = eval(w, \"#%d-%s\", e->q0, addrdelim);\n\tif(q0 == -1)\t/* bad char not found */\n\t\tq0 = 0;\n\telse\t\t\t/* increment past bad char */\n\t\tq0++;\n\n\tq1 = eval(w, \"#%d+%s\", e->q0, addrdelim);\n\tif(q1 < 0){\n\t\tq1 = eval(w, \"$\");\n\t\tif(q1 < 0)\n\t\t\treturn nil;\n\t}\n\tif(q0 >= q1)\n\t\treturn nil;\n\ts = emalloc((q1-q0)*UTFmax+1);\n\twinread(w, q0, q1, s);\n\treturn s;\n}\n\nint\nreplytoaddr(Window *w, Message *m, Event *e, char *s)\n{\n\tint did;\n\tchar *buf;\n\tPlumbmsg *pm;\n\n\tbuf = nil;\n\tdid = 0;\n\tif(e->flag & 2){\n\t\t/* autoexpanded; use our own bigger expansion */\n\t\tbuf = expandaddr(w, e);\n\t\tif(buf == nil)\n\t\t\treturn 0;\n\t\ts = buf;\n\t}\n\tif(isemail(s)){\n\t\tdid = 1;\n\t\tpm = emalloc(sizeof(Plumbmsg));\n\t\tpm->src = estrdup(\"Mail\");\n\t\tpm->dst = estrdup(\"sendmail\");\n\t\tpm->data = estrdup(s);\n\t\tpm->ndata = -1;\n\t\tif(m->subject && m->subject[0]){\n\t\t\tpm->attr = emalloc(sizeof(Plumbattr));\n\t\t\tpm->attr->name = estrdup(\"Subject\");\n\t\t\tif(tolower(m->subject[0]) != 'r' || tolower(m->subject[1]) != 'e' || m->subject[2] != ':')\n\t\t\t\tpm->attr->value = estrstrdup(\"Re: \", m->subject);\n\t\t\telse\n\t\t\t\tpm->attr->value = estrdup(m->subject);\n\t\t\tpm->attr->next = nil;\n\t\t}\n\t\tif(plumbsendtofid(plumbsendfd, pm) < 0)\n\t\t\tfprint(2, \"error writing plumb message: %r\\n\");\n\t\tplumbfree(pm);\n\t}\n\tfree(buf);\n\treturn did;\n}\n\n\nvoid\nmesgctl(void *v)\n{\n\tMessage *m;\n\tWindow *w;\n\tEvent *e, *eq, *e2, *ea;\n\tint na, nopen, i, j;\n\tchar *os, *s, *t, *buf;\n\n\tm = v;\n\tw = m->w;\n\tthreadsetname(\"mesgctl\");\n\twinincref(w);\n\tproccreate(wineventproc, w, STACK);\n\tfor(;;){\n\t\te = recvp(w->cevent);\n\t\tswitch(e->c1){\n\t\tdefault:\n\t\tUnk:\n\t\t\tprint(\"unknown message %c%c\\n\", e->c1, e->c2);\n\t\t\tbreak;\n\n\t\tcase 'E':\t/* write to body; can't affect us */\n\t\t\tbreak;\n\n\t\tcase 'F':\t/* generated by our actions; ignore */\n\t\t\tbreak;\n\n\t\tcase 'K':\t/* type away; we don't care */\n\t\tcase 'M':\n\t\t\tswitch(e->c2){\n\t\t\tcase 'x':\t/* mouse only */\n\t\t\tcase 'X':\n\t\t\t\tea = nil;\n\t\t\t\teq = e;\n\t\t\t\tif(e->flag & 2){\n\t\t\t\t\te2 = recvp(w->cevent);\n\t\t\t\t\teq = e2;\n\t\t\t\t}\n\t\t\t\tif(e->flag & 8){\n\t\t\t\t\tea = recvp(w->cevent);\n\t\t\t\t\trecvp(w->cevent);\n\t\t\t\t\tna = ea->nb;\n\t\t\t\t}else\n\t\t\t\t\tna = 0;\n\t\t\t\tif(eq->q1>eq->q0 && eq->nb==0){\n\t\t\t\t\ts = emalloc((eq->q1-eq->q0)*UTFmax+1);\n\t\t\t\t\twinread(w, eq->q0, eq->q1, s);\n\t\t\t\t}else\n\t\t\t\t\ts = estrdup(eq->b);\n\t\t\t\tif(na){\n\t\t\t\t\tt = emalloc(strlen(s)+1+na+1);\n\t\t\t\t\tsprint(t, \"%s %s\", s, ea->b);\n\t\t\t\t\tfree(s);\n\t\t\t\t\ts = t;\n\t\t\t\t}\n\t\t\t\tif(!mesgcommand(m, s))\t/* send it back */\n\t\t\t\t\twinwriteevent(w, e);\n\t\t\t\tbreak;\n\n\t\t\tcase 'l':\t/* mouse only */\n\t\t\tcase 'L':\n\t\t\t\tbuf = nil;\n\t\t\t\teq = e;\n\t\t\t\tif(e->flag & 2){\n\t\t\t\t\te2 = recvp(w->cevent);\n\t\t\t\t\teq = e2;\n\t\t\t\t}\n\t\t\t\ts = eq->b;\n\t\t\t\tif(eq->q1>eq->q0 && eq->nb==0){\n\t\t\t\t\tbuf = emalloc((eq->q1-eq->q0)*UTFmax+1);\n\t\t\t\t\twinread(w, eq->q0, eq->q1, buf);\n\t\t\t\t\ts = buf;\n\t\t\t\t}\n\t\t\t\tos = s;\n\t\t\t\tnopen = 0;\n\t\t\t\tdo{\n\t\t\t\t\t/* skip mail box name if present */\n\t\t\t\t\tif(strncmp(s, mbox.name, strlen(mbox.name)) == 0)\n\t\t\t\t\t\ts += strlen(mbox.name);\n\t\t\t\t\tif(strstr(s, \"body\") != nil){\n\t\t\t\t\t\t/* strip any known extensions */\n\t\t\t\t\t\tfor(i=0; ports[i].suffix!=nil; i++){\n\t\t\t\t\t\t\tj = strlen(ports[i].suffix);\n\t\t\t\t\t\t\tif(strlen(s)>j && strcmp(s+strlen(s)-j, ports[i].suffix)==0){\n\t\t\t\t\t\t\t\ts[strlen(s)-j] = '\\0';\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(strlen(s)>5 && strcmp(s+strlen(s)-5, \"/body\")==0)\n\t\t\t\t\t\t\ts[strlen(s)-4] = '\\0';\t/* leave / in place */\n\t\t\t\t\t}\n\t\t\t\t\tnopen += mesgopen(&mbox, mbox.name, s, m, 0, nil);\n\t\t\t\t\twhile(*s!=0 && *s++!='\\n')\n\t\t\t\t\t\t;\n\t\t\t\t}while(*s);\n\t\t\t\tif(nopen == 0 && e->c1 == 'L')\n\t\t\t\t\tnopen += replytoaddr(w, m, e, os);\n\t\t\t\tif(nopen == 0)\n\t\t\t\t\twinwriteevent(w, e);\n\t\t\t\tfree(buf);\n\t\t\t\tbreak;\n\n\t\t\tcase 'I':\t/* modify away; we don't care */\n\t\t\tcase 'D':\n\t\t\t\tmesgtagpost(m);\n\t\t\t\t/* fall through */\n\t\t\tcase 'd':\n\t\t\tcase 'i':\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tgoto Unk;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid\nmesgline(Message *m, char *header, char *value)\n{\n\tif(strlen(value) > 0)\n\t\tfsprint(m->w->body, \"%s: %s\\n\", header, value);\n}\n\nint\nisprintable(char *type)\n{\n\tint i;\n\n\tfor(i=0; goodtypes[i]!=nil; i++)\n\t\tif(strcmp(type, goodtypes[i])==0)\n\t\t\treturn 1;\n\treturn 0;\n}\n\nchar*\next(char *type)\n{\n\tint i;\n\n\tfor(i=0; ports[i].type!=nil; i++)\n\t\tif(strcmp(type, ports[i].type)==0)\n\t\t\treturn ports[i].suffix;\n\treturn \"\";\n}\n\nvoid\nmimedisplay(Message *m, char *name, char *rootdir, Window *w, int fileonly)\n{\n\tchar *dest;\n\n\tif(strcmp(m->disposition, \"file\")==0 || strlen(m->filename)!=0 || !fileonly){\n\t\tif(strlen(m->filename) == 0)\n\t\t\tdest = estrstrdup(\"a\", ext(m->type));\n\t\telse\n\t\t\tdest = estrdup(m->filename);\n\t\tif(m->filename[0] != '/')\n\t\t\tdest = egrow(estrdup(home), \"/\", dest);\n\t\tfsprint(w->body, \"\\t9p read %s/%s/%sbody > %s\\n\",\n\t\t\tsrvname, mboxname, name, dest);\n\t\tfree(dest);\n\t}\n}\n\nvoid\nprintheader(char *dir, CFid *fid, char **okheaders)\n{\n\tchar *s;\n\tchar *lines[100];\n\tint i, j, n;\n\n\ts = readfile(dir, \"header\", nil);\n\tif(s == nil)\n\t\treturn;\n\tn = getfields(s, lines, nelem(lines), 0, \"\\n\");\n\tfor(i=0; i<n; i++)\n\t\tfor(j=0; okheaders[j]; j++)\n\t\t\tif(cistrncmp(lines[i], okheaders[j], strlen(okheaders[j])) == 0)\n\t\t\t\tfsprint(fid, \"%s\\n\", lines[i]);\n\tfree(s);\n}\n\nvoid\nmesgload(Message *m, char *rootdir, char *file, Window *w)\n{\n\tchar *s, *subdir, *name, *dir;\n\tMessage *mp, *thisone;\n\tint n;\n\n\tdir = estrstrdup(rootdir, file);\n\n\tif(strcmp(m->type, \"message/rfc822\") != 0){\t/* suppress headers of envelopes */\n\t\tif(strlen(m->from) > 0){\n\t\t\tfsprint(w->body, \"From: %s\\n\", m->from);\n\t\t\tmesgline(m, \"Date\", m->date);\n\t\t\tmesgline(m, \"To\", m->to);\n\t\t\tmesgline(m, \"CC\", m->cc);\n\t\t\tmesgline(m, \"Subject\", m->subject);\n\t\t\tprintheader(dir, w->body, extraheaders);\n\t\t}else{\n\t\t\tprintheader(dir, w->body, okheaders);\n\t\t\tprintheader(dir, w->body, extraheaders);\n\t\t}\n\t\tfsprint(w->body, \"\\n\");\n\t}\n\n\tif(m->level == 1 && m->recursed == 0){\n\t\tm->recursed = 1;\n\t\treadmbox(m, rootdir, m->name);\n\t}\n\tif(m->head == nil){\t/* single part message */\n\t\tif(strcmp(m->type, \"text\")==0 || strncmp(m->type, \"text/\", 5)==0){\n\t\t\tmimedisplay(m, m->name, rootdir, w, 1);\n\t\t\ts = readbody(m->type, dir, &n);\n\t\t\twinwritebody(w, s, n);\n\t\t\tfree(s);\n\t\t}else\n\t\t\tmimedisplay(m, m->name, rootdir, w, 0);\n\t}else{\n\t\t/* multi-part message, either multipart/* or message/rfc822 */\n\t\tthisone = nil;\n\t\tif(strcmp(m->type, \"multipart/alternative\") == 0){\n\t\t\tthisone = m->head;\t/* in case we can't find a good one */\n\t\t\tfor(mp=m->head; mp!=nil; mp=mp->next)\n\t\t\t\tif(isprintable(mp->type)){\n\t\t\t\t\tthisone = mp;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t}\n\t\tfor(mp=m->head; mp!=nil; mp=mp->next){\n\t\t\tif(thisone!=nil && mp!=thisone)\n\t\t\t\tcontinue;\n\t\t\tsubdir = estrstrdup(dir, mp->name);\n\t\t\tname = estrstrdup(file, mp->name);\n\t\t\t/* skip first element in name because it's already in window name */\n\t\t\tif(mp != m->head)\n\t\t\t\tfsprint(w->body, \"\\n===> %s (%s) [%s]\\n\", strchr(name, '/')+1, mp->type, mp->disposition);\n\t\t\tif(strcmp(mp->type, \"text\")==0 || strncmp(mp->type, \"text/\", 5)==0){\n\t\t\t\tmimedisplay(mp, name, rootdir, w, 1);\n\t\t\t\tprintheader(subdir, w->body, okheaders);\n\t\t\t\tprintheader(subdir, w->body, extraheaders);\n\t\t\t\twinwritebody(w, \"\\n\", 1);\n\t\t\t\ts = readbody(mp->type, subdir, &n);\n\t\t\t\twinwritebody(w, s, n);\n\t\t\t\tfree(s);\n\t\t\t}else{\n\t\t\t\tif(strncmp(mp->type, \"multipart/\", 10)==0 || strcmp(mp->type, \"message/rfc822\")==0){\n\t\t\t\t\tmp->w = w;\n\t\t\t\t\tmesgload(mp, rootdir, name, w);\n\t\t\t\t\tmp->w = nil;\n\t\t\t\t}else\n\t\t\t\t\tmimedisplay(mp, name, rootdir, w, 0);\n\t\t\t}\n\t\t\tfree(name);\n\t\t\tfree(subdir);\n\t\t}\n\t}\n\tfree(dir);\n}\n\nint\ntokenizec(char *str, char **args, int max, char *splitc)\n{\n\tint i, na;\n\tint intok = 0;\n\tchar *p;\n\n\tif(max <= 0)\n\t\treturn 0;\n\t\t\n/*\tif(strchr(str, ',') || strchr(str, '\"') || strchr(str, '<') || strchr(str, '(')) */\n/*\t\tsplitc = \",\"; */\n\tfor(na=0; *str != '\\0';str++){\n\t\tif(strchr(splitc, *str) == nil){\n\t\t\tif(intok)\n\t\t\t\tcontinue;\n\t\t\targs[na++] = str;\n\t\t\tintok = 1;\n\t\t}else{\n\t\t\t/* it's a separator/skip character */\n\t\t\t*str = '\\0';\n\t\t\tif(intok){\n\t\t\t\tintok = 0;\n\t\t\t\tif(na >= max)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tfor(i=0; i<na; i++){\n\t\twhile(*args[i] && strchr(\" \\t\\r\\n\", *args[i]))\n\t\t\targs[i]++;\n\t\tp = args[i]+strlen(args[i]);\n\t\twhile(p>args[i] && strchr(\" \\t\\r\\n\", *(p-1)))\n\t\t\t*--p = 0;\n\t}\n\treturn na;\n}\n\nMessage*\nmesglookup(Message *mbox, char *name, char *digest)\n{\n\tint n;\n\tMessage *m;\n\tchar *t;\n\n\tif(digest && digest[0]){\n\t\t/* can find exactly */\n\t\tfor(m=mbox->head; m!=nil; m=m->next)\n\t\t\tif(strcmp(digest, m->digest) == 0)\n\t\t\t\tbreak;\n\t\treturn m;\n\t}\n\n\tn = strlen(name);\n\tif(n == 0)\n\t\treturn nil;\n\tif(name[n-1] == '/')\n\t\tt = estrdup(name);\n\telse\n\t\tt = estrstrdup(name, \"/\");\n\tfor(m=mbox->head; m!=nil; m=m->next)\n\t\tif(strcmp(t, m->name) == 0)\n\t\t\tbreak;\n\tfree(t);\n\treturn m;\n}\n\n/*\n * Find plumb port, knowing type is text, given file name (by extension)\n */\nint\nplumbportbysuffix(char *file)\n{\n\tchar *suf;\n\tint i, nsuf, nfile;\n\n\tnfile = strlen(file);\n\tfor(i=0; ports[i].type!=nil; i++){\n\t\tsuf = ports[i].suffix;\n\t\tnsuf = strlen(suf);\n\t\tif(nfile > nsuf)\n\t\t\tif(cistrncmp(file+nfile-nsuf, suf, nsuf) == 0)\n\t\t\t\treturn i;\n\t}\n\treturn 0;\n}\n\n/*\n * Find plumb port using type and file name (by extension)\n */\nint\nplumbport(char *type, char *file)\n{\n\tint i;\n\n\tfor(i=0; ports[i].type!=nil; i++)\n\t\tif(strncmp(type, ports[i].type, strlen(ports[i].type)) == 0)\n\t\t\treturn i;\n\t/* see if it's a text type */\n\tfor(i=0; goodtypes[i]!=nil; i++)\n\t\tif(strncmp(type, goodtypes[i], strlen(goodtypes[i])) == 0)\n\t\t\treturn plumbportbysuffix(file);\n\treturn -1;\n}\n\nvoid\nplumb(Message *m, char *dir)\n{\n\tint i;\n\tchar *port;\n\tPlumbmsg *pm;\n\n\tif(strlen(m->type) == 0)\n\t\treturn;\n\ti = plumbport(m->type, m->filename);\n\tif(i < 0)\n\t\tfprint(2, \"can't find destination for message subpart\\n\");\n\telse{\n\t\tport = ports[i].port;\n\t\tpm = emalloc(sizeof(Plumbmsg));\n\t\tpm->src = estrdup(\"Mail\");\n\t\tif(port)\n\t\t\tpm->dst = estrdup(port);\n\t\telse\n\t\t\tpm->dst = nil;\n\t\tpm->wdir = nil;\n\t\tpm->type = estrdup(\"text\");\n\t\tpm->ndata = -1;\n\t\tpm->data = estrstrdup(dir, \"body\");\n\t\tpm->data = eappend(pm->data, \"\", ports[i].suffix);\n\t\tif(plumbsendtofid(plumbsendfd, pm) < 0)\n\t\t\tfprint(2, \"error writing plumb message: %r\\n\");\n\t\tplumbfree(pm);\n\t}\n}\n\nint\nmesgopen(Message *mbox, char *dir, char *s, Message *mesg, int plumbed, char *digest)\n{\n\tchar *t, *u, *v;\n\tMessage *m;\n\tchar *direlem[10];\n\tint i, ndirelem, reuse;\n\n\t/* find white-space-delimited first word */\n\tfor(t=s; *t!='\\0' && !isspace(*t); t++)\n\t\t;\n\tu = emalloc(t-s+1);\n\tmemmove(u, s, t-s);\n\t/* separate it on slashes */\n\tndirelem = tokenizec(u, direlem, nelem(direlem), \"/\");\n\tif(ndirelem <= 0){\n    Error:\n\t\tfree(u);\n\t\treturn 0;\n\t}\n\t/*XXX\n\tif(plumbed)\n\t\tdrawtopwindow();\n\t*/\n\t/* open window for message */\n\tm = mesglookup(mbox, direlem[0], digest);\n\tif(m == nil)\n\t\tgoto Error;\n\tif(mesg!=nil && m!=mesg)\t/* string looked like subpart but isn't part of this message */\n\t\tgoto Error;\n\tif(m->opened == 0){\n\t\tif(m->w == nil){\n\t\t\treuse = 0;\n\t\t\tm->w = newwindow();\n\t\t}else{\n\t\t\treuse = 1;\n\t\t\t/* re-use existing window */\n\t\t\tif(winsetaddr(m->w, \"0,$\", 1)){\n\t\t\t\tif(m->w->data == nil)\n\t\t\t\t\tm->w->data = winopenfile(m->w, \"data\");\n\t\t\t\tfswrite(m->w->data, \"\", 0);\n\t\t\t}\n\t\t}\n\t\tv = estrstrdup(mbox->name, m->name);\n\t\twinname(m->w, v);\n\t\tfree(v);\n\t\tif(!reuse){\n\t\t\tif(m->deleted)\n\t\t\t\twintagwrite(m->w, \"Q Reply all UnDelmesg Save \", 2+6+4+10+5);\n\t\t\telse\n\t\t\t\twintagwrite(m->w, \"Q Reply all Delmesg Save \", 2+6+4+8+5);\n\t\t}\n\t\tthreadcreate(mesgctl, m, STACK);\n\t\twinopenbody(m->w, OWRITE);\n\t\tmesgload(m, dir, m->name, m->w);\n\t\twinclosebody(m->w);\n\t\t/* sleep(100); */\n\t\twinclean(m->w);\n\t\tm->opened = 1;\n\t\tif(ndirelem == 1){\n\t\t\tfree(u);\n\t\t\treturn 1;\n\t\t}\n\t}\n\tif(ndirelem == 1 && plumbport(m->type, m->filename) <= 0){\n\t\t/* make sure dot is visible */\n\t\tctlprint(m->w->ctl, \"show\\n\");\n\t\treturn 0;\n\t}\n\t/* walk to subpart */\n\tdir = estrstrdup(dir, m->name);\n\tfor(i=1; i<ndirelem; i++){\n\t\tm = mesglookup(m, direlem[i], digest);\n\t\tif(m == nil)\n\t\t\tbreak;\n\t\tdir = egrow(dir, m->name, nil);\n\t}\n\tif(m != nil && plumbport(m->type, m->filename) > 0)\n\t\tplumb(m, dir);\n\tfree(dir);\n\tfree(u);\n\treturn 1;\n}\n\nvoid\nrewritembox(Window *w, Message *mbox)\n{\n\tMessage *m, *next;\n\tchar *deletestr, *t;\n\tint nopen;\n\n\tdeletestr = estrstrdup(\"delete \", fsname);\n\n\tnopen = 0;\n\tfor(m=mbox->head; m!=nil; m=next){\n\t\tnext = m->next;\n\t\tif(m->deleted == 0)\n\t\t\tcontinue;\n\t\tif(m->opened){\n\t\t\tnopen++;\n\t\t\tcontinue;\n\t\t}\n\t\tif(m->writebackdel){\n\t\t\t/* messages deleted by plumb message are not removed again */\n\t\t\tt = estrdup(m->name);\n\t\t\tif(strlen(t) > 0)\n\t\t\t\tt[strlen(t)-1] = '\\0';\n\t\t\tdeletestr = egrow(deletestr, \" \", t);\n\t\t}\n\t\tmesgmenudel(w, mbox, m);\n\t\tmesgdel(mbox, m);\n\t}\n\tif(fswrite(mbox->ctlfd, deletestr, strlen(deletestr)) < 0)\n\t\tfprint(2, \"Mail: warning: error removing mail message files: %r\\n\");\n\tfree(deletestr);\n\twinselect(w, \"0\", 0);\n\tif(nopen == 0)\n\t\twinclean(w);\n\tmbox->dirty = 0;\n}\n\n/* name is a full file name, but it might not belong to us */\nMessage*\nmesglookupfile(Message *mbox, char *name, char *digest)\n{\n\tint k, n;\n\n\tk = strlen(name);\n\tn = strlen(mbox->name);\n\tif(k==0 || strncmp(name, mbox->name, n) != 0){\n/*\t\tfprint(2, \"Mail: message %s not in this mailbox\\n\", name); */\n\t\treturn nil;\n\t}\n\treturn mesglookup(mbox, name+n, digest);\n}\n", "source": "acme2k/src/cmd/acme/mail/mesg.c", "file_type": "c"}
{"text": "#include <u.h>\n#include <libc.h>\n#include <bio.h>\n#include <thread.h>\n#include <plumb.h>\n#include <9pclient.h>\n#include \"dat.h\"\n\nvoid*\nemalloc(uint n)\n{\n\tvoid *p;\n\n\tp = malloc(n);\n\tif(p == nil)\n\t\terror(\"can't malloc: %r\");\n\tmemset(p, 0, n);\n\tsetmalloctag(p, getcallerpc(&n));\n\treturn p;\n}\n\nvoid*\nerealloc(void *p, uint n)\n{\n\tp = realloc(p, n);\n\tif(p == nil)\n\t\terror(\"can't realloc: %r\");\n\tsetmalloctag(p, getcallerpc(&n));\n\treturn p;\n}\n\nchar*\nestrdup(char *s)\n{\n\tchar *t;\n\n\tt = emalloc(strlen(s)+1);\n\tstrcpy(t, s);\n\treturn t;\n}\n\nchar*\nestrstrdup(char *s, char *t)\n{\n\tchar *u;\n\n\tu = emalloc(strlen(s)+strlen(t)+1);\n\tstrcpy(u, s);\n\tstrcat(u, t);\n\treturn u;\n}\n\nchar*\neappend(char *s, char *sep, char *t)\n{\n\tchar *u;\n\n\tif(t == nil)\n\t\tu = estrstrdup(s, sep);\n\telse{\n\t\tu = emalloc(strlen(s)+strlen(sep)+strlen(t)+1);\n\t\tstrcpy(u, s);\n\t\tstrcat(u, sep);\n\t\tstrcat(u, t);\n\t}\n\tfree(s);\n\treturn u;\n}\n\nchar*\negrow(char *s, char *sep, char *t)\n{\n\ts = eappend(s, sep, t);\n\tfree(t);\n\treturn s;\n}\n\nvoid\nerror(char *fmt, ...)\n{\n\tFmt f;\n\tchar buf[64];\n\tva_list arg;\n\n\tfmtfdinit(&f, 2, buf, sizeof buf);\n\tfmtprint(&f, \"Mail: \");\n\tva_start(arg, fmt);\n\tfmtvprint(&f, fmt, arg);\n\tva_end(arg);\n\tfmtprint(&f, \"\\n\");\n\tfmtfdflush(&f);\n\tthreadexitsall(fmt);\n}\n\nvoid\nctlprint(CFid *fd, char *fmt, ...)\n{\n\tint n;\n\tva_list arg;\n\n\tva_start(arg, fmt);\n\tn = fsvprint(fd, fmt, arg);\n\tva_end(arg);\n\tif(n <= 0)\n\t\terror(\"control file write error: %r\");\n}\n\n", "source": "acme2k/src/cmd/acme/mail/util.c", "file_type": "c"}
{"text": "#include <u.h>\n#include <libc.h>\n#include <bio.h>\n#include <thread.h>\n#include <9pclient.h>\n#include <plumb.h>\n#include <ctype.h>\n#include \"dat.h\"\n\nchar\t*maildir = \"Mail/\";\t\t\t/* mountpoint of mail file system */\nchar *mboxname = \"mbox\";\t\t\t/* mailboxdir/mboxname is mail spool file */\nchar\t*mailboxdir = nil;\t\t\t\t/* nil == /mail/box/$user */\nchar *fsname;\t\t\t\t\t\t/* filesystem for mailboxdir/mboxname is at maildir/fsname */\nchar\t*user;\nchar\t*outgoing;\nchar *srvname;\n\nWindow\t*wbox;\nMessage\tmbox;\nMessage\treplies;\nchar\t\t*home;\nCFid\t\t*plumbsendfd;\nCFid\t\t*plumbseemailfd;\nCFid\t\t*plumbshowmailfd;\nCFid\t\t*plumbsendmailfd;\nChannel\t*cplumb;\nChannel\t*cplumbshow;\nChannel\t*cplumbsend;\nint\t\twctlfd;\nvoid\t\tmainctl(void*);\nvoid\t\tplumbproc(void*);\nvoid\t\tplumbshowproc(void*);\nvoid\t\tplumbsendproc(void*);\nvoid\t\tplumbthread(void);\nvoid\t\tplumbshowthread(void*);\nvoid\t\tplumbsendthread(void*);\n\nint\t\t\tshortmenu;\n\nCFsys *mailfs;\nCFsys *acmefs;\n\nvoid\nusage(void)\n{\n\tfprint(2, \"usage: Mail [-sS] [-n srvname] [-o outgoing] [mailboxname [directoryname]]\\n\");\n\tthreadexitsall(\"usage\");\n}\n\nvoid\nremoveupasfs(void)\n{\n\tchar buf[256];\n\n\tif(strcmp(mboxname, \"mbox\") == 0)\n\t\treturn;\n\tsnprint(buf, sizeof buf, \"close %s\", mboxname);\n\tfswrite(mbox.ctlfd, buf, strlen(buf));\n}\n\nint\nismaildir(char *s)\n{\n\tDir *d;\n\tint ret;\n\n\td = fsdirstat(mailfs, s);\n\tif(d == nil)\n\t\treturn 0;\n\tret = d->qid.type & QTDIR;\n\tfree(d);\n\treturn ret;\n}\n\nvoid\nthreadmain(int argc, char *argv[])\n{\n\tchar *s, *name;\n\tchar err[ERRMAX], *cmd;\n\tint i, newdir;\n\tFmt fmt;\n\n\tdoquote = needsrcquote;\n\tquotefmtinstall();\n\n\t/* open these early so we won't miss notification of new mail messages while we read mbox */\n\tif((plumbsendfd = plumbopenfid(\"send\", OWRITE|OCEXEC)) == nil)\n\t\tfprint(2, \"warning: open plumb/send: %r\\n\");\n\tif((plumbseemailfd = plumbopenfid(\"seemail\", OREAD|OCEXEC)) == nil)\n\t\tfprint(2, \"warning: open plumb/seemail: %r\\n\");\n\tif((plumbshowmailfd = plumbopenfid(\"showmail\", OREAD|OCEXEC)) == nil)\n\t\tfprint(2, \"warning: open plumb/showmail: %r\\n\");\n\n\tshortmenu = 0;\n\tsrvname = \"mail\";\n\tARGBEGIN{\n\tcase 's':\n\t\tshortmenu = 1;\n\t\tbreak;\n\tcase 'S':\n\t\tshortmenu = 2;\n\t\tbreak;\n\tcase 'o':\n\t\toutgoing = EARGF(usage());\n\t\tbreak;\n\tcase 'm':\n\t\tsmprint(maildir, \"%s/\", EARGF(usage()));\n\t\tbreak;\n\tcase 'n':\n\t\tsrvname = EARGF(usage());\n\t\tbreak;\n\tdefault:\n\t\tusage();\n\t}ARGEND\n\n\tacmefs = nsmount(\"acme\",nil);\n\tif(acmefs == nil)\n\t\terror(\"cannot mount acme: %r\");\n\tmailfs = nsmount(srvname, nil);\n\tif(mailfs == nil)\n\t\terror(\"cannot mount %s: %r\", srvname);\n\n\tname = \"mbox\";\n\n\tnewdir = 1;\n\tif(argc > 0){\n\t\ti = strlen(argv[0]);\n\t\tif(argc>2 || i==0)\n\t\t\tusage();\n\t\t/* see if the name is that of an existing /mail/fs directory */\n\t\tif(argc==1 && argv[0][0] != '/' && ismaildir(argv[0])){\n\t\t\tname = argv[0];\n\t\t\tmboxname = estrdup(name);\n\t\t\tnewdir = 0;\n\t\t}else{\n\t\t\tif(argv[0][i-1] == '/')\n\t\t\t\targv[0][i-1] = '\\0';\n\t\t\ts = strrchr(argv[0], '/');\n\t\t\tif(s == nil)\n\t\t\t\tmboxname = estrdup(argv[0]);\n\t\t\telse{\n\t\t\t\t*s++ = '\\0';\n\t\t\t\tif(*s == '\\0')\n\t\t\t\t\tusage();\n\t\t\t\tmailboxdir = argv[0];\n\t\t\t\tmboxname = estrdup(s);\n\t\t\t}\n\t\t\tif(argc > 1)\n\t\t\t\tname = argv[1];\n\t\t\telse\n\t\t\t\tname = mboxname;\n\t\t}\n\t}\n\n\tuser = getenv(\"user\");\n\tif(user == nil)\n\t\tuser = \"none\";\n\thome = getenv(\"home\");\n\tif(home == nil)\n\t\thome = getenv(\"HOME\");\n\tif(home == nil)\n\t\terror(\"can't find $home\");\n\tif(mailboxdir == nil)\n\t\tmailboxdir = estrstrdup(home, \"/mail\");\n\tif(outgoing == nil)\n\t\toutgoing = estrstrdup(mailboxdir, \"/outgoing\");\n\n\tmbox.ctlfd = fsopen(mailfs, estrstrdup(mboxname, \"/ctl\"), OWRITE);\n\tif(mbox.ctlfd == nil)\n\t\terror(\"can't open %s: %r\", estrstrdup(mboxname, \"/ctl\"));\n\n\tfsname = estrdup(name);\n\tif(newdir && argc > 0){\n\t\ts = emalloc(5+strlen(mailboxdir)+strlen(mboxname)+strlen(name)+10+1);\n\t\tfor(i=0; i<10; i++){\n\t\t\tsprint(s, \"open %s/%s %s\", mailboxdir, mboxname, fsname);\n\t\t\tif(fswrite(mbox.ctlfd, s, strlen(s)) >= 0)\n\t\t\t\tbreak;\n\t\t\terr[0] = '\\0';\n\t\t\terrstr(err, sizeof err);\n\t\t\tif(strstr(err, \"mbox name in use\") == nil)\n\t\t\t\terror(\"can't create directory %s for mail: %s\", name, err);\n\t\t\tfree(fsname);\n\t\t\tfsname = emalloc(strlen(name)+10);\n\t\t\tsprint(fsname, \"%s-%d\", name, i);\n\t\t}\n\t\tif(i == 10)\n\t\t\terror(\"can't open %s/%s: %r\", mailboxdir, mboxname);\n\t\tfree(s);\n\t}\n\n\ts = estrstrdup(fsname, \"/\");\n\tmbox.name = estrstrdup(maildir, s);\n\tmbox.level= 0;\n\treadmbox(&mbox, maildir, s);\n\thome = getenv(\"home\");\n\tif(home == nil)\n\t\thome = \"/\";\n\n\twbox = newwindow();\n\twinname(wbox, mbox.name);\n\twintagwrite(wbox, \"Put Mail Delmesg \", 3+1+4+1+7+1);\n\tthreadcreate(mainctl, wbox, STACK);\n\n\tfmtstrinit(&fmt);\n\tfmtprint(&fmt, \"Mail\");\n\tif(shortmenu)\n\t\tfmtprint(&fmt, \" -%c\", \"sS\"[shortmenu-1]);\n\tif(outgoing)\n\t\tfmtprint(&fmt, \" -o %s\", outgoing);\n\tfmtprint(&fmt, \" %s\", name);\n\tcmd = fmtstrflush(&fmt);\n\tif(cmd == nil)\n\t\tsysfatal(\"out of memory\");\n\twinsetdump(wbox, \"/acme/mail\", cmd);\n\tmbox.w = wbox;\n\n\tmesgmenu(wbox, &mbox);\n\twinclean(wbox);\n\n/*\twctlfd = open(\"/dev/wctl\", OWRITE|OCEXEC);\t/* for acme window */\n\twctlfd = -1;\n\tcplumb = chancreate(sizeof(Plumbmsg*), 0);\n\tcplumbshow = chancreate(sizeof(Plumbmsg*), 0);\n\tif(strcmp(name, \"mbox\") == 0){\n\t\t/*\n\t\t * Avoid creating multiple windows to send mail by only accepting\n\t\t * sendmail plumb messages if we're reading the main mailbox.\n\t\t */\n\t\tplumbsendmailfd = plumbopenfid(\"sendmail\", OREAD|OCEXEC);\n\t\tcplumbsend = chancreate(sizeof(Plumbmsg*), 0);\n\t\tproccreate(plumbsendproc, nil, STACK);\n\t\tthreadcreate(plumbsendthread, nil, STACK);\n\t}\n\t/* start plumb reader as separate proc ... */\n\tproccreate(plumbproc, nil, STACK);\n\tproccreate(plumbshowproc, nil, STACK);\n\tthreadcreate(plumbshowthread, nil, STACK);\n\tfswrite(mbox.ctlfd, \"refresh\", 7);\n\t/* ... and use this thread to read the messages */\n\tplumbthread();\n}\n\nvoid\nplumbproc(void* v)\n{\n\tPlumbmsg *m;\n\n\tthreadsetname(\"plumbproc\");\n\tfor(;;){\n\t\tm = plumbrecvfid(plumbseemailfd);\n\t\tsendp(cplumb, m);\n\t\tif(m == nil)\n\t\t\tthreadexits(nil);\n\t}\n}\n\nvoid\nplumbshowproc(void* v)\n{\n\tPlumbmsg *m;\n\n\tthreadsetname(\"plumbshowproc\");\n\tfor(;;){\n\t\tm = plumbrecvfid(plumbshowmailfd);\n\t\tsendp(cplumbshow, m);\n\t\tif(m == nil)\n\t\t\tthreadexits(nil);\n\t}\n}\n\nvoid\nplumbsendproc(void* v)\n{\n\tPlumbmsg *m;\n\n\tthreadsetname(\"plumbsendproc\");\n\tfor(;;){\n\t\tm = plumbrecvfid(plumbsendmailfd);\n\t\tsendp(cplumbsend, m);\n\t\tif(m == nil)\n\t\t\tthreadexits(nil);\n\t}\n}\n\nvoid\nnewmesg(char *name, char *digest)\n{\n\tDir *d;\n\n\tif(strncmp(name, mbox.name, strlen(mbox.name)) != 0)\n\t\treturn;\t/* message is about another mailbox */\n\tif(mesglookupfile(&mbox, name, digest) != nil)\n\t\treturn;\n\tif(strncmp(name, \"Mail/\", 5) == 0)\n\t\tname += 5;\n\td = fsdirstat(mailfs, name);\n\tif(d == nil)\n\t\treturn;\n\tif(mesgadd(&mbox, mbox.name, d, digest))\n\t\tmesgmenunew(wbox, &mbox);\n\tfree(d);\n}\n\nvoid\nshowmesg(char *name, char *digest)\n{\n\tchar *n;\n\tchar *mb;\n\n\tmb = mbox.name;\n\tif(strncmp(name, mb, strlen(mb)) != 0)\n\t\treturn;\t/* message is about another mailbox */\n\tn = estrdup(name+strlen(mb));\n\tif(n[strlen(n)-1] != '/')\n\t\tn = egrow(n, \"/\", nil);\n\tmesgopen(&mbox, mbox.name, name+strlen(mb), nil, 1, digest);\n\tfree(n);\n}\n\nvoid\ndelmesg(char *name, char *digest, int dodel, char *save)\n{\n\tMessage *m;\n\n\tm = mesglookupfile(&mbox, name, digest);\n\tif(m != nil){\n\t\tif(save)\n\t\t\tmesgcommand(m, estrstrdup(\"Save \", save));\n\t\tif(dodel)\n\t\t\tmesgmenumarkdel(wbox, &mbox, m, 1);\n\t\telse{\n\t\t\t/* notification came from plumber - message is gone */\n\t\t\tmesgmenudel(wbox, &mbox, m);\n\t\t\tif(!m->opened)\n\t\t\t\tmesgdel(&mbox, m);\n\t\t}\n\t}\n}\n\nvoid\nplumbthread(void)\n{\n\tPlumbmsg *m;\n\tPlumbattr *a;\n\tchar *type, *digest;\n\n\tthreadsetname(\"plumbthread\");\n\twhile((m = recvp(cplumb)) != nil){\n\t\ta = m->attr;\n\t\tdigest = plumblookup(a, \"digest\");\n\t\ttype = plumblookup(a, \"mailtype\");\n\t\tif(type == nil)\n\t\t\tfprint(2, \"Mail: plumb message with no mailtype attribute\\n\");\n\t\telse if(strcmp(type, \"new\") == 0)\n\t\t\tnewmesg(m->data, digest);\n\t\telse if(strcmp(type, \"delete\") == 0)\n\t\t\tdelmesg(m->data, digest, 0, nil);\n\t\telse\n\t\t\tfprint(2, \"Mail: unknown plumb attribute %s\\n\", type);\n\t\tplumbfree(m);\n\t}\n\tthreadexits(nil);\n}\n\nvoid\nplumbshowthread(void *v)\n{\n\tPlumbmsg *m;\n\n\tUSED(v);\n\tthreadsetname(\"plumbshowthread\");\n\twhile((m = recvp(cplumbshow)) != nil){\n\t\tshowmesg(m->data, plumblookup(m->attr, \"digest\"));\n\t\tplumbfree(m);\n\t}\n\tthreadexits(nil);\n}\n\nvoid\nplumbsendthread(void *v)\n{\n\tPlumbmsg *m;\n\n\tUSED(v);\n\tthreadsetname(\"plumbsendthread\");\n\twhile((m = recvp(cplumbsend)) != nil){\n\t\tmkreply(nil, \"Mail\", m->data, m->attr, nil);\n\t\tplumbfree(m);\n\t}\n\tthreadexits(nil);\n}\n\nint\nmboxcommand(Window *w, char *s)\n{\n\tchar *args[10], **targs, *save;\n\tWindow *sbox;\n\tMessage *m, *next;\n\tint ok, nargs, i, j;\n\tCFid *searchfd;\n\tchar buf[128], *res;\n\n\tnargs = tokenize(s, args, nelem(args));\n\tif(nargs == 0)\n\t\treturn 0;\n\tif(strcmp(args[0], \"Mail\") == 0){\n\t\tif(nargs == 1)\n\t\t\tmkreply(nil, \"Mail\", \"\", nil, nil);\n\t\telse\n\t\t\tmkreply(nil, \"Mail\", args[1], nil, nil);\n\t\treturn 1;\n\t}\n\tif(strcmp(s, \"Del\") == 0){\n\t\tif(mbox.dirty){\n\t\t\tmbox.dirty = 0;\n\t\t\tfprint(2, \"mail: mailbox not written\\n\");\n\t\t\treturn 1;\n\t\t}\n\t\tif(w != mbox.w){\n\t\t\twindel(w, 1);\n\t\t\treturn 1;\n\t\t}\n\t\tok = 1;\n\t\tfor(m=mbox.head; m!=nil; m=next){\n\t\t\tnext = m->next;\n\t\t\tif(m->w){\n\t\t\t\tif(windel(m->w, 0))\n\t\t\t\t\tm->w = nil;\n\t\t\t\telse\n\t\t\t\t\tok = 0;\n\t\t\t}\n\t\t}\n\t\tfor(m=replies.head; m!=nil; m=next){\n\t\t\tnext = m->next;\n\t\t\tif(m->w){\n\t\t\t\tif(windel(m->w, 0))\n\t\t\t\t\tm->w = nil;\n\t\t\t\telse\n\t\t\t\t\tok = 0;\n\t\t\t}\n\t\t}\n\t\tif(ok){\n\t\t\twindel(w, 1);\n\t\t\tremoveupasfs();\n\t\t\tthreadexitsall(nil);\n\t\t}\n\t\treturn 1;\n\t}\n\tif(strcmp(s, \"Put\") == 0){\n\t\trewritembox(wbox, &mbox);\n\t\treturn 1;\n\t}\n\tif(strcmp(s, \"Get\") == 0){\n\t\tfswrite(mbox.ctlfd, \"refresh\", 7);\n\t\treturn 1;\n\t}\n\tif(strcmp(s, \"Delmesg\") == 0){\n\t\tsave = nil;\n\t\tif(nargs > 1)\n\t\t\tsave = args[1];\n\t\ts = winselection(w);\n\t\tif(s == nil)\n\t\t\treturn 1;\n\t\tnargs = 1;\n\t\tfor(i=0; s[i]; i++)\n\t\t\tif(s[i] == '\\n')\n\t\t\t\tnargs++;\n\t\ttargs = emalloc(nargs*sizeof(char*));\t/* could be too many for a local array */\n\t\tnargs = getfields(s, targs, nargs, 1, \"\\n\");\n\t\tfor(i=0; i<nargs; i++){\n\t\t\tif(!isdigit(targs[i][0]))\n\t\t\t\tcontinue;\n\t\t\tj = atoi(targs[i]);\t/* easy way to parse the number! */\n\t\t\tif(j == 0)\n\t\t\t\tcontinue;\n\t\t\tsnprint(buf, sizeof buf, \"%s%d\", mbox.name, j);\n\t\t\tdelmesg(buf, nil, 1, save);\n\t\t}\n\t\tfree(s);\n\t\tfree(targs);\n\t\treturn 1;\n\t}\n\tif(strcmp(s, \"Search\") == 0){\n\t\tif(nargs <= 1)\n\t\t\treturn 1;\n\t\ts = estrstrdup(mboxname, \"/search\");\n\t\tsearchfd = fsopen(mailfs, s, ORDWR);\n\t\tif(searchfd == nil)\n\t\t\treturn 1;\n\t\tsave = estrdup(args[1]);\n\t\tfor(i=2; i<nargs; i++)\n\t\t\tsave = eappend(save, \" \", args[i]);\n\t\tfswrite(searchfd, save, strlen(save));\n\t\tfsseek(searchfd, 0, 0);\n\t\tj = fsread(searchfd, buf, sizeof buf - 1);\n \t\tif(j == 0){\n\t\t\tfprint(2, \"[%s] search %s: no results found\\n\", mboxname, save);\n\t\t\tfsclose(searchfd);\n\t\t\tfree(save);\n\t\t\treturn 1;\n\t\t}\n\t\tfree(save);\n\t\tbuf[j] = '\\0';\n\t\tres = estrdup(buf);\n\t\tj = fsread(searchfd, buf, sizeof buf - 1);\n\t\tfor(; j != 0; j = fsread(searchfd, buf, sizeof buf - 1), buf[j] = '\\0')\n\t\t\tres = eappend(res, \"\", buf);\n\t\tfsclose(searchfd);\n\n\t\tsbox = newwindow();\n\t\twinname(sbox, s);\n\t\tfree(s);\n\t\tthreadcreate(mainctl, sbox, STACK);\n\t\twinopenbody(sbox, OWRITE);\n\n\t\t/* show results in reverse order */\n\t\tm = mbox.tail;\n\t\tsave = nil;\n\t\tfor(s=strrchr(res, ' '); s!=nil || save!=res; s=strrchr(res, ' ')){\n\t\t\tif(s != nil){\n\t\t\t\tsave = s+1;\n\t\t\t\t*s = '\\0';\n\t\t\t}\n\t\t\telse save = res;\n\t\t\tsave = estrstrdup(save, \"/\");\n\t\t\tfor(; m && strcmp(save, m->name) != 0; m=m->prev);\n\t\t\tfree(save);\n\t\t\tif(m == nil)\n\t\t\t\tbreak;\n\t\t\tfsprint(sbox->body, \"%s%s\\n\", m->name, info(m, 0, 0));\n\t\t\tm = m->prev;\n\t\t}\n\t\tfree(res);\n\t\twinclean(sbox);\n\t\twinclosebody(sbox);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nvoid\nmainctl(void *v)\n{\n\tWindow *w;\n\tEvent *e, *e2, *eq, *ea;\n\tint na, nopen;\n\tchar *s, *t, *buf;\n\n\tw = v;\n\twinincref(w);\n\tproccreate(wineventproc, w, STACK);\n\n\tfor(;;){\n\t\te = recvp(w->cevent);\n\t\tswitch(e->c1){\n\t\tdefault:\n\t\tUnknown:\n\t\t\tprint(\"unknown message %c%c\\n\", e->c1, e->c2);\n\t\t\tbreak;\n\t\n\t\tcase 'E':\t/* write to body; can't affect us */\n\t\t\tbreak;\n\t\n\t\tcase 'F':\t/* generated by our actions; ignore */\n\t\t\tbreak;\n\t\n\t\tcase 'K':\t/* type away; we don't care */\n\t\t\tbreak;\n\t\n\t\tcase 'M':\n\t\t\tswitch(e->c2){\n\t\t\tcase 'x':\n\t\t\tcase 'X':\n\t\t\t\tea = nil;\n\t\t\t\te2 = nil;\n\t\t\t\tif(e->flag & 2)\n\t\t\t\t\te2 = recvp(w->cevent);\n\t\t\t\tif(e->flag & 8){\n\t\t\t\t\tea = recvp(w->cevent);\n\t\t\t\t\tna = ea->nb;\n\t\t\t\t\trecvp(w->cevent);\n\t\t\t\t}else\n\t\t\t\t\tna = 0;\n\t\t\t\ts = e->b;\n\t\t\t\t/* if it's a known command, do it */\n\t\t\t\tif((e->flag&2) && e->nb==0)\n\t\t\t\t\ts = e2->b;\n\t\t\t\tif(na){\n\t\t\t\t\tt = emalloc(strlen(s)+1+na+1);\n\t\t\t\t\tsprint(t, \"%s %s\", s, ea->b);\n\t\t\t\t\ts = t;\n\t\t\t\t}\n\t\t\t\t/* if it's a long message, it can't be for us anyway */\n\t\t\t\tif(!mboxcommand(w, s))\t/* send it back */\n\t\t\t\t\twinwriteevent(w, e);\n\t\t\t\tif(na)\n\t\t\t\t\tfree(s);\n\t\t\t\tbreak;\n\t\n\t\t\tcase 'l':\n\t\t\tcase 'L':\n\t\t\t\tbuf = nil;\n\t\t\t\teq = e;\n\t\t\t\tif(e->flag & 2){\n\t\t\t\t\te2 = recvp(w->cevent);\n\t\t\t\t\teq = e2;\n\t\t\t\t}\n\t\t\t\ts = eq->b;\n\t\t\t\tif(eq->q1>eq->q0 && eq->nb==0){\n\t\t\t\t\tbuf = emalloc((eq->q1-eq->q0)*UTFmax+1);\n\t\t\t\t\twinread(w, eq->q0, eq->q1, buf);\n\t\t\t\t\ts = buf;\n\t\t\t\t}\n\t\t\t\tnopen = 0;\n\t\t\t\tdo{\n\t\t\t\t\t/* skip 'deleted' string if present' */\n\t\t\t\t\tif(strncmp(s, deleted, strlen(deleted)) == 0)\n\t\t\t\t\t\ts += strlen(deleted);\n\t\t\t\t\t/* skip mail box name if present */\n\t\t\t\t\tif(strncmp(s, mbox.name, strlen(mbox.name)) == 0)\n\t\t\t\t\t\ts += strlen(mbox.name);\n\t\t\t\t\tnopen += mesgopen(&mbox, mbox.name, s, nil, 0, nil);\n\t\t\t\t\twhile(*s!='\\0' && *s++!='\\n')\n\t\t\t\t\t\t;\n\t\t\t\t}while(*s);\n\t\t\t\tif(nopen == 0)\t/* send it back */\n\t\t\t\t\twinwriteevent(w, e);\n\t\t\t\tfree(buf);\n\t\t\t\tbreak;\n\t\n\t\t\tcase 'I':\t/* modify away; we don't care */\n\t\t\tcase 'D':\n\t\t\tcase 'd':\n\t\t\tcase 'i':\n\t\t\t\tbreak;\n\t\n\t\t\tdefault:\n\t\t\t\tgoto Unknown;\n\t\t\t}\n\t\t}\n\t}\n}\n\n", "source": "acme2k/src/cmd/acme/mail/mail.c", "file_type": "c"}
{"text": "#include <u.h>\n#include <libc.h>\n#include <bio.h>\n#include <thread.h>\n#include <ctype.h>\n#include <plumb.h>\n#include <9pclient.h>\n#include \"dat.h\"\n\nchar*\nformathtml(char *body, int *np)\n{\n\tint i, j, p[2], q[2];\n\tExec *e;\n\tchar buf[1024];\n\tChannel *sync;\n\n\te = emalloc(sizeof(struct Exec));\n\tif(pipe(p) < 0 || pipe(q) < 0)\n\t\terror(\"can't create pipe: %r\");\n\n\te->p[0] = p[0];\n\te->p[1] = p[1];\n\te->q[0] = q[0];\n\te->q[1] = q[1];\n\te->argv = emalloc(3*sizeof(char*));\n\te->argv[0] = estrdup(\"htmlfmt\");\n\te->argv[1] = estrdup(\"-cutf-8\");\n\te->argv[2] = nil;\n\te->prog = \"htmlfmt\";\n\tsync = chancreate(sizeof(int), 0);\n\te->sync = sync;\n\tproccreate(execproc, e, EXECSTACK);\n\trecvul(sync);\n\tclose(p[0]);\n\tclose(q[1]);\n\n\tif((i=write(p[1], body, *np)) != *np){\n\t\tfprint(2, \"Mail: warning: htmlfmt failed: wrote %d of %d: %r\\n\", i, *np);\n\t\tclose(p[1]);\n\t\tclose(q[0]);\n\t\treturn body;\n\t}\n\tclose(p[1]);\n\n\tfree(body);\n\tbody = nil;\n\ti = 0;\n\tfor(;;){\n\t\tj = read(q[0], buf, sizeof buf);\n\t\tif(j <= 0)\n\t\t\tbreak;\n\t\tbody = realloc(body, i+j+1);\n\t\tif(body == nil)\n\t\t\terror(\"realloc failed: %r\");\n\t\tmemmove(body+i, buf, j);\n\t\ti += j;\n\t\tbody[i] = '\\0';\n\t}\n\tclose(q[0]);\n\n\t*np = i;\n\treturn body;\n}\n\nchar*\nreadbody(char *type, char *dir, int *np)\n{\n\tchar *body;\n\t\n\tbody = readfile(dir, \"body\", np);\n\tif(body != nil && strcmp(type, \"text/html\") == 0)\n\t\treturn formathtml(body, np);\n\treturn body;\n}\n", "source": "acme2k/src/cmd/acme/mail/html.c", "file_type": "c"}
{"text": "#!/bin/rc\n\nfor(i){\n\tif(! test -f $i){\n\t\tif(cp /dev/null $i){\n\t\t\tchmod 600 $i\n\t\t\tchmod +al $i\n\t\t}\n\t}\n\tif not echo $i already exists\n}\n", "source": "acme2k/src/cmd/acme/mail/mkbox", "file_type": "rc"}
{"text": "#include <u.h>\n#include <libc.h>\n#include <bio.h>\n#include <thread.h>\n#include <ctype.h>\n#include <plumb.h>\n#include <9pclient.h>\n#include \"dat.h\"\n\nstatic int\treplyid;\n\nint\nquote(Message *m, CFid *fid, char *dir, char *quotetext)\n{\n\tchar *body, *type;\n\tint i, n, nlines;\n\tchar **lines;\n\n\tif(quotetext){\n\t\tbody = quotetext;\n\t\tn = strlen(body);\n\t\ttype = nil;\n\t}else{\n\t\t/* look for first textual component to quote */\n\t\ttype = readfile(dir, \"type\", &n);\n\t\tif(type == nil){\n\t\t\tprint(\"no type in %s\\n\", dir);\n\t\t\treturn 0;\n\t\t}\n\t\tif(strncmp(type, \"multipart/\", 10)==0 || strncmp(type, \"message/\", 8)==0){\n\t\t\tdir = estrstrdup(dir, \"1/\");\n\t\t\tif(quote(m, fid, dir, nil)){\n\t\t\t\tfree(type);\n\t\t\t\tfree(dir);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tfree(dir);\n\t\t}\n\t\tif(strncmp(type, \"text\", 4) != 0){\n\t\t\tfree(type);\n\t\t\treturn 0;\n\t\t}\n\t\tbody = readbody(m->type, dir, &n);\n\t\tif(body == nil)\n\t\t\treturn 0;\n\t}\n\tnlines = 0;\n\tfor(i=0; i<n; i++)\n\t\tif(body[i] == '\\n')\n\t\t\tnlines++;\n\tnlines++;\n\tlines = emalloc(nlines*sizeof(char*));\n\tnlines = getfields(body, lines, nlines, 0, \"\\n\");\n\t/* delete leading and trailing blank lines */\n\ti = 0;\n\twhile(i<nlines && lines[i][0]=='\\0')\n\t\ti++;\n\twhile(i<nlines && lines[nlines-1][0]=='\\0')\n\t\tnlines--;\n\twhile(i < nlines){\n\t\tfsprint(fid, \">%s%s\\n\", lines[i][0]=='>'? \"\" : \" \", lines[i]);\n\t\ti++;\n\t}\n\tfree(lines);\n\tfree(body);\t/* will free quotetext if non-nil */\n\tfree(type);\n\treturn 1;\n}\n\nvoid\nmkreply(Message *m, char *label, char *to, Plumbattr *attr, char *quotetext)\n{\n\tchar buf[100];\n\tCFid *fd;\n\tMessage *r;\n\tchar *dir, *t;\n\tint quotereply;\n\tPlumbattr *a;\n\n\tquotereply = (label[0] == 'Q');\n\t\n\tif(quotereply && m && m->replywinid > 0){\n\t\tsnprint(buf, sizeof buf, \"%d/body\", m->replywinid);\n\t\tif((fd = fsopen(acmefs, buf, OWRITE)) != nil){\n\t\t\tdir = estrstrdup(mbox.name, m->name);\n\t\t\tquote(m, fd, dir, quotetext);\n\t\t\tfree(dir);\n\t\t\treturn;\n\t\t}\n\t}\n\t\n\tr = emalloc(sizeof(Message));\n\tr->isreply = 1;\n\tif(m != nil)\n\t\tr->replyname = estrdup(m->name);\n\tr->next = replies.head;\n\tr->prev = nil;\n\tif(replies.head != nil)\n\t\treplies.head->prev = r;\n\treplies.head = r;\n\tif(replies.tail == nil)\n\t\treplies.tail = r;\n\tr->name = emalloc(strlen(mbox.name)+strlen(label)+10);\n\tsprint(r->name, \"%s%s%d\", mbox.name, label, ++replyid);\n\tr->w = newwindow();\n\tif(m)\n\t\tm->replywinid = r->w->id;\n\twinname(r->w, r->name);\n\tctlprint(r->w->ctl, \"cleartag\");\n\twintagwrite(r->w, \"fmt Look Post Undo\", 4+5+5+4);\n\tr->tagposted = 1;\n\tthreadcreate(mesgctl, r, STACK);\n\twinopenbody(r->w, OWRITE);\n\tif(to!=nil && to[0]!='\\0')\n\t\tfsprint(r->w->body, \"%s\\n\", to);\n\tfor(a=attr; a; a=a->next)\n\t\tfsprint(r->w->body, \"%s: %s\\n\", a->name, a->value);\n\tdir = nil;\n\tif(m != nil){\n\t\tdir = estrstrdup(mbox.name, m->name);\n\t\tif(to == nil && attr == nil){\n\t\t\t/* Reply goes to replyto; Reply all goes to From and To and CC */\n\t\t\tif(strstr(label, \"all\") == nil)\n\t\t\t\tfsprint(r->w->body, \"To: %s\\n\", m->replyto);\n\t\t\telse{\t/* Replyall */\n\t\t\t\tif(strlen(m->from) > 0)\n\t\t\t\t\tfsprint(r->w->body, \"To: %s\\n\", m->from);\n\t\t\t\tif(strlen(m->to) > 0)\n\t\t\t\t\tfsprint(r->w->body, \"To: %s\\n\", m->to);\n\t\t\t\tif(strlen(m->cc) > 0)\n\t\t\t\t\tfsprint(r->w->body, \"CC: %s\\n\", m->cc);\n\t\t\t}\n\t\t}\n\t\tif(strlen(m->subject) > 0){\n\t\t\tt = \"Subject: Re: \";\n\t\t\tif(strlen(m->subject) >= 3)\n\t\t\t\tif(tolower(m->subject[0])=='r' && tolower(m->subject[1])=='e' && m->subject[2]==':')\n\t\t\t\t\tt = \"Subject: \";\n\t\t\tfsprint(r->w->body, \"%s%s\\n\", t, m->subject);\n\t\t}\n\t\tif(!quotereply){\n\t\t\tfsprint(r->w->body, \"Include: %sraw\\n\", dir);\n\t\t\tfree(dir);\n\t\t}\n\t}\n\tfsprint(r->w->body, \"\\n\");\n\tif(m == nil)\n\t\tfsprint(r->w->body, \"\\n\");\n\telse if(quotereply){\n\t\tquote(m, r->w->body, dir, quotetext);\n\t\tfree(dir);\n\t}\n\twinclosebody(r->w);\n\tif(m==nil && (to==nil || to[0]=='\\0'))\n\t\twinselect(r->w, \"0\", 0);\n\telse\n\t\twinselect(r->w, \"$\", 0);\n\twinclean(r->w);\n\twindormant(r->w);\n}\n\nvoid\ndelreply(Message *m)\n{\n\tif(m->next == nil)\n\t\treplies.tail = m->prev;\n\telse\n\t\tm->next->prev = m->prev;\n\tif(m->prev == nil)\n\t\treplies.head = m->next;\n\telse\n\t\tm->prev->next = m->next;\n\tmesgfreeparts(m);\n\tfree(m);\n}\n\n/* copy argv to stack and free the incoming strings, so we don't leak argument vectors */\nvoid\nbuildargv(char **inargv, char *argv[NARGS+1], char args[NARGCHAR])\n{\n\tint i, n;\n\tchar *s, *a;\n\n\ts = args;\n\tfor(i=0; i<NARGS; i++){\n\t\ta = inargv[i];\n\t\tif(a == nil)\n\t\t\tbreak;\n\t\tn = strlen(a)+1;\n\t\tif((s-args)+n >= NARGCHAR)\t/* too many characters */\n\t\t\tbreak;\n\t\targv[i] = s;\n\t\tmemmove(s, a, n);\n\t\ts += n;\n\t\tfree(a);\n\t}\n\targv[i] = nil;\n}\n\nvoid\nexecproc(void *v)\n{\n\tstruct Exec *e;\n\tint p[2], q[2];\n\tchar *prog;\n\tchar *argv[NARGS+1], args[NARGCHAR];\n\tint fd[3];\n\n\te = v;\n\tp[0] = e->p[0];\n\tp[1] = e->p[1];\n\tq[0] = e->q[0];\n\tq[1] = e->q[1];\n\tprog = e->prog;\t/* known not to be malloc'ed */\n\t\n\tfd[0] = dup(p[0], -1);\n\tif(q[0])\n\t\tfd[1] = dup(q[1], -1);\n\telse\n\t\tfd[1] = dup(1, -1);\n\tfd[2] = dup(2, -2);\n\tsendul(e->sync, 1);\n\tbuildargv(e->argv, argv, args);\n\tfree(e->argv);\n\tchanfree(e->sync);\n\tfree(e);\n\t\n\tthreadexec(nil, fd, prog, argv);\n\tclose(fd[0]);\n\tclose(fd[1]);\n\tclose(fd[2]);\n\n\tfprint(2, \"Mail: can't exec %s: %r\\n\", prog);\n\tthreadexits(\"can't exec\");\n}\n\nenum{\n\tATTACH,\n\tBCC,\n\tCC,\n\tFROM,\n\tINCLUDE,\n\tTO\n};\n\nchar *headers[] = {\n\t\"attach:\",\n\t\"bcc:\",\n\t\"cc:\",\n\t\"from:\",\n\t\"include:\",\n\t\"to:\",\n\tnil\n};\n\nint\nwhichheader(char *h)\n{\n\tint i;\n\n\tfor(i=0; headers[i]!=nil; i++)\n\t\tif(cistrcmp(h, headers[i]) == 0)\n\t\t\treturn i;\n\treturn -1;\n}\n\nchar *tolist[200];\nchar\t*cclist[200];\nchar\t*bcclist[200];\nint ncc, nbcc, nto;\nchar\t*attlist[200];\nchar\tincluded[200];\n\nint\naddressed(char *name)\n{\n\tint i;\n\n\tfor(i=0; i<nto; i++)\n\t\tif(strcmp(name, tolist[i]) == 0)\n\t\t\treturn 1;\n\tfor(i=0; i<ncc; i++)\n\t\tif(strcmp(name, cclist[i]) == 0)\n\t\t\treturn 1;\n\tfor(i=0; i<nbcc; i++)\n\t\tif(strcmp(name, bcclist[i]) == 0)\n\t\t\treturn 1;\n\treturn 0;\n}\n\nchar*\nskipbl(char *s, char *e)\n{\n\twhile(s < e){\n\t\tif(*s!=' ' && *s!='\\t' && *s!=',')\n\t\t\tbreak;\n\t\ts++;\n\t}\n\treturn s;\n}\n\nchar*\nfindbl(char *s, char *e)\n{\n\twhile(s < e){\n\t\tif(*s==' ' || *s=='\\t' || *s==',')\n\t\t\tbreak;\n\t\ts++;\n\t}\n\treturn s;\n}\n\n/*\n * comma-separate possibly blank-separated strings in line; e points before newline\n */\nvoid\ncommas(char *s, char *e)\n{\n\tchar *t;\n\n\t/* may have initial blanks */\n\ts = skipbl(s, e);\n\twhile(s < e){\n\t\ts = findbl(s, e);\n\t\tif(s == e)\n\t\t\tbreak;\n\t\tt = skipbl(s, e);\n\t\tif(t == e)\t/* no more words */\n\t\t\tbreak;\n\t\t/* patch comma */\n\t\t*s++ = ',';\n\t\twhile(s < t)\n\t\t\t*s++ = ' ';\n\t}\n}\n\nint\nprint2(int fd, int ofd, char *fmt, ...)\n{\n\tint m, n;\n\tchar *s;\n\tva_list arg;\n\n\tva_start(arg, fmt);\n\ts = vsmprint(fmt, arg);\n\tva_end(arg);\n\tif(s == nil)\n\t\treturn -1;\n\tm = strlen(s);\n\tn = write(fd, s, m);\n\tif(ofd > 0)\n\t\twrite(ofd, s, m);\n\treturn n;\n}\n\nvoid\nwrite2(int fd, int ofd, char *buf, int n, int nofrom)\n{\n\tchar *from, *p;\n\tint m;\n\n\twrite(fd, buf, n);\n\n\tif(ofd <= 0)\n\t\treturn;\n\n\tif(nofrom == 0){\n\t\twrite(ofd, buf, n);\n\t\treturn;\n\t}\n\n\t/* need to escape leading From lines to avoid corrupting 'outgoing' mailbox */\n\tfor(p=buf; *p; p+=m){\n\t\tfrom = cistrstr(p, \"from\");\n\t\tif(from == nil)\n\t\t\tm = n;\n\t\telse\n\t\t\tm = from - p;\n\t\tif(m > 0)\n\t\t\twrite(ofd, p, m);\n\t\tif(from){\n\t\t\tif(p==buf || from[-1]=='\\n')\n\t\t\t\twrite(ofd, \" \", 1);\t/* escape with space if From is at start of line */\n\t\t\twrite(ofd, from, 4);\n\t\t\tm += 4;\n\t\t}\n\t\tn -= m;\n\t}\n}\n\nvoid\nmesgsend(Message *m)\n{\n\tchar *s, *body, *to;\n\tint i, j, h, n, natt, p[2];\n\tstruct Exec *e;\n\tChannel *sync;\n\tint first, nfld, delit, ofd;\n\tchar *copy, *fld[100], *now;\n\n\tbody = winreadbody(m->w, &n);\n\t/* assemble to: list from first line, to: line, and cc: line */\n\tnto = 0;\n\tnatt = 0;\n\tncc = 0;\n\tnbcc = 0;\n\tfirst = 1;\n\tto = body;\n\tfor(;;){\n\t\tfor(s=to; *s!='\\n'; s++)\n\t\t\tif(*s == '\\0'){\n\t\t\t\tfree(body);\n\t\t\t\treturn;\n\t\t\t}\n\t\tif(s++ == to)\t/* blank line */\n\t\t\tbreak;\n\t\t/* make copy of line to tokenize */\n\t\tcopy = emalloc(s-to);\n\t\tmemmove(copy, to, s-to);\n\t\tcopy[s-to-1] = '\\0';\n\t\tnfld = tokenizec(copy, fld, nelem(fld), \", \\t\");\n\t\tif(nfld == 0){\n\t\t\tfree(copy);\n\t\t\tbreak;\n\t\t}\n\t\tn -= s-to;\n\t\tswitch(h = whichheader(fld[0])){\n\t\tcase TO:\n\t\tcase FROM:\n\t\t\tdelit = 1;\n\t\t\tcommas(to+strlen(fld[0]), s-1);\n\t\t\tfor(i=1; i<nfld && nto<nelem(tolist); i++)\n\t\t\t\tif(!addressed(fld[i]))\n\t\t\t\t\ttolist[nto++] = estrdup(fld[i]);\n\t\t\tbreak;\n\t\tcase BCC:\n\t\t\tdelit = 1;\n\t\t\tcommas(to+strlen(fld[0]), s-1);\n\t\t\tfor(i=1; i<nfld && nbcc<nelem(bcclist); i++)\n\t\t\t\tif(!addressed(fld[i]))\n\t\t\t\t\tbcclist[nbcc++] = estrdup(fld[i]);\n\t\t\tbreak;\n\t\tcase CC:\n\t\t\tdelit = 1;\n\t\t\tcommas(to+strlen(fld[0]), s-1);\n\t\t\tfor(i=1; i<nfld && ncc<nelem(cclist); i++)\n\t\t\t\tif(!addressed(fld[i]))\n\t\t\t\t\tcclist[ncc++] = estrdup(fld[i]);\n\t\t\tbreak;\n\t\tcase ATTACH:\n\t\tcase INCLUDE:\n\t\t\tdelit = 1;\n\t\t\tfor(i=1; i<nfld && natt<nelem(attlist); i++){\n\t\t\t\tattlist[natt] = estrdup(fld[i]);\n\t\t\t\tincluded[natt++] = (h == INCLUDE);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif(first){\n\t\t\t\tdelit = 1;\n\t\t\t\tfor(i=0; i<nfld && nto<nelem(tolist); i++)\n\t\t\t\t\ttolist[nto++] = estrdup(fld[i]);\n\t\t\t}else\t/* ignore it */\n\t\t\t\tdelit = 0;\n\t\t\tbreak;\n\t\t}\n\t\tif(delit){\n\t\t\t/* delete line from body */\n\t\t\tmemmove(to, s, n+1);\n\t\t}else\n\t\t\tto = s;\n\t\tfree(copy);\n\t\tfirst = 0;\n\t}\n\n\tofd = open(outgoing, OWRITE|OCEXEC);\t/* no error check necessary */\n\tif(ofd > 0){\n\t\t/* From dhog Fri Aug 24 22:13:00 EDT 2001 */\n\t\tnow = ctime(time(0));\n\t\tseek(ofd, 0, 2);\n\t\tfprint(ofd, \"From %s %s\", user, now);\n\t\tfprint(ofd, \"From: %s\\n\", user);\n\t\tfprint(ofd, \"Date: %s\", now);\n\t\tfor(i=0; i<natt; i++)\n\t\t\tif(included[i])\n\t\t\t\tfprint(ofd, \"Include: %s\\n\", attlist[i]);\n\t\t\telse\n\t\t\t\tfprint(ofd, \"Attach: %s\\n\", attlist[i]);\n\t\t/* needed because mail is by default Latin-1 */\n\t\tfprint(ofd, \"Content-Type: text/plain; charset=\\\"UTF-8\\\"\\n\");\n\t\tfprint(ofd, \"Content-Transfer-Encoding: 8bit\\n\");\n\t}\n\n\te = emalloc(sizeof(struct Exec));\n\tif(pipe(p) < 0)\n\t\terror(\"can't create pipe: %r\");\n\te->p[0] = p[0];\n\te->p[1] = p[1];\n\te->prog = unsharp(\"#9/bin/upas/marshal\");\n\te->argv = emalloc((1+1+2+4*natt+1)*sizeof(char*));\n\te->argv[0] = estrdup(\"marshal\");\n\te->argv[1] = estrdup(\"-8\");\n\tj = 2;\n\tif(m->replyname){\n\t\te->argv[j++] = estrdup(\"-R\");\n\t\te->argv[j++] = estrstrdup(mbox.name, m->replyname);\n\t}\n\tfor(i=0; i<natt; i++){\n\t\tif(included[i])\n\t\t\te->argv[j++] = estrdup(\"-A\");\n\t\telse\n\t\t\te->argv[j++] = estrdup(\"-a\");\n\t\te->argv[j++] = estrdup(attlist[i]);\n\t}\n\tsync = chancreate(sizeof(int), 0);\n\te->sync = sync;\n\tproccreate(execproc, e, EXECSTACK);\n\trecvul(sync);\n\t/* close(p[0]); */\n\n\t/* using marshal -8, so generate rfc822 headers */\n\tif(nto > 0){\n\t\tprint2(p[1], ofd, \"To: \");\n\t\tfor(i=0; i<nto-1; i++)\n\t\t\tprint2(p[1], ofd, \"%s, \", tolist[i]);\n\t\tprint2(p[1], ofd, \"%s\\n\", tolist[i]);\n\t}\n\tif(ncc > 0){\n\t\tprint2(p[1], ofd, \"CC: \");\n\t\tfor(i=0; i<ncc-1; i++)\n\t\t\tprint2(p[1], ofd, \"%s, \", cclist[i]);\n\t\tprint2(p[1], ofd, \"%s\\n\", cclist[i]);\n\t}\n\tif(nbcc > 0){\n\t\tprint2(p[1], ofd, \"BCC: \");\n\t\tfor(i=0; i<nbcc-1; i++)\n\t\t\tprint2(p[1], ofd, \"%s, \", bcclist[i]);\n\t\tprint2(p[1], ofd, \"%s\\n\", bcclist[i]);\n\t}\n\n\ti = strlen(body);\n\tif(i > 0)\n\t\twrite2(p[1], ofd, body, i, 1);\n\n\t/* guarantee a blank line, to ensure attachments are separated from body */\n\tif(i==0 || body[i-1]!='\\n')\n\t\twrite2(p[1], ofd, \"\\n\\n\", 2, 0);\n\telse if(i>1 && body[i-2]!='\\n')\n\t\twrite2(p[1], ofd, \"\\n\", 1, 0);\n\n\t/* these look like pseudo-attachments in the \"outgoing\" box */\n\tif(ofd>0 && natt>0){\n\t\tfor(i=0; i<natt; i++)\n\t\t\tif(included[i])\n\t\t\t\tfprint(ofd, \"=====> Include: %s\\n\", attlist[i]);\n\t\t\telse\n\t\t\t\tfprint(ofd, \"=====> Attach: %s\\n\", attlist[i]);\n\t}\n\tif(ofd > 0)\n\t\twrite(ofd, \"\\n\", 1);\n\n\tfor(i=0; i<natt; i++)\n\t\tfree(attlist[i]);\n\tclose(ofd);\n\tclose(p[1]);\n\tfree(body);\n\n\tif(m->replyname != nil)\n\t\tmesgmenumark(mbox.w, m->replyname, \"\\t[replied]\");\n\tif(m->name[0] == '/')\n\t\ts = estrdup(m->name);\n\telse\n\t\ts = estrstrdup(mbox.name, m->name);\n\ts = egrow(s, \"-R\", nil);\n\twinname(m->w, s);\n\tfree(s);\n\twinclean(m->w);\n\t/* mark message unopened because it's no longer the original message */\n\tm->opened = 0;\n}\n", "source": "acme2k/src/cmd/acme/mail/reply.c", "file_type": "c"}
{"text": "#include <u.h>\n#include <libc.h>\n#include <bio.h>\n#include <thread.h>\n#include <plumb.h>\n#include <9pclient.h>\n#include \"dat.h\"\n\nWindow*\nnewwindow(void)\n{\n\tchar buf[12];\n\tWindow *w;\n\n\tw = emalloc(sizeof(Window));\n\tw->ctl = fsopen(acmefs, \"new/ctl\", ORDWR|OCEXEC);\n\tif(w->ctl == nil || fsread(w->ctl, buf, 12)!=12)\n\t\terror(\"can't open window ctl file: %r\");\n\n\tw->id = atoi(buf);\n\tw->event = winopenfile(w, \"event\");\n\tw->addr = nil;\t/* will be opened when needed */\n\tw->body = nil;\n\tw->data = nil;\n\tw->cevent = chancreate(sizeof(Event*), 0);\n\tw->ref = 1;\n\treturn w;\n}\n\nvoid\nwinincref(Window *w)\n{\n\tqlock(&w->lk);\n\t++w->ref;\n\tqunlock(&w->lk);\n}\n\nvoid\nwindecref(Window *w)\n{\n\tqlock(&w->lk);\n\tif(--w->ref > 0){\n\t\tqunlock(&w->lk);\n\t\treturn;\n\t}\n\tfsclose(w->event);\n\tchanfree(w->cevent);\n\tfree(w);\n}\n\nvoid\nwinsetdump(Window *w, char *dir, char *cmd)\n{\n\tif(dir != nil)\n\t\tctlprint(w->ctl, \"dumpdir %s\\n\", dir);\n\tif(cmd != nil)\n\t\tctlprint(w->ctl, \"dump %s\\n\", cmd);\n}\n\nvoid\nwineventproc(void *v)\n{\n\tWindow *w;\n\tint i;\n\n\tw = v;\n\tfor(i=0; ; i++){\n\t\tif(i >= NEVENT)\n\t\t\ti = 0;\n\t\twingetevent(w, &w->e[i]);\n\t\tsendp(w->cevent, &w->e[i]);\n\t}\n}\n\nstatic CFid*\nwinopenfile1(Window *w, char *f, int m)\n{\n\tchar buf[64];\n\tCFid* fd;\n\n\tsprint(buf, \"%d/%s\", w->id, f);\n\tfd = fsopen(acmefs, buf, m|OCEXEC);\n\tif(fd == nil)\n\t\terror(\"can't open window file %s: %r\", f);\n\treturn fd;\n}\n\nCFid*\nwinopenfile(Window *w, char *f)\n{\n\treturn winopenfile1(w, f, ORDWR);\n}\n\nvoid\nwintagwrite(Window *w, char *s, int n)\n{\n\tCFid* fid;\n\n\tfid = winopenfile(w, \"tag\");\n\tif(fswrite(fid, s, n) != n)\n\t\terror(\"tag write: %r\");\n\tfsclose(fid);\n}\n\nvoid\nwinname(Window *w, char *s)\n{\n\tint len;\n\tchar *ns, *sp;\n\tRune r = L'\u2423';\t/* visible space */\n\n\tlen = 0;\n\tns = emalloc(strlen(s)*runelen(r) + 1);\n\tfor(sp = s; *sp != '\\0'; sp++, len++){\n\t\tif(isspace(*sp)){\n\t\t\tlen += runetochar(ns+len, &r)-1;\n\t\t\tcontinue;\n\t\t}\n\t\t*(ns+len) = *sp;\n\t}\n\tctlprint(w->ctl, \"name %s\\n\", ns);\n\tfree(ns);\n\treturn;\n}\n\nvoid\nwinopenbody(Window *w, int mode)\n{\n\tchar buf[256];\n\tCFid* fid;\n\n\tsprint(buf, \"%d/body\", w->id);\n\tfid = fsopen(acmefs, buf, mode|OCEXEC);\n\tw->body = fid;\n\tif(w->body == nil)\n\t\terror(\"can't open window body file: %r\");\n}\n\nvoid\nwinclosebody(Window *w)\n{\n\tif(w->body != nil){\n\t\tfsclose(w->body);\n\t\tw->body = nil;\n\t}\n}\n\nvoid\nwinwritebody(Window *w, char *s, int n)\n{\n\tif(w->body == nil)\n\t\twinopenbody(w, OWRITE);\n\tif(fswrite(w->body, s, n) != n)\n\t\terror(\"write error to window: %r\");\n}\n\nint\nwingetec(Window *w)\n{\n\tif(w->nbuf == 0){\n\t\tw->nbuf = fsread(w->event, w->buf, sizeof w->buf);\n\t\tif(w->nbuf <= 0){\n\t\t\t/* probably because window has exited, and only called by wineventproc, so just shut down */\n\t\t\twindecref(w);\n\t\t\tthreadexits(nil);\n\t\t}\n\t\tw->bufp = w->buf;\n\t}\n\tw->nbuf--;\n\treturn *w->bufp++;\n}\n\nint\nwingeten(Window *w)\n{\n\tint n, c;\n\n\tn = 0;\n\twhile('0'<=(c=wingetec(w)) && c<='9')\n\t\tn = n*10+(c-'0');\n\tif(c != ' ')\n\t\terror(\"event number syntax\");\n\treturn n;\n}\n\nint\nwingeter(Window *w, char *buf, int *nb)\n{\n\tRune r;\n\tint n;\n\n\tr = wingetec(w);\n\tbuf[0] = r;\n\tn = 1;\n\tif(r >= Runeself) {\n\t\twhile(!fullrune(buf, n))\n\t\t\tbuf[n++] = wingetec(w);\n\t\tchartorune(&r, buf);\n\t} \n\t*nb = n;\n\treturn r;\n}\n\nvoid\nwingetevent(Window *w, Event *e)\n{\n\tint i, nb;\n\n\te->c1 = wingetec(w);\n\te->c2 = wingetec(w);\n\te->q0 = wingeten(w);\n\te->q1 = wingeten(w);\n\te->flag = wingeten(w);\n\te->nr = wingeten(w);\n\tif(e->nr > EVENTSIZE)\n\t\terror(\"event string too long\");\n\te->nb = 0;\n\tfor(i=0; i<e->nr; i++){\n\t\te->r[i] = wingeter(w, e->b+e->nb, &nb);\n\t\te->nb += nb;\n\t}\n\te->r[e->nr] = 0;\n\te->b[e->nb] = 0;\n\tif(wingetec(w) != '\\n')\n\t\terror(\"event syntax error\");\n}\n\nvoid\nwinwriteevent(Window *w, Event *e)\n{\n\tfsprint(w->event, \"%c%c%d %d\\n\", e->c1, e->c2, e->q0, e->q1);\n}\n\nvoid\nwinread(Window *w, uint q0, uint q1, char *data)\n{\n\tint m, n, nr;\n\tchar buf[256];\n\n\tif(w->addr == nil)\n\t\tw->addr = winopenfile(w, \"addr\");\n\tif(w->data == nil)\n\t\tw->data = winopenfile(w, \"data\");\n\tm = q0;\n\twhile(m < q1){\n\t\tn = sprint(buf, \"#%d\", m);\n\t\tif(fswrite(w->addr, buf, n) != n)\n\t\t\terror(\"error writing addr: %r\");\n\t\tn = fsread(w->data, buf, sizeof buf);\n\t\tif(n <= 0)\n\t\t\terror(\"reading data: %r\");\n\t\tnr = utfnlen(buf, n);\n\t\twhile(m+nr >q1){\n\t\t\tdo; while(n>0 && (buf[--n]&0xC0)==0x80);\n\t\t\t--nr;\n\t\t}\n\t\tif(n == 0)\n\t\t\tbreak;\n\t\tmemmove(data, buf, n);\n\t\tdata += n;\n\t\t*data = 0;\n\t\tm += nr;\n\t}\n}\n\nvoid\nwindormant(Window *w)\n{\n\tif(w->addr != nil){\n\t\tfsclose(w->addr);\n\t\tw->addr = nil;\n\t}\n\tif(w->body != nil){\n\t\tfsclose(w->body);\n\t\tw->body = nil;\n\t}\n\tif(w->data != nil){\n\t\tfsclose(w->data);\n\t\tw->data = nil;\n\t}\n}\n\n\nint\nwindel(Window *w, int sure)\n{\n\tif(sure)\n\t\tfswrite(w->ctl, \"delete\\n\", 7);\n\telse if(fswrite(w->ctl, \"del\\n\", 4) != 4)\n\t\treturn 0;\n\t/* event proc will die due to read error from event file */\n\twindormant(w);\n\tfsclose(w->ctl);\n\tw->ctl = nil;\n\treturn 1;\n}\n\nvoid\nwinclean(Window *w)\n{\n\tctlprint(w->ctl, \"clean\\n\");\n}\n\nint\nwinsetaddr(Window *w, char *addr, int errok)\n{\n\tif(w->addr == nil)\n\t\tw->addr = winopenfile(w, \"addr\");\n\tif(fswrite(w->addr, addr, strlen(addr)) < 0){\n\t\tif(!errok)\n\t\t\terror(\"error writing addr(%s): %r\", addr);\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nint\nwinselect(Window *w, char *addr, int errok)\n{\n\tif(winsetaddr(w, addr, errok)){\n\t\tctlprint(w->ctl, \"dot=addr\\n\");\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nchar*\nwinreadbody(Window *w, int *np)\t/* can't use readfile because acme doesn't report the length */\n{\n\tchar *s;\n\tint m, na, n;\n\n\tif(w->body != nil)\n\t\twinclosebody(w);\n\twinopenbody(w, OREAD);\n\ts = nil;\n\tna = 0;\n\tn = 0;\n\tfor(;;){\n\t\tif(na < n+512){\n\t\t\tna += 1024;\n\t\t\ts = realloc(s, na+1);\n\t\t}\n\t\tm = fsread(w->body, s+n, na-n);\n\t\tif(m <= 0)\n\t\t\tbreak;\n\t\tn += m;\n\t}\n\ts[n] = 0;\n\twinclosebody(w);\n\t*np = n;\n\treturn s;\n}\n\nchar*\nwinselection(Window *w)\n{\n\tint m, n;\n\tchar *buf;\n\tchar tmp[256];\n\tCFid* fid;\n\n\tfid = winopenfile1(w, \"rdsel\", OREAD);\n\tif(fid == nil)\n\t\terror(\"can't open rdsel: %r\");\n\tn = 0;\n\tbuf = nil;\n\tfor(;;){\n\t\tm = fsread(fid, tmp, sizeof tmp);\n\t\tif(m <= 0)\n\t\t\tbreak;\n\t\tbuf = erealloc(buf, n+m+1);\n\t\tmemmove(buf+n, tmp, m);\n\t\tn += m;\n\t\tbuf[n] = '\\0';\n\t}\n\tfsclose(fid);\n\treturn buf;\n}\n", "source": "acme2k/src/cmd/acme/mail/win.c", "file_type": "c"}
{"text": "</$objtype/mkfile\n\nBIN=/$objtype/bin\nTARG=aa\nCFLAGS=$CFLAGS -p\n\nHFILES=\\\n\taa.h\\\n\taa_math.h\\\n\tqp.h\\\n\nOFILES=\\\n\taa.$O\\\n\taa_math.$O\\\n\tqp.$O\\\n\trepl.$O\\\n\ndefault:V: all\n\n</sys/src/cmd/mkone\n", "source": "aa/mkfile", "file_type": "mkfile"}
{"text": "#include <u.h>\n#include <libc.h>\n#include <bio.h>\n#include \"aa.h\"\n#include \"qp.h\"\n\n#define CAR(x)        ( (x)->car.o )\n#define CDR(x)        ( (x)->cdr.o )\n#define TAG(x)        ( (x)->car.c )\n#define ISUNBOUND(x)  ( (x) == nil )\n#define ISNULL(x)     ( (x) == &Null )\n#define ISTRUE(x)     ( (x) == &True )\n#define ISFALSE(x)    ( (x) == &False )\n#define TYPE(x)       ( TAG(x) & 0x1 ? TAG(x) >> 2 : AA_TPAIR )\n#define SETTYPE(x,t)  ( TAG(x) = (t) << 2 | 1 )\n#define NUMBER(x)     ( (x)->cdr.n )\n#define PRIM(x)       ( (x)->cdr.c )\n#define CFUNC(x)      ( (x)->cdr.f )\n#define STRBUF(x)     ( &(x)->car.c + 1 )\n\n#define STRBUFSIZE    ( (int)sizeof(aaValue) - 1 )\n#define GCMARKBIT     ( 0x2 )\n\n#define MAX(a,b) ((a)>(b)?(a):(b))\n#define MIN(a,b) ((a)<(b)?(a):(b))\n\n#define evalarg() (nargs++, eval(ctx, aa_nextarg(ctx, &arg, 0), env, nil))\n\n#define arithop(op, init) { \\\n\taaNumber x = {init}; \\\n\twhile(!ISNULL(arg)){ \\\n\t\taaNumber y = aa_tonumber(ctx, evalarg()); \\\n\t\tx.r = x.r op y.r; \\\n\t} \\\n\tres = aa_number(ctx, x); \\\n}\n\n#define numcmpop(op) { \\\n\tint c; \\\n\tva = checktype(ctx, evalarg(), AA_TNUMBER); \\\n\tvb = checktype(ctx, evalarg(), AA_TNUMBER); \\\n\twhile((c = (NUMBER(va).r op NUMBER(vb).r)) && !ISNULL(arg)){ \\\n\t\tva = vb; \\\n\t\tvb = checktype(ctx, evalarg(), AA_TNUMBER); \\\n\t} \\\n\tres = aa_bool(ctx, c); \\\n}\n\nenum {\n\tP_LET,\n\tP_DEFINE,\n\tP_SET_YAS,\n\tP_IF,\n\tP_LAMBDA,\n\tP_MAC,\n\tP_WHILE,\n\tP_QUOTE,\n\tP_EVAL,\n\tP_AND,\n\tP_OR,\n\tP_BEGIN,\n\tP_CONS,\n\tP_CAR,\n\tP_CDR,\n\tP_SETCAR,\n\tP_SETCDR,\n\tP_LIST,\n\tP_NOT,\n\tP_DISPLAY,\n\tP_EQ_HUH,\n\tP_EQUAL_HUH,\n\tP_ATOM_HUH,\n\tP_NUMBER_HUH,\n\tP_BOOLEAN_HUH,\n\tP_PORT_HUH,\n\tP_DEFINED_HUH,\n\tP_STRING_HUH,\n\tP_NAN_HUH,\n\tP_INF_HUH,\n\tP_EQN,\n\tP_LT,\n\tP_GT,\n\tP_LTE,\n\tP_GTE,\n\tP_ADD,\n\tP_SUB,\n\tP_MUL,\n\tP_DIV,\n\tP_MAX,\n\tP_MIN,\n\n\tNumprims\n};\n\nstatic const char *primnames[Numprims] = {\n\t[P_LET] = \"let\",\n\t[P_DEFINE] = \"define\",\n\t[P_SET_YAS] = \"set!\",\n\t[P_IF] = \"if\",\n\t[P_LAMBDA] = \"lambda\",\n\t[P_MAC] = \"mac\",\n\t[P_WHILE] = \"while\",\n\t[P_QUOTE] = \"quote\",\n\t[P_EVAL] = \"eval\",\n\t[P_AND] = \"and\",\n\t[P_OR] = \"or\",\n\t[P_BEGIN] = \"begin\",\n\t[P_CONS] = \"cons\",\n\t[P_CAR] = \"car\",\n\t[P_CDR] = \"cdr\",\n\t[P_SETCAR] = \"setcar\",\n\t[P_SETCDR] = \"setcdr\",\n\t[P_LIST] = \"list\",\n\t[P_NOT] = \"not\",\n\t[P_DISPLAY] = \"display\",\n\t[P_EQ_HUH] = \"eq?\",\n\t[P_EQUAL_HUH] = \"equal?\",\n\t[P_ATOM_HUH] = \"atom?\",\n\t[P_NUMBER_HUH] = \"number?\",\n\t[P_BOOLEAN_HUH] = \"boolean?\",\n\t[P_PORT_HUH] = \"port?\",\n\t[P_DEFINED_HUH] = \"defined?\",\n\t[P_STRING_HUH] = \"string?\",\n\t[P_NAN_HUH] = \"nan?\",\n\t[P_INF_HUH] = \"infinite?\",\n\t[P_EQN] = \"=\",\n\t[P_LT] = \"<\",\n\t[P_GT] = \">\",\n\t[P_LTE] = \"<=\",\n\t[P_GTE] = \">=\",\n\t[P_ADD] = \"+\",\n\t[P_SUB] = \"-\",\n\t[P_MUL] = \"*\",\n\t[P_DIV] = \"/\",\n\t[P_MAX] = \"max\",\n\t[P_MIN] = \"min\",\n};\n\nstatic const char *typenames[AA_TMAX] = {\n\t[AA_TPAIR] = \"pair\",\n\t[AA_TFREE] = \"free\",\n\t[AA_TNUMBER] = \"number\",\n\t[AA_TSYMBOL] = \"symbol\",\n\t[AA_TSTRING] = \"string\",\n\t[AA_TFUNC] = \"func\",\n\t[AA_TMACRO] = \"macro\",\n\t[AA_TPRIM] = \"prim\",\n\t[AA_TCFUNC] = \"cfunc\",\n\t[AA_TPTR] = \"ptr\",\n\t[AA_TBOOL] = \"bool\",\n\t[AA_TPORT] = \"port\",\n};\n\naaObject Null = {{ (void*)(AA_TPAIR << 2 | 1) }, { nil }};\naaObject False = {{ (void*)(AA_TBOOL << 2 | 1) }, { nil }};\naaObject True = {{ (void*)(AA_TBOOL << 2 | 1) }, { nil }};\nstatic aaObject rparen;\n\nstatic char prelude[] = \"\\\n(define newline (lambda () (display \\\"\\\\n\\\")))\\\n(define square (lambda (x) (* x x)))\\\n(define null? (lambda (x) (eq? x ())))\\\n(define finite? (lambda (x) (not (infinite? x))))\\\n\";\n\nstatic aaObject *eval(aaContext *ctx, aaObject *obj, aaObject *env, aaObject **bind);\n\naaHandlers *\naa_handlers(aaContext *ctx)\n{\n\treturn &ctx->handlers;\n}\n\nvoid\naa_error(aaContext *ctx, const char *fmt, ...)\n{\n\tchar buf[128];\n\tva_list arg;\n\taaObject *cl = ctx->calllist;\n\n\t/* reset context state */\n\tctx->calllist = &Null;\n\n\tva_start(arg, fmt);\n\tvsnprint(buf, sizeof(buf), fmt, arg);\n\tva_end(arg);\n\n\t/* do error handler */\n\tif(ctx->handlers.error)\n\t\tctx->handlers.error(ctx, buf, cl);\n\n\t/* error handler returned -- print error and traceback, exit */\n\tBprint(ctx->fd[2], \"error: %s\\n\", buf);\n\tfor(; !ISNULL(cl); cl = CDR(cl))\n\t\tBprint(ctx->fd[2], \"=> %\u00df\\n\", CAR(cl));\n\n\texits(buf);\n}\n\naaObject *\naa_nextarg(aaContext *ctx, aaObject **arg, int optional)\n{\n\taaObject *a = *arg;\n\n\tif(TYPE(a) != AA_TPAIR)\n\t\taa_error(ctx, \"dotted pair in argument list\");\n\tif(ISNULL(a)){\n\t\tif(optional)\n\t\t\treturn nil;\n\t\taa_error(ctx, \"too few arguments\");\n\t}\n\n\t*arg = CDR(a);\n\n\treturn CAR(a);\n}\n\nstatic aaObject *\nchecktype(aaContext *ctx, aaObject *obj, int type)\n{\n\tif(TYPE(obj) != type)\n\t\taa_error(ctx, \"expected %s, got %s\", typenames[type], typenames[TYPE(obj)]);\n\n\treturn obj;\n}\n\nint\naa_type(aaContext *ctx, aaObject *obj)\n{\n\tUSED(ctx);\n\treturn TYPE(obj);\n}\n\nvoid\naa_pushgc(aaContext *ctx, aaObject *obj)\n{\n\tif(ctx->gcstack_idx == GCSTACKSIZE)\n\t\taa_error(ctx, \"gc stack overflow\");\n\n\tctx->gcstack[ctx->gcstack_idx++] = obj;\n}\n\nvoid\naa_restoregc(aaContext *ctx, int idx)\n{\n\tctx->gcstack_idx = idx;\n}\n\nint\naa_savegc(aaContext *ctx)\n{\n\treturn ctx->gcstack_idx;\n}\n\nvoid\naa_mark(aaContext *ctx, aaObject *obj)\n{\n\taaObject *car;\n\nbegin:\n\tif(ISNULL(obj) || (TAG(obj) & GCMARKBIT) != 0)\n\t\treturn;\n\tcar = CAR(obj); /* store car before modifying it with GCMARKBIT */\n\tTAG(obj) |= GCMARKBIT;\n\n\tswitch(TYPE(obj)){\n\tcase AA_TPAIR:\n\t\taa_mark(ctx, car);\n\t\t/* fall through */\n\n\tcase AA_TFUNC:\n\tcase AA_TMACRO:\n\tcase AA_TSYMBOL:\n\tcase AA_TSTRING:\n\t\tobj = CDR(obj);\n\t\tgoto begin;\n\n\tcase AA_TPTR:\n\t\tif(ctx->handlers.mark)\n\t\t\tctx->handlers.mark(ctx, obj);\n\t\tbreak;\n\t}\n}\n\nstatic void\ncollectgarbage(aaContext *ctx)\n{\n\taaObject *obj;\n\tint i;\n\n\t/* mark */\n\tfor(i = 0; i < ctx->gcstack_idx; i++)\n\t\taa_mark(ctx, ctx->gcstack[i]);\n\n\taa_mark(ctx, ctx->symlist);\n\n\t/* sweep and unmark */\n\tfor(i = 0; i < ctx->object_count; i++){\n\t\tobj = &ctx->objects[i];\n\n\t\tif(TYPE(obj) == AA_TFREE)\n\t\t\tcontinue;\n\n\t\tif(~TAG(obj) & GCMARKBIT){\n\t\t\tif(TYPE(obj) == AA_TPTR && ctx->handlers.gc)\n\t\t\t\tctx->handlers.gc(ctx, obj);\n\n\t\t\tSETTYPE(obj, AA_TFREE);\n\t\t\tCDR(obj) = ctx->freelist;\n\t\t\tctx->freelist = obj;\n\t\t}else{\n\t\t\tTAG(obj) &= ~GCMARKBIT;\n\t\t}\n\t}\n}\n\nstatic int\nequal(aaObject *a, aaObject *b)\n{\n\tif(a == b)\n\t\treturn 1;\n\n\tif(TYPE(a) != TYPE(b) || TYPE(a) == AA_TBOOL)\n\t\treturn 0;\n\n\tif(TYPE(a) == AA_TNUMBER)\n\t\treturn NUMBER(a).r == NUMBER(b).r;\n\n\tif(TYPE(a) == AA_TSTRING){\n\t\tfor(; !ISNULL(a); a = CDR(a), b = CDR(b)){\n\t\t\tif(CAR(a) != CAR(b))\n\t\t\t\treturn 0;\n\t\t}\n\t\treturn a == b;\n\t}\n\n\tfor(; TYPE(a) == AA_TPAIR && TYPE(b) == AA_TPAIR && !ISNULL(a) && !ISNULL(b) && a != b; a = CDR(a), b = CDR(b)){\n\t\tif(!equal(CAR(a), CAR(b)))\n\t\t\treturn 0;\n\t}\n\n\treturn a == b;\n}\n\nstatic int\nstreq(aaObject *obj, const char *str)\n{\n\tint i;\n\n\twhile(!ISNULL(obj)){\n\t\tfor(i = 0; i < STRBUFSIZE; i++){\n\t\t\tif(STRBUF(obj)[i] != *str)\n\t\t\t\treturn 0;\n\t\t\tif(*str)\n\t\t\t\tstr++;\n\t\t}\n\t\tobj = CDR(obj);\n\t}\n\n\treturn *str == 0;\n}\n\nstatic aaObject *\nobject(aaContext *ctx)\n{\n\taaObject *obj;\n\n\t/* do gc if freelist has no more objects */\n\tif(ISNULL(ctx->freelist)){\n\t\tcollectgarbage(ctx);\n\t\tif(ISNULL(ctx->freelist))\n\t\t\taa_error(ctx, \"out of memory\");\n\t}\n\n\t/* get object from freelist and push to the gcstack */\n\tobj = ctx->freelist;\n\tctx->freelist = CDR(obj);\n\taa_pushgc(ctx, obj);\n\n\treturn obj;\n}\n\naaObject *\naa_cons(aaContext *ctx, aaObject *car, aaObject *cdr)\n{\n\taaObject *obj = object(ctx);\n\n\tCAR(obj) = car;\n\tCDR(obj) = cdr;\n\n\treturn obj;\n}\n\naaObject *\naa_bool(aaContext *ctx, int b)\n{\n\tUSED(ctx);\n\treturn b ? &True : &False;\n}\n\naaObject *\naa_number(aaContext *ctx, aaNumber n)\n{\n\taaObject *obj = object(ctx);\n\n\tSETTYPE(obj, AA_TNUMBER);\n\tNUMBER(obj) = n;\n\n\treturn obj;\n}\n\nstatic aaObject *\nbuildstring(aaContext *ctx, aaObject *tail, int chr)\n{\n\taaObject *obj;\n\n\tif(!tail || STRBUF(tail)[STRBUFSIZE - 1] != '\\0'){\n\t\tobj = aa_cons(ctx, nil, &Null);\n\t\tSETTYPE(obj, AA_TSTRING);\n\t\tif(tail){\n\t\t\tCDR(tail) = obj;\n\t\t\tctx->gcstack_idx--;\n\t\t}\n\t\ttail = obj;\n\t}\n\tSTRBUF(tail)[strlen(STRBUF(tail))] = chr;\n\n\treturn tail;\n}\n\naaObject *\naa_string(aaContext *ctx, const char *str)\n{\n\taaObject *obj = buildstring(ctx, nil, '\\0');\n\taaObject *tail = obj;\n\n\twhile(*str)\n\t\ttail = buildstring(ctx, tail, *str++);\n\n\treturn obj;\n}\n\naaObject *\naa_symbol_find(aaContext *ctx, const char *name)\n{\n\taaObject *obj;\n\tchar *pk;\n\n\tobj = nil;\n\tqpget(ctx->symtrie, name, 0, &pk, &obj);\n\n\treturn obj;\n}\n\naaObject *\naa_symbol(aaContext *ctx, const char *name)\n{\n\taaObject *obj;\n\n\t/* try to find it first */\n\tif((obj = aa_symbol_find(ctx, name)) != nil)\n\t\treturn obj;\n\n\t/* create new object, push to symlist and return */\n\tobj = object(ctx);\n\tSETTYPE(obj, AA_TSYMBOL);\n\tCDR(obj) = aa_cons(ctx, aa_string(ctx, name), nil); /* nil not &Null, because it's unbound */\n\tctx->symlist = aa_cons(ctx, obj, ctx->symlist);\n\tctx->symtrie = qpset(ctx->symtrie, strdup(name), 0, obj);\n\n\treturn obj;\n}\n\naaObject *\naa_cfunc(aaContext *ctx, aaCFunc fn)\n{\n\taaObject *obj = object(ctx);\n\n\tSETTYPE(obj, AA_TCFUNC);\n\tCFUNC(obj) = fn;\n\n\treturn obj;\n}\n\naaObject *\naa_ptr(aaContext *ctx, void *ptr)\n{\n\taaObject *obj = object(ctx);\n\n\tSETTYPE(obj, AA_TPTR);\n\tCDR(obj) = ptr;\n\n\treturn obj;\n}\n\naaObject *\naa_list(aaContext *ctx, aaObject **objs, int n)\n{\n\taaObject *res = &Null;\n\n\twhile(n--)\n\t\tres = aa_cons(ctx, objs[n], res);\n\n\treturn res;\n}\n\naaObject *\naa_car(aaContext *ctx, aaObject *obj)\n{\n\treturn ISNULL(obj) ? obj : CAR(checktype(ctx, obj, AA_TPAIR));\n}\n\naaObject *\naa_cdr(aaContext *ctx, aaObject *obj)\n{\n\treturn ISNULL(obj) ? obj : CDR(checktype(ctx, obj, AA_TPAIR));\n}\n\nstatic int\nobjfmt(Fmt *f)\n{\n\taaObject *obj;\n\tint qt, i;\n\n\tobj = va_arg(f->args, aaObject*);\n\tif(ISNULL(obj)){\n\t\tfmtstrcpy(f, \"()\");\n\t\treturn 0;\n\t}\n\n\tswitch(TYPE(obj)){\n\tcase AA_TNUMBER:\n\t\tfmtprint(f, \"%.9g\", NUMBER(obj).r);\n\t\tbreak;\n\n\tcase AA_TPAIR:\n\t\tfmtrune(f, '(');\n\t\tdo{\n\t\t\tfmtprint(f, \"%\u00a7\", CAR(obj));\n\t\t\tobj = CDR(obj);\n\t\t\tif(ISNULL(obj))\n\t\t\t\tbreak;\n\t\t\tfmtrune(f, ' ');\n\t\t}while(TYPE(obj) == AA_TPAIR);\n\t\tif(!ISNULL(obj))\n\t\t\tfmtprint(f, \". %\u00a7\", obj);\n\t\tfmtrune(f, ')');\n\t\tbreak;\n\n\tcase AA_TSYMBOL:\n\t\tfmtprint(f, \"%\u00df\", CAR(CDR(obj)));\n\t\tbreak;\n\n\tcase AA_TSTRING:\n\t\tqt = f->r == L'\u00a7';\n\t\tif(qt)\n\t\t\tfmtrune(f, '\"');\n\t\twhile(!ISNULL(obj)){\n\t\t\tfor(i = 0; i < STRBUFSIZE && STRBUF(obj)[i]; i++){\n\t\t\t\tif(qt && STRBUF(obj)[i] == '\"')\n\t\t\t\t\tfmtrune(f, '\\\\');\n\t\t\t\tfmtrune(f, STRBUF(obj)[i]);\n\t\t\t}\n\t\t\tobj = CDR(obj);\n\t\t}\n\t\tif(qt)\n\t\t\tfmtrune(f, '\"');\n\t\tbreak;\n\n\tcase AA_TBOOL:\n\t\tfmtprint(f, ISTRUE(obj) ? \"#t\" : \"#f\");\n\t\tbreak;\n\n\tdefault:\n\t\tfmtprint(f, \"[%s %p]\", typenames[TYPE(obj)], (void*)obj);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\naaNumber\naa_tonumber(aaContext *ctx, aaObject *obj)\n{\n\treturn NUMBER(checktype(ctx, obj, AA_TNUMBER));\n}\n\nvoid *\naa_toptr(aaContext *ctx, aaObject *obj)\n{\n\treturn CDR(checktype(ctx, obj, AA_TPTR));\n}\n\nstatic aaObject *\ngetbound(aaContext *ctx, aaObject *sym, aaObject *env)\n{\n\taaObject *x;\n\n\t/* try to find in environment */\n\tfor(; !ISNULL(env); env = CDR(env)){\n\t\tx = checktype(ctx, CAR(checktype(ctx, env, AA_TPAIR)), AA_TPAIR);\n\t\tif(CAR(x) == sym)\n\t\t\treturn x;\n\t}\n\n\t/* return global */\n\treturn CDR(sym);\n}\n\nvoid\naa_set(aaContext *ctx, aaObject *sym, aaObject *v)\n{\n\tUSED(ctx);\n\tCDR(getbound(ctx, sym, &Null)) = v;\n}\n\nstatic aaObject *\nread_(aaContext *ctx, Biobuf *fp)\n{\n\tconst char *delimiter = \" \\n\\t\\r();\";\n\taaObject *v, *res, **tail;\n\taaNumber n;\n\tlong r;\n\tint gc, i;\n\tchar buf[64], c[5], *p, *p2;\n\n\t/* get next character */\n\tr = ctx->nextrune ? ctx->nextrune : Bgetrune(fp);\n\tctx->nextrune = 0;\n\n\t/* skip whitespace */\n\twhile(r > 0 && utfrune(\" \\n\\t\\r\", r))\n\t\tr = Bgetrune(fp);\n\n\tif(r <= 0)\n\t\treturn nil;\n\n\tswitch(r){\n\tcase ';':\n\t\twhile(r > 0 && r != '\\n')\n\t\t\tr = Bgetrune(fp);\n\t\treturn read_(ctx, fp);\n\n\tcase ')':\n\t\treturn &rparen;\n\n\tcase '(':\n\t\tres = &Null;\n\t\ttail = &res;\n\t\tgc = aa_savegc(ctx);\n\t\taa_pushgc(ctx, res); /* to cause error on too-deep nesting */\n\t\twhile((v = read_(ctx, fp)) != &rparen){\n\t\t\tif(v == nil)\n\t\t\t\taa_error(ctx, \"unclosed list\");\n\t\t\tif(TYPE(v) == AA_TSYMBOL && streq(CAR(CDR(v)), \".\")){\n\t\t\t\t/* dotted pair */\n\t\t\t\t*tail = aa_read(ctx, fp);\n\t\t\t}else{\n\t\t\t\t/* proper pair */\n\t\t\t\t*tail = aa_cons(ctx, v, &Null);\n\t\t\t\ttail = &CDR(*tail);\n\t\t\t}\n\t\t\taa_restoregc(ctx, gc);\n\t\t\taa_pushgc(ctx, res);\n\t\t}\n\t\treturn res;\n\n\tcase '\\'':\n\t\tv = aa_read(ctx, fp);\n\t\tif(!v)\n\t\t\taa_error(ctx, \"stray '''\");\n\t\treturn aa_cons(ctx, aa_symbol(ctx, \"quote\"), aa_cons(ctx, v, &Null));\n\n\tcase '\"':\n\t\tres = buildstring(ctx, nil, '\\0');\n\t\tv = res;\n\t\tfor(r = Bgetrune(fp); r != '\"'; r = Bgetrune(fp)){\n\t\t\tif(r <= 0)\n\t\t\t\taa_error(ctx, \"unclosed string\");\n\t\t\tif(r == '\\\\'){\n\t\t\t\tr = Bgetrune(fp);\n\t\t\t\tif(utfrune(\"nrt\", r))\n\t\t\t\t\tr = utfrune(\"n\\nr\\rt\\t\", r)[1];\n\t\t\t}\n\t\t\tc[runetochar(c, (Rune*)&r)] = 0;\n\t\t\tfor(i = 0; c[i] != 0; i++)\n\t\t\t\tv = buildstring(ctx, v, c[i]);\n\t\t}\n\t\treturn res;\n\n\tdefault:\n\t\tp = buf;\n\t\tdo{\n\t\t\tc[runetochar(c, (Rune*)&r)] = 0;\n\t\t\tif(p == (p2 = utfecpy(p, buf+sizeof(buf), c)))\n\t\t\t\taa_error(ctx, \"symbol too long\");\n\t\t\tp = p2;\n\t\t\tr = Bgetrune(fp);\n\t\t}while(r > 0 && utfrune(delimiter, r) == nil);\n\t\t*p = '\\0';\n\t\tctx->nextrune = r;\n\t\tn.r = strtod(buf, &p); /* try to read as number */\n\t\tif(p != buf && utfrune(delimiter, *p) != nil)\n\t\t\treturn aa_number(ctx, n);\n\t\treturn aa_symbol(ctx, buf);\n\t}\n}\n\naaObject *\naa_read(aaContext *ctx, Biobuf *fp)\n{\n\taaObject *obj = read_(ctx, fp);\n\n\tif(obj == &rparen)\n\t\taa_error(ctx, \"stray ')'\");\n\n\treturn obj;\n}\n\nstatic aaObject *\nevallist(aaContext *ctx, aaObject *lst, aaObject *env)\n{\n\taaObject *res = &Null;\n\taaObject **tail;\n\n\tfor(tail = &res; !ISNULL(lst); tail = &CDR(*tail))\n\t\t*tail = aa_cons(ctx, eval(ctx, aa_nextarg(ctx, &lst, 0), env, nil), &Null);\n\n\treturn res;\n}\n\nstatic aaObject *\nrunlist(aaContext *ctx, aaObject *lst, aaObject *env)\n{\n\taaObject *res;\n\tint save = aa_savegc(ctx);\n\n\tfor(res = &Null; !ISNULL(lst);){\n\t\taa_restoregc(ctx, save);\n\t\taa_pushgc(ctx, lst);\n\t\taa_pushgc(ctx, env);\n\t\tres = eval(ctx, aa_nextarg(ctx, &lst, 0), env, &env);\n\t}\n\n\treturn res;\n}\n\nstatic aaObject *\nargstoenv(aaContext *ctx, aaObject *prm, aaObject *arg, aaObject *env)\n{\n\twhile(!ISNULL(prm)){\n\t\tif(TYPE(prm) != AA_TPAIR){\n\t\t\tenv = aa_cons(ctx, aa_cons(ctx, prm, arg), env);\n\t\t\tbreak;\n\t\t}\n\t\tenv = aa_cons(ctx, aa_cons(ctx, CAR(prm), aa_car(ctx, arg)), env);\n\t\tprm = CDR(prm);\n\t\targ = aa_cdr(ctx, arg);\n\t}\n\n\treturn env;\n}\n\n#define noargs() do{ \\\n\tif(!ISNULL(arg)) \\\n\t\taa_error(ctx, \"%s needs %d arguments\", primnames[prim], nargs); \\\n\t}while(0)\n\nstatic aaObject *\neval(aaContext *ctx, aaObject *obj, aaObject *env, aaObject **newenv)\n{\n\taaObject *fn, *arg, *res;\n\taaObject cl, *va, *vb;\n\taaNumber n, n2;\n\tint i, gc, prim, nargs;\n\n\tif(TYPE(obj) == AA_TSYMBOL){\n\t\targ = getbound(ctx, obj, env);\n\t\tres = CDR(arg);\n\t\tif(ISUNBOUND(res))\n\t\t\taa_error(ctx, \"unbound variable: %\u00df\", CAR(arg));\n\t\treturn res;\n\t}\n\tif(TYPE(obj) != AA_TPAIR || ISNULL(obj))\n\t\treturn obj;\n\n\tCAR(&cl) = obj, CDR(&cl) = ctx->calllist;\n\tctx->calllist = &cl;\n\n\tgc = aa_savegc(ctx);\n\tfn = eval(ctx, CAR(obj), env, nil);\n\targ = CDR(obj);\n\tres = &Null;\n\n\tswitch(TYPE(fn)){\n\tcase AA_TPRIM:\n\t\tnargs = 0;\n\t\tprim = PRIM(fn);\n\t\tswitch(prim){\n\t\tcase P_LET:\n\t\t\tva = checktype(ctx, aa_nextarg(ctx, &arg, 0), AA_TSYMBOL);\n\t\t\tif(newenv)\n\t\t\t\t*newenv = aa_cons(ctx, aa_cons(ctx, va, evalarg()), env);\n\t\t\tbreak;\n\n\t\tcase P_DEFINE:\n\t\t\tres = checktype(ctx, aa_nextarg(ctx, &arg, 0), AA_TSYMBOL);\n\t\t\tCDR(getbound(ctx, res, env)) = evalarg();\n\t\t\tbreak;\n\n\t\tcase P_SET_YAS:\n\t\t\tva = checktype(ctx, aa_nextarg(ctx, &arg, 0), AA_TSYMBOL);\n\t\t\tif(ISUNBOUND(CDR(CDR(va))))\n\t\t\t\taa_error(ctx, \"unbound variable: %\u00df\", va);\n\t\t\telse\n\t\t\t\taa_set(ctx, va, evalarg());\n\t\t\tbreak;\n\n\t\tcase P_IF:\n\t\t\twhile(!ISNULL(arg)){\n\t\t\t\tva = evalarg();\n\t\t\t\tif(!ISFALSE(va)){\n\t\t\t\t\tres = ISNULL(arg) ? va : evalarg();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(ISNULL(arg))\n\t\t\t\t\tbreak;\n\t\t\t\targ = CDR(arg);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase P_LAMBDA:\n\t\tcase P_MAC:\n\t\t\tva = aa_cons(ctx, env, arg);\n\t\t\taa_nextarg(ctx, &arg, 0);\n\t\t\tres = object(ctx);\n\t\t\tSETTYPE(res, PRIM(fn) == P_LAMBDA ? AA_TFUNC : AA_TMACRO);\n\t\t\tCDR(res) = va;\n\t\t\tbreak;\n\n\t\tcase P_WHILE:\n\t\t\tva = aa_nextarg(ctx, &arg, 0);\n\t\t\ti = aa_savegc(ctx);\n\t\t\twhile(!ISFALSE(eval(ctx, va, env, nil))){\n\t\t\t\trunlist(ctx, arg, env);\n\t\t\t\taa_restoregc(ctx, i);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase P_QUOTE:\n\t\t\tres = aa_nextarg(ctx, &arg, 0);\n\t\t\tbreak;\n\n\t\tcase P_EVAL:\n\t\t\tva = evalarg();\n\t\t\tvb = !ISNULL(arg) ? evalarg() : env;\n\t\t\tres = eval(ctx, va, vb, nil);\n\t\t\tbreak;\n\n\t\tcase P_AND:\n\t\t\twhile(!ISNULL(arg) && !ISFALSE(res = evalarg()));\n\t\t\tbreak;\n\n\t\tcase P_OR:\n\t\t\twhile(!ISNULL(arg) && ISFALSE(res = evalarg()));\n\t\t\tbreak;\n\n\t\tcase P_BEGIN:\n\t\t\tres = runlist(ctx, arg, env);\n\t\t\tbreak;\n\n\t\tcase P_CONS:\n\t\t\tva = evalarg();\n\t\t\tres = aa_cons(ctx, va, evalarg());\n\t\t\tnoargs();\n\t\t\tbreak;\n\n\t\tcase P_CAR:\n\t\t\tres = aa_car(ctx, evalarg());\n\t\t\tbreak;\n\n\t\tcase P_CDR:\n\t\t\tres = aa_cdr(ctx, evalarg());\n\t\t\tbreak;\n\n\t\tcase P_SETCAR:\n\t\t\tva = checktype(ctx, evalarg(), AA_TPAIR);\n\t\t\tCAR(va) = evalarg();\n\t\t\tbreak;\n\n\t\tcase P_SETCDR:\n\t\t\tva = checktype(ctx, evalarg(), AA_TPAIR);\n\t\t\tCDR(va) = evalarg();\n\t\t\tbreak;\n\n\t\tcase P_LIST:\n\t\t\tres = evallist(ctx, arg, env);\n\t\t\tbreak;\n\n\t\tcase P_NOT:\n\t\t\tres = aa_bool(ctx, ISFALSE(evalarg()));\n\t\t\tbreak;\n\n\t\tcase P_EQ_HUH:\n\t\t\tres = aa_bool(ctx, evalarg() == evalarg());\n\t\t\tnoargs();\n\t\t\tbreak;\n\n\t\tcase P_EQUAL_HUH:\n\t\t\tres = aa_bool(ctx, equal(evalarg(), evalarg()));\n\t\t\tnoargs();\n\t\t\tbreak;\n\n\t\tcase P_ATOM_HUH:\n\t\t\tres = aa_bool(ctx, aa_type(ctx, evalarg()) != AA_TPAIR);\n\t\t\tnoargs();\n\t\t\tbreak;\n\n\t\tcase P_NUMBER_HUH:\n\t\t\tres = aa_bool(ctx, aa_type(ctx, evalarg()) == AA_TNUMBER);\n\t\t\tnoargs();\n\t\t\tbreak;\n\n\t\tcase P_BOOLEAN_HUH:\n\t\t\tres = aa_bool(ctx, aa_type(ctx, evalarg()) == AA_TBOOL);\n\t\t\tnoargs();\n\t\t\tbreak;\n\n\t\tcase P_PORT_HUH:\n\t\t\tres = aa_bool(ctx, aa_type(ctx, evalarg()) == AA_TPORT);\n\t\t\tnoargs();\n\t\t\tbreak;\n\n\t\tcase P_DEFINED_HUH:\n\t\t\tva = checktype(ctx, evalarg(), AA_TSYMBOL);\n\t\t\tres = aa_bool(ctx, !ISUNBOUND(CDR(CDR(va))));\n\t\t\tnoargs();\n\t\t\tbreak;\n\n\t\tcase P_STRING_HUH:\n\t\t\tres = aa_bool(ctx, aa_type(ctx, evalarg()) == AA_TSTRING);\n\t\t\tnoargs();\n\t\t\tbreak;\n\n\t\tcase P_NAN_HUH:\n\t\t\tn = aa_tonumber(ctx, evalarg());\n\t\t\tres = aa_bool(ctx, isNaN(n.r));\n\t\t\tnoargs();\n\t\t\tbreak;\n\n\t\tcase P_INF_HUH:\n\t\t\tn = aa_tonumber(ctx, evalarg());\n\t\t\tres = aa_bool(ctx, isInf(n.r, -1) || isInf(n.r, +1));\n\t\t\tnoargs();\n\t\t\tbreak;\n\n\t\tcase P_DISPLAY:\n\t\t\tva = evalarg();\n\t\t\tif(!ISNULL(arg)) /* FIXME port */\n\t\t\t\tevalarg();\n\t\t\tnoargs();\n\t\t\tres = aa_bool(ctx, Bprint(ctx->fd[1], \"%\u00df\", va) >= 0);\n\t\t\tbreak;\n\n\t\tcase P_EQN: numcmpop(==); break;\n\t\tcase P_LT: numcmpop(<); break;\n\t\tcase P_GT: numcmpop(>); break;\n\t\tcase P_LTE: numcmpop(<=); break;\n\t\tcase P_GTE: numcmpop(>=); break;\n\t\tcase P_ADD: arithop(+, 0); break;\n\t\tcase P_MUL: arithop(*, 1); break;\n\n\t\tcase P_SUB:\n\t\t\tn = aa_tonumber(ctx, evalarg());\n\t\t\tif(ISNULL(arg)){\n\t\t\t\tn.r = -n.r;\n\t\t\t\tres = aa_number(ctx, n);\n\t\t\t}else{\n\t\t\t\tarithop(+, 0);\n\t\t\t\tNUMBER(res).r = n.r - NUMBER(res).r;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase P_DIV:\n\t\t\tn = aa_tonumber(ctx, evalarg());\n\t\t\tif(ISNULL(arg)){\n\t\t\t\tn.r = 1.0/n.r;\n\t\t\t\tres = aa_number(ctx, n);\n\t\t\t}else{\n\t\t\t\tarithop(*, 1);\n\t\t\t\tNUMBER(res).r = n.r / NUMBER(res).r;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase P_MAX:\n\t\t\tn = aa_tonumber(ctx, evalarg());\n\t\t\tn2 = aa_tonumber(ctx, evalarg());\n\t\t\tn.r = MAX(n.r, n2.r);\n\t\t\twhile(!ISNULL(arg)){\n\t\t\t\tn2 = aa_tonumber(ctx, evalarg());\n\t\t\t\tn.r = MAX(n.r, n2.r);\n\t\t\t}\n\t\t\tres = aa_number(ctx, n);\n\t\t\tbreak;\n\n\t\tcase P_MIN:\n\t\t\tn = aa_tonumber(ctx, evalarg());\n\t\t\tn2 = aa_tonumber(ctx, evalarg());\n\t\t\tn.r = MIN(n.r, n2.r);\n\t\t\twhile(!ISNULL(arg)){\n\t\t\t\tn2 = aa_tonumber(ctx, evalarg());\n\t\t\t\tn.r = MIN(n.r, n2.r);\n\t\t\t}\n\t\t\tres = aa_number(ctx, n);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tsysfatal(\"%s not implemented\", primnames[PRIM(fn)]);\n\t\t}\n\t\tUSED(nargs);\n\t\tbreak;\n\n\tcase AA_TCFUNC:\n\t\tres = CFUNC(fn)(ctx, evallist(ctx, arg, env));\n\t\tif(res == nil)\n\t\t\taa_error(ctx, \"%r\");\n\t\tbreak;\n\n\tcase AA_TFUNC:\n\t\targ = evallist(ctx, arg, env);\n\t\tva = CDR(fn); /* (env params ...) */\n\t\tvb = CDR(va); /* (params ...) */\n\t\tres = runlist(ctx, CDR(vb), argstoenv(ctx, CAR(vb), arg, CAR(va)));\n\t\tbreak;\n\n\tcase AA_TMACRO:\n\t\tva = CDR(fn); /* (env params ...) */\n\t\tvb = CDR(va); /* (params ...) */\n\t\t/* replace caller object with code generated by macro and re-eval */\n\t\t*obj = *runlist(ctx, CDR(vb), argstoenv(ctx, CAR(vb), arg, CAR(va)));\n\t\taa_restoregc(ctx, gc);\n\t\tctx->calllist = CDR(&cl);\n\t\treturn eval(ctx, obj, env, nil);\n\n\tdefault:\n\t\taa_error(ctx, \"tried to call non-callable value\");\n\t}\n\n\taa_restoregc(ctx, gc);\n\taa_pushgc(ctx, res);\n\tctx->calllist = CDR(&cl);\n\n\treturn res;\n}\n\naaObject *\naa_eval(aaContext *ctx, aaObject *obj)\n{\n\treturn eval(ctx, obj, &Null, nil);\n}\n\nstatic int\neof(Biobufhdr *, void *, long)\n{\n\treturn 0;\n}\n\naaContext *\naa_open(void *ptr, int size, int flags)\n{\n\tint i, save;\n\taaContext *ctx;\n\taaObject *v;\n\tBiobuf b;\n\n\tfmtinstall(L'\u00df', objfmt);\n\tfmtinstall(L'\u00a7', objfmt);\n\n\t/* init context struct */\n\tctx = ptr;\n\tmemset(ctx, 0, sizeof(aaContext));\n\tptr = (char*)ptr + sizeof(aaContext);\n\tsize -= sizeof(aaContext);\n\n\t/* init objects memory region */\n\tctx->objects = (aaObject*)ptr;\n\tctx->object_count = size / sizeof(aaObject);\n\n\t/* init lists */\n\tctx->calllist = &Null;\n\tctx->freelist = &Null;\n\tctx->symlist = &Null;\n\n\t/* populate freelist */\n\tfor(i = 0; i < ctx->object_count; i++){\n\t\tv = &ctx->objects[i];\n\t\tSETTYPE(v, AA_TFREE);\n\t\tCDR(v) = ctx->freelist;\n\t\tctx->freelist = v;\n\t}\n\n\t/* register built in primitives */\n\tsave = aa_savegc(ctx);\n\tfor(i = 0; i < nelem(primnames); i++){\n\t\tv = object(ctx);\n\t\tSETTYPE(v, AA_TPRIM);\n\t\tPRIM(v) = i;\n\t\taa_set(ctx, aa_symbol(ctx, primnames[i]), v);\n\t\taa_restoregc(ctx, save);\n\t}\n\taa_set(ctx, aa_symbol(ctx, \"#t\"), &True);\n\taa_set(ctx, aa_symbol(ctx, \"#f\"), &False);\n\taa_set(ctx, aa_symbol(ctx, \"#true\"), &True);\n\taa_set(ctx, aa_symbol(ctx, \"#false\"), &False);\n\taa_restoregc(ctx, save);\n\n\tif((flags & AA_NOSTDIO) == 0){\n\t\tctx->fd[0] = Bfdopen(0, OREAD);\n\t\tctx->fd[1] = Bfdopen(1, OWRITE);\n\t\tctx->fd[2] = Bfdopen(2, OWRITE);\n\t}\n\n\ti = strlen(prelude);\n\tBinits(&b, -1, OREAD, (uchar*)prelude, i);\n\tb.icount = -i;\n\tBiofn(&b, eof);\n\twhile((v = aa_read(ctx, &b)) != nil){\n\t\taa_eval(ctx, v);\n\t\taa_restoregc(ctx, save);\n\t}\n\n\treturn ctx;\n}\n\nvoid\naa_close(aaContext *ctx)\n{\n\tint i;\n\n\tfor(i = 0; i < nelem(ctx->fd); i++)\n\t\tBterm(ctx->fd[i]);\n\n\t/* clear gcstack and symlist; makes all objects unreachable */\n\tctx->gcstack_idx = 0;\n\tctx->symlist = &Null;\n\tcollectgarbage(ctx);\n}\n", "source": "aa/aa.c", "file_type": "c"}
{"text": "#include <u.h>\n#include <libc.h>\n#include <bio.h>\n#include \"aa.h\"\n#include \"aa_math.h\"\n\n#define CFUNC1(func) \\\n\tstatic aaObject * \\\n\tcf_##func(aaContext *ctx, aaObject *arg) \\\n\t{ \\\n\t\taaNumber x = aa_tonumber(ctx, aa_nextarg(ctx, &arg, 0)); \\\n\t\treturn aa_number(ctx, aNumber(func(x.r), 0.0)); \\\n\t}\n\n#define CFUNC2(func) \\\n\tstatic aaObject * \\\n\tcf_##func(aaContext *ctx, aaObject *arg) \\\n\t{ \\\n\t\taaNumber x = aa_tonumber(ctx, aa_nextarg(ctx, &arg, 0)); \\\n\t\taaNumber y = aa_tonumber(ctx, aa_nextarg(ctx, &arg, 0)); \\\n\t\treturn aa_number(ctx, aNumber(func(x.r, y.r), 0.0)); \\\n\t}\n\n#define FUNCS \\\n\tCFUNC1(sin); \\\n\tCFUNC1(cos); \\\n\tCFUNC1(tan); \\\n\tCFUNC1(asin); \\\n\tCFUNC1(acos); \\\n\tCFUNC1(exp); \\\n\tCFUNC1(log); \\\n\tCFUNC1(sqrt); \\\n\tCFUNC1(floor); \\\n\tCFUNC1(log10); \\\n\tCFUNC1(sinh); \\\n\tCFUNC1(cosh); \\\n\tCFUNC1(tanh); \\\n\nFUNCS\nCFUNC1(fabs);\nCFUNC1(ceil);\nCFUNC2(pow);\n\nstatic aaObject *\ncf_atan2(aaContext *ctx, aaObject *arg)\n{\n\taaNumber x = aa_tonumber(ctx, aa_nextarg(ctx, &arg, 0));\n\taaObject *yo = aa_nextarg(ctx, &arg, 1);\n\taaNumber y = yo != nil ? aa_tonumber(ctx, yo) : aNumber(1.0, 0.0);\n\treturn aa_number(ctx, aNumber(atan2(x.r, y.r), 0.0));\n}\n\nstatic aaObject *\ncf_truncate(aaContext *ctx, aaObject *arg)\n{\n\taaNumber x = aa_tonumber(ctx, aa_nextarg(ctx, &arg, 0));\n\tmodf(x.r, &x.r);\n\treturn aa_number(ctx, x);\n}\n\n#undef CFUNC1\n#undef CFUNC2\n#define CFUNC(func, name) aa_set(ctx, aa_symbol(ctx, name), aa_cfunc(ctx, cf_##func))\n#define CFUNC1(x) CFUNC(x, #x)\n#define CFUNC2(x) CFUNC(x, #x)\n\nvoid\naa_include_math(aaContext *ctx)\n{\n\tFUNCS;\n\tCFUNC(fabs, \"abs\");\n\tCFUNC(ceil, \"ceiling\");\n\tCFUNC(pow, \"expt\");\n\tCFUNC(atan2, \"atan\");\n\tCFUNC(truncate, \"truncate\");\n}\n", "source": "aa/aa_math.c", "file_type": "c"}
{"text": "#include <u.h>\n#include <libc.h>\n#include <bio.h>\n#include \"aa.h\"\n#include \"aa_math.h\"\n\n/* need this for note handling\n * FIXME in threaded program we'd probably use thread local storage?\n */\nstatic aaContext *curctx;\n\nstatic jmp_buf toplevel;\nstatic char buf[64000];\n\nstatic void\nonerror(aaContext *ctx, const char *msg, aaObject *cl)\n{\n\tUSED(cl);\n\tBprint(ctx->fd[2], \"error: %s\\n\", msg);\n\tBflush(ctx->fd[2]);\n\tlongjmp(toplevel, -1);\n}\n\nstatic void\nonnote(void *uregs, char *msg)\n{\n\tif(strncmp(msg, \"sys: trap: \", 11) == 0)\n\t\tnoted(NDFLT);\n\tBprint(curctx->fd[2], \"error: %s\\n\", msg);\n\tBflush(curctx->fd[2]);\n\tnotejmp(uregs, toplevel, -1);\n}\n\nvoid\nmain(int argc, char **argv)\n{\n\tint gc;\n\taaObject *obj;\n\tBiobuf *fp;\n\taaContext *ctx = aa_open(buf, sizeof(buf), 0);\n\n\taa_include_math(ctx);\n\tcurctx = ctx;\n\tnotify(onnote);\n\n\tif(argc > 1){\n\t\tif((fp = Bopen(argv[1], OREAD)) == nil)\n\t\t\taa_error(ctx, \"could not open input file\");\n\t\telse\n\t\t\tctx->fd[0] = fp;\n\t}else{\n\t\tfp = ctx->fd[0];\n\t\taa_handlers(ctx)->error = onerror;\n\t\tBprint(ctx->fd[2], \"aa v0.0.1\\n\");\n\t}\n\n\tgc = aa_savegc(ctx);\n\tsetjmp(toplevel);\n\n\tfor(;;){\n\t\taa_restoregc(ctx, gc);\n\t\tif(fp->fid == 0){\n\t\t\tBflush(ctx->fd[2]);\n\t\t\tBflush(ctx->fd[1]);\n\t\t}\n\t\tif((obj = aa_read(ctx, fp)) == nil)\n\t\t\tbreak;\n\t\tobj = aa_eval(ctx, obj);\n\t\tif(fp->fid == 0)\n\t\t\tBprint(ctx->fd[2], \"\\x08 \u21d2 %\u00a7\\n\", obj);\n\t}\n\n\taa_close(ctx);\n\n\texits(nil);\n}\n", "source": "aa/repl.c", "file_type": "c"}
{"text": "#include <u.h>\n#include <libc.h>\n#include \"qp.h\"\n\ntypedef u16int Tbitmap;\ntypedef struct Tbranch Tbranch;\ntypedef struct Tleaf Tleaf;\n\nstruct Tleaf {\n\tchar *k;\n\tvoid *v;\n};\n\nstruct Tbranch {\n\tTrie *twigs;\n\tu64int x;\n};\n\nunion Trie {\n\tTleaf leaf;\n\tTbranch branch;\n};\n\n#define x_flags(x) ((x)>>62)\n#define x_index(x) ((x)>>16 & ((1ULL<<46)-1ULL))\n#define x_bitmap(x) ((x) & 0xffff)\n\n#define isbranch(t) (x_flags((t)->branch.x) != 0)\n#define hastwig(t, b) (x_bitmap((t)->branch.x) & (b))\n#define twigoff(t, b) popcount(x_bitmap((t)->branch.x) & ((b)-1))\n#define twig(t, i) (&(t)->branch.twigs[(i)])\n#define twigoffmax(off, max, t, b) do{ off = twigoff(t, b); max = popcount(x_bitmap((t)->branch.x)); }while(0)\n#define nibbit(k, f) (1 << (((k) & (((f)-2) ^ 0x0f) & 0xff) >> ((2-(f))<<2)))\n#define twigbit(t, k, len) \\\n\t(x_index((t)->branch.x) >= (len) ? \\\n\t1 : \\\n\tnibbit((u8int)(k)[x_index((t)->branch.x)], x_flags((t)->branch.x)))\n\n/*\n// need some speed? just say no.\n#define POPCNT\tBYTE $0xf3; BYTE $0x0f; BYTE $0xb8\n\nTEXT popcount(SB),$0\n\tMOVL b+0(FP), AX\n\tPOPCNT\n\tRET\n*/\nstatic u16int\npopcount(u16int b)\n{\n\tb -= b>>1 & 0x5555;\n\tb = (b & 0x3333) + ((b>>2) & 0x3333);\n\tb = (b + (b>>4)) & 0x0f0f;\n\tb = (b + (b>>8)) & 0x00ff;\n\treturn b;\n}\n\nint\nqpget(Trie *t, char *k, int len, char **pk, void **pv)\n{\n\tTbitmap b;\n\n\tassert(k != nil && pk != nil && pv != nil);\n\n\tif(len < 1)\n\t\tlen = strlen(k);\n\tif(t == nil)\n\t\treturn -1;\n\tfor(; isbranch(t); t = twig(t, twigoff(t, b))){\n\t\tb = twigbit(t, k, len);\n\t\tif(!hastwig(t, b))\n\t\t\treturn -1;\n\t}\n\tif(strncmp(k, t->leaf.k, len) != 0)\n\t\treturn -1;\n\t*pk = t->leaf.k;\n\t*pv = t->leaf.v;\n\n\treturn 0;\n}\n\nint\nqpnext(Trie *t, char **pk, int *plen, void **pv)\n{\n\tTbitmap b;\n\tuint s, m;\n\n\tassert(pk != nil && plen != nil && pv != nil);\n\n\tif(isbranch(t)){\n\t\tb = twigbit(t, *pk, *plen);\n\t\ttwigoffmax(s, m, t, b);\n\t\tfor(; s < m; s++){\n\t\t\tif(qpnext(twig(t, s), pk, plen, pv) == 0)\n\t\t\t\treturn 0;\n\t\t}\n\t\treturn -1;\n\t}\n\n\tif(*pk == nil){\n\t\t*pk = t->leaf.k;\n\t\t*plen = strlen(*pk);\n\t\t*pv = t->leaf.v;\n\t\treturn 0;\n\t}\n\n\treturn -1;\n}\n\nTrie *\nqpset(Trie *t, char *k, int len, void *v)\n{\n\tTrie *t0, t1, t2;\n\tuint i, s, m;\n\tu8int f;\n\tTbitmap b, b1, b2;\n\tu8int k2;\n\n\tassert(k != nil && v != nil);\n\tif(len < 1)\n\t\tlen = strlen(k);\n\tassert(len > 0);\n\n\tif(t == nil){\n\t\tt = malloc(sizeof(*t));\n\t\tassert(t != nil);\n\t\tt->leaf.k = k;\n\t\tt->leaf.v = v;\n\t\treturn t;\n\t}\n\n\tt0 = t;\n\tfor(; isbranch(t); t = twig(t, i)){\n\t\tb = twigbit(t, k, len);\n\t\ti = hastwig(t, b) ? twigoff(t, b) : 0;\n\t}\n\tfor(i = 0; i <= len && k[i] == t->leaf.k[i]; i++);\n\tif(i == len+1){\n\t\tt->leaf.v = v;\n\t\treturn t0;\n\t}\n\n\tk2 = (u8int)t->leaf.k[i];\n\tf = (((u8int)k[i] ^ k2) & 0xf0) ? 1 : 2;\n\tb1 = nibbit(k[i], f);\n\tt1.leaf.k = k;\n\tt1.leaf.v = v;\n\tfor(t = t0; isbranch(t); t = twig(t, twigoff(t, b))){\n\t\tif(i == x_index(t->branch.x)){\n\t\t\tif(f == x_flags(t->branch.x))\n\t\t\t\tgoto growbranch;\n\t\t\tif(f < x_flags(t->branch.x))\n\t\t\t\tbreak;\n\t\t}else if(i < x_index(t->branch.x)){\n\t\t\tbreak;\n\t\t}\n\t\tb = twigbit(t, k, len);\n\t\tassert(hastwig(t, b));\n\t}\n\n\tt2 = *t;\n\tb2 = nibbit(k2, f);\n\tt->branch.twigs = malloc(sizeof(*t)*2);\n\tassert(t->branch.twigs != nil);\n\tt->branch.x = (uvlong)f<<62 | (uvlong)i<<16 | b1 | b2;\n\t*twig(t, twigoff(t, b1)) = t1;\n\t*twig(t, twigoff(t, b2)) = t2;\n\n\treturn t0;\n\ngrowbranch:\n\tassert(!hastwig(t, b1));\n\ttwigoffmax(s, m, t, b1);\n\tt->branch.twigs = realloc(t->branch.twigs, sizeof(*t)*(m+1));\n\tmemmove(t->branch.twigs+s+1, t->branch.twigs+s, sizeof(*t)*(m-s));\n\tmemmove(t->branch.twigs+s, &t1, sizeof(t1));\n\tt->branch.x |= b1;\n\n\treturn t0;\n}\n", "source": "aa/qp.c", "file_type": "c"}
{"text": "#!/bin/rc\nrfork ne\n\nd=`{pwd}\na=''\nwhile(! p=`{ns | grep ' /mnt/term/.* '^$\"d^'[ ]*$' | sed 's,.*/mnt/term([^ ]*).*,\\1,g'}) {\n\ta=`{basename $\"d}^/^$\"a\n\td=`{basename -d $\"d}\n}\necho $p/$a\n", "source": "neindaw/osdir", "file_type": "rc"}
{"text": "#include <u.h>\n#include <libc.h>\n#include <tos.h>\n\nint usensec = 0;\n\nstatic int b2i[255] = {\n\t['0'] =  0,  1,  2,  3,  4,  5,  6,  7,  8,  9,\n\t['a'] = 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n\t['k'] = 20, 21, 22, 23, 24, 25, 26, 27, 28, 29,\n\t['u'] = 30, 31, 32, 33, 34, 35,\n\t['A'] = 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n\t['K'] = 20, 21, 22, 23, 24, 25, 26, 27, 28, 29,\n\t['U'] = 30, 31, 32, 33, 34, 35,\n};\n\nstatic float notes[/* octave */]['g'-'A'+1 /* note */] = {\n#include \"a440.h\"\n};\n\nint\ni36(uchar c)\n{\n\treturn b2i[c];\n}\n\nfloat\nnote2freq(uchar note, uchar octave)\n{\n\tnote -= 'A';\n\toctave -= '0';\n\tif (octave >= nelem(notes) || note >= nelem(notes[0]))\n\t\treturn 0.0;\n\treturn notes[octave][note];\n}\n\nint\npathopen(char *path, char *fmt, ...)\n{\n\tva_list arg;\n\tchar *s;\n\tint fd;\n\n\tva_start(arg, fmt);\n\ts = vsmprint(fmt, arg);\n\tva_end(arg);\n\n\tif (s == nil || (path = smprint(\"%s/%s\", path, s)) == nil)\n\t\tsysfatal(\"memory\");\n\tfree(s);\n\tif ((fd = open(path, OWRITE)) < 0)\n\t\tfprint(2, \"%s: %r\\n\", path);\n\tfree(path);\n\n\treturn fd;\n}\n\n/*\n * nsec() is wallclock and can be adjusted by timesync\n * so need to use cycles() instead, but fall back to\n * nsec() in case we can't\n */\nuvlong\nnanosec(void)\n{\n\tstatic uvlong fasthz, xstart;\n\tuvlong x, div;\n\n\tif(fasthz == ~0ULL)\n\t\treturn nsec() - xstart;\n\n\tif(fasthz == 0){\n\t\tfasthz = _tos->cyclefreq;\n\t\tif(fasthz == 0){\n\t\t\tfasthz = ~0ULL;\n\t\t\txstart = nsec();\n\t\t\tfprint(2, \"cyclefreq not available, falling back to nsec()\\n\");\n\t\t\tfprint(2, \"you might want to disable aux/timesync\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tcycles(&xstart);\n\t\treturn 0;\n\t}\n\tcycles(&x);\n\tx -= xstart;\n\n\t/* this is ugly */\n\tfor(div = 1000000000ULL; x < 0x1999999999999999ULL && div > 1 ; div /= 10ULL, x *= 10ULL);\n\n\treturn x / (fasthz / div);\n}\n", "source": "neindaw/util.c", "file_type": "c"}
{"text": "#include <u.h>\n#include <libc.h>\n#include <fcall.h>\n#include <thread.h>\n#include <9p.h>\n#include \"common.h\"\n#include \"ui.h\"\n#include \"fs.h\"\n#include \"uiglue.h\"\n\nstatic struct {\n\tfloat *zone;\n\tMeta *meta;\n\tint nummeta;\n\tint autovoice;\n\tint crossvoice;\n}decl;\n\nFile *uif;\nState *uis;\n\nchar *\nui_readstr(UI *ui, int auxtype, char *s, int sz)\n{\n\tchar *x, *t;\n\tint i;\n\n\tif (auxtype == Xuictl) {\n\t\tif (ui->type < 0 || ui->type >= UInum)\n\t\t\tsysfatal(\"unknown ui type %d\", ui->type);\n\t\tt = uitypenames[ui->type];\n\t\tswitch (ui->type) {\n\t\tcase UITGroup:\n\t\tcase UIHGroup:\n\t\tcase UIVGroup:\n\t\t\tsnprint(s, sz, \"%s\\n\", t);\n\t\t\treturn s;\n\t\tcase UIButton:\n\t\tcase UICheckBox:\n\t\t\tsnprint(s, sz, \"%s\\t%g%s%s\\n\", t, *ui->zone,\n\t\t\t\tui->autovoice ? \"\\tautovoice\" : \"\",\n\t\t\t\tui->crossvoice ? \"\\tcrossvoice\" : \"\"\n\t\t\t);\n\t\t\treturn s;\n\t\tcase UIVSlider:\n\t\tcase UIHSlider:\n\t\tcase UINEntry:\n\t\t\tsnprint(s, sz, \"%s\\t%g\\t%g\\t%g\\t%g\\t%g\\n\", t, *ui->zone, ui->init, ui->min, ui->max, ui->step);\n\t\t\treturn s;\n\t\tcase UIHBarGraph:\n\t\tcase UIVBarGraph:\n\t\t\tsnprint(s, sz, \"%s\\t%g\\t%g\\t%g\\n\", t, *ui->zone, ui->min, ui->max);\n\t\t\treturn s;\n\t\tdefault:\n\t\t\tsysfatal(\"readstr not implemented for ui type %d\", ui->type);\n\t\t}\n\t} else if (auxtype == Xuimeta) {\n\t\tx = s;\n\t\t*x = 0;\n\t\tfor (i = 0; i < ui->nummeta; i++)\n\t\t\tx = seprint(x, s+sz-1, \"%s\\t%s\\n\", ui->meta[i].k, ui->meta[i].v);\n\t\treturn s;\n\t} else {\n\t\tsysfatal(\"unsupported ui aux %d\", auxtype);\n\t}\n\n\treturn nil;\n}\n\nint\nui_writestr(UI *ui, int auxtype, char *s)\n{\n\tchar *e;\n\tint failoor;\n\tfloat v;\n\n\tif (auxtype != Xuictl)\n\t\tsysfatal(\"unsupported ui aux %d\", auxtype);\n\n\t/* FIXME optional argument should specify at which frame to apply the change */\n\n\tv = 0.0f;\n\tfailoor = 0;\n\tif (strncmp(s, \"reset\", 5) == 0) { /* FIXME reset for a box should reset ALL controls inside it */\n\t\tv = ui->init;\n\t} else if (strncmp(s, \"add\", 3) == 0) {\n\t\tif (ui->zone != nil)\n\t\t\tv = *ui->zone + atof(s+3);\n\t} else if (strncmp(s, \"sub\", 3) == 0) {\n\t\tif (ui->zone != nil)\n\t\t\tv = *ui->zone - atof(s+3);\n\t} else {\n\t\tv = strtod(s, &e);\n\t\tif (*e != 0 && *e != '\\n')\n\t\t\treturn -1;\n\t\tfailoor = 1;\n\t}\n\n\tif (ui->zone != nil) {\n\t\tif (ui->type == UIButton || ui->type == UICheckBox) {\n\t\t\t*ui->zone = v > 0 ? 1 : 0;\n\t\t} else {\n\t\t\tif (v < ui->min) {\n\t\t\t\tif (failoor)\n\t\t\t\t\treturn -1;\n\t\t\t\tv = ui->min;\n\t\t\t} else if (v > ui->max) {\n\t\t\t\tif (failoor)\n\t\t\t\t\treturn -1;\n\t\t\t\tv = ui->max;\n\t\t\t}\n\t\t\t*ui->zone = v;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic UI *\nnewui(const char *label, int type)\n{\n\tAux *a;\n\tFile *f, *d;\n\n\ta = calloc(1, sizeof(*a) + sizeof(UI) + sizeof(Meta)*decl.nummeta);\n\ta->type = Xui;\n\ta->ui = (UI*)(a+1);\n\ta->ui->type = type;\n\ta->ui->meta = (Meta*)(a->ui+1);\n\ta->ui->nummeta = decl.nummeta;\n\tmemmove(a->ui->meta, decl.meta, sizeof(Meta)*decl.nummeta);\n\ta->ctl = Xuictl;\n\ta->metadata = Xuimeta;\n\ta->state = uis;\n\ta->ui->zone = decl.zone;\n\ta->ui->autovoice = decl.autovoice;\n\ta->ui->crossvoice = decl.crossvoice;\n\ta->ui->label = label;\n\ta->ui->readstr = ui_readstr;\n\ta->ui->writestr = ui_writestr;\n\tif ((d = createfile(uif, label, nil, DMDIR|0775, a)) == nil)\n\t\tsysfatal(\"failed to create '%s': %r\", label);\n\tif ((f = createfile(d, \"ctl\", nil, 0664, &a->ctl)) == nil)\n\t\tsysfatal(\"failed to create '%s/ctl': %r\", label);\n\tclosefile(f);\n\tif ((f = createfile(d, \"metadata\", nil, 0664, &a->metadata)) == nil)\n\t\tsysfatal(\"failed to create '%s/metadata': %r\", label);\n\tclosefile(f);\n\tclosefile(d);\n\n\tfree(decl.meta);\n\tdecl.zone = nil;\n\tdecl.meta = nil;\n\tdecl.nummeta = 0;\n\tdecl.autovoice = 0;\n\tdecl.crossvoice = 0;\n\n\tif (type == UITGroup || type == UIHGroup || type == UIVGroup)\n\t\tuif = d;\n\n\treturn a->ui;\n}\n\nstatic UI *\nnewdef(int type, const char *label, float *zone)\n{\n\tif (zone != decl.zone) { /* no \"declare\" called before */\n\t\tdecl.zone = zone;\n\t\tfree(decl.meta);\n\t\tdecl.meta = nil;\n\t\tdecl.nummeta = 0;\n\t}\n\treturn newui(label, type);\n}\n\nvoid\nui_tgroup(const char *label)\n{\n\tnewui(label, UITGroup);\n}\n\nvoid\nui_hgroup(const char *label)\n{\n\tnewui(label, UIHGroup);\n}\n\nvoid\nui_vgroup(const char *label)\n{\n\tnewui(label, UIVGroup);\n}\n\nvoid\nui_endgroup(void)\n{\n\tuif = uif->parent;\n}\n\nUI *\nui_button(const char *label, float *zone)\n{\n\tUI *ui;\n\n\tui = newdef(UIButton, label, zone);\n\t*zone = 0;\n\n\treturn ui;\n}\n\nUI *\nui_checkbox(const char *label, float *zone)\n{\n\tUI *ui;\n\n\tui = newdef(UICheckBox, label, zone);\n\t*zone = 0;\n\n\treturn ui;\n}\n\nUI *\nui_vslider(const char *label, float *zone, float init, float min, float max, float step)\n{\n\tUI *ui;\n\n\tui = newdef(UIVSlider, label, zone);\n\tui->init = *zone = init;\n\tui->min = min;\n\tui->max = max;\n\tui->step = step;\n\n\treturn ui;\n}\n\nUI *\nui_hslider(const char *label, float *zone, float init, float min, float max, float step)\n{\n\tUI *ui;\n\n\tui = newdef(UIHSlider, label, zone);\n\tui->init = *zone = init;\n\tui->min = min;\n\tui->max = max;\n\tui->step = step;\n\n\treturn ui;\n}\n\nUI *\nui_nentry(const char *label, float *zone, float init, float min, float max, float step)\n{\n\tUI *ui;\n\n\tui = newdef(UINEntry, label, zone);\n\tui->init = *zone = init;\n\tui->min = min;\n\tui->max = max;\n\tui->step = step;\n\n\treturn ui;\n}\n\nUI *\nui_hbargraph(const char *label, float *zone, float min, float max)\n{\n\tUI *ui;\n\n\tui = newdef(UIHBarGraph, label, zone);\n\tui->min = min;\n\tui->max = max;\n\t*zone = 0;\n\n\treturn ui;\n}\n\nUI *\nui_vbargraph(const char *label, float *zone, float min, float max)\n{\n\tUI *ui;\n\n\tui = newdef(UIVBarGraph, label, zone);\n\tui->min = min;\n\tui->max = max;\n\t*zone = 0;\n\n\treturn ui;\n}\n\nvoid\nui_declare(float *zone, const char *key, const char *value)\n{\n\tif (decl.zone != nil && decl.zone != zone)\n\t\tsysfatal(\"%s=\\\"%s\\\": zone mismatch during declaration (%p != %p)\", key, value, decl.zone, zone);\n\tdecl.zone = zone;\n\tdecl.meta = realloc(decl.meta, sizeof(Meta)*(decl.nummeta+1));\n\tdecl.meta[decl.nummeta].k = key;\n\tdecl.meta[decl.nummeta].v = value;\n\tdecl.nummeta++;\n\tif (strcmp(key, \"autovoice\") == 0)\n\t\tdecl.autovoice = 1;\n\telse if (strcmp(key, \"crossvoice\") == 0)\n\t\tdecl.crossvoice = 1;\n}\n", "source": "neindaw/ui.c", "file_type": "c"}
{"text": "#include <u.h>\n#include <libc.h>\n#include <fcall.h>\n#include <thread.h>\n#include <9p.h>\n#include \"common.h\"\n#include \"ui.h\"\n#include \"fs.h\"\n\n#define MAX(a,b) ((a)>=(b)?(a):(b))\n#define MIN(a,b) ((a)<=(b)?(a):(b))\n#define CROSS(a,b) (a <= 0.0f && a <= b && b >= 0.0f)\n#define Silence 0.00003f\n\nenum {\n\tMaxobjs = 64,\n};\n\nstatic Aux *objs[Maxobjs];\n\nstatic Aux rootaux[] = {\n\t[Xctl] = {.type = Xctl},\n\t[Xmetadata] = {.type = Xmetadata},\n\t[Xclone] = {.type = Xclone},\n};\n\nextern File *uif;\nextern State *uis;\n\nstatic Fs *fs;\n\nstatic void\nshutup(State *s, Voice *v)\n{\n\tif (s->voice != v && v->dsp != nil) {\n\t\tfs->dsp.free(v->dsp);\n\t\tv->dsp = nil;\n\t}\n\tv->state = Vsilent;\n}\n\nstatic Voice *\nnewvoice(State *s, Auxdsp *dsp)\n{\n\tVoice *v, *f;\n\tint i;\n\n\tf = s->voice;\n\tfor (i = 0, v = s->voice; i < nelem(s->voice); i++, v++) {\n\t\tif (v->dsp == nil) {\n\t\t\tf = v;\n\t\t\tbreak;\n\t\t}\n\t\tif (v->state == Vplaying && f->samples < v->samples)\n\t\t\tf = v;\n\t}\n\n\tshutup(s, f);\n\tf->dsp = dsp;\n\n\treturn f;\n}\n\nstatic Aux *\nnewobj(char *name)\n{\n\tFile *f;\n\tAux *o;\n\tVoice *v;\n\tint i, mode;\n\n\tfor (i = 0, o = nil; o == nil && i < nelem(objs); i++) {\n\t\tif (objs[i] == nil){\n\t\t\to = objs[i] = calloc(1, sizeof(*o));\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (o == nil)\n\t\treturn nil;\n\n\to->id = i;\n\to->type = Xdsp;\n\to->ctl = Xdspctl;\n\to->data = Xdspdata;\n\n\tsprint(name, \"%d\", o->id);\n\tif ((f = createfile(fs->srv.tree->root, name, nil, DMDIR|0775, o)) == nil)\n\t\treturn nil;\n\tclosefile(createfile(f, \"ctl\", nil, 0664, &o->ctl));\n\tmode = 0;\n\tif (fs->dsp.read != nil)\n\t\tmode |= 0444;\n\tif (fs->dsp.write != nil)\n\t\tmode |= 0222;\n\tclosefile(createfile(f, \"data\", nil, mode, &o->data));\n\n\tuif = f;\n\to->state = uis = calloc(1, sizeof(State));\n\tv = newvoice(o->state, fs->dsp.new(&o->numin, &o->numout, &o->rate));\n\tv->state = Vsilent;\n\tclosefile(f);\n\n\treturn o;\n}\n\nstatic void\nfreeobj(Aux *o)\n{\n\tint i;\n\n\tif (o == nil)\n\t\treturn;\n\n\tif (o->type == Xdsp) {\n\t\tobjs[o->id] = nil;\n\t\tfor (i = 0; i < nelem(o->state->voice); i++) {\n\t\t\tif (o->state->voice[i].dsp != nil)\n\t\t\t\tfs->dsp.free(o->state->voice[i].dsp);\n\t\t}\n\t\tfree(o->state);\n\t}\n\n\tfree(o);\n}\n\nstatic void *\nauxtype2obj(int *type)\n{\n\tswitch (*type) {\n\tcase Xdspctl:\n\tcase Xuictl:\n\t\treturn (uchar*)type - offsetof(Aux, ctl);\n\tcase Xdspdata:\n\t\treturn (uchar*)type - offsetof(Aux, data);\n\tcase Xuimeta:\n\t\treturn (uchar*)type - offsetof(Aux, metadata);\n\tdefault:\n\t\tsysfatal(\"trying to get aux out of type %d\", *type);\n\t}\n\n\treturn nil;\n}\n\nstatic void\nfsopen(Req *r)\n{\n\trespond(r, nil);\n}\n\nstatic int\nauxreaddsp(Aux *a, float *b, int total)\n{\n\tint i, j, n, cross, nzeromax;\n\tVoice *v;\n\tfloat *m;\n\tState *s;\n\n\ts = a->state;\n\n\t/* make sure we have a buffer for mixing */\n\tm = s->mixer;\n\tif (s->mixersz < total) {\n\t\tif ((m = realloc(m, total*sizeof(float))) != nil) {\n\t\t\ts->mixer = m;\n\t\t\ts->mixersz = total;\n\t\t} else {\n\t\t\ttotal = s->mixersz;\n\t\t}\n\t}\n\n\t/* silence first */\n\tmemset(b, 0, sizeof(*b)*total);\n\n\tv = s->voice;\n\tcross = -1;\n\ta->numvoices = 0;\n\tnzeromax = a->rate / 5; /* 1/5th of a second, assuming it's mono */\n\tfor (i = 0, n = total; i < nelem(s->voice) && n > 0; i++, v++) {\n\t\tif (v->dsp == nil)\n\t\t\tcontinue;\n\n\t\tswitch (v->state) {\n\t\tcase Vsilent: /* nothing to do here, ignore it */\n\t\t\tcontinue;\n\t\tcase Vstarting: /* should start playing it */\n\t\t\tif (s->crossvoice && i > 0 && v[-1].state != Vsilent) {\n\t\t\t\t/* always start another voice at zero crossing to avoid clicks & pops */\n\t\t\t\tif (cross < 0) /* no crossing yet? give up for now */\n\t\t\t\t\tgoto done;\n\t\t\t\tmemset(b+cross, 0, sizeof(*b)*(n - cross)); /* silence the prev voice after zero crossing */\n\t\t\t\tcross++; /* leaving one as 0 */\n\t\t\t\tn -= cross;\n\t\t\t\tb += cross;\n\t\t\t\tcross = 0;\n\t\t\t\tshutup(s, &v[-1]);\n\t\t\t}\n\t\t\tv->state = Vplaying;\n\t\t\tv->samples = 0;\n\t\t\tv->nzero = 0;\n\t\t\t/* slippery floor */\n\t\tcase Vplaying:\n\t\t\tif (n < 1)\n\t\t\t\tbreak;\n\t\t\tif (fs->dsp.read(v->dsp, m, n) != n)\n\t\t\t\treturn -1;\n\t\t\tv->samples += n;\n\n\t\t\tfor (j = 0; j < n; j++) {\n\t\t\t\tb[j] += m[j];\n\t\t\t\tif (s->crossvoice && cross < 0 && j > 0 && CROSS(m[j-1], m[j]))\n\t\t\t\t\tcross = j;\n\t\t\t\tif (m[j] >= -Silence && m[j] <= Silence)\n\t\t\t\t\tv->nzero++;\n\t\t\t\telse\n\t\t\t\t\tv->nzero = 0;\n\t\t\t}\n\n\t\t\tif (v->nzero >= nzeromax) { /* been quite for a while? shut it */\n\t\t\t\tcross = 0;\n\t\t\t\tshutup(s, v);\n\t\t\t} else {\n\t\t\t\ta->numvoices++;\n\t\t\t}\n\t\t}\n\t}\n\ndone:\n\n\t/* relocate the voices */\n\tfor (i = j = 1; i < nelem(s->voice); i++) {\n\t\ts->voice[j] = s->voice[i];\n\t\tif(s->voice[j].dsp != nil)\n\t\t\tj++;\n\t}\n\tmemset(s->voice+j, 0, sizeof(*s->voice)*(i - j));\n\n\treturn total;\n}\n\nstatic void\nauxreset(Aux *a)\n{\n\tint i;\n\n\tfor (i = 0; i < nelem(a->state->voice); i++) {\n\t\tif (a->state->voice[i].dsp != nil)\n\t\t\tfs->dsp.reset(a->state->voice[i].dsp);\n\t}\n}\n\nstatic void\nfsread(Req *r)\n{\n\tAux *a, *o;\n\tchar b[256];\n\n\ta = r->fid->file->aux;\n\tswitch (a->type) {\n\tcase Xctl:\n\t\trespond(r, nil);\n\t\tbreak;\n\tcase Xdspctl:\n\t\to = auxtype2obj(&a->type);\n\t\tsprint(b, \"numin\\t%d\\nnumout\\t%d\\nrate\\t%d\\nnumvoices\\t%d\\n\", o->numin, o->numout, o->rate, o->numvoices);\n\t\treadstr(r, b);\n\t\trespond(r, nil);\n\t\tbreak;\n\tcase Xmetadata:\n\t\treadstr(r, fs->metadata);\n\t\trespond(r, nil);\n\t\tbreak;\n\tcase Xclone:\n\t\tif (r->ifcall.offset == 0) {\n\t\t\tif (newobj(b) != nil) {\n\t\t\t\treadstr(r, b);\n\t\t\t} else {\n\t\t\t\tsnprint(b, sizeof(b), \"no free objects: %r\");\n\t\t\t\trespond(r, b);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\trespond(r, nil);\n\t\tbreak;\n\tcase Xuictl:\n\tcase Xuimeta:\n\t\to = auxtype2obj(&a->type);\n\t\tif (o->ui->readstr != nil)\n\t\t\treadstr(r, o->ui->readstr(o->ui, a->type, b, sizeof(b)));\n\t\trespond(r, nil);\n\t\tbreak;\n\tcase Xdspdata:\n\t\to = auxtype2obj(&a->type);\n\t\tr->ofcall.count = auxreaddsp(o, (float*)r->ofcall.data, r->ifcall.count/sizeof(float))*sizeof(float);\n\t\trespond(r, nil);\n\t\tbreak;\n\tdefault:\n\t\trespond(r, \"not implemented\");\n\t\tbreak;\n\t}\n}\n\nstatic int\nauxwrite(Aux *a, int type, char *data)\n{\n\tState *s;\n\tAuxdsp *clone;\n\tVoice *v;\n\tvoid *so, *sc;\n\tu8int *tmp;\n\tint i, r, sz, nused;\n\n\tif (a->ui->writestr == nil) {\n\t\twerrstr(\"not implemented\");\n\t\treturn -1;\n\t}\n\n\ts = a->state;\n\ts->crossvoice |= a->ui->crossvoice;\n\n\tfor (i = nused = 0; i < nelem(s->voice); i++) {\n\t\tif (s->voice[i].state != Vsilent)\n\t\t\tnused++;\n\t}\n\n\t/* autovoice means every write needs to use (possibly) a new instance */\n\tif (a->ui->autovoice && nused > 0 && fs->dsp.clone != nil && fs->dsp.state != nil) {\n\t\t/* now do the impossible */\n\t\tso = fs->dsp.state(s->voice[0].dsp, &sz);\n\t\ttmp = malloc(sz);\n\t\tmemmove(tmp, so, sz); /* save the original state */\n\t\t/* write to the original and check if a new voice has to be created */\n\t\tif ((r = a->ui->writestr(a->ui, type, data)) < 0 || *a->ui->zone == 0.0f) {\n\t\t\tfree(tmp);\n\t\t\treturn r;\n\t\t}\n\t\tclone = fs->dsp.clone(s->voice[0].dsp); /* clone the original */\n\t\tsc = fs->dsp.state(clone, &sz);\n\t\tmemmove(sc, so, sz); /* copy the changed state to the clone */\n\t\tmemmove(so, tmp, sz); /* revert the original state */\n\t\tfree(tmp);\n\t\t/* now we have the original dsp intact, with a cloned dsp actually having the changed state */\n\n\t\tv = newvoice(s, clone);\n\t\tv->state = Vstarting;\n\n\t\treturn r;\n\t}\n\n\t/* in any other case, just write to the original */\n\ts->voice[0].state = Vstarting;\n\treturn a->ui->writestr(a->ui, type, data);\n}\n\nstatic void\nfswrite(Req *r)\n{\n\tAux *a, *o;\n\tchar b[256];\n\n\tif (r->ifcall.count >= sizeof(b)) {\n\t\trespond(r, \"can't fit into buffer\");\n\t\treturn;\n\t}\n\n\tmemmove(b, r->ifcall.data, r->ifcall.count);\n\tb[r->ifcall.count] = '\\0';\n\tr->ofcall.count = r->ifcall.count;\n\n\ta = r->fid->file->aux;\n\tswitch (a->type) {\n\tcase Xuictl:\n\t\to = auxtype2obj(&a->type);\n\t\tif (auxwrite(o, a->type, b) >= 0)\n\t\t\trespond(r, nil);\n\t\telse\n\t\t\tresponderror(r);\n\t\tbreak;\n\tcase Xdspctl: /* FIXME changing sampling rate */\n\t\to = auxtype2obj(&a->type);\n\t\tif (strncmp(b, \"reset\", 5) == 0) /* FIXME ui needs to be reset as well */\n\t\t\tauxreset(o);\n\t\trespond(r, nil);\n\t\tbreak;\n\tcase Xmetadata: /* FIXME should be possible to add new key/value */\n\tdefault:\n\t\trespond(r, \"not implemented\");\n\t\tbreak;\n\t}\n}\n\nstatic void\nfsdestroyfile(File *f)\n{\n\tAux *a;\n\n\tif ((a = f->aux) == nil)\n\t\treturn;\n\tswitch (a->type) {\n\tcase Xdsp:\n\tcase Xui:\n\t\tfreeobj(a);\n\t\tf->aux = nil;\n\t\tbreak;\n\t}\n}\n\nvoid\nfsinit(void *fs_)\n{\n\tfs = fs_;\n\tfs->srv.open = fsopen;\n\tfs->srv.read = fsread;\n\tfs->srv.write = fswrite;\n\tfs->srv.tree = alloctree(nil, nil, DMDIR|0775, fsdestroyfile);\n\tclosefile(createfile(fs->srv.tree->root, \"ctl\", nil, 0666, &rootaux[Xctl]));\n\tclosefile(createfile(fs->srv.tree->root, \"metadata\", nil, 0444, &rootaux[Xmetadata]));\n\tclosefile(createfile(fs->srv.tree->root, \"clone\", nil, 0444, &rootaux[Xclone]));\n}\n", "source": "neindaw/fs.c", "file_type": "c"}
{"text": "#!/bin/rc\n\nawk '\n\tBEGIN {\n\t\toctave = -1\n\t}\n\n\t/#/ {\n\t\t$1 = tolower($1)\n\t\tsub(\"#\", \"\")\n\t}\n\n\t{\n\t\tsplit($1, n, \"\")\n\t\tif(n[2] != octave){\n\t\t\tif(octave >= 0)\n\t\t\t\tprintf \"\t},\\n\"\n\t\t\tprintf \"\t[%d] = {\\n\", n[2]\n\t\t}\n\t\toctave = n[2]\n\t\tprintf \"\t\t[''%s''-''A''] = %s,\\n\", n[1], $2\n\t}\n\n\tEND {\n\t\tprintf \"\t}\\n\"\n\t}\n'\n", "source": "neindaw/notegen", "file_type": "rc"}
{"text": "#include <u.h>\n#include <libc.h>\n#include <fcall.h>\n#include <thread.h>\n#include <9p.h>\n#include \"common.h\"\n#include \"ui.h\"\n#include \"fs.h\"\n#include \"uiglue.h\"\n\nstatic void openTabBox(void *, const char *label) { ui_tgroup(label); }\nstatic void openHorizontalBox(void *, const char *label) { ui_hgroup(label); }\nstatic void openVerticalBox(void *, const char *label) { ui_vgroup(label); }\nstatic void closeBox(void *) { ui_endgroup(); }\nstatic void addButton(void *, const char *label, float *zone) { ui_button(label, zone); }\nstatic void addCheckButton(void *, const char *label, float *zone) { ui_checkbox(label, zone); }\nstatic void addVerticalSlider(void *, const char *label, float *zone, float init, float min, float max, float step) { ui_vslider(label, zone, init, min, max, step); }\nstatic void addHorizontalSlider(void *, const char *label, float *zone, float init, float min, float max, float step) { ui_hslider(label, zone, init, min, max, step); }\nstatic void addNumEntry(void *, const char *label, float *zone, float init, float min, float max, float step) { ui_nentry(label, zone, init, min, max, step); }\nstatic void addVerticalBargraph(void *, const char *label, float *zone, float min, float max) { ui_vbargraph(label, zone, min, max); }\nstatic void addHorizontalBargraph(void *, const char *label, float *zone, float min, float max) { ui_hbargraph(label, zone, min, max); }\nstatic void declare(void *, float *zone, const char *key, const char *value) { ui_declare(zone, key, value); }\n\nUIGlue uiglue = {\n\t.openTabBox = openTabBox,\n\t.openHorizontalBox = openHorizontalBox,\n\t.openVerticalBox = openVerticalBox,\n\t.closeBox = closeBox,\n\t.addButton = addButton,\n\t.addCheckButton = addCheckButton,\n\t.addVerticalSlider = addVerticalSlider,\n\t.addHorizontalSlider = addHorizontalSlider,\n\t.addNumEntry = addNumEntry,\n\t.addVerticalBargraph = addVerticalBargraph,\n\t.addHorizontalBargraph = addHorizontalBargraph,\n\t.declare = declare,\n};\n", "source": "neindaw/uiglue.c", "file_type": "c"}
{"text": "</$objtype/mkfile\n\nLIBS=\\\n\tmicroui\\\n\nCMDS=\\\n\tay\\\n\tcfg\\\n\tdsp\\\n\tpiper\\\n\trepeat\\\n\tsample\\\n\nBIN=/$objtype/bin/daw\n\ndefault:V:\tall\n\n%.h: %.txt\n\t./notegen <$stem.txt >$stem.h\n\nCLEANFILES=a440.h\n\nall install clean nuke:VQ: a440.h $BIN\n\tfor (i in $LIBS $CMDS) @{\n\t\tcd $i\n\t\tmk $target\n\t}\n\n$BIN:\n\tmkdir -p $BIN\n\nlibs:V:\n\tfor (i in $LIBS) @{\n\t\tcd $i\n\t\tmk clean\n\t\tmk install\n\t\tmk clean\n\t}\n", "source": "neindaw/mkfile", "file_type": "mkfile"}
{"text": "</$objtype/mkfile\n\nTARG=\\\n\tcfg\\\n\nBIN=/$objtype/bin/daw\nCFLAGS=$CFLAGS -I..\nOFILES=\\\n\tcommon.$O\\\n\tcfg.$O\\\n\ndefault:V:\tall\n\ncommon.$O: ../common.c\n\t$CC $CFLAGS $prereq\n\n</sys/src/cmd/mkone\n", "source": "neindaw/cfg/mkfile", "file_type": "mkfile"}
{"text": "#include <u.h>\n#include <libc.h>\n#include <bio.h>\n#include <draw.h>\n#include <mouse.h>\n#include <keyboard.h>\n#include <thread.h>\n#include <microui.h>\n#include \"common.h\"\n\nenum {\n\tHasclone = 1<<0,\n};\n\ntypedef struct UI UI;\n\nstruct UI {\n\tint type;\n\tconst char *label;\n\tint index;\n\n\tuvlong qidpath;\n\tint fd;\n\n\tint ivalue;\n\tdouble value;\n\tdouble init;\n\tdouble min;\n\tdouble max;\n\tdouble step;\n\n\tint flags;\n\n\tchar *group;\n\tchar *name;\n\tchar *unit;\n\n\tchar *ctlpath;\n\tchar *path;\n\tUI **child;\n\tint numchild;\n\n\t/* \u00b5ui stuff goes here */\n\tmu_Container *win;\n\tint show;\n};\n\nint mainstacksize = 32768;\n\nstatic char **dirs;\nstatic UI **top;\nstatic int numtop;\nstatic int winopt;\n\nstatic int\nreadmeta(UI *ui, char *path)\n{\n\tBiobuf *b;\n\tchar *s, *k;\n\tint index;\n\n\tif ((b = Bopen(path, OREAD)) == nil)\n\t\treturn -1;\n\n\tui->group = ui->name = ui->unit = nil;\n\tui->index = -1;\n\tfor (; (s = Brdstr(b, '\\n', 1)) != nil; free(s)) {\n\t\tif ((k = strtok(s, \"\\t\")) == nil)\n\t\t\tcontinue;\n\t\tif (strcmp(k, \"group\") == 0) /* FIXME more than one group? */\n\t\t\tui->group = strdup(strtok(nil, \"\\t\"));\n\t\telse if (strcmp(k, \"name\") == 0)\n\t\t\tui->name = strdup(strtok(nil, \"\\t\"));\n\t\telse if (strcmp(k, \"unit\") == 0)\n\t\t\tui->unit = strdup(strtok(nil, \"\\t\"));\n\t\telse if ((index = strtol(k, &k, 10)) >= 0 && *k == 0)\n\t\t\tui->index = index;\n\t}\n\n\tBterm(b);\n\treturn 0;\n}\n\nstatic int\ninitctl(UI *ui, char *path)\n{\n\tBiobuf b;\n\tchar *s, *k;\n\tint i, fd;\n\tDir *d;\n\n\tif ((fd = open(path, OREAD)) < 0) {\n\t\tfprint(2, \"%r\\n\");\n\t\treturn -1;\n\t}\n\tif ((d = dirfstat(fd)) == nil) {\n\t\tfprint(2, \"%r\\n\");\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\tfree(d);\n\n\tui->ctlpath = path;\n\tui->qidpath = d->qid.path;\n\tui->type = -1;\n\tui->show = 1; /* show everything by default */\n\n\tBinit(&b, fd, OREAD);\n\n\tif ((s = Brdstr(&b, '\\n', 1)) != nil && (k = strtok(s, \"\\t\")) != nil) {\n\t\tfor (i = 0; i < nelem(uitypenames); i++) {\n\t\t\tif (strcmp(k, uitypenames[i]) == 0) {\n\t\t\t\tui->type = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tswitch (ui->type) {\n\t\tcase UITGroup:\n\t\tcase UIHGroup:\n\t\tcase UIVGroup:\n\t\t\tbreak;\n\t\tcase UIButton:\n\t\tcase UICheckBox:\n\t\t\tui->value = atof(strtok(nil, \"\\t\"));\n\t\t\tui->ivalue = !!ui->value;\n\t\t\tbreak;\n\t\tcase UIVSlider:\n\t\tcase UIHSlider:\n\t\tcase UINEntry:\n\t\t\tui->value = atof(strtok(nil, \"\\t\"));\n\t\t\tui->init = atof(strtok(nil, \"\\t\"));\n\t\t\tui->min = atof(strtok(nil, \"\\t\"));\n\t\t\tui->max = atof(strtok(nil, \"\\t\"));\n\t\t\tui->step = atof(strtok(nil, \"\\t\"));\n\t\t\tbreak;\n\t\tcase UIHBarGraph:\n\t\tcase UIVBarGraph:\n\t\t\tui->min = atof(strtok(nil, \"\\t\"));\n\t\t\tui->max = atof(strtok(nil, \"\\t\"));\n\t\t\tbreak;\n\t\t}\n\t}\n\tfree(s);\n\tclose(fd);\n\tBterm(&b);\n\n\treturn 0;\n}\n\nstatic UI *\nnewui(char *path)\n{\n\tUI *ui;\n\tDir *dirs;\n\tchar *s, *name, tmp[64];\n\tlong i, n;\n\tint f;\n\n\t/* FIXME perhaps a prefix common for all dirs should be removed too */\n\tpath = cleanname(path);\n\n\tif ((f = open(path, OREAD)) < 0)\n\t\treturn nil;\n\tui = calloc(1, sizeof(*ui));\n\tui->path = strdup(path);\n\tui->fd = -1;\n\n\tif ((s = strrchr(ui->path, '/')) == nil && fd2path(f, tmp, sizeof(tmp)) == 0) {\n\t\tif ((s = strrchr(tmp, '/')) == nil)\n\t\t\ts = path;\n\t}\n\tui->label = strdup(s != nil ? s + 1 : ui->path);\n\n\tn = dirreadall(f, &dirs);\n\tclose(f);\n\tif (n < 0)\n\t\tfprint(2, \"newui: %s: %r\", s);\n\n\tfor (i = 0; i < n; i++) {\n\t\tname = dirs[i].name;\n\t\ts = smprint(\"%s/%s\", path, name);\n\t\tif (strcmp(name, \"metadata\") == 0) {\n\t\t\treadmeta(ui, s);\n\t\t} else if (strcmp(name, \"clone\") == 0) {\n\t\t\tui->flags |= Hasclone;\n\t\t} else if (strcmp(name, \"ctl\") == 0) {\n\t\t\tif (initctl(ui, s) == 0)\n\t\t\t\ts = nil;\n\t\t} else if (dirs[i].mode & DMDIR) {\n\t\t\tui->child = realloc(ui->child, (ui->numchild+1) * sizeof(*ui->child));\n\t\t\tui->child[ui->numchild++] = newui(s);\n\t\t}\n\t\tfree(s);\n\t}\n\tfree(dirs);\n\n\treturn ui;\n}\n\nstatic int\nuiwrite(UI *ui, char *s, int n)\n{\n\tif (ui->ctlpath == nil)\n\t\treturn -1;\n\n\tif (ui->fd < 0 && (ui->fd = open(ui->ctlpath, OWRITE)) < 0) {\n\t\tfprint(2, \"%r\\n\");\n\t\treturn -1;\n\t}\n\n\treturn write(ui->fd, s, n);\n}\n\nstatic void\nuidone(UI *ui)\n{\n\tif (ui->fd >= 0)\n\t\tclose(ui->fd);\n\tui->fd = -1;\n}\n\nstatic void\nprocess_ui(UI *w)\n{\n\tUI *c, *slider;\n\tdouble v;\n\tmu_Id id;\n\tint i, n, widths[32], maxwidth, x, dt;\n\tchar tmp[256];\n\n\tdt = stringwidth(mu_style.font, \": \");\n\n\tslider = nil;\n\tfor (i = 0; i < w->numchild; i++) {\n\t\tc = w->child[i];\n\n\t\tif (slider != nil && c->type != UIVSlider && c->type != UIHSlider) {\n\t\t\twidths[0] = -1;\n\t\t\tmu_layout_row(1, widths, 0);\n\t\t\tslider = nil;\n\t\t}\n\n\t\tswitch (c->type) {\n\t\tcase UIHGroup: /* FIXME use mu_layout_row/mu_layout_begin_column here */\n\t\tcase UITGroup: /* FIXME no tgroup in \u00b5ui yet */\n\t\tcase UIVGroup:\n\t\t\tif (mu_header(&c->show, c->label))\n\t\t\t\tprocess_ui(c);\n\t\t\tbreak;\n\t\tcase UIButton:\n\t\t\tif (mu_button(c->label) & MU_RES_SUBMIT) {\n\t\t\t\tif (uiwrite(c, \"1\", 1) > 0)\n\t\t\t\t\tc->value = 1;\n\t\t\t\tuidone(c);\n\t\t\t} else if (c->value) {\n\t\t\t\tid = mu_get_id(c->label, strlen(c->label));\n\t\t\t\tif (mu_ctx.focus != id || mu_ctx.mouse_down != MU_MOUSE_LEFT) {\n\t\t\t\t\tif (uiwrite(c, \"0\", 1) > 0)\n\t\t\t\t\t\tc->value = 0;\n\t\t\t\t\tuidone(c);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase UICheckBox:\n\t\t\tif (mu_checkbox(&c->ivalue, c->label) & MU_RES_CHANGE) {\n\t\t\t\tif (uiwrite(c, c->ivalue ? \"1\" : \"0\", 1) < 0)\n\t\t\t\t\tc->value = c->ivalue;\n\t\t\t\tuidone(c);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase UIVSlider: /* FIXME no vslider in \u00b5ui yet */\n\t\tcase UIHSlider:\n\t\t\tif (slider == nil) {\n\t\t\t\tslider = c;\n\t\t\t\tmaxwidth = 0;\n\t\t\t\tfor (n = i; n < w->numchild; n++) {\n\t\t\t\t\tif (w->child[n]->type != UIVSlider && w->child[n]->type != UIHSlider)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tif ((x = stringwidth(mu_style.font, w->child[n]->label)) > maxwidth)\n\t\t\t\t\t\tmaxwidth = x;\n\t\t\t\t}\n\t\t\t\twidths[0] = maxwidth + dt;\n\t\t\t\twidths[1] = -1;\n\t\t\t\tmu_layout_row(2, widths, 0);\n\t\t\t}\n\n\t\t\tsnprint(tmp, sizeof(tmp), \"%s: \", c->label);\n\t\t\tmu_label(tmp);\n\t\t\tmu_push_id(&c, sizeof(c));\n\t\t\tv = c->value;\n\t\t\tsnprint(tmp, sizeof(tmp), \"%%g%s\", c->unit == nil ? \"\" : c->unit);\n\t\t\tif (mu_slider_ex(&v, c->min, c->max, c->step, tmp, MU_OPT_ALIGNCENTER) & MU_RES_CHANGE) {\n\t\t\t\tn = snprint(tmp, sizeof(tmp), \"%g\", v);\n\t\t\t\tif (uiwrite(c, tmp, n) > 0)\n\t\t\t\t\tc->value = v;\n\t\t\t\tuidone(c);\n\t\t\t}\n\t\t\tmu_pop_id();\n\t\tcase UINEntry:\n\t\t\tbreak;\n\t\tcase UIHBarGraph:\n\t\tcase UIVBarGraph:\n\t\t\t/* FIXME */\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void\nprocess_frame(void)\n{\n\tUI *prev, *ui, *ch;\n\tchar tmp[128], *s;\n\tint i, j;\n\n\tmu_begin();\n\tfor (i = 0, prev = nil; i < numtop; i++) {\n\t\tui = top[i];\n\t\tif ((ui->flags & Hasclone) == 0) {\n\t\t\tif (mu_begin_window_ex(ui->win, ui->label, winopt)) {\n\t\t\t\tif (prev != nil && (winopt & MU_OPT_AUTOSIZE))\n\t\t\t\t\tui->win->rect.x = prev->win->rect.x + prev->win->rect.w;\n\t\t\t\tprev = ui;\n\t\t\t\tprocess_ui(ui);\n\t\t\t\tmu_end_window();\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tfor (j = 0; j < ui->numchild; j++) {\n\t\t\ts = ui->child[j]->path;\n\t\t\tch = ui->child[j]->child[0];\n\n\t\t\tsnprint(tmp, sizeof(tmp), \"[%s] %s\", s, ch->label);\n\n\t\t\tif (mu_begin_window_ex(ch->win, tmp, winopt)) {\n\t\t\t\tif (prev != nil && (winopt & MU_OPT_AUTOSIZE))\n\t\t\t\t\tch->win->rect.x = prev->win->rect.x + prev->win->rect.w;\n\t\t\t\tprocess_ui(ch);\n\t\t\t\tmu_end_window();\n\t\t\t}\n\t\t\tprev = ch;\n\t\t}\n\t}\n\tmu_end();\n}\n\nstatic void\ndiradd(char *path)\n{\n\tUI *ui, *ch;\n\tmu_Container *w;\n\tint i;\n\n\ttop = realloc(top, (numtop+1) * sizeof(*top));\n\tui = newui(path);\n\ttop[numtop++] = ui;\n\tif ((ui->flags & Hasclone) == 0) {\n\t\tui->win = w = calloc(1, sizeof(*w));\n\t\tmu_init_window(w, 0);\n\t\tw->rect = mu_rect(10 + 210, 10, 200, 400);\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < ui->numchild; i++) {\n\t\tif (ui->child[i]->numchild < 1)\n\t\t\tcontinue;\n\n\t\tch = ui->child[i]->child[0];\n\t\tch->win = w = calloc(1, sizeof(*w));\n\n\t\tmu_init_window(w, 0);\n\t\tw->rect = mu_rect(10 + i*210, 10, 200, 400);\n\t}\n}\n\nstatic void\nusage(void)\n{\n\tprint(\"usage: %s [DIR]...\\n\", argv0);\n\tthreadexitsall(\"usage\");\n}\n\nvoid\nthreadmain(int argc, char **argv)\n{\n\tchar *s;\n\tBiobuf *snarf;\n\tMousectl *mctl;\n\tKeyboardctl *kctl;\n\tRune key;\n\tMouse m;\n\tAlt a[] = {\n\t\t{ nil, &m, CHANRCV },\n\t\t{ nil, nil, CHANRCV },\n\t\t{ nil, &key, CHANRCV },\n\t\t{ nil, nil, CHANEND },\n\t};\n\tchar *curdir[] = {\".\", nil};\n\tint oldbuttons, b, nkey, gotevent, i, force;\n\tchar text[5];\n\n\tARGBEGIN{\n\tdefault:\n\t\tusage();\n\t}ARGEND\n\n\tdirs = *argv == nil ? curdir : argv;\n\ttop = nil;\n\tfor (i = 0; dirs[i] != nil; i++)\n\t\tdiradd(dirs[i]);\n\n\tif (initdraw(nil, nil, \"daw/cfg\") < 0)\n\t\tsysfatal(\"initdraw: %r\");\n\tif ((mctl = initmouse(nil, screen)) == nil)\n\t\tsysfatal(\"initmouse: %r\");\n\tif ((kctl = initkeyboard(nil)) == nil)\n\t\tsysfatal(\"initkeyboard: %r\");\n\n\ta[0].c = mctl->c;\n\ta[1].c = mctl->resizec;\n\ta[2].c = kctl->c;\n\n\tsrand(time(0));\n\tthreadsetname(\"daw/cfg\");\n\n\tmu_init();\n\tmu_style.font = font;\n\tmu_style.size.y = font->height - 6;\n\tmu_style.title_height = mu_style.size.y + 12;\n\n\twinopt = MU_OPT_AUTOSIZE_H;\n\t/* FIXME that's how much it takes for the sizing to kick in :( */\n\tfor (i = 0; i < 3; i++)\n\t\tprocess_frame();\n\twinopt &= ~MU_OPT_AUTOSIZE_H;\n\n\toldbuttons = 0;\n\tforce = 1;\n\tfor (;;) {\n\t\tprocess_frame();\n\t\tif (mu_render(force))\n\t\t\tflushimage(display, 1);\n\t\tforce = 0;\n\n\t\tgotevent = 1;\n\t\tswitch (alt(a)) {\n\t\tcase 0: /* mouse */\n\t\t\tm.xy.x -= screen->r.min.x;\n\t\t\tm.xy.y -= screen->r.min.y;\n\t\t\tmu_input_mousemove(m.xy.x, m.xy.y);\n\t\t\tif ((b = (m.buttons & 1)) != (oldbuttons & 1))\n\t\t\t\t(b ? mu_input_mousedown : mu_input_mouseup)(m.xy.x, m.xy.y, MU_MOUSE_LEFT);\n\t\t\telse if ((b = (m.buttons & 2)) != (oldbuttons & 2))\n\t\t\t\t(b ? mu_input_mousedown : mu_input_mouseup)(m.xy.x, m.xy.y, MU_MOUSE_MIDDLE);\n\t\t\telse if ((b = (m.buttons & 4)) != (oldbuttons & 4))\n\t\t\t\t(b ? mu_input_mousedown : mu_input_mouseup)(m.xy.x, m.xy.y, MU_MOUSE_RIGHT);\n\t\t\tif (m.buttons == 5 && (snarf = Bopen(\"/dev/snarf\", OREAD)) != nil) {\n\t\t\t\tif ((s = Brdstr(snarf, 0, 1)) != nil) {\n\t\t\t\t\tmu_input_text(s);\n\t\t\t\t\tfree(s);\n\t\t\t\t}\n\t\t\t\tBterm(snarf);\n\t\t\t}\n\t\t\toldbuttons = m.buttons;\n\t\t\tbreak;\n\n\t\tcase 1: /* resize */\n\t\t\tgetwindow(display, Refnone);\n\t\t\tforce = 1;\n\t\t\tbreak;\n\n\t\tcase 2: /* keyboard */\n\t\t\tnkey = -1;\n\t\t\tswitch (key) {\n\t\t\tcase Kdel: goto end;\n\t\t\tcase Kshift: nkey = MU_KEY_SHIFT; break;\n\t\t\tcase Kbs: nkey = MU_KEY_BACKSPACE; break;\n\t\t\tcase '\\n': nkey = MU_KEY_RETURN; break;\n\t\t\tcase Knack: nkey = MU_KEY_NACK; break;\n\t\t\tcase Kleft: nkey = MU_KEY_LEFT; break;\n\t\t\tcase Kright: nkey = MU_KEY_RIGHT; break;\n\t\t\tcase Kesc: mu_set_focus(0); break;\n\t\t\tdefault:\n\t\t\t\tif (key < 0xf000 || key > 0xffff) {\n\t\t\t\t\tmemset(text, 0, sizeof(text));\n\t\t\t\t\tif (runetochar(text, &key) > 0)\n\t\t\t\t\t\tmu_input_text(text);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (nkey >= 0) {\n\t\t\t\tmu_input_keydown(nkey);\n\t\t\t\tmu_input_keyup(nkey);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tgotevent = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (gotevent)\n\t\t\tprocess_frame();\n\t}\n\nend:\n\tthreadexitsall(nil);\n}\n", "source": "neindaw/cfg/cfg.c", "file_type": "c"}
{"text": "#include <u.h>\n#include <libc.h>\n#include <draw.h>\n#include <mouse.h>\n#include <keyboard.h>\n#include <thread.h>\n\nenum {\n\tDback = 0,\n\tDfhigh,\n\tDfmed,\n\tDflow,\n\tDfinv,\n\tDbhigh,\n\tDbmed,\n\tDblow,\n\tDbinv,\n\tNumcolors,\n\n\tKnobleft360 = 0<<0,\n\tKnobtop180 = 1<<0,\n\tKnobvaluetop = 0<<1,\n\tKnobvaluebot = 1<<1,\n};\n\n#define MIN(a,b) ((a)<=(b)?(a):(b))\n#define MAX(a,b) ((a)>=(b)?(a):(b))\n\nstatic struct {\n\tchar *id;\n\tu32int color;\n}theme[Numcolors] = {\n\t[Dback]  = {\"background\", 0x000000},\n\t[Dfhigh] = {\"f_high\",     0xffffff},\n\t[Dfmed]  = {\"f_med\",      0x777777},\n\t[Dflow]  = {\"f_low\",      0x444444},\n\t[Dfinv]  = {\"f_inv\",      0x000000},\n\t[Dbhigh] = {\"b_high\",     0xdddddd},\n\t[Dbmed]  = {\"b_med\",      0x72dec2},\n\t[Dblow]  = {\"b_low\",      0x222222},\n\t[Dbinv]  = {\"b_inv\",      0xffb545},\n};\n\ntypedef struct Style Style;\n\nstruct Style {\n\tstruct {\n\t\tint r;\n\t\tint w;\n\t}knob;\n\tint margin;\n\tFont *font;\n};\n\nstatic Style style = {\n\t.knob = {\n\t\t.r = 24,\n\t\t.w = 4,\n\t},\n\t.margin = 4,\n};\n\nstatic Image *color[Numcolors];\nstatic Rectangle knobs[8][2];\n\nstatic Rectangle\nknob(Rectangle r, char *d, char *vs, float v, int kt)\n{\n\tPoint c, t, p0, p1;\n\tint a, hw, dw, vw;\n\n\tdw = stringwidth(style.font, d);\n\tvw = stringwidth(style.font, vs);\n\thw = MAX(style.knob.r, MAX(dw, vw)/2); /* \"half width\", center of the component */\n\tr.max = r.min;\n\tr.max.x += hw*2;\n\n\t/* value */\n\tif (vw > 0 && !(kt&Knobvaluebot)) {\nvaluebot:\n\t\tt.x = r.min.x + hw - vw/2;\n\t\tt.y = r.max.y;\n\t\tstring(screen, t, color[Dfhigh], ZP, style.font, vs);\n\t\tr.max.y = t.y + style.font->height + style.margin;\n\t\tif (kt & Knobvaluebot)\n\t\t\treturn r;\n\t}\n\n\t/* knob */\n\ta = (kt&Knobtop180) ? 90 : 180;\n\tv = v*((kt&Knobtop180) ? -180 : -360);\n\tc.x = r.min.x + Dx(r)/2;\n\tc.y = r.max.y + style.knob.r;\n\tfillarc(screen, c, style.knob.r, style.knob.r, color[Dfhigh], ZP, a, v);\n\tfillellipse(screen, c, style.knob.r-style.knob.w, style.knob.r-style.knob.w, color[Dflow], ZP);\n\ticossin(a+v, &p0.x, &p0.y);\n\tp1.x = c.x + p0.x*(style.knob.r-style.knob.w*4/3)/1024;\n\tp1.y = c.y - p0.y*(style.knob.r-style.knob.w*4/3)/1024;\n\tp0.x = c.x + p0.x*style.knob.w*3/1024;\n\tp0.y = c.y - p0.y*style.knob.w*3/1024;\n\tline(screen, p0, p1, 0, 0, 0, color[Dfhigh], ZP);\n\tr.max.y += 2*style.knob.r;\n\n\t/* description */\n\tif (dw > 0) {\n\t\tt.x = r.min.x + hw - dw/2;\n\t\tt.y = r.max.y + style.margin;\n\t\tstring(screen, t, color[Dfhigh], ZP, style.font, d);\n\t\tr.max.y = t.y + style.font->height;\n\t}\n\n\tif (kt & Knobvaluebot) {\n\t\tr.max.y += style.margin;\n\t\tgoto valuebot;\n\t}\n\n\treturn r;\n}\n\nstatic void\nredraw(void)\n{\n\tfloat f;\n\tRectangle r, t;\n\tchar s[16];\n\tint i;\n\n\tlockdisplay(display);\n\tr = screen->r;\n\tdraw(screen, r, color[Dback], nil, ZP);\n\n\tr.min.x += style.margin;\n\tr.min.y += style.margin;\n\tfor (i = 0; i < nelem(knobs); i++) {\n\t\tf = (i+1)*0.1;\n\t\tsprint(s, \"%g\", f);\n\t\tt = knob(r, nil, s+1, f, Knobleft360);\n\t\tknobs[i][0] = t;\n\t\tr.min.y += Dy(t) + 2*style.margin;\n\n\t\tf = (i-4)*0.2;\n\t\tsprint(s, \"%+g\", f);\n\t\tif (s[2] != 0)\n\t\t\ts[1] = s[0];\n\t\tknobs[i][1] = knob(r, nil, s+1, f, Knobtop180|Knobvaluebot);\n\t\tr = t;\n\t\tr.min.x += Dx(r) + 2*style.margin;\n\t}\n\n\tflushimage(display, 1);\n\tunlockdisplay(display);\n}\n\nvoid\nthreadmain(int argc, char **argv)\n{\n\tMousectl *mctl;\n\tKeyboardctl *kctl;\n\tRune key;\n\tMouse m;\n\tint n, oldbuttons;\n\tPoint oldxy;\n\tfloat zoom, oldzoom;\n\tStyle s;\n\tAlt a[] = {\n\t\t{ nil, &m, CHANRCV },\n\t\t{ nil, nil, CHANRCV },\n\t\t{ nil, &key, CHANRCV },\n\t\t{ nil, nil, CHANEND },\n\t};\n\n\tUSED(argc); USED(argv);\n\n\tif (initdraw(nil, nil, \"daw/ui\") < 0)\n\t\tsysfatal(\"initdraw: %r\");\n\tstyle.font = font;\n\tdisplay->locking = 1;\n\tunlockdisplay(display);\n\tif ((mctl = initmouse(nil, screen)) == nil)\n\t\tsysfatal(\"initmouse: %r\");\n\tif ((kctl = initkeyboard(nil)) == nil)\n\t\tsysfatal(\"initkeyboard: %r\");\n\n\tfor (n = 0; n < Numcolors; n++)\n\t\tcolor[n] = allocimage(display, Rect(0, 0, 1, 1), RGB24, 1, theme[n].color<<8 | 0xff);\n\n\ta[0].c = mctl->c;\n\ta[1].c = mctl->resizec;\n\ta[2].c = kctl->c;\n\n\tthreadsetname(\"daw/ui\");\n\tredraw();\n\toldbuttons = 0;\n\toldxy = ZP;\n\tmemmove(&s, &style, sizeof(s));\n\toldzoom = 1.0f;\n\n\tfor (;;) {\n\t\tswitch (alt(a)) {\n\t\tcase 0: /* mouse */\n\t\t\tif (m.buttons == 2) {\n\t\t\t\tif (oldbuttons == 0) {\n\t\t\t\t\toldxy = m.xy;\n\t\t\t\t} else if (oldbuttons == 2) {\n\t\t\t\t\tzoom = MAX(0, oldzoom + m.xy.y-oldxy.y);\n\t\t\t\t\tstyle.knob.r = s.knob.r*(1 + zoom/100.f);\n\t\t\t\t\tstyle.knob.w = s.knob.w*(1 + zoom/100.f);\n\t\t\t\t\tredraw();\n\t\t\t\t}\n\t\t\t} else if (m.buttons == 0) {\n\t\t\t\tif (oldbuttons == 2)\n\t\t\t\t\toldzoom = zoom;\n\t\t\t}\n\t\t\toldbuttons = m.buttons;\n\t\t\tbreak;\n\n\t\tcase 1: /* resize */\n\t\t\tgetwindow(display, Refnone);\n\t\t\tredraw();\n\t\t\tbreak;\n\n\t\tcase 2: /* keyboard */\n\t\t\tswitch (key) {\n\t\t\tcase Kdel:\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\nend:\n\tthreadexitsall(nil);\n}\n", "source": "neindaw/ui/ui.c", "file_type": "c"}
{"text": "</$objtype/mkfile\n\nTARG=ui\nBIN=/$objtype/bin/daw\n\nOFILES=\\\n\tui.$O\\\n\ndefault:V:\tall\n\n</sys/src/cmd/mkone\n", "source": "neindaw/ui/mkfile", "file_type": "mkfile"}
{"text": "</$objtype/mkfile\n\nTARG=\\\n\tsample\\\n\nBIN=/$objtype/bin/daw\nCFLAGS=$CFLAGS\nOFILES=sample.$O\n\ndefault:V:\tall\n\n</sys/src/cmd/mkone\n", "source": "neindaw/sample/mkfile", "file_type": "mkfile"}
{"text": "#include <u.h>\n#include <libc.h>\n\nstatic void\nusage(void)\n{\n\tprint(\"usage: %s [-b buf_frames] [-c channels]\\n\", argv0);\n\texits(\"usage\");\n}\n\nvoid\nmain(int argc, char **argv)\n{\n\tint bufsz, bufframes, framesz, chan, n, r, end, i;\n\tfloat f;\n\tu8int *b;\n\n\tbufframes = 2048;\n\tchan = 1;\n\n\tARGBEGIN{\n\tcase 'b':\n\t\tbufframes = atoi(EARGF(usage()));\n\t\tbreak;\n\tcase 'c':\n\t\tchan = atoi(EARGF(usage()));\n\t\tbreak;\n\tdefault:\n\t\tusage();\n\t}ARGEND\n\n\tif (bufframes < 1)\n\t\tsysfatal(\"invalid buffer size: %d frames\", bufframes);\n\tif (chan < 1)\n\t\tsysfatal(\"invalid number of channels: %d\", chan);\n\n\tframesz = chan * 4;\n\tbufsz = bufframes * framesz;\n\tb = malloc(bufsz);\n\n\tn = 0;\n\tfor (;;) {\n\t\tr = read(0, b+n, bufsz-n);\n\t\tif (r < 0)\n\t\t\texits(\"read failed\");\n\t\telse if (r == 0)\n\t\t\tbreak;\n\t\tn += r;\n\n\t\tend = n & ~(framesz-1);\n\t\tif (end < 1)\n\t\t\tcontinue;\n\n\t\tfor (; end > 0; end -= framesz) {\n\t\t\tfor (i = 0; i < chan; i++) {\n\t\t\t\tf = *(float*)(b + end - framesz - i*4);\n\t\t\t\tif (f != 0)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\nout:\n\t\tif (end == 0)\n\t\t\tbreak;\n\n\t\tif (write(1, b, end) != end)\n\t\t\texits(\"write failed\");\n\t\tn -= end;\n\t\tmemmove(b, b+end, n);\n\t}\n\n\texits(nil);\n}\n", "source": "neindaw/sample/sample.c", "file_type": "c"}
{"text": "#!/bin/rc\nrfork en\nfont = /lib/font/bit/vga/unicode.font\nif(~ $#* 0) instr = (piano kick_drum ay)\nif not instr = $*\nfor(i in $instr){\n\tdaw/$i -m /n/$i || exit badarg\n\tcat /n/$i/clone >/dev/null\n}\n\n>/tmp/orcastart cat <<'...'\n#!/bin/rc\necho resize -minx 96 > /dev/wctl\nlabel orca\nd = `{syscall -o read 0 buf 48 </dev/wctl >[2]/dev/null}\nd = `{echo $d(3) $d(1) -8-p2/2+p4-p | dc}\nwindow -r $d(3) 0 $d(1) 9000 'echo daw/cfg /n/$instr; daw/cfg /n/$instr; rc'\nwindow -r 0 0 $d(2) 9000 'echo ''games/orca -p -u /fd/3 |[3] daw/piper'' /n/$instr\n\tgames/orca -p -u /fd/3 |[3] daw/piper /n/$instr; rc'\n...\nchmod +x /tmp/orcastart\n\nwindow -cd $home/orca -r 0 0 9000 9000 -m rio -i /tmp/orcastart\n", "source": "neindaw/contrib/o", "file_type": "rc"}
{"text": "/* mydsp Plan 9 C architecture for Faust. */\n\n#include <u.h>\n#include <libc.h>\n#include \"uiglue.h\"\n\n#define max(x,y) (((x) > (y)) ? (x) : (y))\n#define min(x,y) (((x) < (y)) ? (x) : (y))\n\n<<includeIntrinsic>>\n<<includeclass>>\n\nstatic mydsp *clonemydsp(mydsp *dsp) {\n\treturn memmove(newmydsp(), dsp, sizeof(*dsp));\n}\n\nstatic void *statemydsp(mydsp *dsp, int *sz) {\n\t*sz = sizeof(*dsp);\n\treturn dsp;\n}\n\n#define DSP mydsp\n\n#include \"dspf.h\"\n\nstatic DSPf dspf = {\n\t.new = newmydsp,\n\t.clone = clonemydsp,\n\t.state = statemydsp,\n\t.init = instanceInitmydsp,\n\t.delete = deletemydsp,\n\t.metadata = metadatamydsp,\n\t.num_in = getNumInputsmydsp,\n\t.num_out = getNumOutputsmydsp,\n\t.clear = instanceClearmydsp,\n\t.reset_ui = instanceResetUserInterfacemydsp,\n\t.build_ui = buildUserInterfacemydsp,\n\t.compute = computemydsp,\n};\n\nvoid *\nclass_init(int rate)\n{\n\tclassInitmydsp(rate);\n\treturn &dspf;\n}\n", "source": "neindaw/dsp/arch.c", "file_type": "c"}
{"text": "/* ------------------------------------------------------------\nauthor: \"Romain Michon (rmichon@ccrma.stanford.edu)\"\ncopyright: \"Romain Michon\"\nname: \"Piano\"\nversion: \"1.0\"\nCode generated with Faust 2.28.0 (https://faust.grame.fr)\nCompilation options: -lang c -scal -ftz 0\n------------------------------------------------------------ */\n\n#ifndef  __Piano_H__\n#define  __Piano_H__\n\n/* Piano Plan 9 C architecture for Faust. */\n\n#include <u.h>\n#include <libc.h>\n#include \"uiglue.h\"\n\n#define max(x,y) (((x) > (y)) ? (x) : (y))\n#define min(x,y) (((x) < (y)) ? (x) : (y))\n\n#ifndef FAUSTFLOAT\n#define FAUSTFLOAT float\n#endif \n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/* link with : \"\" */\n#include <math.h>\n#include <piano.h>\n#include <stdlib.h>\n\nstatic float Piano_faustpower2_f(float value) {\n\treturn (value * value);\n}\n\n#ifndef FAUSTCLASS \n#define FAUSTCLASS Piano\n#endif\n#ifdef __APPLE__ \n#define exp10f __exp10f\n#define exp10 __exp10\n#endif\n\ntypedef struct {\n\tFAUSTFLOAT fHslider0;\n\tFAUSTFLOAT fHslider1;\n\tfloat fRec10[2];\n\tint fSampleRate;\n\tfloat fConst0;\n\tfloat fConst1;\n\tFAUSTFLOAT fHslider2;\n\tfloat fConst2;\n\tFAUSTFLOAT fHslider3;\n\tfloat fConst3;\n\tFAUSTFLOAT fHslider4;\n\tFAUSTFLOAT fButton0;\n\tfloat fRec19[2];\n\tFAUSTFLOAT fHslider5;\n\tint iRec25[2];\n\tfloat fRec27[2];\n\tfloat fConst4;\n\tFAUSTFLOAT fHslider6;\n\tfloat fRec26[2];\n\tfloat fConst5;\n\tfloat fConst6;\n\tfloat fConst7;\n\tFAUSTFLOAT fHslider7;\n\tfloat fConst8;\n\tfloat fRec28[2];\n\tfloat fRec24[2];\n\tfloat fRec23[2];\n\tfloat fRec22[2];\n\tfloat fRec21[2];\n\tfloat fRec20[2];\n\tfloat fVec0[2];\n\tfloat fRec18[2];\n\tfloat fRec17[2];\n\tint IOTA;\n\tfloat fRec16[8192];\n\tfloat fVec1[2];\n\tfloat fRec31[2];\n\tfloat fRec30[2];\n\tfloat fRec29[8192];\n\tfloat fVec2[2];\n\tfloat fRec15[2];\n\tfloat fRec12[2];\n\tfloat fRec13[2];\n\tfloat fConst9;\n\tfloat fRec11[3];\n\tfloat fConst10;\n\tfloat fVec3[2];\n\tfloat fVec4[2];\n\tfloat fRec41[2];\n\tfloat fRec40[2];\n\tfloat fRec39[2];\n\tfloat fRec38[2];\n\tfloat fRec37[2];\n\tfloat fRec36[3];\n\tfloat fRec35[3];\n\tfloat fRec34[3];\n\tfloat fRec33[3];\n\tfloat fRec32[2];\n\tfloat fVec5[8192];\n\tfloat fVec6[4096];\n\tint iConst11;\n\tfloat fConst12;\n\tfloat fConst13;\n\tfloat fConst14;\n\tfloat fConst15;\n\tFAUSTFLOAT fHslider8;\n\tfloat fConst16;\n\tfloat fConst17;\n\tfloat fConst18;\n\tfloat fConst19;\n\tfloat fRec43[2];\n\tfloat fRec42[2];\n\tfloat fVec7[16384];\n\tfloat fConst20;\n\tint iConst21;\n\tfloat fVec8[4096];\n\tint iConst22;\n\tfloat fRec8[2];\n\tfloat fConst23;\n\tfloat fConst24;\n\tfloat fConst25;\n\tfloat fConst26;\n\tfloat fRec47[2];\n\tfloat fRec46[2];\n\tfloat fVec9[16384];\n\tfloat fConst27;\n\tint iConst28;\n\tfloat fVec10[4096];\n\tint iConst29;\n\tfloat fRec44[2];\n\tfloat fConst30;\n\tFAUSTFLOAT fHslider9;\n\tfloat fVec11[4096];\n\tfloat fConst31;\n\tfloat fConst32;\n\tfloat fConst33;\n\tfloat fConst34;\n\tfloat fRec51[2];\n\tfloat fRec50[2];\n\tfloat fVec12[16384];\n\tfloat fConst35;\n\tint iConst36;\n\tfloat fVec13[4096];\n\tint iConst37;\n\tfloat fRec48[2];\n\tfloat fConst38;\n\tfloat fConst39;\n\tfloat fConst40;\n\tfloat fConst41;\n\tfloat fRec55[2];\n\tfloat fRec54[2];\n\tfloat fVec14[16384];\n\tfloat fConst42;\n\tint iConst43;\n\tfloat fVec15[2048];\n\tint iConst44;\n\tfloat fRec52[2];\n\tfloat fConst45;\n\tfloat fConst46;\n\tfloat fConst47;\n\tfloat fConst48;\n\tfloat fRec59[2];\n\tfloat fRec58[2];\n\tfloat fVec16[32768];\n\tfloat fConst49;\n\tint iConst50;\n\tfloat fVec17[4096];\n\tint iConst51;\n\tfloat fRec56[2];\n\tfloat fConst52;\n\tfloat fConst53;\n\tfloat fConst54;\n\tfloat fConst55;\n\tfloat fRec63[2];\n\tfloat fRec62[2];\n\tfloat fVec18[32768];\n\tfloat fConst56;\n\tint iConst57;\n\tfloat fVec19[4096];\n\tint iConst58;\n\tfloat fRec60[2];\n\tfloat fConst59;\n\tfloat fConst60;\n\tfloat fConst61;\n\tfloat fConst62;\n\tfloat fRec67[2];\n\tfloat fRec66[2];\n\tfloat fVec20[16384];\n\tfloat fConst63;\n\tint iConst64;\n\tfloat fVec21[2048];\n\tint iConst65;\n\tfloat fRec64[2];\n\tfloat fConst66;\n\tfloat fConst67;\n\tfloat fConst68;\n\tfloat fConst69;\n\tfloat fRec71[2];\n\tfloat fRec70[2];\n\tfloat fVec22[32768];\n\tfloat fConst70;\n\tint iConst71;\n\tfloat fVec23[2048];\n\tint iConst72;\n\tfloat fRec68[2];\n\tfloat fRec0[3];\n\tfloat fRec1[3];\n\tfloat fRec2[3];\n\tfloat fRec3[3];\n\tfloat fRec4[3];\n\tfloat fRec5[3];\n\tfloat fRec6[3];\n\tfloat fRec7[3];\n} Piano;\n\nPiano* newPiano(void) { \n\tPiano* dsp = (Piano*)calloc(1, sizeof(Piano));\n\treturn dsp;\n}\n\nvoid deletePiano(Piano* dsp) {\n\tUSED(dsp); \n\tfree(dsp);\n}\n\nvoid metadataPiano(MetaGlue* m) { \n\tm->declare(m->metaInterface, \"author\", \"Romain Michon (rmichon@ccrma.stanford.edu)\");\n\tm->declare(m->metaInterface, \"basics.lib/name\", \"Faust Basic Element Library\");\n\tm->declare(m->metaInterface, \"basics.lib/version\", \"0.1\");\n\tm->declare(m->metaInterface, \"copyright\", \"Romain Michon\");\n\tm->declare(m->metaInterface, \"delays.lib/name\", \"Faust Delay Library\");\n\tm->declare(m->metaInterface, \"delays.lib/version\", \"0.1\");\n\tm->declare(m->metaInterface, \"description\", \"A commuted WaveGuide piano.\");\n\tm->declare(m->metaInterface, \"filename\", \"piano.dsp\");\n\tm->declare(m->metaInterface, \"filters.lib/allpass_comb:author\", \"Julius O. Smith III\");\n\tm->declare(m->metaInterface, \"filters.lib/allpass_comb:copyright\", \"Copyright (C) 2003-2019 by Julius O. Smith III <jos@ccrma.stanford.edu>\");\n\tm->declare(m->metaInterface, \"filters.lib/allpass_comb:license\", \"MIT-style STK-4.3 license\");\n\tm->declare(m->metaInterface, \"filters.lib/lowpass0_highpass1\", \"Copyright (C) 2003-2019 by Julius O. Smith III <jos@ccrma.stanford.edu>\");\n\tm->declare(m->metaInterface, \"filters.lib/lowpass0_highpass1:author\", \"Julius O. Smith III\");\n\tm->declare(m->metaInterface, \"filters.lib/lowpass:author\", \"Julius O. Smith III\");\n\tm->declare(m->metaInterface, \"filters.lib/lowpass:copyright\", \"Copyright (C) 2003-2019 by Julius O. Smith III <jos@ccrma.stanford.edu>\");\n\tm->declare(m->metaInterface, \"filters.lib/lowpass:license\", \"MIT-style STK-4.3 license\");\n\tm->declare(m->metaInterface, \"filters.lib/name\", \"Faust Filters Library\");\n\tm->declare(m->metaInterface, \"filters.lib/tf1:author\", \"Julius O. Smith III\");\n\tm->declare(m->metaInterface, \"filters.lib/tf1:copyright\", \"Copyright (C) 2003-2019 by Julius O. Smith III <jos@ccrma.stanford.edu>\");\n\tm->declare(m->metaInterface, \"filters.lib/tf1:license\", \"MIT-style STK-4.3 license\");\n\tm->declare(m->metaInterface, \"filters.lib/tf1s:author\", \"Julius O. Smith III\");\n\tm->declare(m->metaInterface, \"filters.lib/tf1s:copyright\", \"Copyright (C) 2003-2019 by Julius O. Smith III <jos@ccrma.stanford.edu>\");\n\tm->declare(m->metaInterface, \"filters.lib/tf1s:license\", \"MIT-style STK-4.3 license\");\n\tm->declare(m->metaInterface, \"group\", \"Synthesis\");\n\tm->declare(m->metaInterface, \"instruments.lib/author\", \"Romain Michon (rmichon@ccrma.stanford.edu)\");\n\tm->declare(m->metaInterface, \"instruments.lib/copyright\", \"Romain Michon\");\n\tm->declare(m->metaInterface, \"instruments.lib/licence\", \"STK-4.3\");\n\tm->declare(m->metaInterface, \"instruments.lib/name\", \"Faust-STK Tools Library\");\n\tm->declare(m->metaInterface, \"instruments.lib/version\", \"1.0\");\n\tm->declare(m->metaInterface, \"licence\", \"STK-4.3\");\n\tm->declare(m->metaInterface, \"maths.lib/author\", \"GRAME\");\n\tm->declare(m->metaInterface, \"maths.lib/copyright\", \"GRAME\");\n\tm->declare(m->metaInterface, \"maths.lib/license\", \"LGPL with exception\");\n\tm->declare(m->metaInterface, \"maths.lib/name\", \"Faust Math Library\");\n\tm->declare(m->metaInterface, \"maths.lib/version\", \"2.3\");\n\tm->declare(m->metaInterface, \"name\", \"Piano\");\n\tm->declare(m->metaInterface, \"noises.lib/name\", \"Faust Noise Generator Library\");\n\tm->declare(m->metaInterface, \"noises.lib/version\", \"0.0\");\n\tm->declare(m->metaInterface, \"platform.lib/name\", \"Generic Platform Library\");\n\tm->declare(m->metaInterface, \"platform.lib/version\", \"0.1\");\n\tm->declare(m->metaInterface, \"reverbs.lib/name\", \"Faust Reverb Library\");\n\tm->declare(m->metaInterface, \"reverbs.lib/version\", \"0.0\");\n\tm->declare(m->metaInterface, \"routes.lib/name\", \"Faust Signal Routing Library\");\n\tm->declare(m->metaInterface, \"routes.lib/version\", \"0.2\");\n\tm->declare(m->metaInterface, \"signals.lib/name\", \"Faust Signal Routing Library\");\n\tm->declare(m->metaInterface, \"signals.lib/version\", \"0.0\");\n\tm->declare(m->metaInterface, \"version\", \"1.0\");\n}\n\nint getSampleRatePiano(Piano* dsp) {\n\tUSED(dsp);\n\treturn dsp->fSampleRate;\n}\n\nint getNumInputsPiano(Piano* dsp) {\n\tUSED(dsp);\n\treturn 0;\n}\nint getNumOutputsPiano(Piano* dsp) {\n\tUSED(dsp);\n\treturn 2;\n}\nint getInputRatePiano(Piano* dsp, int channel) {\n\tUSED(dsp);\n\tint rate;\n\tswitch ((channel)) {\n\t\tdefault: {\n\t\t\trate = -1;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn rate;\n}\nint getOutputRatePiano(Piano* dsp, int channel) {\n\tUSED(dsp);\n\tint rate;\n\tswitch ((channel)) {\n\t\tcase 0: {\n\t\t\trate = 1;\n\t\t\tbreak;\n\t\t}\n\t\tcase 1: {\n\t\t\trate = 1;\n\t\t\tbreak;\n\t\t}\n\t\tdefault: {\n\t\t\trate = -1;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn rate;\n}\n\nvoid classInitPiano(int sample_rate) {\n\tUSED(sample_rate);\n}\n\nvoid instanceResetUserInterfacePiano(Piano* dsp) {\n\tUSED(dsp);\n\tdsp->fHslider0 = (FAUSTFLOAT)0.59999999999999998f;\n\tdsp->fHslider1 = (FAUSTFLOAT)0.13700000000000001f;\n\tdsp->fHslider2 = (FAUSTFLOAT)440.0f;\n\tdsp->fHslider3 = (FAUSTFLOAT)0.28000000000000003f;\n\tdsp->fHslider4 = (FAUSTFLOAT)0.10000000000000001f;\n\tdsp->fButton0 = (FAUSTFLOAT)0.0f;\n\tdsp->fHslider5 = (FAUSTFLOAT)0.0f;\n\tdsp->fHslider6 = (FAUSTFLOAT)1.0f;\n\tdsp->fHslider7 = (FAUSTFLOAT)0.10000000000000001f;\n\tdsp->fHslider8 = (FAUSTFLOAT)0.71999999999999997f;\n\tdsp->fHslider9 = (FAUSTFLOAT)0.5f;\n}\n\nvoid instanceClearPiano(Piano* dsp) {\n\tUSED(dsp);\n\t/* C99 loop */\n\t{\n\t\tint l0;\n\t\tfor (l0 = 0; (l0 < 2); l0 = (l0 + 1)) {\n\t\t\tdsp->fRec10[l0] = 0.0f;\n\t\t}\n\t}\n\t/* C99 loop */\n\t{\n\t\tint l1;\n\t\tfor (l1 = 0; (l1 < 2); l1 = (l1 + 1)) {\n\t\t\tdsp->fRec19[l1] = 0.0f;\n\t\t}\n\t}\n\t/* C99 loop */\n\t{\n\t\tint l2;\n\t\tfor (l2 = 0; (l2 < 2); l2 = (l2 + 1)) {\n\t\t\tdsp->iRec25[l2] = 0;\n\t\t}\n\t}\n\t/* C99 loop */\n\t{\n\t\tint l3;\n\t\tfor (l3 = 0; (l3 < 2); l3 = (l3 + 1)) {\n\t\t\tdsp->fRec27[l3] = 0.0f;\n\t\t}\n\t}\n\t/* C99 loop */\n\t{\n\t\tint l4;\n\t\tfor (l4 = 0; (l4 < 2); l4 = (l4 + 1)) {\n\t\t\tdsp->fRec26[l4] = 0.0f;\n\t\t}\n\t}\n\t/* C99 loop */\n\t{\n\t\tint l5;\n\t\tfor (l5 = 0; (l5 < 2); l5 = (l5 + 1)) {\n\t\t\tdsp->fRec28[l5] = 0.0f;\n\t\t}\n\t}\n\t/* C99 loop */\n\t{\n\t\tint l6;\n\t\tfor (l6 = 0; (l6 < 2); l6 = (l6 + 1)) {\n\t\t\tdsp->fRec24[l6] = 0.0f;\n\t\t}\n\t}\n\t/* C99 loop */\n\t{\n\t\tint l7;\n\t\tfor (l7 = 0; (l7 < 2); l7 = (l7 + 1)) {\n\t\t\tdsp->fRec23[l7] = 0.0f;\n\t\t}\n\t}\n\t/* C99 loop */\n\t{\n\t\tint l8;\n\t\tfor (l8 = 0; (l8 < 2); l8 = (l8 + 1)) {\n\t\t\tdsp->fRec22[l8] = 0.0f;\n\t\t}\n\t}\n\t/* C99 loop */\n\t{\n\t\tint l9;\n\t\tfor (l9 = 0; (l9 < 2); l9 = (l9 + 1)) {\n\t\t\tdsp->fRec21[l9] = 0.0f;\n\t\t}\n\t}\n\t/* C99 loop */\n\t{\n\t\tint l10;\n\t\tfor (l10 = 0; (l10 < 2); l10 = (l10 + 1)) {\n\t\t\tdsp->fRec20[l10] = 0.0f;\n\t\t}\n\t}\n\t/* C99 loop */\n\t{\n\t\tint l11;\n\t\tfor (l11 = 0; (l11 < 2); l11 = (l11 + 1)) {\n\t\t\tdsp->fVec0[l11] = 0.0f;\n\t\t}\n\t}\n\t/* C99 loop */\n\t{\n\t\tint l12;\n\t\tfor (l12 = 0; (l12 < 2); l12 = (l12 + 1)) {\n\t\t\tdsp->fRec18[l12] = 0.0f;\n\t\t}\n\t}\n\t/* C99 loop */\n\t{\n\t\tint l13;\n\t\tfor (l13 = 0; (l13 < 2); l13 = (l13 + 1)) {\n\t\t\tdsp->fRec17[l13] = 0.0f;\n\t\t}\n\t}\n\tdsp->IOTA = 0;\n\t/* C99 loop */\n\t{\n\t\tint l14;\n\t\tfor (l14 = 0; (l14 < 8192); l14 = (l14 + 1)) {\n\t\t\tdsp->fRec16[l14] = 0.0f;\n\t\t}\n\t}\n\t/* C99 loop */\n\t{\n\t\tint l15;\n\t\tfor (l15 = 0; (l15 < 2); l15 = (l15 + 1)) {\n\t\t\tdsp->fVec1[l15] = 0.0f;\n\t\t}\n\t}\n\t/* C99 loop */\n\t{\n\t\tint l16;\n\t\tfor (l16 = 0; (l16 < 2); l16 = (l16 + 1)) {\n\t\t\tdsp->fRec31[l16] = 0.0f;\n\t\t}\n\t}\n\t/* C99 loop */\n\t{\n\t\tint l17;\n\t\tfor (l17 = 0; (l17 < 2); l17 = (l17 + 1)) {\n\t\t\tdsp->fRec30[l17] = 0.0f;\n\t\t}\n\t}\n\t/* C99 loop */\n\t{\n\t\tint l18;\n\t\tfor (l18 = 0; (l18 < 8192); l18 = (l18 + 1)) {\n\t\t\tdsp->fRec29[l18] = 0.0f;\n\t\t}\n\t}\n\t/* C99 loop */\n\t{\n\t\tint l19;\n\t\tfor (l19 = 0; (l19 < 2); l19 = (l19 + 1)) {\n\t\t\tdsp->fVec2[l19] = 0.0f;\n\t\t}\n\t}\n\t/* C99 loop */\n\t{\n\t\tint l20;\n\t\tfor (l20 = 0; (l20 < 2); l20 = (l20 + 1)) {\n\t\t\tdsp->fRec15[l20] = 0.0f;\n\t\t}\n\t}\n\t/* C99 loop */\n\t{\n\t\tint l21;\n\t\tfor (l21 = 0; (l21 < 2); l21 = (l21 + 1)) {\n\t\t\tdsp->fRec12[l21] = 0.0f;\n\t\t}\n\t}\n\t/* C99 loop */\n\t{\n\t\tint l22;\n\t\tfor (l22 = 0; (l22 < 2); l22 = (l22 + 1)) {\n\t\t\tdsp->fRec13[l22] = 0.0f;\n\t\t}\n\t}\n\t/* C99 loop */\n\t{\n\t\tint l23;\n\t\tfor (l23 = 0; (l23 < 3); l23 = (l23 + 1)) {\n\t\t\tdsp->fRec11[l23] = 0.0f;\n\t\t}\n\t}\n\t/* C99 loop */\n\t{\n\t\tint l24;\n\t\tfor (l24 = 0; (l24 < 2); l24 = (l24 + 1)) {\n\t\t\tdsp->fVec3[l24] = 0.0f;\n\t\t}\n\t}\n\t/* C99 loop */\n\t{\n\t\tint l25;\n\t\tfor (l25 = 0; (l25 < 2); l25 = (l25 + 1)) {\n\t\t\tdsp->fVec4[l25] = 0.0f;\n\t\t}\n\t}\n\t/* C99 loop */\n\t{\n\t\tint l26;\n\t\tfor (l26 = 0; (l26 < 2); l26 = (l26 + 1)) {\n\t\t\tdsp->fRec41[l26] = 0.0f;\n\t\t}\n\t}\n\t/* C99 loop */\n\t{\n\t\tint l27;\n\t\tfor (l27 = 0; (l27 < 2); l27 = (l27 + 1)) {\n\t\t\tdsp->fRec40[l27] = 0.0f;\n\t\t}\n\t}\n\t/* C99 loop */\n\t{\n\t\tint l28;\n\t\tfor (l28 = 0; (l28 < 2); l28 = (l28 + 1)) {\n\t\t\tdsp->fRec39[l28] = 0.0f;\n\t\t}\n\t}\n\t/* C99 loop */\n\t{\n\t\tint l29;\n\t\tfor (l29 = 0; (l29 < 2); l29 = (l29 + 1)) {\n\t\t\tdsp->fRec38[l29] = 0.0f;\n\t\t}\n\t}\n\t/* C99 loop */\n\t{\n\t\tint l30;\n\t\tfor (l30 = 0; (l30 < 2); l30 = (l30 + 1)) {\n\t\t\tdsp->fRec37[l30] = 0.0f;\n\t\t}\n\t}\n\t/* C99 loop */\n\t{\n\t\tint l31;\n\t\tfor (l31 = 0; (l31 < 3); l31 = (l31 + 1)) {\n\t\t\tdsp->fRec36[l31] = 0.0f;\n\t\t}\n\t}\n\t/* C99 loop */\n\t{\n\t\tint l32;\n\t\tfor (l32 = 0; (l32 < 3); l32 = (l32 + 1)) {\n\t\t\tdsp->fRec35[l32] = 0.0f;\n\t\t}\n\t}\n\t/* C99 loop */\n\t{\n\t\tint l33;\n\t\tfor (l33 = 0; (l33 < 3); l33 = (l33 + 1)) {\n\t\t\tdsp->fRec34[l33] = 0.0f;\n\t\t}\n\t}\n\t/* C99 loop */\n\t{\n\t\tint l34;\n\t\tfor (l34 = 0; (l34 < 3); l34 = (l34 + 1)) {\n\t\t\tdsp->fRec33[l34] = 0.0f;\n\t\t}\n\t}\n\t/* C99 loop */\n\t{\n\t\tint l35;\n\t\tfor (l35 = 0; (l35 < 2); l35 = (l35 + 1)) {\n\t\t\tdsp->fRec32[l35] = 0.0f;\n\t\t}\n\t}\n\t/* C99 loop */\n\t{\n\t\tint l36;\n\t\tfor (l36 = 0; (l36 < 8192); l36 = (l36 + 1)) {\n\t\t\tdsp->fVec5[l36] = 0.0f;\n\t\t}\n\t}\n\t/* C99 loop */\n\t{\n\t\tint l37;\n\t\tfor (l37 = 0; (l37 < 4096); l37 = (l37 + 1)) {\n\t\t\tdsp->fVec6[l37] = 0.0f;\n\t\t}\n\t}\n\t/* C99 loop */\n\t{\n\t\tint l38;\n\t\tfor (l38 = 0; (l38 < 2); l38 = (l38 + 1)) {\n\t\t\tdsp->fRec43[l38] = 0.0f;\n\t\t}\n\t}\n\t/* C99 loop */\n\t{\n\t\tint l39;\n\t\tfor (l39 = 0; (l39 < 2); l39 = (l39 + 1)) {\n\t\t\tdsp->fRec42[l39] = 0.0f;\n\t\t}\n\t}\n\t/* C99 loop */\n\t{\n\t\tint l40;\n\t\tfor (l40 = 0; (l40 < 16384); l40 = (l40 + 1)) {\n\t\t\tdsp->fVec7[l40] = 0.0f;\n\t\t}\n\t}\n\t/* C99 loop */\n\t{\n\t\tint l41;\n\t\tfor (l41 = 0; (l41 < 4096); l41 = (l41 + 1)) {\n\t\t\tdsp->fVec8[l41] = 0.0f;\n\t\t}\n\t}\n\t/* C99 loop */\n\t{\n\t\tint l42;\n\t\tfor (l42 = 0; (l42 < 2); l42 = (l42 + 1)) {\n\t\t\tdsp->fRec8[l42] = 0.0f;\n\t\t}\n\t}\n\t/* C99 loop */\n\t{\n\t\tint l43;\n\t\tfor (l43 = 0; (l43 < 2); l43 = (l43 + 1)) {\n\t\t\tdsp->fRec47[l43] = 0.0f;\n\t\t}\n\t}\n\t/* C99 loop */\n\t{\n\t\tint l44;\n\t\tfor (l44 = 0; (l44 < 2); l44 = (l44 + 1)) {\n\t\t\tdsp->fRec46[l44] = 0.0f;\n\t\t}\n\t}\n\t/* C99 loop */\n\t{\n\t\tint l45;\n\t\tfor (l45 = 0; (l45 < 16384); l45 = (l45 + 1)) {\n\t\t\tdsp->fVec9[l45] = 0.0f;\n\t\t}\n\t}\n\t/* C99 loop */\n\t{\n\t\tint l46;\n\t\tfor (l46 = 0; (l46 < 4096); l46 = (l46 + 1)) {\n\t\t\tdsp->fVec10[l46] = 0.0f;\n\t\t}\n\t}\n\t/* C99 loop */\n\t{\n\t\tint l47;\n\t\tfor (l47 = 0; (l47 < 2); l47 = (l47 + 1)) {\n\t\t\tdsp->fRec44[l47] = 0.0f;\n\t\t}\n\t}\n\t/* C99 loop */\n\t{\n\t\tint l48;\n\t\tfor (l48 = 0; (l48 < 4096); l48 = (l48 + 1)) {\n\t\t\tdsp->fVec11[l48] = 0.0f;\n\t\t}\n\t}\n\t/* C99 loop */\n\t{\n\t\tint l49;\n\t\tfor (l49 = 0; (l49 < 2); l49 = (l49 + 1)) {\n\t\t\tdsp->fRec51[l49] = 0.0f;\n\t\t}\n\t}\n\t/* C99 loop */\n\t{\n\t\tint l50;\n\t\tfor (l50 = 0; (l50 < 2); l50 = (l50 + 1)) {\n\t\t\tdsp->fRec50[l50] = 0.0f;\n\t\t}\n\t}\n\t/* C99 loop */\n\t{\n\t\tint l51;\n\t\tfor (l51 = 0; (l51 < 16384); l51 = (l51 + 1)) {\n\t\t\tdsp->fVec12[l51] = 0.0f;\n\t\t}\n\t}\n\t/* C99 loop */\n\t{\n\t\tint l52;\n\t\tfor (l52 = 0; (l52 < 4096); l52 = (l52 + 1)) {\n\t\t\tdsp->fVec13[l52] = 0.0f;\n\t\t}\n\t}\n\t/* C99 loop */\n\t{\n\t\tint l53;\n\t\tfor (l53 = 0; (l53 < 2); l53 = (l53 + 1)) {\n\t\t\tdsp->fRec48[l53] = 0.0f;\n\t\t}\n\t}\n\t/* C99 loop */\n\t{\n\t\tint l54;\n\t\tfor (l54 = 0; (l54 < 2); l54 = (l54 + 1)) {\n\t\t\tdsp->fRec55[l54] = 0.0f;\n\t\t}\n\t}\n\t/* C99 loop */\n\t{\n\t\tint l55;\n\t\tfor (l55 = 0; (l55 < 2); l55 = (l55 + 1)) {\n\t\t\tdsp->fRec54[l55] = 0.0f;\n\t\t}\n\t}\n\t/* C99 loop */\n\t{\n\t\tint l56;\n\t\tfor (l56 = 0; (l56 < 16384); l56 = (l56 + 1)) {\n\t\t\tdsp->fVec14[l56] = 0.0f;\n\t\t}\n\t}\n\t/* C99 loop */\n\t{\n\t\tint l57;\n\t\tfor (l57 = 0; (l57 < 2048); l57 = (l57 + 1)) {\n\t\t\tdsp->fVec15[l57] = 0.0f;\n\t\t}\n\t}\n\t/* C99 loop */\n\t{\n\t\tint l58;\n\t\tfor (l58 = 0; (l58 < 2); l58 = (l58 + 1)) {\n\t\t\tdsp->fRec52[l58] = 0.0f;\n\t\t}\n\t}\n\t/* C99 loop */\n\t{\n\t\tint l59;\n\t\tfor (l59 = 0; (l59 < 2); l59 = (l59 + 1)) {\n\t\t\tdsp->fRec59[l59] = 0.0f;\n\t\t}\n\t}\n\t/* C99 loop */\n\t{\n\t\tint l60;\n\t\tfor (l60 = 0; (l60 < 2); l60 = (l60 + 1)) {\n\t\t\tdsp->fRec58[l60] = 0.0f;\n\t\t}\n\t}\n\t/* C99 loop */\n\t{\n\t\tint l61;\n\t\tfor (l61 = 0; (l61 < 32768); l61 = (l61 + 1)) {\n\t\t\tdsp->fVec16[l61] = 0.0f;\n\t\t}\n\t}\n\t/* C99 loop */\n\t{\n\t\tint l62;\n\t\tfor (l62 = 0; (l62 < 4096); l62 = (l62 + 1)) {\n\t\t\tdsp->fVec17[l62] = 0.0f;\n\t\t}\n\t}\n\t/* C99 loop */\n\t{\n\t\tint l63;\n\t\tfor (l63 = 0; (l63 < 2); l63 = (l63 + 1)) {\n\t\t\tdsp->fRec56[l63] = 0.0f;\n\t\t}\n\t}\n\t/* C99 loop */\n\t{\n\t\tint l64;\n\t\tfor (l64 = 0; (l64 < 2); l64 = (l64 + 1)) {\n\t\t\tdsp->fRec63[l64] = 0.0f;\n\t\t}\n\t}\n\t/* C99 loop */\n\t{\n\t\tint l65;\n\t\tfor (l65 = 0; (l65 < 2); l65 = (l65 + 1)) {\n\t\t\tdsp->fRec62[l65] = 0.0f;\n\t\t}\n\t}\n\t/* C99 loop */\n\t{\n\t\tint l66;\n\t\tfor (l66 = 0; (l66 < 32768); l66 = (l66 + 1)) {\n\t\t\tdsp->fVec18[l66] = 0.0f;\n\t\t}\n\t}\n\t/* C99 loop */\n\t{\n\t\tint l67;\n\t\tfor (l67 = 0; (l67 < 4096); l67 = (l67 + 1)) {\n\t\t\tdsp->fVec19[l67] = 0.0f;\n\t\t}\n\t}\n\t/* C99 loop */\n\t{\n\t\tint l68;\n\t\tfor (l68 = 0; (l68 < 2); l68 = (l68 + 1)) {\n\t\t\tdsp->fRec60[l68] = 0.0f;\n\t\t}\n\t}\n\t/* C99 loop */\n\t{\n\t\tint l69;\n\t\tfor (l69 = 0; (l69 < 2); l69 = (l69 + 1)) {\n\t\t\tdsp->fRec67[l69] = 0.0f;\n\t\t}\n\t}\n\t/* C99 loop */\n\t{\n\t\tint l70;\n\t\tfor (l70 = 0; (l70 < 2); l70 = (l70 + 1)) {\n\t\t\tdsp->fRec66[l70] = 0.0f;\n\t\t}\n\t}\n\t/* C99 loop */\n\t{\n\t\tint l71;\n\t\tfor (l71 = 0; (l71 < 16384); l71 = (l71 + 1)) {\n\t\t\tdsp->fVec20[l71] = 0.0f;\n\t\t}\n\t}\n\t/* C99 loop */\n\t{\n\t\tint l72;\n\t\tfor (l72 = 0; (l72 < 2048); l72 = (l72 + 1)) {\n\t\t\tdsp->fVec21[l72] = 0.0f;\n\t\t}\n\t}\n\t/* C99 loop */\n\t{\n\t\tint l73;\n\t\tfor (l73 = 0; (l73 < 2); l73 = (l73 + 1)) {\n\t\t\tdsp->fRec64[l73] = 0.0f;\n\t\t}\n\t}\n\t/* C99 loop */\n\t{\n\t\tint l74;\n\t\tfor (l74 = 0; (l74 < 2); l74 = (l74 + 1)) {\n\t\t\tdsp->fRec71[l74] = 0.0f;\n\t\t}\n\t}\n\t/* C99 loop */\n\t{\n\t\tint l75;\n\t\tfor (l75 = 0; (l75 < 2); l75 = (l75 + 1)) {\n\t\t\tdsp->fRec70[l75] = 0.0f;\n\t\t}\n\t}\n\t/* C99 loop */\n\t{\n\t\tint l76;\n\t\tfor (l76 = 0; (l76 < 32768); l76 = (l76 + 1)) {\n\t\t\tdsp->fVec22[l76] = 0.0f;\n\t\t}\n\t}\n\t/* C99 loop */\n\t{\n\t\tint l77;\n\t\tfor (l77 = 0; (l77 < 2048); l77 = (l77 + 1)) {\n\t\t\tdsp->fVec23[l77] = 0.0f;\n\t\t}\n\t}\n\t/* C99 loop */\n\t{\n\t\tint l78;\n\t\tfor (l78 = 0; (l78 < 2); l78 = (l78 + 1)) {\n\t\t\tdsp->fRec68[l78] = 0.0f;\n\t\t}\n\t}\n\t/* C99 loop */\n\t{\n\t\tint l79;\n\t\tfor (l79 = 0; (l79 < 3); l79 = (l79 + 1)) {\n\t\t\tdsp->fRec0[l79] = 0.0f;\n\t\t}\n\t}\n\t/* C99 loop */\n\t{\n\t\tint l80;\n\t\tfor (l80 = 0; (l80 < 3); l80 = (l80 + 1)) {\n\t\t\tdsp->fRec1[l80] = 0.0f;\n\t\t}\n\t}\n\t/* C99 loop */\n\t{\n\t\tint l81;\n\t\tfor (l81 = 0; (l81 < 3); l81 = (l81 + 1)) {\n\t\t\tdsp->fRec2[l81] = 0.0f;\n\t\t}\n\t}\n\t/* C99 loop */\n\t{\n\t\tint l82;\n\t\tfor (l82 = 0; (l82 < 3); l82 = (l82 + 1)) {\n\t\t\tdsp->fRec3[l82] = 0.0f;\n\t\t}\n\t}\n\t/* C99 loop */\n\t{\n\t\tint l83;\n\t\tfor (l83 = 0; (l83 < 3); l83 = (l83 + 1)) {\n\t\t\tdsp->fRec4[l83] = 0.0f;\n\t\t}\n\t}\n\t/* C99 loop */\n\t{\n\t\tint l84;\n\t\tfor (l84 = 0; (l84 < 3); l84 = (l84 + 1)) {\n\t\t\tdsp->fRec5[l84] = 0.0f;\n\t\t}\n\t}\n\t/* C99 loop */\n\t{\n\t\tint l85;\n\t\tfor (l85 = 0; (l85 < 3); l85 = (l85 + 1)) {\n\t\t\tdsp->fRec6[l85] = 0.0f;\n\t\t}\n\t}\n\t/* C99 loop */\n\t{\n\t\tint l86;\n\t\tfor (l86 = 0; (l86 < 3); l86 = (l86 + 1)) {\n\t\t\tdsp->fRec7[l86] = 0.0f;\n\t\t}\n\t}\n}\n\nvoid instanceConstantsPiano(Piano* dsp, int sample_rate) {\n\tUSED(sample_rate);\n\tUSED(dsp);\n\tdsp->fSampleRate = sample_rate;\n\tdsp->fConst0 = fminf(192000.0f, fmaxf(1.0f, (float)dsp->fSampleRate));\n\tdsp->fConst1 = (1.0f / Piano_faustpower2_f(dsp->fConst0));\n\tdsp->fConst2 = (0.159154937f * dsp->fConst0);\n\tdsp->fConst3 = (6.28318548f / dsp->fConst0);\n\tdsp->fConst4 = (7.0f / dsp->fConst0);\n\tdsp->fConst5 = expf((0.0f - (5.0f / dsp->fConst0)));\n\tdsp->fConst6 = expf((0.0f - (0.5f / dsp->fConst0)));\n\tdsp->fConst7 = (0.100000001f * dsp->fConst0);\n\tdsp->fConst8 = (10.0f / dsp->fConst0);\n\tdsp->fConst9 = (2.0f / dsp->fConst0);\n\tdsp->fConst10 = (0.0500000007f / dsp->fConst0);\n\tdsp->iConst11 = (int)fminf(8192.0f, fmaxf(0.0f, (0.0199999996f * dsp->fConst0)));\n\tdsp->fConst12 = cosf((37699.1133f / dsp->fConst0));\n\tdsp->fConst13 = floorf(((0.174713001f * dsp->fConst0) + 0.5f));\n\tdsp->fConst14 = ((0.0f - (6.90775537f * dsp->fConst13)) / dsp->fConst0);\n\tdsp->fConst15 = (0.5f * dsp->fConst14);\n\tdsp->fConst16 = (0.333333343f * dsp->fConst14);\n\tdsp->fConst17 = (1.0f / tanf((628.318542f / dsp->fConst0)));\n\tdsp->fConst18 = (1.0f / (dsp->fConst17 + 1.0f));\n\tdsp->fConst19 = (1.0f - dsp->fConst17);\n\tdsp->fConst20 = floorf(((0.0229039993f * dsp->fConst0) + 0.5f));\n\tdsp->iConst21 = (int)fminf(8192.0f, fmaxf(0.0f, (dsp->fConst13 - dsp->fConst20)));\n\tdsp->iConst22 = (int)fminf(2048.0f, fmaxf(0.0f, (dsp->fConst20 + -1.0f)));\n\tdsp->fConst23 = floorf(((0.127837002f * dsp->fConst0) + 0.5f));\n\tdsp->fConst24 = ((0.0f - (6.90775537f * dsp->fConst23)) / dsp->fConst0);\n\tdsp->fConst25 = (0.5f * dsp->fConst24);\n\tdsp->fConst26 = (0.333333343f * dsp->fConst24);\n\tdsp->fConst27 = floorf(((0.0316039994f * dsp->fConst0) + 0.5f));\n\tdsp->iConst28 = (int)fminf(8192.0f, fmaxf(0.0f, (dsp->fConst23 - dsp->fConst27)));\n\tdsp->iConst29 = (int)fminf(2048.0f, fmaxf(0.0f, (dsp->fConst27 + -1.0f)));\n\tdsp->fConst30 = (0.5f * dsp->fConst0);\n\tdsp->fConst31 = floorf(((0.192303002f * dsp->fConst0) + 0.5f));\n\tdsp->fConst32 = ((0.0f - (6.90775537f * dsp->fConst31)) / dsp->fConst0);\n\tdsp->fConst33 = (0.5f * dsp->fConst32);\n\tdsp->fConst34 = (0.333333343f * dsp->fConst32);\n\tdsp->fConst35 = floorf(((0.0292910002f * dsp->fConst0) + 0.5f));\n\tdsp->iConst36 = (int)fminf(8192.0f, fmaxf(0.0f, (dsp->fConst31 - dsp->fConst35)));\n\tdsp->iConst37 = (int)fminf(2048.0f, fmaxf(0.0f, (dsp->fConst35 + -1.0f)));\n\tdsp->fConst38 = floorf(((0.125f * dsp->fConst0) + 0.5f));\n\tdsp->fConst39 = ((0.0f - (6.90775537f * dsp->fConst38)) / dsp->fConst0);\n\tdsp->fConst40 = (0.5f * dsp->fConst39);\n\tdsp->fConst41 = (0.333333343f * dsp->fConst39);\n\tdsp->fConst42 = floorf(((0.0134579996f * dsp->fConst0) + 0.5f));\n\tdsp->iConst43 = (int)fminf(8192.0f, fmaxf(0.0f, (dsp->fConst38 - dsp->fConst42)));\n\tdsp->iConst44 = (int)fminf(1024.0f, fmaxf(0.0f, (dsp->fConst42 + -1.0f)));\n\tdsp->fConst45 = floorf(((0.210389003f * dsp->fConst0) + 0.5f));\n\tdsp->fConst46 = ((0.0f - (6.90775537f * dsp->fConst45)) / dsp->fConst0);\n\tdsp->fConst47 = (0.5f * dsp->fConst46);\n\tdsp->fConst48 = (0.333333343f * dsp->fConst46);\n\tdsp->fConst49 = floorf(((0.0244210009f * dsp->fConst0) + 0.5f));\n\tdsp->iConst50 = (int)fminf(16384.0f, fmaxf(0.0f, (dsp->fConst45 - dsp->fConst49)));\n\tdsp->iConst51 = (int)fminf(2048.0f, fmaxf(0.0f, (dsp->fConst49 + -1.0f)));\n\tdsp->fConst52 = floorf(((0.256891012f * dsp->fConst0) + 0.5f));\n\tdsp->fConst53 = ((0.0f - (6.90775537f * dsp->fConst52)) / dsp->fConst0);\n\tdsp->fConst54 = (0.5f * dsp->fConst53);\n\tdsp->fConst55 = (0.333333343f * dsp->fConst53);\n\tdsp->fConst56 = floorf(((0.0273330007f * dsp->fConst0) + 0.5f));\n\tdsp->iConst57 = (int)fminf(16384.0f, fmaxf(0.0f, (dsp->fConst52 - dsp->fConst56)));\n\tdsp->iConst58 = (int)fminf(2048.0f, fmaxf(0.0f, (dsp->fConst56 + -1.0f)));\n\tdsp->fConst59 = floorf(((0.153128996f * dsp->fConst0) + 0.5f));\n\tdsp->fConst60 = ((0.0f - (6.90775537f * dsp->fConst59)) / dsp->fConst0);\n\tdsp->fConst61 = (0.5f * dsp->fConst60);\n\tdsp->fConst62 = (0.333333343f * dsp->fConst60);\n\tdsp->fConst63 = floorf(((0.0203460008f * dsp->fConst0) + 0.5f));\n\tdsp->iConst64 = (int)fminf(8192.0f, fmaxf(0.0f, (dsp->fConst59 - dsp->fConst63)));\n\tdsp->iConst65 = (int)fminf(1024.0f, fmaxf(0.0f, (dsp->fConst63 + -1.0f)));\n\tdsp->fConst66 = floorf(((0.219990999f * dsp->fConst0) + 0.5f));\n\tdsp->fConst67 = ((0.0f - (6.90775537f * dsp->fConst66)) / dsp->fConst0);\n\tdsp->fConst68 = (0.5f * dsp->fConst67);\n\tdsp->fConst69 = (0.333333343f * dsp->fConst67);\n\tdsp->fConst70 = floorf(((0.0191229992f * dsp->fConst0) + 0.5f));\n\tdsp->iConst71 = (int)fminf(16384.0f, fmaxf(0.0f, (dsp->fConst66 - dsp->fConst70)));\n\tdsp->iConst72 = (int)fminf(1024.0f, fmaxf(0.0f, (dsp->fConst70 + -1.0f)));\n}\n\nvoid instanceInitPiano(Piano* dsp, int sample_rate) {\n\tUSED(sample_rate);\n\tUSED(dsp);\n\tinstanceConstantsPiano(dsp, sample_rate);\n\tinstanceResetUserInterfacePiano(dsp);\n\tinstanceClearPiano(dsp);\n}\n\nvoid initPiano(Piano* dsp, int sample_rate) {\n\tUSED(sample_rate);\n\tUSED(dsp);\n\tclassInitPiano(sample_rate);\n\tinstanceInitPiano(dsp, sample_rate);\n}\n\nvoid buildUserInterfacePiano(Piano* dsp, UIGlue* ui_interface) {\n\tUSED(dsp);\n\tui_interface->openVerticalBox(ui_interface->uiInterface, \"Piano\");\n\tui_interface->openHorizontalBox(ui_interface->uiInterface, \"Basic\");\n\tui_interface->declare(ui_interface->uiInterface, &dsp->fHslider2, \"1\", \"\");\n\tui_interface->declare(ui_interface->uiInterface, &dsp->fHslider2, \"tooltip\", \"Tone frequency\");\n\tui_interface->declare(ui_interface->uiInterface, &dsp->fHslider2, \"unit\", \"Hz\");\n\tui_interface->addHorizontalSlider(ui_interface->uiInterface, \"Freq\", &dsp->fHslider2, 440.0f, 20.0f, 20000.0f, 1.0f);\n\tui_interface->declare(ui_interface->uiInterface, &dsp->fHslider6, \"1\", \"\");\n\tui_interface->declare(ui_interface->uiInterface, &dsp->fHslider6, \"tooltip\", \"Gain (value between 0 and 1)\");\n\tui_interface->addHorizontalSlider(ui_interface->uiInterface, \"Gain\", &dsp->fHslider6, 1.0f, 0.0f, 1.0f, 0.00999999978f);\n\tui_interface->declare(ui_interface->uiInterface, &dsp->fButton0, \"1\", \"\");\n\tui_interface->declare(ui_interface->uiInterface, &dsp->fButton0, \"autovoice\", \"\");\n\tui_interface->declare(ui_interface->uiInterface, &dsp->fButton0, \"tooltip\", \"noteOn = 1, noteOff = 0\");\n\tui_interface->addButton(ui_interface->uiInterface, \"Gate\", &dsp->fButton0);\n\tui_interface->closeBox(ui_interface->uiInterface);\n\tui_interface->openVerticalBox(ui_interface->uiInterface, \"Physical\");\n\tui_interface->declare(ui_interface->uiInterface, &dsp->fHslider5, \"2\", \"\");\n\tui_interface->declare(ui_interface->uiInterface, &dsp->fHslider5, \"tooltip\", \"A value between 0 and 1\");\n\tui_interface->addHorizontalSlider(ui_interface->uiInterface, \"Brightness Factor\", &dsp->fHslider5, 0.0f, 0.0f, 1.0f, 0.00999999978f);\n\tui_interface->declare(ui_interface->uiInterface, &dsp->fHslider4, \"2\", \"\");\n\tui_interface->declare(ui_interface->uiInterface, &dsp->fHslider4, \"tooltip\", \"A value between 0 and 1\");\n\tui_interface->addHorizontalSlider(ui_interface->uiInterface, \"Detuning Factor\", &dsp->fHslider4, 0.100000001f, 0.0f, 1.0f, 0.00999999978f);\n\tui_interface->declare(ui_interface->uiInterface, &dsp->fHslider7, \"2\", \"\");\n\tui_interface->declare(ui_interface->uiInterface, &dsp->fHslider7, \"tooltip\", \"A value between 0 and 1\");\n\tui_interface->addHorizontalSlider(ui_interface->uiInterface, \"Hammer Hardness\", &dsp->fHslider7, 0.100000001f, 0.0f, 1.0f, 0.00999999978f);\n\tui_interface->declare(ui_interface->uiInterface, &dsp->fHslider3, \"2\", \"\");\n\tui_interface->declare(ui_interface->uiInterface, &dsp->fHslider3, \"tooltip\", \"A value between 0 and 1\");\n\tui_interface->addHorizontalSlider(ui_interface->uiInterface, \"Stiffness Factor\", &dsp->fHslider3, 0.280000001f, 0.0f, 1.0f, 0.00999999978f);\n\tui_interface->closeBox(ui_interface->uiInterface);\n\tui_interface->openVerticalBox(ui_interface->uiInterface, \"Reverb\");\n\tui_interface->addHorizontalSlider(ui_interface->uiInterface, \"reverbGain\", &dsp->fHslider1, 0.136999995f, 0.0f, 1.0f, 0.00999999978f);\n\tui_interface->addHorizontalSlider(ui_interface->uiInterface, \"roomSize\", &dsp->fHslider8, 0.720000029f, 0.00999999978f, 2.0f, 0.00999999978f);\n\tui_interface->closeBox(ui_interface->uiInterface);\n\tui_interface->openVerticalBox(ui_interface->uiInterface, \"Spat\");\n\tui_interface->addHorizontalSlider(ui_interface->uiInterface, \"pan angle\", &dsp->fHslider0, 0.600000024f, 0.0f, 1.0f, 0.00999999978f);\n\tui_interface->addHorizontalSlider(ui_interface->uiInterface, \"spatial width\", &dsp->fHslider9, 0.5f, 0.0f, 1.0f, 0.00999999978f);\n\tui_interface->closeBox(ui_interface->uiInterface);\n\tui_interface->closeBox(ui_interface->uiInterface);\n}\n\nvoid computePiano(Piano* dsp, int count, FAUSTFLOAT** inputs, FAUSTFLOAT** outputs) {\n\tUSED(inputs);\n\tUSED(dsp);\n\tFAUSTFLOAT* output0 = outputs[0];\n\tFAUSTFLOAT* output1 = outputs[1];\n\tfloat fSlow0 = (float)dsp->fHslider0;\n\tfloat fSlow1 = (12.0f * (1.0f - fSlow0));\n\tfloat fSlow2 = (0.00100000005f * (float)dsp->fHslider1);\n\tfloat fSlow3 = (float)dsp->fHslider2;\n\tint iSlow4 = (int)((17.3123398f * (logf(fSlow3) + -6.08677483f)) + 69.5f);\n\tfloat fSlow5 = (float)getValueEQBandWidthFactor((float)iSlow4);\n\tfloat fSlow6 = (dsp->fConst1 * (Piano_faustpower2_f(fSlow3) * Piano_faustpower2_f(fSlow5)));\n\tfloat fSlow7 = (0.5f * (1.0f - fSlow6));\n\tfloat fSlow8 = (float)getValueEQGain((float)iSlow4);\n\tfloat fSlow9 = (float)getValueSingleStringZero((float)iSlow4);\n\tfloat fSlow10 = (1.0f - fSlow9);\n\tfloat fSlow11 = powf(10.0f, (0.0500000007f * ((float)getValueSingleStringDecayRate((float)iSlow4) / fSlow3)));\n\tfloat fSlow12 = (float)getValueSingleStringPole((float)iSlow4);\n\tfloat fSlow13 = (1.0f - fSlow12);\n\tfloat fSlow14 = (fSlow11 * fSlow13);\n\tfloat fSlow15 = ((3.0f * fSlow10) - fSlow14);\n\tfloat fSlow16 = (1.0f / fSlow15);\n\tfloat fSlow17 = (fSlow12 * fSlow10);\n\tfloat fSlow18 = ((fSlow11 * fSlow9) * fSlow13);\n\tfloat fSlow19 = (fSlow17 - fSlow18);\n\tfloat fSlow20 = (float)dsp->fHslider3;\n\tfloat fSlow21 = (float)getValueStiffnessCoefficient((float)iSlow4);\n\tfloat fSlow22 = (13.6899996f * (Piano_faustpower2_f(fSlow20) * Piano_faustpower2_f(fSlow21)));\n\tfloat fSlow23 = (fSlow22 + -1.0f);\n\tfloat fSlow24 = (5.0f * ((float)dsp->fHslider4 * (float)getValueDetuningHz((float)iSlow4)));\n\tfloat fSlow25 = (fSlow3 + fSlow24);\n\tfloat fSlow26 = (dsp->fConst3 * fSlow25);\n\tfloat fSlow27 = sinf(fSlow26);\n\tfloat fSlow28 = (fSlow20 * fSlow21);\n\tfloat fSlow29 = (7.4000001f * fSlow28);\n\tfloat fSlow30 = (fSlow22 + 1.0f);\n\tfloat fSlow31 = cosf(fSlow26);\n\tfloat fSlow32 = (3.0f * atan2f((fSlow23 * fSlow27), (fSlow29 + (fSlow30 * fSlow31))));\n\tfloat fSlow33 = (3.0f * fSlow17);\n\tfloat fSlow34 = (fSlow18 - fSlow33);\n\tfloat fSlow35 = (4.0f * fSlow19);\n\tfloat fSlow36 = (fSlow34 + fSlow35);\n\tfloat fSlow37 = (((fSlow31 * fSlow34) / fSlow15) + 1.0f);\n\tfloat fSlow38 = ((fSlow9 + fSlow14) + -1.0f);\n\tfloat fSlow39 = (4.0f * fSlow38);\n\tfloat fSlow40 = (((fSlow39 + (fSlow31 * fSlow36)) / fSlow15) + 1.0f);\n\tfloat fSlow41 = (Piano_faustpower2_f(fSlow27) * fSlow34);\n\tfloat fSlow42 = Piano_faustpower2_f(fSlow15);\n\tfloat fSlow43 = (dsp->fConst2 * (((fSlow32 + atan2f((((0.0f - ((fSlow27 * fSlow36) / fSlow15)) * fSlow37) + (((fSlow27 * fSlow34) * fSlow40) / fSlow15)), ((fSlow37 * fSlow40) + ((fSlow41 * fSlow36) / fSlow42)))) + 6.28318548f) / fSlow25));\n\tfloat fSlow44 = floorf(fSlow43);\n\tfloat fSlow45 = (fSlow44 + (1.0f - fSlow43));\n\tfloat fSlow46 = (float)dsp->fButton0;\n\tfloat fSlow47 = (0.0f - (fSlow46 + -1.0f));\n\tfloat fSlow48 = (0.00100000005f * ((0.999599993f * fSlow46) + (0.899999976f * (fSlow47 * (float)getValueReleaseLoopGain((float)iSlow4)))));\n\tfloat fSlow49 = (float)getValueDCBa1((float)iSlow4);\n\tfloat fSlow50 = (1.0f - fSlow49);\n\tfloat fSlow51 = (0.5f * fSlow50);\n\tfloat fSlow52 = (0.25f * (float)dsp->fHslider5);\n\tfloat fSlow53 = (float)getValueLoudPole((float)iSlow4);\n\tfloat fSlow54 = ((fSlow52 + (0.980000019f - fSlow53)) * (float)getValueLoudGain((float)iSlow4));\n\tfloat fSlow55 = (1.39698386e-09f * (fSlow54 * (float)(iSlow4 < 88)));\n\tint iSlow56 = (fSlow46 > 0.0f);\n\tfloat fSlow57 = expf((0.0f - (dsp->fConst4 / ((float)dsp->fHslider6 * (float)getValueDryTapAmpT60((float)iSlow4)))));\n\tint iSlow58 = (fSlow46 < 1.0f);\n\tfloat fSlow59 = (dsp->fConst5 * fSlow47);\n\tfloat fSlow60 = (float)dsp->fHslider7;\n\tfloat fSlow61 = (dsp->fConst7 * fSlow60);\n\tfloat fSlow62 = expf((0.0f - (dsp->fConst8 / fSlow60)));\n\tfloat fSlow63 = (0.200000003f * (float)getValueSustainPedalLevel((float)iSlow4));\n\tfloat fSlow64 = (fSlow53 + (0.0199999996f - fSlow52));\n\tfloat fSlow65 = (0.0f - fSlow51);\n\tfloat fSlow66 = (3.70000005f * fSlow28);\n\tfloat fSlow67 = ((fSlow18 + fSlow35) - fSlow33);\n\tfloat fSlow68 = (((fSlow39 + (fSlow31 * fSlow67)) / fSlow15) + 1.0f);\n\tint iSlow69 = (int)(dsp->fConst2 * (((fSlow32 + atan2f((0.0f - ((fSlow27 * ((fSlow67 * fSlow37) - (fSlow34 * fSlow68))) / fSlow15)), ((fSlow37 * fSlow68) + ((fSlow41 * fSlow67) / fSlow42)))) + 6.28318548f) / fSlow25));\n\tint iSlow70 = min(4097, max(0, iSlow69));\n\tfloat fSlow71 = (fSlow3 - fSlow24);\n\tfloat fSlow72 = (dsp->fConst3 * fSlow71);\n\tfloat fSlow73 = sinf(fSlow72);\n\tfloat fSlow74 = cosf(fSlow72);\n\tfloat fSlow75 = (3.0f * atan2f((fSlow23 * fSlow73), (fSlow29 + (fSlow30 * fSlow74))));\n\tfloat fSlow76 = (((fSlow74 * fSlow34) / fSlow15) + 1.0f);\n\tfloat fSlow77 = ((((fSlow74 * fSlow36) + fSlow39) / fSlow15) + 1.0f);\n\tfloat fSlow78 = (Piano_faustpower2_f(fSlow73) * fSlow34);\n\tfloat fSlow79 = (dsp->fConst2 * (((fSlow75 + atan2f((((0.0f - ((fSlow73 * fSlow36) / fSlow15)) * fSlow76) + (((fSlow73 * fSlow34) * fSlow77) / fSlow15)), ((fSlow76 * fSlow77) + ((fSlow78 * fSlow36) / fSlow42)))) + 6.28318548f) / fSlow71));\n\tfloat fSlow80 = floorf(fSlow79);\n\tfloat fSlow81 = (fSlow80 + (1.0f - fSlow79));\n\tfloat fSlow82 = (((fSlow39 + (fSlow74 * fSlow67)) / fSlow15) + 1.0f);\n\tint iSlow83 = (int)(dsp->fConst2 * (((fSlow75 + atan2f(((fSlow73 * ((fSlow34 * fSlow82) - (fSlow76 * fSlow67))) / fSlow15), ((fSlow76 * fSlow82) + ((fSlow78 * fSlow67) / fSlow42)))) + 6.28318548f) / fSlow71));\n\tint iSlow84 = min(4097, max(0, iSlow83));\n\tfloat fSlow85 = (fSlow79 - fSlow80);\n\tint iSlow86 = min(4097, max(0, (iSlow83 + 1)));\n\tfloat fSlow87 = (fSlow43 - fSlow44);\n\tint iSlow88 = min(4097, max(0, (iSlow69 + 1)));\n\tfloat fSlow89 = ((0.0f - (dsp->fConst9 * (fSlow3 * fSlow5))) * cosf((dsp->fConst3 * (fSlow3 / (float)getValueStrikePosition((float)iSlow4)))));\n\tfloat fSlow90 = powf(10.0f, (0.0500000007f * (float)getValueSecondStageAmpRatio((float)iSlow4)));\n\tfloat fSlow91 = powf(10.0f, (dsp->fConst10 * (float)getValuer1_1db((float)iSlow4)));\n\tfloat fSlow92 = Piano_faustpower2_f(fSlow91);\n\tfloat fSlow93 = powf(10.0f, (dsp->fConst10 * (float)getValuer1_2db((float)iSlow4)));\n\tfloat fSlow94 = Piano_faustpower2_f(fSlow93);\n\tfloat fSlow95 = (1.0f - fSlow90);\n\tfloat fSlow96 = ((fSlow90 * fSlow92) + (fSlow94 * fSlow95));\n\tfloat fSlow97 = (2.0f * (float)getValueBq4_gEarBalled((float)iSlow4));\n\tfloat fSlow98 = (float)(iSlow4 >= 88);\n\tfloat fSlow99 = (2.32830644e-10f * fSlow98);\n\tfloat fSlow100 = (1.16415322e-10f * fSlow98);\n\tfloat fSlow101 = powf(10.0f, (dsp->fConst10 * (float)getValuer3db((float)iSlow4)));\n\tfloat fSlow102 = (cosf((dsp->fConst3 * (fSlow3 * (float)getValueThirdPartialFactor((float)iSlow4)))) * (0.0f - (2.0f * fSlow101)));\n\tfloat fSlow103 = Piano_faustpower2_f(fSlow101);\n\tfloat fSlow104 = powf(10.0f, (dsp->fConst10 * (float)getValuer2db((float)iSlow4)));\n\tfloat fSlow105 = (cosf((dsp->fConst3 * (fSlow3 * (float)getValueSecondPartialFactor((float)iSlow4)))) * (0.0f - (2.0f * fSlow104)));\n\tfloat fSlow106 = Piano_faustpower2_f(fSlow104);\n\tfloat fSlow107 = cosf((dsp->fConst3 * fSlow3));\n\tfloat fSlow108 = (fSlow107 * (0.0f - (2.0f * fSlow91)));\n\tfloat fSlow109 = (0.0f - (2.0f * ((fSlow90 * fSlow91) + (fSlow93 * fSlow95))));\n\tfloat fSlow110 = (0.0f - (2.0f * fSlow93));\n\tfloat fSlow111 = (float)dsp->fHslider8;\n\tfloat fSlow112 = expf((dsp->fConst15 / fSlow111));\n\tfloat fSlow113 = Piano_faustpower2_f(fSlow112);\n\tfloat fSlow114 = (1.0f - (dsp->fConst12 * fSlow113));\n\tfloat fSlow115 = (1.0f - fSlow113);\n\tfloat fSlow116 = (fSlow114 / fSlow115);\n\tfloat fSlow117 = sqrtf(fmaxf(0.0f, ((Piano_faustpower2_f(fSlow114) / Piano_faustpower2_f(fSlow115)) + -1.0f)));\n\tfloat fSlow118 = (fSlow116 - fSlow117);\n\tfloat fSlow119 = (fSlow112 * (fSlow117 + (1.0f - fSlow116)));\n\tfloat fSlow120 = ((expf((dsp->fConst16 / fSlow111)) / fSlow112) + -1.0f);\n\tfloat fSlow121 = expf((dsp->fConst25 / fSlow111));\n\tfloat fSlow122 = Piano_faustpower2_f(fSlow121);\n\tfloat fSlow123 = (1.0f - (dsp->fConst12 * fSlow122));\n\tfloat fSlow124 = (1.0f - fSlow122);\n\tfloat fSlow125 = (fSlow123 / fSlow124);\n\tfloat fSlow126 = sqrtf(fmaxf(0.0f, ((Piano_faustpower2_f(fSlow123) / Piano_faustpower2_f(fSlow124)) + -1.0f)));\n\tfloat fSlow127 = (fSlow125 - fSlow126);\n\tfloat fSlow128 = (fSlow121 * (fSlow126 + (1.0f - fSlow125)));\n\tfloat fSlow129 = ((expf((dsp->fConst26 / fSlow111)) / fSlow121) + -1.0f);\n\tfloat fSlow130 = (12.0f * fSlow0);\n\tint iSlow131 = (int)fminf(4096.0f, fmaxf(0.0f, (dsp->fConst30 * ((float)dsp->fHslider9 / fSlow3))));\n\tfloat fSlow132 = expf((dsp->fConst33 / fSlow111));\n\tfloat fSlow133 = Piano_faustpower2_f(fSlow132);\n\tfloat fSlow134 = (1.0f - (dsp->fConst12 * fSlow133));\n\tfloat fSlow135 = (1.0f - fSlow133);\n\tfloat fSlow136 = (fSlow134 / fSlow135);\n\tfloat fSlow137 = sqrtf(fmaxf(0.0f, ((Piano_faustpower2_f(fSlow134) / Piano_faustpower2_f(fSlow135)) + -1.0f)));\n\tfloat fSlow138 = (fSlow136 - fSlow137);\n\tfloat fSlow139 = (fSlow132 * (fSlow137 + (1.0f - fSlow136)));\n\tfloat fSlow140 = ((expf((dsp->fConst34 / fSlow111)) / fSlow132) + -1.0f);\n\tfloat fSlow141 = expf((dsp->fConst40 / fSlow111));\n\tfloat fSlow142 = Piano_faustpower2_f(fSlow141);\n\tfloat fSlow143 = (1.0f - (dsp->fConst12 * fSlow142));\n\tfloat fSlow144 = (1.0f - fSlow142);\n\tfloat fSlow145 = (fSlow143 / fSlow144);\n\tfloat fSlow146 = sqrtf(fmaxf(0.0f, ((Piano_faustpower2_f(fSlow143) / Piano_faustpower2_f(fSlow144)) + -1.0f)));\n\tfloat fSlow147 = (fSlow145 - fSlow146);\n\tfloat fSlow148 = (fSlow141 * (fSlow146 + (1.0f - fSlow145)));\n\tfloat fSlow149 = ((expf((dsp->fConst41 / fSlow111)) / fSlow141) + -1.0f);\n\tfloat fSlow150 = expf((dsp->fConst47 / fSlow111));\n\tfloat fSlow151 = Piano_faustpower2_f(fSlow150);\n\tfloat fSlow152 = (1.0f - (dsp->fConst12 * fSlow151));\n\tfloat fSlow153 = (1.0f - fSlow151);\n\tfloat fSlow154 = (fSlow152 / fSlow153);\n\tfloat fSlow155 = sqrtf(fmaxf(0.0f, ((Piano_faustpower2_f(fSlow152) / Piano_faustpower2_f(fSlow153)) + -1.0f)));\n\tfloat fSlow156 = (fSlow154 - fSlow155);\n\tfloat fSlow157 = (fSlow150 * (fSlow155 + (1.0f - fSlow154)));\n\tfloat fSlow158 = ((expf((dsp->fConst48 / fSlow111)) / fSlow150) + -1.0f);\n\tfloat fSlow159 = expf((dsp->fConst54 / fSlow111));\n\tfloat fSlow160 = Piano_faustpower2_f(fSlow159);\n\tfloat fSlow161 = (1.0f - (dsp->fConst12 * fSlow160));\n\tfloat fSlow162 = (1.0f - fSlow160);\n\tfloat fSlow163 = (fSlow161 / fSlow162);\n\tfloat fSlow164 = sqrtf(fmaxf(0.0f, ((Piano_faustpower2_f(fSlow161) / Piano_faustpower2_f(fSlow162)) + -1.0f)));\n\tfloat fSlow165 = (fSlow163 - fSlow164);\n\tfloat fSlow166 = (fSlow159 * (fSlow164 + (1.0f - fSlow163)));\n\tfloat fSlow167 = ((expf((dsp->fConst55 / fSlow111)) / fSlow159) + -1.0f);\n\tfloat fSlow168 = expf((dsp->fConst61 / fSlow111));\n\tfloat fSlow169 = Piano_faustpower2_f(fSlow168);\n\tfloat fSlow170 = (1.0f - (dsp->fConst12 * fSlow169));\n\tfloat fSlow171 = (1.0f - fSlow169);\n\tfloat fSlow172 = (fSlow170 / fSlow171);\n\tfloat fSlow173 = sqrtf(fmaxf(0.0f, ((Piano_faustpower2_f(fSlow170) / Piano_faustpower2_f(fSlow171)) + -1.0f)));\n\tfloat fSlow174 = (fSlow172 - fSlow173);\n\tfloat fSlow175 = (fSlow168 * (fSlow173 + (1.0f - fSlow172)));\n\tfloat fSlow176 = ((expf((dsp->fConst62 / fSlow111)) / fSlow168) + -1.0f);\n\tfloat fSlow177 = expf((dsp->fConst68 / fSlow111));\n\tfloat fSlow178 = Piano_faustpower2_f(fSlow177);\n\tfloat fSlow179 = (1.0f - (dsp->fConst12 * fSlow178));\n\tfloat fSlow180 = (1.0f - fSlow178);\n\tfloat fSlow181 = (fSlow179 / fSlow180);\n\tfloat fSlow182 = sqrtf(fmaxf(0.0f, ((Piano_faustpower2_f(fSlow179) / Piano_faustpower2_f(fSlow180)) + -1.0f)));\n\tfloat fSlow183 = (fSlow181 - fSlow182);\n\tfloat fSlow184 = (fSlow177 * (fSlow182 + (1.0f - fSlow181)));\n\tfloat fSlow185 = ((expf((dsp->fConst69 / fSlow111)) / fSlow177) + -1.0f);\n\t/* C99 loop */\n\t{\n\t\tint i;\n\t\tfor (i = 0; (i < count); i = (i + 1)) {\n\t\t\tdsp->fRec10[0] = (fSlow2 + (0.999000013f * dsp->fRec10[1]));\n\t\t\tdsp->fRec19[0] = (fSlow48 + (0.999000013f * dsp->fRec19[1]));\n\t\t\tdsp->iRec25[0] = ((1103515245 * dsp->iRec25[1]) + 12345);\n\t\t\tdsp->fRec27[0] = ((fSlow46 * dsp->fRec27[1]) + 1.0f);\n\t\t\tfloat fTemp0 = (dsp->fRec27[0] + -1.0f);\n\t\t\tfloat fTemp1 = (float)((fTemp0 < 2.0f) & iSlow56);\n\t\t\tfloat fTemp2 = ((0.0301973838f * fTemp1) + (fSlow57 * (float)((fTemp0 >= 2.0f) | iSlow58)));\n\t\t\tdsp->fRec26[0] = ((dsp->fRec26[1] * fTemp2) + (0.150000006f * (fTemp1 * (1.0f - fTemp2))));\n\t\t\tint iTemp3 = (fTemp0 < fSlow61);\n\t\t\tfloat fTemp4 = (fSlow46 * ((dsp->fConst6 * (float)(fTemp0 >= fSlow61)) + (fSlow62 * (float)iTemp3)));\n\t\t\tdsp->fRec28[0] = ((dsp->fRec28[1] * (fSlow59 + fTemp4)) + (fSlow63 * (((1.0f - fTemp4) - fSlow59) * (float)(iTemp3 & iSlow56))));\n\t\t\tfloat fTemp5 = ((float)dsp->iRec25[0] * (dsp->fRec26[0] + dsp->fRec28[0]));\n\t\t\tdsp->fRec24[0] = ((fSlow55 * fTemp5) + (fSlow64 * dsp->fRec24[1]));\n\t\t\tdsp->fRec23[0] = ((fSlow54 * dsp->fRec24[0]) + (fSlow64 * dsp->fRec23[1]));\n\t\t\tdsp->fRec22[0] = ((fSlow54 * dsp->fRec23[0]) + (fSlow64 * dsp->fRec22[1]));\n\t\t\tdsp->fRec21[0] = ((fSlow54 * dsp->fRec22[0]) + (fSlow64 * dsp->fRec21[1]));\n\t\t\tdsp->fRec20[0] = (((fSlow51 * dsp->fRec21[0]) + (fSlow65 * dsp->fRec21[1])) - (fSlow49 * dsp->fRec20[1]));\n\t\t\tfloat fTemp6 = (dsp->fRec19[0] * (dsp->fRec20[0] + dsp->fRec12[1]));\n\t\t\tdsp->fVec0[0] = fTemp6;\n\t\t\tdsp->fRec18[0] = (dsp->fVec0[1] + (fSlow66 * (fTemp6 - dsp->fRec18[1])));\n\t\t\tdsp->fRec17[0] = (dsp->fRec18[1] + (fSlow66 * (dsp->fRec18[0] - dsp->fRec17[1])));\n\t\t\tdsp->fRec16[(dsp->IOTA & 8191)] = (dsp->fRec17[1] + (fSlow66 * (dsp->fRec17[0] - dsp->fRec16[((dsp->IOTA - 1) & 8191)])));\n\t\t\tfloat fTemp7 = (fSlow45 * dsp->fRec16[((dsp->IOTA - iSlow70) & 8191)]);\n\t\t\tfloat fTemp8 = (dsp->fRec20[0] + (dsp->fRec19[0] * dsp->fRec13[1]));\n\t\t\tdsp->fVec1[0] = fTemp8;\n\t\t\tdsp->fRec31[0] = (dsp->fVec1[1] - (fSlow66 * (dsp->fRec31[1] - fTemp8)));\n\t\t\tdsp->fRec30[0] = (dsp->fRec31[1] - (fSlow66 * (dsp->fRec30[1] - dsp->fRec31[0])));\n\t\t\tdsp->fRec29[(dsp->IOTA & 8191)] = (dsp->fRec30[1] + (fSlow66 * (dsp->fRec30[0] - dsp->fRec29[((dsp->IOTA - 1) & 8191)])));\n\t\t\tfloat fTemp9 = ((fSlow81 * dsp->fRec29[((dsp->IOTA - iSlow84) & 8191)]) + (fSlow85 * dsp->fRec29[((dsp->IOTA - iSlow86) & 8191)]));\n\t\t\tfloat fTemp10 = (fSlow87 * dsp->fRec16[((dsp->IOTA - iSlow88) & 8191)]);\n\t\t\tfloat fTemp11 = (fTemp7 + (fTemp9 + fTemp10));\n\t\t\tdsp->fVec2[0] = fTemp11;\n\t\t\tdsp->fRec15[0] = (fSlow16 * ((2.0f * ((fSlow19 * dsp->fVec2[1]) + (fSlow38 * fTemp11))) - (fSlow34 * dsp->fRec15[1])));\n\t\t\tdsp->fRec12[0] = (dsp->fRec15[0] + (fTemp7 + fTemp10));\n\t\t\tdsp->fRec13[0] = (dsp->fRec15[0] + fTemp9);\n\t\t\tfloat fRec14 = fTemp11;\n\t\t\tdsp->fRec11[0] = ((fSlow8 * fRec14) - ((fSlow89 * dsp->fRec11[1]) + (fSlow6 * dsp->fRec11[2])));\n\t\t\tdsp->fVec3[0] = (fSlow99 * fTemp5);\n\t\t\tfloat fTemp12 = (0.0f - ((0.5f * dsp->fVec3[1]) + (fSlow100 * fTemp5)));\n\t\t\tdsp->fVec4[0] = fTemp12;\n\t\t\tdsp->fRec41[0] = (((fSlow51 * fTemp12) + (fSlow65 * dsp->fVec4[1])) - (fSlow49 * dsp->fRec41[1]));\n\t\t\tdsp->fRec40[0] = ((fSlow54 * dsp->fRec41[0]) + (fSlow64 * dsp->fRec40[1]));\n\t\t\tdsp->fRec39[0] = ((fSlow54 * dsp->fRec40[0]) + (fSlow64 * dsp->fRec39[1]));\n\t\t\tdsp->fRec38[0] = ((fSlow54 * dsp->fRec39[0]) + (fSlow64 * dsp->fRec38[1]));\n\t\t\tdsp->fRec37[0] = ((fSlow54 * dsp->fRec38[0]) + (fSlow64 * dsp->fRec37[1]));\n\t\t\tdsp->fRec36[0] = ((fSlow97 * (0.0f - (0.5f * (dsp->fRec37[1] - dsp->fRec37[0])))) - ((fSlow102 * dsp->fRec36[1]) + (fSlow103 * dsp->fRec36[2])));\n\t\t\tdsp->fRec35[0] = ((fSlow97 * dsp->fRec36[0]) - ((fSlow105 * dsp->fRec35[1]) + (fSlow106 * dsp->fRec35[2])));\n\t\t\tdsp->fRec34[0] = (dsp->fRec35[0] - ((fSlow108 * dsp->fRec34[1]) + (fSlow92 * dsp->fRec34[2])));\n\t\t\tdsp->fRec33[0] = (((fSlow96 * dsp->fRec34[2]) + (dsp->fRec34[0] + (fSlow107 * ((fSlow109 * dsp->fRec34[1]) - (fSlow110 * dsp->fRec33[1]))))) - (fSlow94 * dsp->fRec33[2]));\n\t\t\tdsp->fRec32[0] = ((fSlow50 * dsp->fRec33[0]) - (fSlow49 * dsp->fRec32[1]));\n\t\t\tfloat fTemp13 = ((fSlow7 * (dsp->fRec11[0] - dsp->fRec11[2])) + (fRec14 + dsp->fRec32[0]));\n\t\t\tdsp->fVec5[(dsp->IOTA & 8191)] = fTemp13;\n\t\t\tdsp->fVec6[(dsp->IOTA & 4095)] = (fSlow1 * (dsp->fRec10[0] * fTemp13));\n\t\t\tfloat fTemp14 = (0.300000012f * dsp->fVec6[((dsp->IOTA - dsp->iConst11) & 4095)]);\n\t\t\tdsp->fRec43[0] = (dsp->fConst18 * ((dsp->fRec4[1] + dsp->fRec4[2]) - (dsp->fConst19 * dsp->fRec43[1])));\n\t\t\tdsp->fRec42[0] = ((fSlow118 * dsp->fRec42[1]) + (fSlow119 * (dsp->fRec4[1] + (fSlow120 * dsp->fRec43[0]))));\n\t\t\tdsp->fVec7[(dsp->IOTA & 16383)] = ((0.353553385f * dsp->fRec42[0]) + 9.99999968e-21f);\n\t\t\tfloat fTemp15 = ((fTemp14 + dsp->fVec7[((dsp->IOTA - dsp->iConst21) & 16383)]) - (0.600000024f * dsp->fRec8[1]));\n\t\t\tdsp->fVec8[(dsp->IOTA & 4095)] = fTemp15;\n\t\t\tdsp->fRec8[0] = dsp->fVec8[((dsp->IOTA - dsp->iConst22) & 4095)];\n\t\t\tfloat fRec9 = (0.600000024f * fTemp15);\n\t\t\tdsp->fRec47[0] = (dsp->fConst18 * ((dsp->fRec2[1] + dsp->fRec2[2]) - (dsp->fConst19 * dsp->fRec47[1])));\n\t\t\tdsp->fRec46[0] = ((fSlow127 * dsp->fRec46[1]) + (fSlow128 * (dsp->fRec2[1] + (fSlow129 * dsp->fRec47[0]))));\n\t\t\tdsp->fVec9[(dsp->IOTA & 16383)] = ((0.353553385f * dsp->fRec46[0]) + 9.99999968e-21f);\n\t\t\tfloat fTemp16 = (dsp->fVec9[((dsp->IOTA - dsp->iConst28) & 16383)] - (fTemp14 + (0.600000024f * dsp->fRec44[1])));\n\t\t\tdsp->fVec10[(dsp->IOTA & 4095)] = fTemp16;\n\t\t\tdsp->fRec44[0] = dsp->fVec10[((dsp->IOTA - dsp->iConst29) & 4095)];\n\t\t\tfloat fRec45 = (0.600000024f * fTemp16);\n\t\t\tfloat fTemp17 = dsp->fVec5[((dsp->IOTA - iSlow131) & 8191)];\n\t\t\tdsp->fVec11[(dsp->IOTA & 4095)] = (fSlow130 * (dsp->fRec10[0] * fTemp17));\n\t\t\tfloat fTemp18 = (0.300000012f * dsp->fVec11[((dsp->IOTA - dsp->iConst11) & 4095)]);\n\t\t\tdsp->fRec51[0] = (0.0f - (dsp->fConst18 * ((dsp->fConst19 * dsp->fRec51[1]) - (dsp->fRec5[1] + dsp->fRec5[2]))));\n\t\t\tdsp->fRec50[0] = ((fSlow138 * dsp->fRec50[1]) + (fSlow139 * (dsp->fRec5[1] + (fSlow140 * dsp->fRec51[0]))));\n\t\t\tdsp->fVec12[(dsp->IOTA & 16383)] = ((0.353553385f * dsp->fRec50[0]) + 9.99999968e-21f);\n\t\t\tfloat fTemp19 = ((0.600000024f * dsp->fRec48[1]) + (fTemp18 + dsp->fVec12[((dsp->IOTA - dsp->iConst36) & 16383)]));\n\t\t\tdsp->fVec13[(dsp->IOTA & 4095)] = fTemp19;\n\t\t\tdsp->fRec48[0] = dsp->fVec13[((dsp->IOTA - dsp->iConst37) & 4095)];\n\t\t\tfloat fRec49 = (0.0f - (0.600000024f * fTemp19));\n\t\t\tdsp->fRec55[0] = (dsp->fConst18 * ((dsp->fRec6[1] + dsp->fRec6[2]) - (dsp->fConst19 * dsp->fRec55[1])));\n\t\t\tdsp->fRec54[0] = ((fSlow147 * dsp->fRec54[1]) + (fSlow148 * (dsp->fRec6[1] + (fSlow149 * dsp->fRec55[0]))));\n\t\t\tdsp->fVec14[(dsp->IOTA & 16383)] = ((0.353553385f * dsp->fRec54[0]) + 9.99999968e-21f);\n\t\t\tfloat fTemp20 = (dsp->fVec14[((dsp->IOTA - dsp->iConst43) & 16383)] - (fTemp14 + (0.600000024f * dsp->fRec52[1])));\n\t\t\tdsp->fVec15[(dsp->IOTA & 2047)] = fTemp20;\n\t\t\tdsp->fRec52[0] = dsp->fVec15[((dsp->IOTA - dsp->iConst44) & 2047)];\n\t\t\tfloat fRec53 = (0.600000024f * fTemp20);\n\t\t\tdsp->fRec59[0] = (0.0f - (dsp->fConst18 * ((dsp->fConst19 * dsp->fRec59[1]) - (dsp->fRec1[1] + dsp->fRec1[2]))));\n\t\t\tdsp->fRec58[0] = ((fSlow156 * dsp->fRec58[1]) + (fSlow157 * (dsp->fRec1[1] + (fSlow158 * dsp->fRec59[0]))));\n\t\t\tdsp->fVec16[(dsp->IOTA & 32767)] = ((0.353553385f * dsp->fRec58[0]) + 9.99999968e-21f);\n\t\t\tfloat fTemp21 = (dsp->fVec16[((dsp->IOTA - dsp->iConst50) & 32767)] + ((0.600000024f * dsp->fRec56[1]) + fTemp18));\n\t\t\tdsp->fVec17[(dsp->IOTA & 4095)] = fTemp21;\n\t\t\tdsp->fRec56[0] = dsp->fVec17[((dsp->IOTA - dsp->iConst51) & 4095)];\n\t\t\tfloat fRec57 = (0.0f - (0.600000024f * fTemp21));\n\t\t\tdsp->fRec63[0] = (0.0f - (dsp->fConst18 * ((dsp->fConst19 * dsp->fRec63[1]) - (dsp->fRec3[1] + dsp->fRec3[2]))));\n\t\t\tdsp->fRec62[0] = ((fSlow165 * dsp->fRec62[1]) + (fSlow166 * (dsp->fRec3[1] + (fSlow167 * dsp->fRec63[0]))));\n\t\t\tdsp->fVec18[(dsp->IOTA & 32767)] = ((0.353553385f * dsp->fRec62[0]) + 9.99999968e-21f);\n\t\t\tfloat fTemp22 = (((0.600000024f * dsp->fRec60[1]) + dsp->fVec18[((dsp->IOTA - dsp->iConst57) & 32767)]) - fTemp18);\n\t\t\tdsp->fVec19[(dsp->IOTA & 4095)] = fTemp22;\n\t\t\tdsp->fRec60[0] = dsp->fVec19[((dsp->IOTA - dsp->iConst58) & 4095)];\n\t\t\tfloat fRec61 = (0.0f - (0.600000024f * fTemp22));\n\t\t\tdsp->fRec67[0] = (dsp->fConst18 * ((dsp->fRec0[1] + dsp->fRec0[2]) - (dsp->fConst19 * dsp->fRec67[1])));\n\t\t\tdsp->fRec66[0] = ((fSlow174 * dsp->fRec66[1]) + (fSlow175 * (dsp->fRec0[1] + (fSlow176 * dsp->fRec67[0]))));\n\t\t\tdsp->fVec20[(dsp->IOTA & 16383)] = ((0.353553385f * dsp->fRec66[0]) + 9.99999968e-21f);\n\t\t\tfloat fTemp23 = ((dsp->fVec20[((dsp->IOTA - dsp->iConst64) & 16383)] + fTemp14) - (0.600000024f * dsp->fRec64[1]));\n\t\t\tdsp->fVec21[(dsp->IOTA & 2047)] = fTemp23;\n\t\t\tdsp->fRec64[0] = dsp->fVec21[((dsp->IOTA - dsp->iConst65) & 2047)];\n\t\t\tfloat fRec65 = (0.600000024f * fTemp23);\n\t\t\tdsp->fRec71[0] = (0.0f - (dsp->fConst18 * ((dsp->fConst19 * dsp->fRec71[1]) - (dsp->fRec7[1] + dsp->fRec7[2]))));\n\t\t\tdsp->fRec70[0] = ((fSlow183 * dsp->fRec70[1]) + (fSlow184 * (dsp->fRec7[1] + (fSlow185 * dsp->fRec71[0]))));\n\t\t\tdsp->fVec22[(dsp->IOTA & 32767)] = ((0.353553385f * dsp->fRec70[0]) + 9.99999968e-21f);\n\t\t\tfloat fTemp24 = (((0.600000024f * dsp->fRec68[1]) + dsp->fVec22[((dsp->IOTA - dsp->iConst71) & 32767)]) - fTemp18);\n\t\t\tdsp->fVec23[(dsp->IOTA & 2047)] = fTemp24;\n\t\t\tdsp->fRec68[0] = dsp->fVec23[((dsp->IOTA - dsp->iConst72) & 2047)];\n\t\t\tfloat fRec69 = (0.0f - (0.600000024f * fTemp24));\n\t\t\tfloat fTemp25 = (dsp->fRec64[1] + dsp->fRec52[1]);\n\t\t\tfloat fTemp26 = (fRec49 + fTemp25);\n\t\t\tdsp->fRec0[0] = (dsp->fRec8[1] + (fRec45 + (dsp->fRec44[1] + (dsp->fRec48[1] + (fRec53 + (dsp->fRec56[1] + (fRec61 + (fRec65 + (fRec9 + (fRec57 + (dsp->fRec68[1] + (dsp->fRec60[1] + (fRec69 + fTemp26)))))))))))));\n\t\t\tdsp->fRec1[0] = ((dsp->fRec8[1] + (fRec45 + (dsp->fRec44[1] + (fRec53 + (fRec65 + (fRec9 + fTemp25)))))) - (dsp->fRec48[1] + (dsp->fRec56[1] + (fRec61 + (fRec57 + (dsp->fRec68[1] + (dsp->fRec60[1] + (fRec49 + fRec69))))))));\n\t\t\tfloat fTemp27 = (fRec49 + dsp->fRec64[1]);\n\t\t\tdsp->fRec2[0] = ((dsp->fRec8[1] + (dsp->fRec48[1] + (dsp->fRec56[1] + (fRec65 + (fRec9 + (fRec57 + fTemp27)))))) - (fRec45 + (dsp->fRec44[1] + (fRec53 + (fRec61 + (dsp->fRec68[1] + (dsp->fRec60[1] + (fRec69 + dsp->fRec52[1]))))))));\n\t\t\tfloat fTemp28 = (fRec49 + dsp->fRec52[1]);\n\t\t\tdsp->fRec3[0] = ((dsp->fRec8[1] + (fRec61 + (fRec65 + (fRec9 + (dsp->fRec68[1] + (dsp->fRec60[1] + (fRec69 + dsp->fRec64[1]))))))) - (fRec45 + (dsp->fRec44[1] + (dsp->fRec48[1] + (fRec53 + (dsp->fRec56[1] + (fRec57 + fTemp28)))))));\n\t\t\tdsp->fRec4[0] = ((fRec45 + (dsp->fRec44[1] + (dsp->fRec56[1] + (fRec61 + (fRec65 + (fRec57 + (dsp->fRec64[1] + dsp->fRec60[1]))))))) - (dsp->fRec8[1] + (dsp->fRec48[1] + (fRec53 + (fRec9 + (dsp->fRec68[1] + (fRec69 + fTemp28)))))));\n\t\t\tdsp->fRec5[0] = ((fRec45 + (dsp->fRec44[1] + (dsp->fRec48[1] + (fRec65 + (dsp->fRec68[1] + (fRec69 + fTemp27)))))) - (dsp->fRec8[1] + (fRec53 + (dsp->fRec56[1] + (fRec61 + (fRec9 + (fRec57 + (dsp->fRec52[1] + dsp->fRec60[1]))))))));\n\t\t\tdsp->fRec6[0] = ((fRec53 + (dsp->fRec56[1] + (fRec65 + (fRec57 + (dsp->fRec68[1] + (fRec69 + fTemp25)))))) - (dsp->fRec8[1] + (fRec45 + (dsp->fRec44[1] + (dsp->fRec48[1] + (fRec61 + (fRec9 + (fRec49 + dsp->fRec60[1]))))))));\n\t\t\tdsp->fRec7[0] = ((dsp->fRec48[1] + (fRec53 + (fRec61 + (fRec65 + (dsp->fRec60[1] + fTemp26))))) - (dsp->fRec8[1] + (fRec45 + (dsp->fRec44[1] + (dsp->fRec56[1] + (fRec9 + (fRec57 + (fRec69 + dsp->fRec68[1]))))))));\n\t\t\tfloat fTemp29 = (1.0f - dsp->fRec10[0]);\n\t\t\toutput0[i] = (FAUSTFLOAT)((0.370000005f * (dsp->fRec1[0] + dsp->fRec2[0])) + (fSlow1 * (fTemp29 * fTemp13)));\n\t\t\toutput1[i] = (FAUSTFLOAT)((0.370000005f * (dsp->fRec1[0] - dsp->fRec2[0])) + (fSlow130 * (fTemp29 * fTemp17)));\n\t\t\tdsp->fRec10[1] = dsp->fRec10[0];\n\t\t\tdsp->fRec19[1] = dsp->fRec19[0];\n\t\t\tdsp->iRec25[1] = dsp->iRec25[0];\n\t\t\tdsp->fRec27[1] = dsp->fRec27[0];\n\t\t\tdsp->fRec26[1] = dsp->fRec26[0];\n\t\t\tdsp->fRec28[1] = dsp->fRec28[0];\n\t\t\tdsp->fRec24[1] = dsp->fRec24[0];\n\t\t\tdsp->fRec23[1] = dsp->fRec23[0];\n\t\t\tdsp->fRec22[1] = dsp->fRec22[0];\n\t\t\tdsp->fRec21[1] = dsp->fRec21[0];\n\t\t\tdsp->fRec20[1] = dsp->fRec20[0];\n\t\t\tdsp->fVec0[1] = dsp->fVec0[0];\n\t\t\tdsp->fRec18[1] = dsp->fRec18[0];\n\t\t\tdsp->fRec17[1] = dsp->fRec17[0];\n\t\t\tdsp->IOTA = (dsp->IOTA + 1);\n\t\t\tdsp->fVec1[1] = dsp->fVec1[0];\n\t\t\tdsp->fRec31[1] = dsp->fRec31[0];\n\t\t\tdsp->fRec30[1] = dsp->fRec30[0];\n\t\t\tdsp->fVec2[1] = dsp->fVec2[0];\n\t\t\tdsp->fRec15[1] = dsp->fRec15[0];\n\t\t\tdsp->fRec12[1] = dsp->fRec12[0];\n\t\t\tdsp->fRec13[1] = dsp->fRec13[0];\n\t\t\tdsp->fRec11[2] = dsp->fRec11[1];\n\t\t\tdsp->fRec11[1] = dsp->fRec11[0];\n\t\t\tdsp->fVec3[1] = dsp->fVec3[0];\n\t\t\tdsp->fVec4[1] = dsp->fVec4[0];\n\t\t\tdsp->fRec41[1] = dsp->fRec41[0];\n\t\t\tdsp->fRec40[1] = dsp->fRec40[0];\n\t\t\tdsp->fRec39[1] = dsp->fRec39[0];\n\t\t\tdsp->fRec38[1] = dsp->fRec38[0];\n\t\t\tdsp->fRec37[1] = dsp->fRec37[0];\n\t\t\tdsp->fRec36[2] = dsp->fRec36[1];\n\t\t\tdsp->fRec36[1] = dsp->fRec36[0];\n\t\t\tdsp->fRec35[2] = dsp->fRec35[1];\n\t\t\tdsp->fRec35[1] = dsp->fRec35[0];\n\t\t\tdsp->fRec34[2] = dsp->fRec34[1];\n\t\t\tdsp->fRec34[1] = dsp->fRec34[0];\n\t\t\tdsp->fRec33[2] = dsp->fRec33[1];\n\t\t\tdsp->fRec33[1] = dsp->fRec33[0];\n\t\t\tdsp->fRec32[1] = dsp->fRec32[0];\n\t\t\tdsp->fRec43[1] = dsp->fRec43[0];\n\t\t\tdsp->fRec42[1] = dsp->fRec42[0];\n\t\t\tdsp->fRec8[1] = dsp->fRec8[0];\n\t\t\tdsp->fRec47[1] = dsp->fRec47[0];\n\t\t\tdsp->fRec46[1] = dsp->fRec46[0];\n\t\t\tdsp->fRec44[1] = dsp->fRec44[0];\n\t\t\tdsp->fRec51[1] = dsp->fRec51[0];\n\t\t\tdsp->fRec50[1] = dsp->fRec50[0];\n\t\t\tdsp->fRec48[1] = dsp->fRec48[0];\n\t\t\tdsp->fRec55[1] = dsp->fRec55[0];\n\t\t\tdsp->fRec54[1] = dsp->fRec54[0];\n\t\t\tdsp->fRec52[1] = dsp->fRec52[0];\n\t\t\tdsp->fRec59[1] = dsp->fRec59[0];\n\t\t\tdsp->fRec58[1] = dsp->fRec58[0];\n\t\t\tdsp->fRec56[1] = dsp->fRec56[0];\n\t\t\tdsp->fRec63[1] = dsp->fRec63[0];\n\t\t\tdsp->fRec62[1] = dsp->fRec62[0];\n\t\t\tdsp->fRec60[1] = dsp->fRec60[0];\n\t\t\tdsp->fRec67[1] = dsp->fRec67[0];\n\t\t\tdsp->fRec66[1] = dsp->fRec66[0];\n\t\t\tdsp->fRec64[1] = dsp->fRec64[0];\n\t\t\tdsp->fRec71[1] = dsp->fRec71[0];\n\t\t\tdsp->fRec70[1] = dsp->fRec70[0];\n\t\t\tdsp->fRec68[1] = dsp->fRec68[0];\n\t\t\tdsp->fRec0[2] = dsp->fRec0[1];\n\t\t\tdsp->fRec0[1] = dsp->fRec0[0];\n\t\t\tdsp->fRec1[2] = dsp->fRec1[1];\n\t\t\tdsp->fRec1[1] = dsp->fRec1[0];\n\t\t\tdsp->fRec2[2] = dsp->fRec2[1];\n\t\t\tdsp->fRec2[1] = dsp->fRec2[0];\n\t\t\tdsp->fRec3[2] = dsp->fRec3[1];\n\t\t\tdsp->fRec3[1] = dsp->fRec3[0];\n\t\t\tdsp->fRec4[2] = dsp->fRec4[1];\n\t\t\tdsp->fRec4[1] = dsp->fRec4[0];\n\t\t\tdsp->fRec5[2] = dsp->fRec5[1];\n\t\t\tdsp->fRec5[1] = dsp->fRec5[0];\n\t\t\tdsp->fRec6[2] = dsp->fRec6[1];\n\t\t\tdsp->fRec6[1] = dsp->fRec6[0];\n\t\t\tdsp->fRec7[2] = dsp->fRec7[1];\n\t\t\tdsp->fRec7[1] = dsp->fRec7[0];\n\t\t}\n\t}\n}\n\n#ifdef __cplusplus\n}\n#endif\n\nstatic Piano *clonePiano(Piano *dsp) {\n\treturn memmove(newPiano(), dsp, sizeof(*dsp));\n}\n\nstatic void *statePiano(Piano *dsp, int *sz) {\n\t*sz = sizeof(*dsp);\n\treturn dsp;\n}\n\n#define DSP Piano\n\n#include \"dspf.h\"\n\nstatic DSPf dspf = {\n\t.new = newPiano,\n\t.clone = clonePiano,\n\t.state = statePiano,\n\t.init = instanceInitPiano,\n\t.delete = deletePiano,\n\t.metadata = metadataPiano,\n\t.num_in = getNumInputsPiano,\n\t.num_out = getNumOutputsPiano,\n\t.clear = instanceClearPiano,\n\t.reset_ui = instanceResetUserInterfacePiano,\n\t.build_ui = buildUserInterfacePiano,\n\t.compute = computePiano,\n};\n\nvoid *\nclass_init(int rate)\n{\n\tclassInitPiano(rate);\n\treturn &dspf;\n}\n\n#endif\n", "source": "neindaw/dsp/piano.c", "file_type": "c"}
{"text": "</$objtype/mkfile\n\nTARG=\\\n\tkick_drum\\\n\tpiano\\\n\nBIN=/$objtype/bin/daw\n\nOFILES=\\\n\tmain.$O\\\n\tuiglue.$O\\\n\nCLEANFILES=\\\n\nMANY=many\n\n<../mkfs\n\n#%.c: %.dsp\n#\tos -d `{../osdir} ./dsp2c $\"prereq || \\\n#\t{ echo $target needs to be regenerated with \"./dsp2c $prereq\"; exit 1 }\n\n</sys/src/cmd/mkmany\n", "source": "neindaw/dsp/mkfile", "file_type": "mkfile"}
{"text": "/* ------------------------------------------------------------\nname: \"Kick Drum\"\nCode generated with Faust 2.23.10 (https://faust.grame.fr)\nCompilation options: -lang c -scal -ftz 0\n------------------------------------------------------------ */\n\n#ifndef  __KickDrum_H__\n#define  __KickDrum_H__\n\n/* KickDrum Plan 9 C architecture for Faust. */\n\n#include <u.h>\n#include <libc.h>\n#include \"uiglue.h\"\n\n#define max(x,y) (((x) > (y)) ? (x) : (y))\n#define min(x,y) (((x) < (y)) ? (x) : (y))\n\n#ifndef FAUSTFLOAT\n#define FAUSTFLOAT float\n#endif \n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#include <math.h>\n#include <stdlib.h>\n\ntypedef struct {\n\tint iRec0[2];\n} KickDrumSIG0;\n\nstatic KickDrumSIG0* newKickDrumSIG0(void) { return (KickDrumSIG0*)calloc(1, sizeof(KickDrumSIG0)); }\nstatic void deleteKickDrumSIG0(KickDrumSIG0* dsp) {\n\tUSED(dsp); free(dsp); }\n\nint getNumInputsKickDrumSIG0(KickDrumSIG0* dsp) {\n\tUSED(dsp);\n\treturn 0;\n}\nint getNumOutputsKickDrumSIG0(KickDrumSIG0* dsp) {\n\tUSED(dsp);\n\treturn 1;\n}\nint getInputRateKickDrumSIG0(KickDrumSIG0* dsp, int channel) {\n\tUSED(dsp);\n\tint rate;\n\tswitch ((channel)) {\n\t\tdefault: {\n\t\t\trate = -1;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn rate;\n}\nint getOutputRateKickDrumSIG0(KickDrumSIG0* dsp, int channel) {\n\tUSED(dsp);\n\tint rate;\n\tswitch ((channel)) {\n\t\tcase 0: {\n\t\t\trate = 0;\n\t\t\tbreak;\n\t\t}\n\t\tdefault: {\n\t\t\trate = -1;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn rate;\n}\n\nstatic void instanceInitKickDrumSIG0(KickDrumSIG0* dsp, int sample_rate) {\n\tUSED(sample_rate);\n\tUSED(dsp);\n\t/* C99 loop */\n\t{\n\t\tint l0;\n\t\tfor (l0 = 0; (l0 < 2); l0 = (l0 + 1)) {\n\t\t\tdsp->iRec0[l0] = 0;\n\t\t}\n\t}\n}\n\nstatic void fillKickDrumSIG0(KickDrumSIG0* dsp, int count, float* table) {\n\tUSED(dsp);\n\t/* C99 loop */\n\t{\n\t\tint i;\n\t\tfor (i = 0; (i < count); i = (i + 1)) {\n\t\t\tdsp->iRec0[0] = (dsp->iRec0[1] + 1);\n\t\t\ttable[i] = sinf((9.58738019e-05f * (float)(dsp->iRec0[0] + -1)));\n\t\t\tdsp->iRec0[1] = dsp->iRec0[0];\n\t\t}\n\t}\n}\n\nstatic float ftbl0KickDrumSIG0[65536];\n\n#ifndef FAUSTCLASS \n#define FAUSTCLASS KickDrum\n#endif\n#ifdef __APPLE__ \n#define exp10f __exp10f\n#define exp10 __exp10\n#endif\n\ntypedef struct {\n\tFAUSTFLOAT fHslider0;\n\tint fSampleRate;\n\tfloat fConst0;\n\tfloat fConst1;\n\tFAUSTFLOAT fHslider1;\n\tFAUSTFLOAT fCheckbox0;\n\tFAUSTFLOAT fHslider2;\n\tFAUSTFLOAT fHslider3;\n\tFAUSTFLOAT fButton0;\n\tfloat fVec0[2];\n\tint iRec2[2];\n\tFAUSTFLOAT fHslider4;\n\tfloat fRec1[2];\n\tFAUSTFLOAT fHslider5;\n\tFAUSTFLOAT fHslider6;\n} KickDrum;\n\nKickDrum* newKickDrum(void) { \n\tKickDrum* dsp = (KickDrum*)calloc(1, sizeof(KickDrum));\n\treturn dsp;\n}\n\nvoid deleteKickDrum(KickDrum* dsp) {\n\tUSED(dsp); \n\tfree(dsp);\n}\n\nvoid metadataKickDrum(MetaGlue* m) { \n\tm->declare(m->metaInterface, \"basics.lib/name\", \"Faust Basic Element Library\");\n\tm->declare(m->metaInterface, \"basics.lib/version\", \"0.1\");\n\tm->declare(m->metaInterface, \"envelopes.lib/ar:author\", \"Yann Orlarey, St\u00e9phane Letz\");\n\tm->declare(m->metaInterface, \"envelopes.lib/author\", \"GRAME\");\n\tm->declare(m->metaInterface, \"envelopes.lib/copyright\", \"GRAME\");\n\tm->declare(m->metaInterface, \"envelopes.lib/license\", \"LGPL with exception\");\n\tm->declare(m->metaInterface, \"envelopes.lib/name\", \"Faust Envelope Library\");\n\tm->declare(m->metaInterface, \"envelopes.lib/version\", \"0.1\");\n\tm->declare(m->metaInterface, \"filename\", \"kick_drum.dsp\");\n\tm->declare(m->metaInterface, \"group\", \"Synthesis\");\n\tm->declare(m->metaInterface, \"maths.lib/author\", \"GRAME\");\n\tm->declare(m->metaInterface, \"maths.lib/copyright\", \"GRAME\");\n\tm->declare(m->metaInterface, \"maths.lib/license\", \"LGPL with exception\");\n\tm->declare(m->metaInterface, \"maths.lib/name\", \"Faust Math Library\");\n\tm->declare(m->metaInterface, \"maths.lib/version\", \"2.3\");\n\tm->declare(m->metaInterface, \"name\", \"Kick Drum\");\n\tm->declare(m->metaInterface, \"oscillators.lib/name\", \"Faust Oscillator Library\");\n\tm->declare(m->metaInterface, \"oscillators.lib/version\", \"0.1\");\n\tm->declare(m->metaInterface, \"platform.lib/name\", \"Generic Platform Library\");\n\tm->declare(m->metaInterface, \"platform.lib/version\", \"0.1\");\n}\n\nint getSampleRateKickDrum(KickDrum* dsp) {\n\tUSED(dsp);\n\treturn dsp->fSampleRate;\n}\n\nint getNumInputsKickDrum(KickDrum* dsp) {\n\tUSED(dsp);\n\treturn 0;\n}\nint getNumOutputsKickDrum(KickDrum* dsp) {\n\tUSED(dsp);\n\treturn 1;\n}\nint getInputRateKickDrum(KickDrum* dsp, int channel) {\n\tUSED(dsp);\n\tint rate;\n\tswitch ((channel)) {\n\t\tdefault: {\n\t\t\trate = -1;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn rate;\n}\nint getOutputRateKickDrum(KickDrum* dsp, int channel) {\n\tUSED(dsp);\n\tint rate;\n\tswitch ((channel)) {\n\t\tcase 0: {\n\t\t\trate = 1;\n\t\t\tbreak;\n\t\t}\n\t\tdefault: {\n\t\t\trate = -1;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn rate;\n}\n\nvoid classInitKickDrum(int sample_rate) {\n\tUSED(sample_rate);\n\tKickDrumSIG0* sig0 = newKickDrumSIG0();\n\tinstanceInitKickDrumSIG0(sig0, sample_rate);\n\tfillKickDrumSIG0(sig0, 65536, ftbl0KickDrumSIG0);\n\tdeleteKickDrumSIG0(sig0);\n}\n\nvoid instanceResetUserInterfaceKickDrum(KickDrum* dsp) {\n\tUSED(dsp);\n\tdsp->fHslider0 = (FAUSTFLOAT)1.0f;\n\tdsp->fHslider1 = (FAUSTFLOAT)100.0f;\n\tdsp->fCheckbox0 = (FAUSTFLOAT)0.0f;\n\tdsp->fHslider2 = (FAUSTFLOAT)-5.0f;\n\tdsp->fHslider3 = (FAUSTFLOAT)0.001f;\n\tdsp->fButton0 = (FAUSTFLOAT)0.0f;\n\tdsp->fHslider4 = (FAUSTFLOAT)0.001f;\n\tdsp->fHslider5 = (FAUSTFLOAT)0.001f;\n\tdsp->fHslider6 = (FAUSTFLOAT)0.001f;\n}\n\nvoid instanceClearKickDrum(KickDrum* dsp) {\n\tUSED(dsp);\n\t/* C99 loop */\n\t{\n\t\tint l1;\n\t\tfor (l1 = 0; (l1 < 2); l1 = (l1 + 1)) {\n\t\t\tdsp->fVec0[l1] = 0.0f;\n\t\t}\n\t}\n\t/* C99 loop */\n\t{\n\t\tint l2;\n\t\tfor (l2 = 0; (l2 < 2); l2 = (l2 + 1)) {\n\t\t\tdsp->iRec2[l2] = 0;\n\t\t}\n\t}\n\t/* C99 loop */\n\t{\n\t\tint l3;\n\t\tfor (l3 = 0; (l3 < 2); l3 = (l3 + 1)) {\n\t\t\tdsp->fRec1[l3] = 0.0f;\n\t\t}\n\t}\n}\n\nvoid instanceConstantsKickDrum(KickDrum* dsp, int sample_rate) {\n\tUSED(sample_rate);\n\tUSED(dsp);\n\tdsp->fSampleRate = sample_rate;\n\tdsp->fConst0 = fminf(192000.0f, fmaxf(1.0f, (float)dsp->fSampleRate));\n\tdsp->fConst1 = (1.0f / dsp->fConst0);\n}\n\nvoid instanceInitKickDrum(KickDrum* dsp, int sample_rate) {\n\tUSED(sample_rate);\n\tUSED(dsp);\n\tinstanceConstantsKickDrum(dsp, sample_rate);\n\tinstanceResetUserInterfaceKickDrum(dsp);\n\tinstanceClearKickDrum(dsp);\n}\n\nvoid initKickDrum(KickDrum* dsp, int sample_rate) {\n\tUSED(sample_rate);\n\tUSED(dsp);\n\tclassInitKickDrum(sample_rate);\n\tinstanceInitKickDrum(dsp, sample_rate);\n}\n\nvoid buildUserInterfaceKickDrum(KickDrum* dsp, UIGlue* ui_interface) {\n\tUSED(dsp);\n\tui_interface->openVerticalBox(ui_interface->uiInterface, \"Kick Drum\");\n\tui_interface->openVerticalBox(ui_interface->uiInterface, \"A\");\n\tui_interface->declare(ui_interface->uiInterface, &dsp->fHslider1, \"0\", \"\");\n\tui_interface->declare(ui_interface->uiInterface, &dsp->fHslider1, \"unit\", \"Hz\");\n\tui_interface->addHorizontalSlider(ui_interface->uiInterface, \"Frequency\", &dsp->fHslider1, 100.0f, 5.0f, 200.0f, 1.0f);\n\tui_interface->declare(ui_interface->uiInterface, &dsp->fHslider5, \"1\", \"\");\n\tui_interface->declare(ui_interface->uiInterface, &dsp->fHslider5, \"unit\", \"s\");\n\tui_interface->addHorizontalSlider(ui_interface->uiInterface, \"Attack\", &dsp->fHslider5, 0.00100000005f, 9.99999975e-06f, 0.200000003f, 0.00100000005f);\n\tui_interface->declare(ui_interface->uiInterface, &dsp->fHslider6, \"3\", \"\");\n\tui_interface->declare(ui_interface->uiInterface, &dsp->fHslider6, \"unit\", \"s\");\n\tui_interface->addHorizontalSlider(ui_interface->uiInterface, \"Release\", &dsp->fHslider6, 0.00100000005f, 9.99999975e-06f, 1.0f, 0.00100000005f);\n\tui_interface->closeBox(ui_interface->uiInterface);\n\tui_interface->openVerticalBox(ui_interface->uiInterface, \"B\");\n\tui_interface->declare(ui_interface->uiInterface, &dsp->fHslider2, \"0\", \"\");\n\tui_interface->declare(ui_interface->uiInterface, &dsp->fHslider2, \"unit\", \"Hz\");\n\tui_interface->addHorizontalSlider(ui_interface->uiInterface, \"Frequency\", &dsp->fHslider2, -5.0f, -200.0f, 200.0f, 1.0f);\n\tui_interface->declare(ui_interface->uiInterface, &dsp->fHslider3, \"1\", \"\");\n\tui_interface->declare(ui_interface->uiInterface, &dsp->fHslider3, \"unit\", \"s\");\n\tui_interface->addHorizontalSlider(ui_interface->uiInterface, \"Attack\", &dsp->fHslider3, 0.00100000005f, 9.99999975e-06f, 0.200000003f, 0.00100000005f);\n\tui_interface->declare(ui_interface->uiInterface, &dsp->fHslider4, \"2\", \"\");\n\tui_interface->declare(ui_interface->uiInterface, &dsp->fHslider4, \"unit\", \"s\");\n\tui_interface->addHorizontalSlider(ui_interface->uiInterface, \"Release\", &dsp->fHslider4, 0.00100000005f, 9.99999975e-06f, 1.0f, 0.00100000005f);\n\tui_interface->declare(ui_interface->uiInterface, &dsp->fCheckbox0, \"3\", \"\");\n\tui_interface->addCheckButton(ui_interface->uiInterface, \"Enable\", &dsp->fCheckbox0);\n\tui_interface->closeBox(ui_interface->uiInterface);\n\tui_interface->openVerticalBox(ui_interface->uiInterface, \"Control\");\n\tui_interface->declare(ui_interface->uiInterface, &dsp->fHslider0, \"0\", \"\");\n\tui_interface->declare(ui_interface->uiInterface, &dsp->fHslider0, \"style\", \"knob\");\n\tui_interface->addHorizontalSlider(ui_interface->uiInterface, \"Gain\", &dsp->fHslider0, 1.0f, 0.0f, 1.0f, 0.00999999978f);\n\tui_interface->declare(ui_interface->uiInterface, &dsp->fButton0, \"1\", \"\");\n\tui_interface->declare(ui_interface->uiInterface, &dsp->fButton0, \"autovoice\", \"\");\n\tui_interface->declare(ui_interface->uiInterface, &dsp->fButton0, \"crossvoice\", \"\");\n\tui_interface->addButton(ui_interface->uiInterface, \"Gate\", &dsp->fButton0);\n\tui_interface->closeBox(ui_interface->uiInterface);\n\tui_interface->closeBox(ui_interface->uiInterface);\n}\n\nvoid computeKickDrum(KickDrum* dsp, int count, FAUSTFLOAT** inputs, FAUSTFLOAT** outputs) {\n\tUSED(inputs);\n\tUSED(dsp);\n\tFAUSTFLOAT* output0 = outputs[0];\n\tfloat fSlow0 = (float)dsp->fHslider0;\n\tfloat fSlow1 = (float)dsp->fHslider1;\n\tfloat fSlow2 = ((float)dsp->fCheckbox0 * (float)dsp->fHslider2);\n\tfloat fSlow3 = fmaxf(1.0f, (dsp->fConst0 * (float)dsp->fHslider3));\n\tfloat fSlow4 = (1.0f / fSlow3);\n\tfloat fSlow5 = (float)dsp->fButton0;\n\tfloat fSlow6 = (1.0f / fmaxf(1.0f, (dsp->fConst0 * (float)dsp->fHslider4)));\n\tfloat fSlow7 = fmaxf(1.0f, (dsp->fConst0 * (float)dsp->fHslider5));\n\tfloat fSlow8 = (1.0f / fSlow7);\n\tfloat fSlow9 = (1.0f / fmaxf(1.0f, (dsp->fConst0 * (float)dsp->fHslider6)));\n\t/* C99 loop */\n\t{\n\t\tint i;\n\t\tfor (i = 0; (i < count); i = (i + 1)) {\n\t\t\tdsp->fVec0[0] = fSlow5;\n\t\t\tdsp->iRec2[0] = ((fSlow5 > dsp->fVec0[1]) + ((fSlow5 <= dsp->fVec0[1]) * (dsp->iRec2[1] + (dsp->iRec2[1] > 0))));\n\t\t\tfloat fTemp0 = (float)dsp->iRec2[0];\n\t\t\tfloat fTemp1 = (dsp->fConst1 * (fSlow1 + (fSlow2 * fmaxf(0.0f, fminf((fSlow4 * fTemp0), (1.0f - (fSlow6 * (fTemp0 - fSlow3))))))));\n\t\t\tfloat fTemp2 = (fSlow5 - dsp->fVec0[1]);\n\t\t\tfloat fTemp3 = (dsp->fRec1[1] * ((float)((fTemp2 * (float)(fTemp2 > 0.0f)) > 0.0f) + -1.0f));\n\t\t\tdsp->fRec1[0] = (fTemp1 - (fTemp3 + floorf((fTemp1 - fTemp3))));\n\t\t\toutput0[i] = (FAUSTFLOAT)(fSlow0 * (ftbl0KickDrumSIG0[(int)(65536.0f * dsp->fRec1[0])] * fmaxf(0.0f, fminf((fSlow8 * fTemp0), ((fSlow9 * (fSlow7 - fTemp0)) + 1.0f)))));\n\t\t\tdsp->fVec0[1] = dsp->fVec0[0];\n\t\t\tdsp->iRec2[1] = dsp->iRec2[0];\n\t\t\tdsp->fRec1[1] = dsp->fRec1[0];\n\t\t}\n\t}\n}\n\n#ifdef __cplusplus\n}\n#endif\n\nstatic KickDrum *cloneKickDrum(KickDrum *dsp) {\n\treturn memmove(newKickDrum(), dsp, sizeof(*dsp));\n}\n\nstatic void *stateKickDrum(KickDrum *dsp, int *sz) {\n\t*sz = sizeof(*dsp);\n\treturn dsp;\n}\n\n#define DSP KickDrum\n\n#include \"dspf.h\"\n\nstatic DSPf dspf = {\n\t.new = newKickDrum,\n\t.clone = cloneKickDrum,\n\t.state = stateKickDrum,\n\t.init = instanceInitKickDrum,\n\t.delete = deleteKickDrum,\n\t.metadata = metadataKickDrum,\n\t.num_in = getNumInputsKickDrum,\n\t.num_out = getNumOutputsKickDrum,\n\t.clear = instanceClearKickDrum,\n\t.reset_ui = instanceResetUserInterfaceKickDrum,\n\t.build_ui = buildUserInterfaceKickDrum,\n\t.compute = computeKickDrum,\n};\n\nvoid *\nclass_init(int rate)\n{\n\tclassInitKickDrum(rate);\n\treturn &dspf;\n}\n\n#endif\n", "source": "neindaw/dsp/kick_drum.c", "file_type": "c"}
{"text": "#include <u.h>\n#include <libc.h>\n#include <fcall.h>\n#include <thread.h>\n#include <9p.h>\n#include \"uiglue.h\"\ntypedef struct DSP DSP;\n#include \"dspf.h\"\n#include \"common.h\"\n#include \"fs.h\"\n#include \"ui.h\"\n\n/* FIXME figure out how to get the buffering right */\nenum {\n\tInmax = 2048, /* float = 8192 bytes */\n\tOutmax = 2048, /* float = 8192 bytes */\n};\n\nstruct Auxdsp {\n\tvoid *dsp;\n\tfloat **in, **out;\n\tint numin, numout;\n\tint inmax, outmax;\n};\n\nstatic int rate = RATE;\nstatic DSPf *dspf;\n\nstatic Auxdsp *\ndspwrap(void *p)\n{\n\tAuxdsp *dsp;\n\tint i;\n\n\tif ((dsp = calloc(1, sizeof(*dsp))) == nil)\n\t\treturn nil;\n\n\tdsp->dsp = p;\n\tdsp->in = dsp->out = nil;\n\tif ((dsp->numin = dspf->num_in(dsp->dsp)) > 0) {\n\t\tdsp->in = malloc(sizeof(*dsp->in) * dsp->numin);\n\t\tdsp->inmax = Inmax;\n\t\tfor (i = 0; i < dsp->numin; i++)\n\t\t\tdsp->in[i] = malloc(sizeof(**dsp->in) * dsp->inmax);\n\t}\n\tif ((dsp->numout = dspf->num_out(dsp->dsp)) > 0) {\n\t\tdsp->out = malloc(sizeof(*dsp->out) * dsp->numout);\n\t\tdsp->outmax = Outmax;\n\t\tfor (i = 0; i < dsp->numout; i++)\n\t\t\tdsp->out[i] = malloc(sizeof(**dsp->out) * dsp->outmax);\n\t}\n\n\treturn dsp;\n}\n\nstatic Auxdsp *\ndspnew(int *numin, int *numout, int *orate)\n{\n\tAuxdsp *dsp;\n\n\tdsp = dspwrap(dspf->new());\n\tdspf->init(dsp->dsp, rate);\n\tdspf->build_ui(dsp->dsp, &uiglue);\n\t*numin = dspf->num_in(dsp->dsp);\n\t*numout = dspf->num_out(dsp->dsp);\n\t*orate = rate;\n\n\treturn dsp;\n}\n\nstatic Auxdsp *\ndspclone(Auxdsp *dsp)\n{\n\tAuxdsp *clone;\n\tint i;\n\n\tclone = dspwrap(dspf->clone(dsp->dsp));\n\tif (clone->in != nil) {\n\t\t/* copy input data */\n\t\t/* FIXME need to set the valid data size when the processing is in */\n\t\tfor (i = 0; i < dsp->numin; i++)\n\t\t\tmemmove(clone->in[i], dsp->in[i], sizeof(**dsp->in)*dsp->inmax);\n\t}\n\n\treturn clone;\n}\n\nstatic void *\ndspstate(Auxdsp *dsp, int *sz)\n{\n\treturn dspf->state(dsp->dsp, sz);\n}\n\nstatic void\ndspfree(Auxdsp *dsp)\n{\n\tint i;\n\n\tdspf->delete(dsp->dsp);\n\tfor (i = 0; i < dsp->numin; i++)\n\t\tfree(dsp->in[i]);\n\tfree(dsp->in);\n\tfor (i = 0; i < dsp->numout; i++)\n\t\tfree(dsp->out[i]);\n\tfree(dsp->out);\n\tfree(dsp);\n}\n\nstatic void\ndspreset(Auxdsp *dsp)\n{\n\tdspf->reset_ui(dsp->dsp);\n}\n\nstatic int\ndspread(Auxdsp *dsp, float *b, int n)\n{\n\tint i, j, numframes;\n\n\tnumframes = n / dsp->numout;\n\tdspf->compute(dsp->dsp, numframes, dsp->in, dsp->out);\n\tfor (i = 0; i < numframes; i++) {\n\t\tfor (j = 0; j < dsp->numout; j++)\n\t\t\t*b++ = dsp->out[j][i];\n\t}\n\n\treturn n;\n}\n\nstatic void\nusage(void)\n{\n\tprint(\"usage: %s [-s srv] [-m mtpt] [-r rate]\\n\", argv0);\n\texits(\"usage\");\n}\n\nstatic Fs fs = {\n\t.dsp = {\n\t\t.new = dspnew,\n\t\t.clone = dspclone,\n\t\t.state = dspstate,\n\t\t.free = dspfree,\n\t\t.reset = dspreset,\n\t\t.read = dspread,\n\t},\n};\n\nstatic void\naddmeta(void *metaInterface, const char *k, const char *v)\n{\n\tint klen, vlen;\n\tstatic int metalen;\n\n\tUSED(metaInterface);\n\n\tif (strchr(k, '/') != nil) /* ignore library-specific meta */ \n\t\treturn;\n\n\tklen = strlen(k);\n\tvlen = strlen(v);\n\tfs.metadata = realloc(fs.metadata, metalen + klen + 1 + vlen + 2);\n\tstrcpy(fs.metadata+metalen, k);\n\tmetalen += klen;\n\tfs.metadata[metalen++] = '\\t';\n\tstrcpy(fs.metadata+metalen, v);\n\tmetalen += vlen;\n\tfs.metadata[metalen++] = '\\n';\n\tfs.metadata[metalen] = 0;\n}\n\nvoid\nthreadmain(int argc, char **argv)\n{\n\tchar *srv, *mtpt;\n\tMetaGlue mg;\n\n\tsrv = nil;\n\tmtpt = nil;\n\tARGBEGIN{\n\tcase 'D':\n\t\tchatty9p++;\n\t\tbreak;\n\tcase 's':\n\t\tsrv = EARGF(usage());\n\t\tbreak;\n\tcase 'm':\n\t\tmtpt = EARGF(usage());\n\t\tbreak;\n\tcase 'r':\n\t\trate = atoi(EARGF(usage()));\n\t\tbreak;\n\tdefault:\n\t\tusage();\n\t}ARGEND\n\n\tif (srv == nil && mtpt == nil)\n\t\tsysfatal(\"must specify -s or -m option\");\n\n\tsetfcr(FPPDBL|FPRNR);\n\n\tmg.declare = addmeta;\n\tdspf = class_init(rate);\n\tdspf->metadata(&mg);\n\n\tfsinit(&fs);\n\tthreadpostmountsrv(&fs.srv, srv, mtpt, MREPL);\n\tthreadexits(nil);\n}\n", "source": "neindaw/dsp/main.c", "file_type": "c"}
{"text": "#include <u.h>\n#include <libc.h>\n#include <draw.h>\n#include <mouse.h>\n#include <keyboard.h>\n#include <thread.h>\n\n#define MIN(a,b) ((a)<=(b)?(a):(b))\n#define MAX(a,b) ((a)>=(b)?(a):(b))\n\ntypedef struct Waveform Waveform;\n\nstruct Waveform {\n\tfloat *samples;\n\tImage *image;\n\tfloat min;\n\tfloat max;\n\tint nchan;\n\tint nframes;\n\tint nvalid;\n\tint rate;\n};\n\nstatic Waveform *\nwvform(int f, int nchan, int rate)\n{\n\tWaveform *w;\n\tint i, r, n, sz;\n\n\tw = calloc(1, sizeof(*w));\n\tw->nchan = nchan;\n\tw->rate = rate;\n\tsz = 128*nchan;\n\tw->samples = malloc(sz*sizeof(float));\n\tfor (n = 0;;) {\n\t\tif (sz-n < 1) {\n\t\t\tsz *= 2;\n\t\t\tw->samples = realloc(w->samples, sz*sizeof(float));\n\t\t}\n\t\tif ((r = read(f, w->samples+n, (sz-n)*sizeof(float))) < 0) {\n\t\t\tfree(w->samples);\n\t\t\tfree(w);\n\t\t\treturn nil;\n\t\t}\n\t\tr /= sizeof(float);\n\t\tif (r == 0)\n\t\t\tbreak;\n\t\tif (n == 0)\n\t\t\tw->min = w->max = w->samples[0];\n\t\tfor (i = 0; i < r; i++, n++) {\n\t\t\tw->min = MIN(w->min, w->samples[n]);\n\t\t\tw->max = MAX(w->max, w->samples[n]);\n\t\t}\n\t}\n\n\tw->samples = realloc(w->samples, n*sizeof(float));\n\tw->nframes = w->nvalid = n / nchan;\n\n\treturn w;\n}\n\nstatic u64int *\nrotate9064(u64int *b, int h)\n{\n\tu64int *p;\n\tint i, j;\n\tu64int v, i7;\n\n\tp = calloc(1, 64*h/8);\n\n\tfor (i = 0; i < h; i++) {\n\t\ti7 = 1ULL<<(i^7);\n\t\tv = b[i];\n\t\tfor (j = 0; j < 64; j++) {\n\t\t\tif (v & (1ULL<<(j^56)))\n\t\t\t\tp[j*h/64 + i/64] |= i7;\n\t\t}\n\t}\n\tfor (i = 0; i < h; i++)\n\t\tp[i] = ~p[i];\n\n\treturn p;\n}\n\nstatic u64int *\nrotate90128(u64int *b, int h)\n{\n\tu64int *p;\n\tint i, j;\n\tu64int v, v2, i7;\n\n\tp = calloc(1, 128*h/8);\n\n\tfor (i = 0; i < h; i++) {\n\t\ti7 = 1ULL<<(i^7);\n\t\tv = b[i*2+0];\n\t\tv2 = b[i*2+1];\n\t\tfor (j = 1; j < 65; j++) {\n\t\t\tif (v & (1ULL<<(j^56)))\n\t\t\t\tp[(j+63)*h/64 + i/64] |= i7;\n\t\t\tif (v2 & (1ULL<<(j^56)))\n\t\t\t\tp[j*h/64 + i/64] |= i7;\n\t\t}\n\t}\n\tfor (i = 0; i < 128*h/64; i++)\n\t\tp[i] = ~p[i];\n\n\treturn p;\n}\n\nstatic int\nwvimage64(Waveform *w, int offset, Rectangle r, float zoom)\n{\n\tfloat m, i;\n\tu64int *b, *p;\n\tint x, x2, y, incy, y2;\n\n\toffset = MIN(offset, w->nvalid);\n\tr = Rect(0, 0, 64, Dx(r));\n\tif (badrect(r))\n\t\treturn -1;\n\ty = (Dy(r)+63) & ~63;\n\tb = calloc(1, 64*y);\n\tm = MAX(abs(w->min), abs(w->max));\n\tm = m > 1.0f ? 31.0f/m : 31.0f;\n\n\tfor (y = 0, i = offset; y < Dy(r) && i < w->nvalid;) {\n\t\tx = 31 + m*w->samples[(int)i];\n\t\ti += zoom;\n\t\tx2 = i < w->nvalid ? 31 + m*w->samples[(int)i] : x;\n\t\tincy = (x2 + x)/2;\n\t\ty2 = y + 1;\n\t\tdo {\n\t\t\tb[y+1] |= 1ULL<<(x^7);\n\t\t\tif (x == x2)\n\t\t\t\tbreak;\n\t\t\telse if (x < x2)\n\t\t\t\tx++;\n\t\t\telse if (x > x2)\n\t\t\t\tx--;\n\t\t\telse if (x == incy)\n\t\t\t\ty++;\n\t\t} while (1);\n\t\ty = y2;\n\t}\n\n\ty = (y+63) & ~63;\n\tp = rotate9064(b, y);\n\tfree(b);\n\tr.max.x = y;\n\tr.max.y = 64;\n\tif (w->image == nil || !eqrect(r, w->image->r)) {\n\t\tfreeimage(w->image);\n\t\tif ((w->image = allocimage(display, r, GREY1, 0, DNofill)) == nil)\n\t\t\treturn -1;\n\t}\n\n\tif (loadimage(w->image, r, (void*)p, 64*y) < 0)\n\t\tfprint(2, \"failed: %r\\n\");\n\tfree(p);\n\n\treturn 0;\n}\n\nstatic int\nwvimage128(Waveform *w, int offset, Rectangle r, float zoom)\n{\n\tfloat m, i;\n\tu64int *b, *p;\n\tint x, x2, y, incy, y2;\n\n\toffset = MIN(offset, w->nvalid);\n\tr = Rect(0, 0, 128, Dx(r));\n\tif (badrect(r))\n\t\treturn -1;\n\ty = (Dy(r)+63) & ~63;\n\tb = calloc(1, 128*y);\n\tm = MAX(abs(w->min), abs(w->max));\n\tm = m > 1.0f ? 63.0f/m : 63.0f;\n\n\tfor (y = 0, i = offset; y < Dy(r) && i < w->nvalid;) {\n\t\tx = m*w->samples[(int)i];\n\t\ti += zoom;\n\t\tx2 = i < w->nvalid ? m*w->samples[(int)i] : x;\n\t\tincy = (x2 + x)/2;\n\t\ty2 = y + 1;\n\t\tdo {\n\t\t\tif (x >= 0)\n\t\t\t\tb[y*2+1] |= 1ULL<<(x^7);\n\t\t\telse\n\t\t\t\tb[y*2+0] |= 1ULL<<(-x^56);\n\t\t\tif (x == x2)\n\t\t\t\tbreak;\n\t\t\telse if (x < x2)\n\t\t\t\tx++;\n\t\t\telse if (x > x2)\n\t\t\t\tx--;\n\t\t\telse if (x == incy)\n\t\t\t\ty++;\n\t\t} while (1);\n\t\ty = y2;\n\t}\n\n\ty = (y+63) & ~63;\n\tp = rotate90128(b, y);\n\tfree(b);\n\tr.max.x = y;\n\tr.max.y = 128;\n\tif (w->image == nil || !eqrect(r, w->image->r)) {\n\t\tfreeimage(w->image);\n\t\tif ((w->image = allocimage(display, r, GREY1, 0, DNofill)) == nil)\n\t\t\treturn -1;\n\t}\n\n\tif (loadimage(w->image, r, (void*)p, 128*y) < 0)\n\t\tfprint(2, \"failed: %r\\n\");\n\tfree(p);\n\n\treturn 0;\n}\n\nstatic int offset;\nstatic float zoom;\n\nstatic void\nredraw(Waveform *w)\n{\n\tRectangle r;\n\n\tlockdisplay(display);\n\tr = screen->r;\n\tr.min.y += Dy(r)/4;\n\tr.max.y -= Dy(r)/4;\n\tdraw(screen, screen->r, display->white, nil, ZP);\n\tif (wvimage64(w, offset, r, zoom) == 0)\n\t\tdraw(screen, r, w->image, nil, ZP);\n\tflushimage(display, 1);\n\tunlockdisplay(display);\n}\n\nstatic Waveform *\nwvbuffer(int nsamples)\n{\n\tWaveform *w;\n\n\tw = calloc(1, sizeof(*w));\n\tw->samples = malloc(nsamples*sizeof(float));\n\tw->min = -1.0f;\n\tw->max = 1.0f;\n\tw->nchan = 1;\n\tw->nframes = nsamples;\n\tw->rate = 44100;\n\tw->nvalid = 0;\n\n\treturn w;\n}\n\nstatic void\nwvproc(void *w_)\n{\n\tint fi, fo, n, i;\n\tWaveform *w = w_;\n\tint c;\n\n\tfi = 0;\n\tfo = 1;\n\tfor (c = 0;; c++) {\n\t\tif ((n = readn(fi, w->samples, sizeof(float)*w->nframes)) < 1)\n\t\t\tbreak;\n\t\tn /= sizeof(float);\n\t\tw->nvalid = n;\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tw->min = MIN(-1.0f, MIN(w->min, w->samples[i]));\n\t\t\tw->max = MAX(1.0f, MAX(w->max, w->samples[i]));\n\t\t}\n\t\tif (write(fo, w->samples, n*sizeof(float)) != n*sizeof(float))\n\t\t\tbreak;\n\t\tredraw(w);\n\t}\n\n\tthreadexits(nil);\n}\n\nvoid\nthreadmain(int argc, char **argv)\n{\n\tWaveform *w;\n\tMousectl *mctl;\n\tKeyboardctl *kctl;\n\tRune key;\n\tint oldo;\n\tMouse m;\n\tint oldb;\n\tPoint oldp;\n\tAlt a[] = {\n\t\t{ nil, &m, CHANRCV },\n\t\t{ nil, nil, CHANRCV },\n\t\t{ nil, &key, CHANRCV },\n\t\t{ nil, nil, CHANEND },\n\t};\n\n\tUSED(argc); USED(argv);\n\n\n\tif ((w = wvform(0, 1, 44100)) == nil)\n\t\tsysfatal(\"%r\");\n\t\t/*\n\tif ((w = wvbuffer(1024)) == nil)\n\t\tsysfatal(\"%r\");\n\t\t*/\n\n\tif (initdraw(nil, nil, \"daw/waveform\") < 0)\n\t\tsysfatal(\"initdraw: %r\");\n\tdisplay->locking = 1;\n\tunlockdisplay(display);\n\tif ((mctl = initmouse(nil, screen)) == nil)\n\t\tsysfatal(\"initmouse: %r\");\n\tif ((kctl = initkeyboard(nil)) == nil)\n\t\tsysfatal(\"initkeyboard: %r\");\n\n\ta[0].c = mctl->c;\n\ta[1].c = mctl->resizec;\n\ta[2].c = kctl->c;\n\n\tthreadsetname(\"daw/waveform\");\n\n\tzoom = 1.0f;\n\toffset = 0;\n\toldb = 0;\n\toldo = 0;\n\toldp = ZP;\n\n\t//proccreate(wvproc, w, mainstacksize);\n\tredraw(w);\n\n\tfor (;;) {\n\t\tswitch (alt(a)) {\n\t\tcase 0: /* mouse */\n\t\t\tif (m.buttons == 1) {\n\t\t\t\tif (oldb == 0) {\n\t\t\t\t\toldp = m.xy;\n\t\t\t\t\toldo = offset;\n\t\t\t\t} else if (oldb == 1) {\n\t\t\t\t\toffset = MAX(0, oldo + (oldp.x - m.xy.x)*zoom);\n\t\t\t\t\tredraw(w);\n\t\t\t\t}\n\t\t\t}\n\t\t\toldb = m.buttons;\n\t\t\tbreak;\n\n\t\tcase 1: /* resize */\n\t\t\tgetwindow(display, Refnone);\n\t\t\tredraw(w);\n\t\t\tbreak;\n\n\t\tcase 2: /* keyboard */\n\t\t\tswitch (key) {\n\t\t\tcase Kdel:\n\t\t\t\tgoto end;\n\t\t\tcase Kleft:\n\t\t\t\toffset = MAX(0, offset-MAX(8, 8*MAX(1, 1/zoom)));\n\t\t\t\tredraw(w);\n\t\t\t\tbreak;\n\t\t\tcase Kright:\n\t\t\t\toffset = MIN(w->nframes-1, offset+MAX(8, 8*MAX(1, 1/zoom)));\n\t\t\t\tredraw(w);\n\t\t\t\tbreak;\n\t\t\tcase '-':\n\t\t\t\tzoom *= 1.1f;\n\t\t\t\tif (zoom > 32.0f)\n\t\t\t\t\tzoom = 32.0f;\n\t\t\t\tredraw(w);\n\t\t\t\tbreak;\n\t\t\tcase '+':\n\t\t\t\tzoom /= 1.1f;\n\t\t\t\tif (zoom < 0.01f)\n\t\t\t\t\tzoom = 0.01f;\n\t\t\t\tredraw(w);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\nend:\n\tthreadexitsall(nil);\n}\n", "source": "neindaw/waveform/waveform.c", "file_type": "c"}
{"text": "</$objtype/mkfile\n\nTARG=waveform\nBIN=/$objtype/bin/daw\n\nOFILES=\\\n\twaveform.$O\\\n\ndefault:V:\tall\n\n</sys/src/cmd/mkone\n", "source": "neindaw/waveform/mkfile", "file_type": "mkfile"}
{"text": "</$objtype/mkfile\n\nTARG=ay\n\nOFILES=\\\n\tay.$O\\\n\ndefault:V:\tall\n\nMANY=one\n<../mkfs\n", "source": "neindaw/ay/mkfile", "file_type": "mkfile"}
{"text": "#include <u.h>\n#include <libc.h>\n#include <fcall.h>\n#include <thread.h>\n#include <9p.h>\n#define CHIPS_IMPL\n#define CHIPS_ASSERT assert\n#include \"ay38910.h\"\n#include \"common.h\"\n#include \"ui.h\"\n#include \"fs.h\"\n\n#define MIN(a,b) ((a)<=(b)?(a):(b))\n#define MAX(a,b) ((a)>=(b)?(a):(b))\n\nenum {\n\tLevelenv = 1<<4,\n\n\tHold = 1<<0,\n\tAlternate = 1<<1,\n\tAttack = 1<<2,\n\tContinue = 1<<3,\n};\n\nstruct Auxdsp {\n\tay38910_t ay;\n\tstruct {\n\t\tfloat freq;\n\t\tfloat amp;\n\t\tfloat envelope;\n\t\tfloat noise;\n\t\tfloat enable;\n\t}chan[3];\n\tfloat hold, alternate, attack, cont;\n\tfloat noisefreq;\n\tfloat envperiod;\n\tfloat hit;\n\tint envmode;\n};\n\nstatic int tickhz = 1773400;\nstatic int rate = RATE;\n\nstatic void\nregw(ay38910_t *ay, int reg, int v)\n{\n\tu64int p;\n\n\t/* latch address */\n\tp = AY38910_BDIR | AY38910_BC1;\n\tAY38910_SET_DATA(p, reg);\n\tay38910_iorq(ay, p);\n\n\t/* write to psg */\n\tp = AY38910_BDIR;\n\tAY38910_SET_DATA(p, v);\n\tay38910_iorq(ay, p);\n\n\t/* inactive */\n\tay38910_iorq(ay, 0);\n}\n\nstatic int\nregr(ay38910_t *ay, int reg)\n{\n\tu64int p;\n\tint v;\n\n\t/* latch address */\n\tp = AY38910_BDIR | AY38910_BC1;\n\tAY38910_SET_DATA(p, reg);\n\tay38910_iorq(ay, p);\n\n\t/* read from psg */\n\tv = AY38910_GET_DATA(ay38910_iorq(ay, AY38910_BC1));\n\n\t/* inactive */\n\tay38910_iorq(ay, 0);\n\n\treturn v;\n}\n\nstatic float\ntone(ay38910_t *ay, int chan, float hz)\n{\n\tint tp;\n\n\ttp = MAX(1, MIN(4095, tickhz / (MAX(1, hz) * 16)));\n\tregw(ay, AY38910_REG_PERIOD_A_FINE + 2*chan, tp & 0xff);\n\tregw(ay, AY38910_REG_PERIOD_A_COARSE + 2*chan, (tp>>8) & 0x0f);\n\n\treturn tickhz/tp/16;\n}\n\nstatic int\nwritectl(UI *ui, int auxtype, char *s)\n{\n\tstruct Auxdsp *dsp;\n\tay38910_t *ay;\n\tint r, i, level;\n\tvlong pd;\n\n\tif ((r = ui_writestr(ui, auxtype, s)) < 0)\n\t\treturn r;\n\n\tdsp = ui->userdata;\n\tay = &dsp->ay;\n\tfor (i = 0; i < nelem(dsp->chan); i++) {\n\t\tif (ui->zone == &dsp->chan[i].freq) {\n\t\t\t*ui->zone = tone(ay, i, *ui->zone);\n\t\t\treturn 0;\n\t\t}\n\t\tif (ui->zone == &dsp->chan[i].enable) {\n\t\t\tr = regr(ay, AY38910_REG_ENABLE) | 1<<i;\n\t\t\tif (*ui->zone)\n\t\t\t\tr &= ~(1<<i);\n\t\t\tregw(ay, AY38910_REG_ENABLE, r);\n\t\t\treturn 0;\n\t\t}\n\t\tif (ui->zone == &dsp->chan[i].noise) {\n\t\t\tr = regr(ay, AY38910_REG_ENABLE) | 1<<(3+i);\n\t\t\tif (*ui->zone)\n\t\t\t\tr &= ~(1<<(3+i));\n\t\t\tregw(ay, AY38910_REG_ENABLE, r);\n\t\t\treturn 0;\n\t\t}\n\t\tif (ui->zone == &dsp->chan[i].envelope) {\n\t\t\tr = regr(ay, AY38910_REG_AMP_A+i) & ~(1<<4);\n\t\t\tif (*ui->zone)\n\t\t\t\tr |= 1<<4;\n\t\t\tregw(ay, AY38910_REG_AMP_A+i, r);\n\t\t\treturn 0;\n\t\t}\n\t\tif (ui->zone == &dsp->chan[i].amp) {\n\t\t\tlevel = MAX(0, MIN(15, *ui->zone * 15));\n\t\t\tlevel |= regr(ay, AY38910_REG_AMP_A+i) & (1<<4);\n\t\t\tregw(ay, AY38910_REG_AMP_A+i, level);\n\t\t\t*ui->zone = (float)(level&0xf) / 15.0f;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (ui->zone == &dsp->envperiod) {\n\t\tpd = MAX(1, MIN(65535, tickhz*(*ui->zone) / 256));\n\t\tregw(ay, AY38910_REG_ENV_PERIOD_FINE, pd&0xff);\n\t\tregw(ay, AY38910_REG_ENV_PERIOD_COARSE, pd>>8);\n\t\t*ui->zone = MAX(1, pd*256000LL/tickhz);\n\t\treturn 0;\n\t}\n\n\tif (ui->zone == &dsp->noisefreq) {\n\t\tr = MAX(1, MIN(31, tickhz/(16 * (*ui->zone))));\n\t\tregw(ay, AY38910_REG_PERIOD_NOISE, r);\n\t\t*ui->zone = tickhz/16/r;\n\t\treturn 0;\n\t}\n\n\tif (ui->zone == &dsp->hit) {\n\t\tif (*ui->zone)\n\t\t\tregw(ay, AY38910_REG_ENV_SHAPE_CYCLE, dsp->envmode);\n\t\treturn 0;\n\t}\n\n\tdsp->envmode = 0;\n\tif (dsp->hold)\n\t\tdsp->envmode |= 1<<0;\n\tif (dsp->alternate)\n\t\tdsp->envmode |= 1<<1;\n\tif (dsp->attack)\n\t\tdsp->envmode |= 1<<2;\n\tif (dsp->cont)\n\t\tdsp->envmode |= 1<<3;\n\n\treturn 0;\n}\n\n#define BIND(x) do { ui = x; ui->userdata = dsp; ui->writestr = writectl; writectl(ui, Xuictl, \"reset\"); } while(0)\n\nextern File *uif;\n\nstatic Auxdsp *\ndspnew(int *numin, int *numout, int *orate)\n{\n\tstruct Auxdsp *dsp;\n\tUI *ui;\n\tchar s[32];\n\tfloat min, step, max;\n\tay38910_desc_t desc = {\n\t\t.type = AY38910_TYPE_8910,\n\t\t.tick_hz = tickhz,\n\t\t.sound_hz = rate,\n\t\t.magnitude = 1.0,\n\t};\n\tint i;\n\n\t*numin = 0;\n\t*numout = 1;\n\t*orate = rate;\n\n\tif ((dsp = malloc(sizeof(*dsp))) == nil)\n\t\treturn nil;\n\tay38910_init(&dsp->ay, &desc);\n\tregw(&dsp->ay, AY38910_REG_ENABLE, 0xff); /* disable everything */\n\n\tmin = ceil(tickhz/65520);\n\tmax = floor(tickhz/16);\n\tstep = MAX(1, ceil(tickhz/65504 - tickhz/65520));\n\n\tui_vgroup(\"AY-3-8910\");\n\n\tBIND(ui_hslider(\"Volume\", &dsp->ay.mag, 1.0f, 0.0f, 1.0f, 0.001f));\n\n\tfor (i = 0; i < nelem(dsp->chan); i++) {\n\t\tsprint(s, \"%c\", 'A'+i);\n\t\tui_tgroup(s);\n\t\t\tui_hgroup(\"Tone\");\n\t\t\t\tui_declare(&dsp->chan[i].freq, \"0\", \"\");\n\t\t\t\tui_declare(&dsp->chan[i].freq, \"unit\", \"Hz\");\n\t\t\t\tBIND(ui_hslider(\"Frequency\", &dsp->chan[i].freq, min, min, max, step));\n\n\t\t\t\tui_declare(&dsp->chan[i].enable, \"1\", \"\");\n\t\t\t\tBIND(ui_checkbox(\"Enable\", &dsp->chan[i].enable));\n\t\t\tui_endgroup();\n\n\t\t\tui_declare(&dsp->chan[i].amp, \"0\", \"\");\n\t\t\tBIND(ui_hslider(\"Volume\", &dsp->chan[i].amp, 1.0f, 0.0f, 1.0f, 1.0f/15.0f));\n\n\t\t\tui_declare(&dsp->chan[i].envelope, \"1\", \"\");\n\t\t\tBIND(ui_checkbox(\"Envelope\", &dsp->chan[i].envelope));\n\n\t\t\tui_declare(&dsp->chan[i].noise, \"2\", \"\");\n\t\t\tBIND(ui_checkbox(\"Noise\", &dsp->chan[i].noise));\n\t\tui_endgroup();\n\t}\n\n\tmin = ceil(tickhz/496);\n\tmax = floor(tickhz/16);\n\tstep = MAX(1, tickhz/480 - tickhz/496);\n\tui_declare(&dsp->noisefreq, \"unit\", \"Hz\");\n\tBIND(ui_hslider(\"Noise\", &dsp->noisefreq, min, min, max, step));\n\n\tui_vgroup(\"Envelope\");\n\t\tmin = MAX(1, 256000/tickhz);\n\t\tmax = floor(16776960000LL/tickhz);\n\t\tui_declare(&dsp->envperiod, \"0\", \"\");\n\t\tui_declare(&dsp->envperiod, \"unit\", \"s\");\n\t\tBIND(ui_hslider(\"Period\", &dsp->envperiod, 0.5, min/1000.0, max/1000.0, 0.001));\n\n\t\tui_declare(&dsp->hold, \"1\", \"\");\n\t\tBIND(ui_checkbox(\"Hold\", &dsp->hold));\n\n\t\tui_declare(&dsp->alternate, \"2\", \"\");\n\t\tBIND(ui_checkbox(\"Alternate\", &dsp->alternate));\n\n\t\tui_declare(&dsp->attack, \"3\", \"\");\n\t\tBIND(ui_checkbox(\"Attack\", &dsp->attack));\n\n\t\tui_declare(&dsp->cont, \"4\", \"\");\n\t\tBIND(ui_checkbox(\"Continue\", &dsp->cont));\n\n\t\tui_declare(&dsp->hit, \"5\", \"\");\n\t\tBIND(ui_button(\"Hit\", &dsp->hit));\n\tui_endgroup();\n\n\tui_endgroup();\n\n\treturn dsp;\n}\n\nstatic void\ndspfree(Auxdsp *dsp)\n{\n\tfree(dsp);\n}\n\nstatic void\ndspreset(Auxdsp *dsp)\n{\n\tay38910_reset(&dsp->ay);\n}\n\nstatic int\ndspread(Auxdsp *dsp, float *b, int n)\n{\n\tint i;\n\n\tfor (i = 0; i < n; i++) {\n\t\twhile (!ay38910_tick(&dsp->ay));\n\t\tb[i] = dsp->ay.sample;\n\t}\n\n\treturn n;\n}\n\nstatic void\nusage(void)\n{\n\tprint(\"usage: %s [-s srv] [-m mtpt] [-r rate] [-t HZ]\\n\", argv0);\n\tthreadexitsall(\"usage\");\n}\n\nstatic Fs fs = {\n\t.metadata =\"name\\tAY-3-8910\\ngroup\\tSynthesis\\n\",\n\t.dsp = {\n\t\t.new = dspnew,\n\t\t.free = dspfree,\n\t\t.reset = dspreset,\n\t\t.read = dspread,\n\t},\n};\n\nvoid\nthreadmain(int argc, char **argv)\n{\n\tchar *srv, *mtpt;\n\n\tsrv = nil;\n\tmtpt = nil;\n\tARGBEGIN{\n\tcase 'D':\n\t\tchatty9p++;\n\t\tbreak;\n\tcase 's':\n\t\tsrv = EARGF(usage());\n\t\tbreak;\n\tcase 'm':\n\t\tmtpt = EARGF(usage());\n\t\tbreak;\n\tcase 'r':\n\t\trate = atoi(EARGF(usage()));\n\t\tbreak;\n\tcase 't':\n\t\ttickhz = atoi(EARGF(usage()));\n\t\tbreak;\n\tdefault:\n\t\tusage();\n\t}ARGEND\n\n\tif (rate < 1 || tickhz < 1)\n\t\tusage();\n\n\tif (srv == nil && mtpt == nil)\n\t\tsysfatal(\"must specify -s or -m option\");\n\n\tfsinit(&fs);\n\tthreadpostmountsrv(&fs.srv, srv, mtpt, MREPL);\n\tthreadexits(nil);\n}\n", "source": "neindaw/ay/ay.c", "file_type": "c"}
{"text": "</$objtype/mkfile\n\nTARG=\\\n\trepeat\\\n\nBIN=/$objtype/bin/daw\nCFLAGS=$CFLAGS\nOFILES=repeat.$O\n\ndefault:V:\tall\n\n</sys/src/cmd/mkone\n", "source": "neindaw/repeat/mkfile", "file_type": "mkfile"}
{"text": "#include <u.h>\n#include <libc.h>\n\nstatic void\nusage(void)\n{\n\tprint(\"usage: %s -l len_frames [-t times] [-c channels] [-f file]\\n\", argv0);\n\texits(\"usage\");\n}\n\nvoid\nmain(int argc, char **argv)\n{\n\tint length, chan, t, f, r, n;\n\tu8int *b;\n\n\tlength = 0;\n\tchan = 1;\n\tt = -1;\n\tf = 0;\n\n\tARGBEGIN{\n\tcase 'l':\n\t\tlength = atoi(EARGF(usage()));\n\t\tbreak;\n\tcase 't':\n\t\tt = atoi(EARGF(usage()));\n\t\tbreak; \n\tcase 'c':\n\t\tchan = atoi(EARGF(usage()));\n\t\tbreak;\n\tcase 'f':\n\t\tif ((f = open(EARGF(usage()), OREAD)) < 0)\n\t\t\tsysfatal(\"%r\");\n\t\tbreak;\n\tdefault:\n\t\tusage();\n\t}ARGEND\n\n\tif (length < 1)\n\t\tsysfatal(\"invalid length: %d frames\", length);\n\tif (chan < 1)\n\t\tsysfatal(\"invalid number of channels: %d\", chan);\n\n\tlength *= chan * 4;\n\tif ((b = malloc(length)) == nil)\n\t\tsysfatal(\"couldn't allocate %d bytes\", length);\n\n\tn = 0;\n\twhile (t != 0) {\n\t\tif (f != 0 || n == 0) {\n\t\t\tseek(f, 0, 0);\n\n\t\t\tfor (n = 0; n < length; n += r) {\n\t\t\t\tr = read(f, b+n, length-n);\n\t\t\t\tif (r < 0)\n\t\t\t\t\texits(\"read failed\");\n\t\t\t\telse if (r == 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmemset(b+n, 0, length-n);\n\t\t}\n\n\t\tif (write(1, b, length) != length)\n\t\t\tbreak;\n\n\t\tif (t > 0)\n\t\t\tt--;\n\t}\n\n\texits(nil);\n}\n", "source": "neindaw/repeat/repeat.c", "file_type": "c"}
{"text": "</$objtype/mkfile\nLIB=/$objtype/lib/libmicroui.a\n\nOFILES=\\\n\tmicroui.$O\\\n\nHFILES=\\\n\t/sys/include/microui.h\\\n\n/sys/include/%.h: %.h\n\tcp $stem.h /sys/include/$stem.h\n\n</sys/src/cmd/mksyslib\n", "source": "neindaw/microui/mkfile", "file_type": "mkfile"}
{"text": "#include <u.h>\n#include <libc.h>\n#include <draw.h>\n#include <microui.h>\n\n#define MU_REAL_FMT \"%g\"\n#define MU_SLIDER_FMT \"%.2f\"\n\n#define MIN(a, b) ((a) < (b) ? (a) : (b))\n#define MAX(a, b) ((a) > (b) ? (a) : (b))\n#define CLAMP(x, a, b) MIN(b, MAX(a, x))\n\nstatic mu_Rect unclipped_rect = { 0, 0, 0x1000000, 0x1000000 };\n\nstatic u8int atlasraw[] = {\n\t0x63, 0x6f, 0x6d, 0x70, 0x72, 0x65, 0x73, 0x73, 0x65, 0x64, 0x0a, 0x20, 0x20, 0x20, 0x72, 0x38,\n\t0x67, 0x38, 0x62, 0x38, 0x61, 0x38, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t0x20, 0x30, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x30, 0x20, 0x20,\n\t0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x33, 0x34, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t0x20, 0x20, 0x20, 0x20, 0x32, 0x35, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t0x32, 0x35, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x34, 0x33, 0x39, 0x20, 0x80,\n\t0x00, 0x7c, 0x00, 0x7c, 0x00, 0x7c, 0x00, 0x78, 0x00, 0x7c, 0x00, 0x7c, 0x00, 0x7c, 0x00, 0x7c,\n\t0x00, 0x7c, 0x00, 0x7c, 0x00, 0x7c, 0x00, 0x7c, 0x00, 0x7c, 0x00, 0x7c, 0x00, 0x34, 0x00, 0x80,\n\t0x14, 0x00, 0x00, 0x80, 0x5c, 0x00, 0x00, 0x54, 0x1f, 0x04, 0x1b, 0x04, 0x23, 0x24, 0x13, 0x7c,\n\t0x00, 0x3c, 0x00, 0x80, 0x20, 0x00, 0x00, 0x80, 0xc0, 0x00, 0x00, 0x04, 0x07, 0x44, 0x1f, 0x80,\n\t0x5e, 0x00, 0x00, 0x80, 0xff, 0x00, 0x00, 0x80, 0x70, 0x00, 0x00, 0x34, 0x1b, 0x04, 0x13, 0x04,\n\t0x1b, 0x04, 0x23, 0x24, 0x17, 0x7c, 0x00, 0x2c, 0x00, 0x80, 0x21, 0x00, 0x00, 0x80, 0xe0, 0x00,\n\t0x00, 0x80, 0xea, 0x00, 0x00, 0x80, 0x2c, 0x00, 0x00, 0x54, 0x27, 0x14, 0x6f, 0x24, 0x8b, 0x44,\n\t0x13, 0x14, 0x00, 0x7c, 0x00, 0x4c, 0x83, 0x80, 0x2d, 0x00, 0x00, 0x74, 0x2f, 0x24, 0x77, 0x74,\n\t0x83, 0x7c, 0x00, 0x1c, 0x83, 0x80, 0xe1, 0x00, 0x00, 0x80, 0xeb, 0x00, 0x00, 0x7c, 0x83, 0x3c,\n\t0x8b, 0x74, 0x83, 0x24, 0x00, 0x80, 0x0e, 0x00, 0x00, 0x7c, 0x83, 0x7c, 0x83, 0x7c, 0x87, 0x3c,\n\t0x00, 0x14, 0x00, 0x80, 0x3d, 0x00, 0x00, 0x80, 0xed, 0x00, 0x00, 0x80, 0x45, 0x00, 0x00, 0x24,\n\t0x17, 0x80, 0x22, 0x00, 0x00, 0x7c, 0x83, 0x7d, 0x97, 0x75, 0x97, 0x14, 0x00, 0x80, 0x13, 0x00,\n\t0x00, 0x80, 0xd0, 0x00, 0x00, 0x80, 0xf6, 0x00, 0x00, 0x14, 0x8b, 0x24, 0x83, 0x80, 0x2e, 0x00,\n\t0x00, 0x7c, 0x79, 0x7e, 0xa7, 0x54, 0x8b, 0x54, 0x8b, 0x80, 0x63, 0x00, 0x00, 0x7c, 0x83, 0x4c,\n\t0x00, 0x7f, 0xb7, 0x3f, 0xb7, 0x54, 0x8b, 0x04, 0x2b, 0x80, 0xec, 0x00, 0x00, 0x7c, 0x83, 0x3c,\n\t0x00, 0x80, 0x14, 0x00, 0x00, 0x80, 0x5c, 0x00, 0x00, 0x54, 0x1f, 0x04, 0x1b, 0x04, 0x23, 0x24,\n\t0x13, 0x54, 0x8b, 0x80, 0xbc, 0x00, 0x00, 0x7c, 0x83, 0x7c, 0x00, 0x7c, 0x00, 0x0c, 0x00, 0x7c,\n\t0x00, 0x7c, 0x00, 0x7c, 0x00, 0x7c, 0x00, 0x7c, 0x00, 0x7c, 0x00, 0x7c, 0x00, 0x7c, 0x00, 0x7c,\n\t0x00, 0x7c, 0x00, 0x64, 0x00, 0x80, 0x5a, 0x00, 0x00, 0x06, 0x6b, 0x14, 0x07, 0x80, 0x8f, 0x00,\n\t0x00, 0x44, 0x27, 0x7c, 0x00, 0x7c, 0x00, 0x64, 0x00, 0x80, 0x3c, 0x00, 0x00, 0x80, 0xaa, 0x00,\n\t0x00, 0x04, 0x07, 0x04, 0x83, 0x54, 0x8b, 0x44, 0x17, 0x14, 0x2f, 0x7c, 0x65, 0x7c, 0x00, 0x34,\n\t0x00, 0x54, 0x8b, 0x34, 0x17, 0x64, 0xb3, 0x7c, 0x00, 0x0c, 0x00, 0x80, 0x6e, 0x00, 0x00, 0x05,\n\t0x03, 0x35, 0x0f, 0x64, 0x8b, 0x34, 0x17, 0x7c, 0x83, 0x7c, 0x00, 0x80, 0xa5, 0x00, 0x00, 0x15,\n\t0x4f, 0x26, 0x1f, 0x64, 0x83, 0x74, 0xa3, 0x7c, 0x00, 0x7c, 0x00, 0x7c, 0x63, 0x81, 0x00, 0x00,\n\t0x34, 0x27, 0x7c, 0x4d, 0x4c, 0x00, 0x80, 0x55, 0x00, 0x00, 0x80, 0x37, 0x00, 0x00, 0x04, 0x0b,\n\t0x04, 0x07, 0x04, 0x0f, 0x04, 0x0b, 0x80, 0x1e, 0x00, 0x00, 0x04, 0x0b, 0x04, 0x07, 0x64, 0x83,\n\t0x7c, 0x00, 0x7c, 0x00, 0x16, 0xef, 0x05, 0x8f, 0x75, 0x97, 0x54, 0x00, 0x7c, 0x00, 0x7c, 0x00,\n\t0x7d, 0x0f, 0x0d, 0x0f, 0x64, 0x3f,\n};\n\nstatic mu_Rect default_atlas_icons[] = {\n\t[MU_ICON_CHECK] = {0, 0, 18, 18},\n\t[MU_ICON_CLOSE] = {18, 0, 16, 16},\n\t[MU_ICON_COLLAPSED] = {27, 16, 5, 7},\n\t[MU_ICON_EXPANDED] = {0, 18, 7, 5},\n\t[MU_ICON_RESIZE] = {18, 16, 9, 9},\n\t[ATLAS_DIMENSIONS] = {0, 0, 34, 25},\n};\n\nmu_Context mu_ctx;\nmu_Style mu_style = {\n\t.font = nil,\n\t.size = { 68, 10 },\n\t.padding = 6,\n\t.spacing = 4,\n\t.indent = 24,\n\t.title_height = 26,\n\t.scrollbar_size = 12,\n\t.thumb_size = 8,\n\t.colors = {nil},\n};\n\nImage *atlasimage = nil;\nmu_Rect *atlasicons = default_atlas_icons;\nu8int defaultcolors[MU_COLOR_MAX][4] = {\n\t[MU_COLOR_BG] = {119, 119, 119, 255},\n\t[MU_COLOR_TEXT] = {230, 230, 230, 255},\n\t[MU_COLOR_BORDER] = {25, 25, 25, 255},\n\t[MU_COLOR_WINDOWBG] = {50, 50, 50, 255},\n\t[MU_COLOR_TITLEBG] = {25, 25, 25, 255},\n\t[MU_COLOR_TITLETEXT] = {240, 240, 240, 255},\n\t[MU_COLOR_PANELBG] = {0, 0, 0, 0},\n\t[MU_COLOR_BUTTON] = {75, 75, 75, 255},\n\t[MU_COLOR_BUTTONHOVER] = {95, 95, 95, 255},\n\t[MU_COLOR_BUTTONFOCUS] = {115, 115, 115, 255},\n\t[MU_COLOR_BASE] = {30, 30, 30, 255},\n\t[MU_COLOR_BASEHOVER] = {35, 35, 35, 255},\n\t[MU_COLOR_BASEFOCUS] = {40, 40, 40, 255},\n\t[MU_COLOR_SCROLLBASE] = {43, 43, 43, 255},\n\t[MU_COLOR_SCROLLTHUMB] = {30, 30, 30, 255},\n};\n\nstatic void\nbuffer_grow(void **buf, int onesz, int *bufmax, int bufnum)\n{\n\twhile (*bufmax <= bufnum) {\n\t\t*bufmax = MAX(16, *bufmax) * 2;\n\t\tif ((*buf = realloc(*buf, *bufmax*onesz)) == nil)\n\t\t\tsysfatal(\"not enough memory for %d items (%d bytes)\", *bufmax, *bufmax*onesz);\n\t}\n}\n\nmu_Rect\nmu_rect(int x, int y, int w, int h)\n{\n\tmu_Rect res;\n\tres.x = x, res.y = y, res.w = w, res.h = h;\n\treturn res;\n}\n\nImage *\nmu_color(u8int r, u8int g, u8int b, u8int a)\n{\n\tImage *c;\n\tif ((c = allocimage(display, Rect(0, 0, 1, 1), RGBA32, 1, setalpha(r<<24 | g<<16 | b<<8, a))) == nil)\n\t\tsysfatal(\"couldn't allocate color\");\n\treturn c;\n}\n\nstatic Rectangle\nscreenrect(mu_Rect r)\n{\n\tRectangle rect;\n\trect.min = screen->r.min;\n\trect.min.x += r.x;\n\trect.min.y += r.y;\n\trect.max = rect.min;\n\trect.max.x += r.w;\n\trect.max.y += r.h;\n\treturn rect;\n}\n\nstatic mu_Rect\nexpand_rect(mu_Rect rect, int n) {\n\treturn mu_rect(rect.x - n, rect.y - n, rect.w + n * 2, rect.h + n * 2);\n}\n\n\nstatic mu_Rect\nclip_rect(mu_Rect r1, mu_Rect r2)\n{\n\tint x1 = MAX(r1.x, r2.x);\n\tint y1 = MAX(r1.y, r2.y);\n\tint x2 = MAX(MIN(r1.x + r1.w, r2.x + r2.w), x1);\n\tint y2 = MAX(MIN(r1.y + r1.h, r2.y + r2.h), y1);\n\treturn mu_rect(x1, y1, x2 - x1, y2 - y1);\n}\n\n\nstatic int\nrect_overlaps_vec2(mu_Rect r, Point p)\n{\n\treturn p.x >= r.x && p.x < r.x + r.w && p.y >= r.y && p.y < r.y + r.h;\n}\n\nstatic void\ndraw_frame(mu_Rect rect, int colorid)\n{\n\tmu_draw_rect(rect, mu_style.colors[colorid]);\n\tif (colorid == MU_COLOR_SCROLLBASE\t|| colorid == MU_COLOR_SCROLLTHUMB || colorid == MU_COLOR_TITLEBG)\n\t\treturn;\n\t/* draw border */\n\tmu_draw_box(expand_rect(rect, 1), mu_style.colors[MU_COLOR_BORDER]);\n}\n\nstatic int\ntext_width(Font *font, const char *text, int len)\n{\n\treturn stringnwidth(font, text, len >= 0 ? len : strlen(text));\n}\n\nvoid\nmu_init(void)\n{\n\tRectangle r;\n\tint res, i;\n\n\tif (atlasimage == nil) {\n\t\tr = Rect(0, 0, atlasicons[ATLAS_DIMENSIONS].w, atlasicons[ATLAS_DIMENSIONS].h);\n\t\tatlasimage = allocimage(display, r, RGBA32, 1, DTransparent);\n\t\tif (memcmp(atlasraw, \"compressed\\n\", 11) == 0)\n\t\t\tres = cloadimage(atlasimage, r, atlasraw+11+5*12, sizeof(atlasraw)-11-5*12);\n\t\telse\n\t\t\tres = loadimage(atlasimage, r, atlasraw, sizeof(atlasraw));\n\t\tif (res < 0)\n\t\t\tsysfatal(\"failed to load atlas: %r\");\n\t}\n\n\tif (mu_style.colors[0] == nil) {\n\t\tfor (i = 0; i < MU_COLOR_MAX; i++) {\n\t\t\tmu_style.colors[i] = mu_color(\n\t\t\t\tdefaultcolors[i][0],\n\t\t\t\tdefaultcolors[i][1],\n\t\t\t\tdefaultcolors[i][2],\n\t\t\t\tdefaultcolors[i][3]\n\t\t\t);\n\t\t}\n\t}\n}\n\nvoid\nmu_begin(void)\n{\n\tmu_ctx.cmdsnum = mu_ctx.rootnum = 0;\n\tmu_ctx.strnum = 0;\n\tmu_ctx.scroll_target = nil;\n\tmu_ctx.last_hover_root = mu_ctx.hover_root;\n\tmu_ctx.hover_root = nil;\n\tmu_ctx.mouse_delta.x = mu_ctx.mouse_pos.x - mu_ctx.last_mouse_pos.x;\n\tmu_ctx.mouse_delta.y = mu_ctx.mouse_pos.y - mu_ctx.last_mouse_pos.y;\n}\n\nstatic int\ncompare_zindex(const void *a, const void *b)\n{\n\treturn (*(mu_Container**)a)->zindex - (*(mu_Container**)b)->zindex;\n}\n\nvoid\nmu_end(void)\n{\n\tint i, n;\n\t/* check stacks */\n\tassert(mu_ctx.cntnum == 0);\n\tassert(mu_ctx.clipnum == 0);\n\tassert(mu_ctx.idsnum == 0);\n\tassert(mu_ctx.layoutsnum == 0);\n\n\t/* handle scroll input */\n\tif (mu_ctx.scroll_target) {\n\t\tmu_ctx.scroll_target->scroll.x += mu_ctx.scroll_delta.x;\n\t\tmu_ctx.scroll_target->scroll.y += mu_ctx.scroll_delta.y;\n\t}\n\n\t/* unset focus if focus id was not touched this frame */\n\tif (!mu_ctx.updated_focus)\n\t\tmu_ctx.focus = 0;\n\tmu_ctx.updated_focus = 0;\n\n\t/* bring hover root to front if mouse was pressed */\n\tif (mu_ctx.mouse_pressed && mu_ctx.hover_root && mu_ctx.hover_root->zindex < mu_ctx.last_zindex)\n\t\tmu_bring_to_front(mu_ctx.hover_root);\n\n\t/* reset input state */\n\tmu_ctx.key_pressed = 0;\n\tmu_ctx.text_input[0] = 0;\n\tmu_ctx.mouse_pressed = 0;\n\tmu_ctx.scroll_delta = ZP;\n\tmu_ctx.last_mouse_pos = mu_ctx.mouse_pos;\n\n\t/* sort root containers by zindex */\n\tn = mu_ctx.rootnum;\n\tqsort(mu_ctx.root, n, sizeof(*mu_ctx.root), compare_zindex);\n\n\t/* set root container jump commands */\n\tfor (i = 0; i < n; i++) {\n\t\tmu_Container *cnt = mu_ctx.root[i];\n\t\t/* if this is the first container then make the first command jump to it.\n\t\t** otherwise set the previous container's tail to jump to this one */\n\t\tif (i == 0)\n\t\t\tmu_ctx.cmds[0].jump.dst = cnt->head + 1;\n\t\telse\n\t\t\tmu_ctx.cmds[mu_ctx.root[i - 1]->tail].jump.dst = cnt->head + 1;\n\n\t\t/* make the last container's tail jump to the end of command list */\n\t\tif (i == n - 1)\n\t\t\tmu_ctx.cmds[cnt->tail].jump.dst = mu_ctx.cmdsnum;\n\t}\n}\n\n\nvoid\nmu_set_focus(mu_Id id)\n{\n\tmu_ctx.focus = id;\n\tmu_ctx.updated_focus = 1;\n}\n\n/* 32bit fnv-1a hash */\n#define HASH_INITIAL 2166136261U\n\nstatic void\nhash(mu_Id *hash, const void *data, int size)\n{\n\tconst unsigned char *p = data;\n\twhile (size--) {\n\t\t*hash = (*hash ^ *p++) * 16777619;\n\t}\n}\n\n\nmu_Id\nmu_get_id(const void *data, int size)\n{\n\tint idx = mu_ctx.idsnum;\n\tmu_Id res = (idx > 0) ? mu_ctx.ids[idx - 1] : HASH_INITIAL;\n\thash(&res, data, size);\n\tmu_ctx.last_id = res;\n\treturn res;\n}\n\n\nvoid\nmu_push_id(const void *data, int size)\n{\n\tbuffer_grow(&mu_ctx.ids, sizeof(*mu_ctx.ids), &mu_ctx.idsmax, mu_ctx.idsnum);\n\tmu_ctx.ids[mu_ctx.idsnum++] = mu_get_id(data, size);\n}\n\nvoid\nmu_pop_id(void)\n{\n\tmu_ctx.idsnum--;\n}\n\nvoid\nmu_push_clip_rect(mu_Rect rect)\n{\n\tmu_Rect last = mu_get_clip_rect();\n\tbuffer_grow(&mu_ctx.clip, sizeof(*mu_ctx.clip), &mu_ctx.clipmax, mu_ctx.clipnum);\n\tmu_ctx.clip[mu_ctx.clipnum++] = clip_rect(rect, last);\n}\n\n\nvoid\nmu_pop_clip_rect(void)\n{\n\tmu_ctx.clipnum--;\n}\n\n\nmu_Rect\nmu_get_clip_rect(void)\n{\n\tassert(mu_ctx.clipnum > 0);\n\treturn mu_ctx.clip[mu_ctx.clipnum - 1];\n}\n\n\nint\nmu_check_clip(mu_Rect r)\n{\n\tmu_Rect cr = mu_get_clip_rect();\n\tif (r.x > cr.x + cr.w || r.x + r.w < cr.x || r.y > cr.y + cr.h || r.y + r.h < cr.y)\n\t\treturn MU_CLIP_ALL;\n\tif (r.x >= cr.x && r.x + r.w <= cr.x + cr.w && r.y >= cr.y && r.y + r.h <= cr.y + cr.h)\n\t\treturn MU_CLIP_NONE;\n\treturn MU_CLIP_PART;\n}\n\n\nstatic void\npush_layout(mu_Rect body, Point scroll)\n{\n\tmu_Layout layout;\n\tint width = 0;\n\tmemset(&layout, 0, sizeof(mu_Layout));\n\tlayout.body = mu_rect(body.x - scroll.x, body.y - scroll.y, body.w, body.h);\n\tlayout.max = Pt(-0x1000000, -0x1000000);\n\tbuffer_grow(&mu_ctx.layouts, sizeof(*mu_ctx.layouts), &mu_ctx.layoutsmax, mu_ctx.layoutsnum);\n\tmu_ctx.layouts[mu_ctx.layoutsnum++] = layout;\n\tmu_layout_row(1, &width, 0);\n}\n\nstatic mu_Layout *\nget_layout(void)\n{\n\treturn &mu_ctx.layouts[mu_ctx.layoutsnum - 1];\n}\n\n\nstatic void\npush_container(mu_Container *cnt)\n{\n\tbuffer_grow(&mu_ctx.cnt, sizeof(*mu_ctx.cnt), &mu_ctx.cntmax, mu_ctx.cntnum);\n\tmu_ctx.cnt[mu_ctx.cntnum++] = cnt;\n\tmu_push_id(&cnt, sizeof(mu_Container*));\n}\n\n\nstatic void\npop_container(void)\n{\n\tmu_Container *cnt = mu_get_container();\n\tmu_Layout *layout = get_layout();\n\tcnt->content_size.x = layout->max.x - layout->body.x;\n\tcnt->content_size.y = layout->max.y - layout->body.y;\n\tmu_ctx.cntnum--;\n\tmu_ctx.layoutsnum--;\n\tmu_pop_id();\n}\n\n\nmu_Container *\nmu_get_container(void)\n{\n\tassert(mu_ctx.cntnum > 0);\n\treturn mu_ctx.cnt[mu_ctx.cntnum - 1];\n}\n\n\nvoid\nmu_init_window(mu_Container *cnt, int opt)\n{\n\tmemset(cnt, 0, sizeof(*cnt));\n\tcnt->inited = 1;\n\tcnt->open = opt & MU_OPT_CLOSED ? 0 : 1;\n\tcnt->rect = mu_rect(100, 100, 300, 300);\n\tmu_bring_to_front(cnt);\n}\n\n\nvoid\nmu_bring_to_front(mu_Container *cnt)\n{\n\tcnt->zindex = ++mu_ctx.last_zindex;\n}\n\n\n/*============================================================================\n** input handlers\n**============================================================================*/\n\nvoid\nmu_input_mousemove(int x, int y)\n{\n\tmu_ctx.mouse_pos = Pt(x, y);\n}\n\n\nvoid\nmu_input_mousedown(int x, int y, int btn)\n{\n\tmu_input_mousemove(x, y);\n\tmu_ctx.mouse_down |= btn;\n\tmu_ctx.mouse_pressed |= btn;\n}\n\n\nvoid\nmu_input_mouseup(int x, int y, int btn)\n{\n\tmu_input_mousemove(x, y);\n\tmu_ctx.mouse_down &= ~btn;\n}\n\n\nvoid\nmu_input_scroll(int x, int y)\n{\n\tmu_ctx.scroll_delta.x += x;\n\tmu_ctx.scroll_delta.y += y;\n}\n\n\nvoid\nmu_input_keydown(int key)\n{\n\tmu_ctx.key_pressed |= key;\n\tmu_ctx.key_down |= key;\n}\n\n\nvoid\nmu_input_keyup(int key)\n{\n\tmu_ctx.key_down &= ~key;\n}\n\n\nvoid\nmu_input_text(const char *text)\n{\n\tint len = strlen(mu_ctx.text_input);\n\tint size = strlen(text) + 1;\n\tassert(len + size <= (int) sizeof(mu_ctx.text_input));\n\tmemcpy(mu_ctx.text_input + len, text, size);\n}\n\n/*============================================================================\n** commandlist\n**============================================================================*/\n\nmu_Command *\nmu_push_command(int type)\n{\n\tmu_Command *cmd;\n\n\tbuffer_grow(&mu_ctx.cmds, sizeof(mu_Command), &mu_ctx.cmdsmax, mu_ctx.cmdsnum);\n\tcmd = &mu_ctx.cmds[mu_ctx.cmdsnum++];\n\tmemset(cmd, 0, sizeof(*cmd));\n\tcmd->type = type;\n\n\treturn cmd;\n}\n\nstatic int\npush_jump(int dst)\n{\n\tmu_Command *cmd;\n\tcmd = mu_push_command(MU_COMMAND_JUMP);\n\tcmd->jump.dst = dst;\n\treturn mu_ctx.cmdsnum-1;\n}\n\nvoid\nmu_set_clip(mu_Rect rect)\n{\n\tmu_Command *cmd;\n\tcmd = mu_push_command(MU_COMMAND_CLIP);\n\tcmd->clip.rect = rect;\n}\n\nvoid\nmu_draw_rect(mu_Rect rect, Image *color)\n{\n\tmu_Command *cmd;\n\tmu_Rect clipped;\n\tclipped = clip_rect(rect, mu_get_clip_rect());\n\tif (rect.w > 0 && rect.h > 0) {\n\t\tcmd = mu_push_command(MU_COMMAND_RECT);\n\t\tcmd->rect.rect = clipped;\n\t\tcmd->rect.position = subpt(Pt(clipped.x, clipped.y), Pt(rect.x, rect.y));\n\t\tcmd->rect.color = color;\n\t}\n}\n\nvoid\nmu_draw_box(mu_Rect rect, Image *color)\n{\n\tmu_draw_rect(mu_rect(rect.x + 1, rect.y, rect.w - 2, 1), color);\n\tmu_draw_rect(mu_rect(rect.x+1, rect.y + rect.h-1, rect.w-2, 1), color);\n\tmu_draw_rect(mu_rect(rect.x, rect.y, 1, rect.h), color);\n\tmu_draw_rect(mu_rect(rect.x + rect.w - 1, rect.y, 1, rect.h), color);\n}\n\n\nvoid\nmu_draw_text(Font *font, const char *s, int len, Point pos, Image *color)\n{\n\tmu_Command *cmd;\n\tmu_Rect rect;\n\tint clipped;\n\n\tif (len < 0)\n\t\tlen = strlen(s);\n\trect = mu_rect(pos.x, pos.y, text_width(font, s, len), font->height);\n\tclipped = mu_check_clip(rect);\n\n\tif (clipped == MU_CLIP_ALL )\n\t\treturn;\n\tif (clipped == MU_CLIP_PART)\n\t\tmu_set_clip(mu_get_clip_rect());\n\n\tif (mu_ctx.strmax <= mu_ctx.strnum+len+1) {\n\t\tmu_ctx.strmax = MAX(mu_ctx.strmax, mu_ctx.strnum+len+1) * 2;\n\t\tif ((mu_ctx.str = realloc(mu_ctx.str, mu_ctx.strmax)) == nil)\n\t\t\tsysfatal(\"not enough memory for %d chars\", mu_ctx.strmax);\n\t}\n\tcmd = mu_push_command(MU_COMMAND_TEXT);\n\tcmd->text.s = mu_ctx.strnum;\n\tmemmove(mu_ctx.str+mu_ctx.strnum, s, len);\n\tmu_ctx.strnum += len;\n\tmu_ctx.str[mu_ctx.strnum++] = 0;\n\tcmd->text.pos = pos;\n\tcmd->text.color = color;\n\tcmd->text.font = font;\n\n\t/* reset clipping if it was set */\n\tif (clipped)\n\t\tmu_set_clip(unclipped_rect);\n}\n\n\nvoid\nmu_draw_icon(int id, mu_Rect rect)\n{\n\tmu_Command *cmd;\n\t/* do clip command if the rect isn't fully contained within the cliprect */\n\tint clipped = mu_check_clip(rect);\n\tif (clipped == MU_CLIP_ALL )\n\t\treturn;\n\tif (clipped == MU_CLIP_PART)\n\t\tmu_set_clip(mu_get_clip_rect());\n\t/* do icon command */\n\tcmd = mu_push_command(MU_COMMAND_ICON);\n\tcmd->icon.id = id;\n\tcmd->icon.rect = rect;\n\t/* reset clipping if it was set */\n\tif (clipped)\n\t\tmu_set_clip(unclipped_rect);\n}\n\n\n/*============================================================================\n** layout\n**============================================================================*/\n\nenum\n{\n\tRELATIVE = 1,\n\tABSOLUTE,\n};\n\n\nvoid\nmu_layout_begin_column(void)\n{\n\tpush_layout(mu_layout_next(), ZP);\n}\n\n\nvoid\nmu_layout_end_column(void)\n{\n\tmu_Layout *a, *b;\n\tb = get_layout();\n\tmu_ctx.layoutsnum--;\n\t/* inherit position/next_row/max from child layout if they are greater */\n\ta = get_layout();\n\ta->position.x = MAX(a->position.x, b->position.x + b->body.x - a->body.x);\n\ta->next_row = MAX(a->next_row, b->next_row + b->body.y - a->body.y);\n\ta->max.x = MAX(a->max.x, b->max.x);\n\ta->max.y = MAX(a->max.y, b->max.y);\n}\n\n\nvoid\nmu_layout_row(int items, const int *widths, int height)\n{\n\tmu_Layout *layout = get_layout();\n\tif (widths) {\n\t\tassert(items <= MU_MAX_WIDTHS);\n\t\tmemcpy(layout->widths, widths, items * sizeof(widths[0]));\n\t}\n\tlayout->items = items;\n\tlayout->position = Pt(layout->indent, layout->next_row);\n\tlayout->size.y = height;\n\tlayout->row_index = 0;\n}\n\n\nvoid\nmu_layout_width(int width)\n{\n\tget_layout()->size.x = width;\n}\n\n\nvoid\nmu_layout_height(int height)\n{\n\tget_layout()->size.y = height;\n}\n\n\nvoid\nmu_layout_set_next(mu_Rect r, int relative)\n{\n\tmu_Layout *layout = get_layout();\n\tlayout->next = r;\n\tlayout->next_type = relative ? RELATIVE : ABSOLUTE;\n}\n\n\nmu_Rect\nmu_layout_next(void)\n{\n\tmu_Layout *layout = get_layout();\n\tmu_Rect res;\n\n\tif (layout->next_type) {\n\t\t/* handle rect set by `mu_layout_set_next` */\n\t\tint type = layout->next_type;\n\t\tlayout->next_type = 0;\n\t\tres = layout->next;\n\t\tif (type == ABSOLUTE) {\n\t\t\tmu_ctx.last_rect = res;\n\t\t\treturn res;\n\t\t}\n\n\t} else {\n\t\t/* handle next row */\n\t\tif (layout->row_index == layout->items)\n\t\t\tmu_layout_row(layout->items, nil, layout->size.y);\n\n\t\t/* position */\n\t\tres.x = layout->position.x;\n\t\tres.y = layout->position.y;\n\n\t\t/* size */\n\t\tres.w = layout->items > -1 ? layout->widths[layout->row_index] : layout->size.x;\n\t\tres.h = layout->size.y;\n\t\tif (res.w == 0)\n\t\t\tres.w = mu_style.size.x + mu_style.padding * 2;\n\t\tif (res.h == 0)\n\t\t\tres.h = mu_style.size.y + mu_style.padding * 2;\n\t\tif (res.w <\t0)\n\t\t\tres.w += layout->body.w - res.x + 1;\n\t\tif (res.h <\t0)\n\t\t\tres.h += layout->body.h - res.y + 1;\n\n\t\tlayout->row_index++;\n\t}\n\n\t/* update position */\n\tlayout->position.x += res.w + mu_style.spacing;\n\tlayout->next_row = MAX(layout->next_row, res.y + res.h + mu_style.spacing);\n\n\t/* apply body offset */\n\tres.x += layout->body.x;\n\tres.y += layout->body.y;\n\n\t/* update max position */\n\tlayout->max.x = MAX(layout->max.x, res.x + res.w);\n\tlayout->max.y = MAX(layout->max.y, res.y + res.h);\n\n\tmu_ctx.last_rect = res;\n\treturn res;\n}\n\n\n/*============================================================================\n** controls\n**============================================================================*/\n\nstatic int\nin_hover_root(void)\n{\n\tint i = mu_ctx.cntnum;\n\twhile (i--) {\n\t\tif (mu_ctx.cnt[i] == mu_ctx.last_hover_root)\n\t\t\treturn 1;\n\t\t/* only root containers have their `head` field set; stop searching if we've\n\t\t** reached the current root container */\n\t\tif (mu_ctx.cnt[i]->head >= 0)\n\t\t\tbreak;\n\t}\n\treturn 0;\n}\n\n\nvoid\nmu_draw_control_frame(mu_Id id, mu_Rect rect, int colorid, int opt)\n{\n\tif (opt & MU_OPT_NOFRAME)\n\t\treturn;\n\tcolorid += (mu_ctx.focus == id) ? 2 : (mu_ctx.hover == id) ? 1 : 0;\n\tdraw_frame(rect, colorid);\n}\n\n\nvoid\nmu_draw_control_text(const char *str, mu_Rect rect, int colorid, int opt)\n{\n\tPoint pos;\n\tFont *font = mu_style.font;\n\tint tw = text_width(font, str, -1);\n\tmu_push_clip_rect(rect);\n\tpos.y = rect.y + (rect.h - font->height) / 2;\n\tif (opt & MU_OPT_ALIGNCENTER)\n\t\tpos.x = rect.x + (rect.w - tw) / 2;\n\telse if (opt & MU_OPT_ALIGNRIGHT)\n\t\tpos.x = rect.x + rect.w - tw - mu_style.padding;\n\telse\n\t\tpos.x = rect.x + mu_style.padding;\n\n\tmu_draw_text(font, str, -1, pos, mu_style.colors[colorid]);\n\tmu_pop_clip_rect();\n}\n\n\nint\nmu_mouse_over(mu_Rect rect)\n{\n\treturn rect_overlaps_vec2(rect, mu_ctx.mouse_pos) &&\n\t\trect_overlaps_vec2(mu_get_clip_rect(), mu_ctx.mouse_pos) &&\n\t\tin_hover_root();\n}\n\n\nvoid\nmu_update_control(mu_Id id, mu_Rect rect, int opt)\n{\n\tint mouseover = mu_mouse_over(rect);\n\n\tif (mu_ctx.focus == id)\n\t\tmu_ctx.updated_focus = 1;\n\tif (opt & MU_OPT_NOINTERACT)\n\t\treturn;\n\tif (mouseover && !mu_ctx.mouse_down)\n\t\tmu_ctx.hover = id;\n\n\tif (mu_ctx.focus == id) {\n\t\tif (mu_ctx.mouse_pressed && !mouseover)\n\t\t\tmu_set_focus(0);\n\t\tif (!mu_ctx.mouse_down && ~opt & MU_OPT_HOLDFOCUS)\n\t\t\tmu_set_focus(0);\n\t}\n\n\tif (mu_ctx.hover == id) {\n\t\tif (!mouseover)\n\t\t\tmu_ctx.hover = 0;\n\t\telse if (mu_ctx.mouse_pressed)\n\t\t\tmu_set_focus(id);\n\t}\n}\n\n\nvoid\nmu_text(const char *text)\n{\n\tconst char *start, *end, *p = text;\n\tint width = -1;\n\tFont *font = mu_style.font;\n\tImage *color = mu_style.colors[MU_COLOR_TEXT];\n\tmu_layout_begin_column();\n\tmu_layout_row(1, &width, font->height);\n\tdo {\n\t\tmu_Rect r = mu_layout_next();\n\t\tint w = 0;\n\t\tstart = end = p;\n\t\tdo {\n\t\t\tconst char* word = p;\n\t\t\twhile (*p && *p != ' ' && *p != '\\n')\n\t\t\t\tp++;\n\t\t\tw += text_width(font, word, p - word);\n\t\t\tif (w > r.w && end != start)\n\t\t\t\tbreak;\n\t\t\tw += text_width(font, p, 1);\n\t\t\tend = p++;\n\t\t} while (*end && *end != '\\n');\n\t\tmu_draw_text(font, start, end - start, Pt(r.x, r.y), color);\n\t\tp = end + 1;\n\t} while (*end);\n\tmu_layout_end_column();\n}\n\n\nvoid\nmu_label(const char *text)\n{\n\tmu_draw_control_text(text, mu_layout_next(), MU_COLOR_TEXT, 0);\n}\n\n\nint\nmu_button_ex(const char *label, int icon, int opt) {\n\tint res = 0;\n\tmu_Id id = label ? mu_get_id(label, strlen(label)) : mu_get_id(&icon, sizeof(icon));\n\tmu_Rect r = mu_layout_next();\n\tmu_update_control(id, r, opt);\n\t/* handle click */\n\tif (mu_ctx.mouse_pressed == MU_MOUSE_LEFT && mu_ctx.focus == id)\n\t\tres |= MU_RES_SUBMIT;\n\n\t/* draw */\n\tmu_draw_control_frame(id, r, MU_COLOR_BUTTON, opt);\n\tif (label)\n\t\tmu_draw_control_text(label, r, MU_COLOR_TEXT, opt);\n\tif (icon)\n\t\tmu_draw_icon(icon, r);\n\treturn res;\n}\n\n\nint\nmu_button(const char *label)\n{\n\treturn mu_button_ex(label, 0, MU_OPT_ALIGNCENTER);\n}\n\n\nint\nmu_checkbox(int *state, const char *label)\n{\n\tint res = 0;\n\tmu_Id id = mu_get_id(&state, sizeof(state));\n\tmu_Rect r = mu_layout_next();\n\tmu_Rect box = mu_rect(r.x, r.y, r.h, r.h);\n\tmu_update_control(id, r, 0);\n\t/* handle click */\n\tif (mu_ctx.mouse_pressed == MU_MOUSE_LEFT && mu_ctx.focus == id) {\n\t\tres |= MU_RES_CHANGE;\n\t\t*state = !*state;\n\t}\n\t/* draw */\n\tmu_draw_control_frame(id, box, MU_COLOR_BASE, 0);\n\tif (*state)\n\t\tmu_draw_icon(MU_ICON_CHECK, box);\n\n\tr = mu_rect(r.x + box.w, r.y, r.w - box.w, r.h);\n\tmu_draw_control_text(label, r, MU_COLOR_TEXT, 0);\n\treturn res;\n}\n\n\nint\nmu_textbox_raw(char *buf, int bufsz, mu_Id id, mu_Rect r, int opt)\n{\n\tint res = 0;\n\tmu_update_control(id, r, opt | MU_OPT_HOLDFOCUS);\n\n\tif (mu_ctx.focus == id) {\n\t\t/* handle text input */\n\t\tint len = strlen(buf);\n\t\tint n = MIN(bufsz - len - 1, (int)strlen(mu_ctx.text_input));\n\t\tif (n > 0) {\n\t\t\tmemcpy(buf + len, mu_ctx.text_input, n);\n\t\t\tlen += n;\n\t\t\tbuf[len] = '\\0';\n\t\t\tres |= MU_RES_CHANGE;\n\t\t}\n\t\t/* handle backspace */\n\t\tif (mu_ctx.key_pressed & MU_KEY_BACKSPACE && len > 0) {\n\t\t\t/* skip utf-8 continuation bytes */\n\t\t\twhile ((buf[--len] & 0xc0) == 0x80 && len > 0);\n\t\t\tbuf[len] = '\\0';\n\t\t\tres |= MU_RES_CHANGE;\n\t\t}\n\t\tif (mu_ctx.key_pressed & MU_KEY_NACK && len > 0) {\n\t\t\tbuf[0] = '\\0';\n\t\t\tres |= MU_RES_CHANGE;\n\t\t}\n\t\t/* handle return */\n\t\tif (mu_ctx.key_pressed & MU_KEY_RETURN) {\n\t\t\tmu_set_focus(0);\n\t\t\tres |= MU_RES_SUBMIT;\n\t\t}\n\t}\n\n\t/* draw */\n\tmu_draw_control_frame(id, r, MU_COLOR_BASE, opt);\n\tif (mu_ctx.focus == id) {\n\t\tImage *color = mu_style.colors[MU_COLOR_TEXT];\n\t\tFont *font = mu_style.font;\n\t\tint textw = text_width(font, buf, -1);\n\t\tint texth = font->height;\n\t\tint ofx = r.w - mu_style.padding - textw - 1;\n\t\tint textx = r.x + MIN(ofx, mu_style.padding);\n\t\tint texty = r.y + (r.h - texth) / 2;\n\t\tmu_push_clip_rect(r);\n\t\tmu_draw_text(font, buf, -1, Pt(textx, texty), color);\n\t\tmu_draw_rect(mu_rect(textx + textw, texty, 1, texth), color);\n\t\tmu_pop_clip_rect();\n\t} else {\n\t\tmu_draw_control_text(buf, r, MU_COLOR_TEXT, opt);\n\t}\n\n\treturn res;\n}\n\n\nstatic int\nnumber_textbox(double *value, mu_Rect r, mu_Id id)\n{\n\tif (((mu_ctx.mouse_pressed == MU_MOUSE_LEFT && mu_ctx.key_down & MU_KEY_SHIFT) || mu_ctx.mouse_pressed == MU_MOUSE_RIGHT) && mu_ctx.hover == id) {\n\t\tmu_ctx.number_editing = id;\n\t\tsprint(mu_ctx.number_buf, MU_REAL_FMT, *value);\n\t}\n\tif (mu_ctx.number_editing == id) {\n\t\tint res = mu_textbox_raw(mu_ctx.number_buf, sizeof(mu_ctx.number_buf), id, r, 0);\n\t\tif (res & MU_RES_SUBMIT || mu_ctx.focus != id) {\n\t\t\t*value = strtod(mu_ctx.number_buf, nil);\n\t\t\tmu_ctx.number_editing = 0;\n\t\t} else {\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\n\nint\nmu_textbox_ex(char *buf, int bufsz, int opt)\n{\n\tmu_Id id = mu_get_id(&buf, sizeof(buf));\n\tmu_Rect r = mu_layout_next();\n\treturn mu_textbox_raw(buf, bufsz, id, r, opt);\n}\n\n\nint\nmu_textbox(char *buf, int bufsz)\n{\n\treturn mu_textbox_ex(buf, bufsz, 0);\n}\n\n\nint\nmu_slider_ex(double *value, double low, double high, double step, const char *fmt, int opt)\n{\n\tchar buf[MU_MAX_FMT + 1];\n\tmu_Rect thumb;\n\tint w, res = 0;\n\tdouble normalized, last = *value, v = last;\n\tmu_Id id = mu_get_id(&value, sizeof(value));\n\tmu_Rect base = mu_layout_next();\n\n\t/* handle text input mode */\n\tif (number_textbox(&v, base, id))\n\t\treturn res;\n\n\t/* handle normal mode */\n\tmu_update_control(id, base, opt);\n\n\t/* handle input */\n\tif (mu_ctx.focus == id) {\n\t\tif (mu_ctx.mouse_down == MU_MOUSE_LEFT)\n\t\t\tv = low + ((double)(mu_ctx.mouse_pos.x - base.x) / base.w) * (high - low);\n\t} else if (mu_ctx.hover == id) {\n\t\tif ((mu_ctx.key_pressed & (MU_KEY_LEFT | MU_KEY_RIGHT)) == MU_KEY_LEFT) {\n\t\t\tv -= step ? step : 1;\n\t\t\tif (v < low)\n\t\t\t\tv = low;\n\t\t} else if ((mu_ctx.key_pressed & (MU_KEY_LEFT | MU_KEY_RIGHT)) == MU_KEY_RIGHT) {\n\t\t\tv += step ? step : 1;\n\t\t\tif (v > high)\n\t\t\t\tv = high;\n\t\t}\n\t}\n\n\tif (step)\n\t\tv = ((long)((v + (v > 0 ? step/2 : (-step/2))) / step)) * step;\n\t/* clamp and store value, update res */\n\t*value = v = CLAMP(v, low, high);\n\tif (last != v)\n\t\tres |= MU_RES_CHANGE;\n\n\t/* draw base */\n\tmu_draw_control_frame(id, base, MU_COLOR_BASE, opt);\n\t/* draw thumb */\n\tw = mu_style.thumb_size;\n\tnormalized = (v - low) / (high - low);\n\tthumb = mu_rect(base.x + normalized * (base.w - w), base.y, w, base.h);\n\tmu_draw_control_frame(id, thumb, MU_COLOR_BUTTON, opt);\n\t/* draw text\t*/\n\tsprint(buf, fmt, v);\n\tmu_draw_control_text(buf, base, MU_COLOR_TEXT, opt);\n\n\treturn res;\n}\n\n\nint\nmu_slider(double *value, double low, double high)\n{\n\treturn mu_slider_ex(value, low, high, 0, MU_SLIDER_FMT, MU_OPT_ALIGNCENTER);\n}\n\n\nint\nmu_number_ex(double *value, double step, const char *fmt, int opt)\n{\n\tchar buf[MU_MAX_FMT + 1];\n\tint res = 0;\n\tmu_Id id = mu_get_id(&value, sizeof(value));\n\tmu_Rect base = mu_layout_next();\n\tdouble last = *value;\n\n\t/* handle text input mode */\n\tif (number_textbox(value, base, id))\n\t\treturn res;\n\n\t/* handle normal mode */\n\tmu_update_control(id, base, opt);\n\n\t/* handle input */\n\tif (mu_ctx.focus == id && mu_ctx.mouse_down == MU_MOUSE_LEFT)\n\t\t*value += mu_ctx.mouse_delta.x * step;\n\n\t/* set flag if value changed */\n\tif (*value != last)\n\t\tres |= MU_RES_CHANGE;\n\n\t/* draw base */\n\tmu_draw_control_frame(id, base, MU_COLOR_BASE, opt);\n\t/* draw text\t*/\n\tsprint(buf, fmt, *value);\n\tmu_draw_control_text(buf, base, MU_COLOR_TEXT, opt);\n\n\treturn res;\n}\n\n\nint\nmu_number(double *value, double step)\n{\n\treturn mu_number_ex(value, step, MU_SLIDER_FMT, MU_OPT_ALIGNCENTER);\n}\n\n\nstatic int\nheader(int *state, const char *label, int istreenode)\n{\n\tmu_Rect r;\n\tmu_Id id;\n\tint width = -1;\n\tmu_layout_row(1, &width, 0);\n\tr = mu_layout_next();\n\tid = mu_get_id(&state, sizeof(state));\n\tmu_update_control(id, r, 0);\n\t/* handle click */\n\tif (mu_ctx.mouse_pressed == MU_MOUSE_LEFT && mu_ctx.focus == id)\n\t\t*state = !(*state);\n\n\t/* draw */\n\tif (istreenode) {\n\t\tif (mu_ctx.hover == id)\n\t\t\tdraw_frame(r, MU_COLOR_BUTTONHOVER);\n\t} else {\n\t\tmu_draw_control_frame(id, r, MU_COLOR_BUTTON, 0);\n\t}\n\tmu_draw_icon(\n\t\t*state ? MU_ICON_EXPANDED : MU_ICON_COLLAPSED,\n\t\tmu_rect(r.x, r.y, r.h, r.h)\n\t);\n\tr.x += r.h - mu_style.padding;\n\tr.w -= r.h - mu_style.padding;\n\tmu_draw_control_text(label, r, MU_COLOR_TEXT, 0);\n\treturn *state ? MU_RES_ACTIVE : 0;\n}\n\n\nint\nmu_header(int *state, const char *label)\n{\n\treturn header(state, label, 0);\n}\n\n\nint\nmu_begin_treenode(int *state, const char *label)\n{\n\tint res = header(state, label, 1);\n\tif (res & MU_RES_ACTIVE) {\n\t\tget_layout()->indent += mu_style.indent;\n\t\tmu_push_id(&state, sizeof(void*));\n\t}\n\treturn res;\n}\n\n\nvoid\nmu_end_treenode(void)\n{\n\tget_layout()->indent -= mu_style.indent;\n\tmu_pop_id();\n}\n\nstatic void\nscrollbar(mu_Container *cnt, mu_Rect *b, Point cs, int v)\n{\n\t/* only add scrollbar if content size is larger than body */\n\tint maxscroll = v ? cs.y - b->h : cs.x - b->w;\n\n\tif (maxscroll > 0 && (v ? b->h : b->x) > 0) {\n\t\tmu_Rect base, thumb;\n\t\tmu_Id id = mu_get_id(v ? \"!scrollbary\" : \"!scrollbarx\", 11);\n\n\t\t/* get sizing / positioning */\n\t\tbase = *b;\n\t\tif (v) {\n\t\t\tbase.x = b->x + b->w;\n\t\t\tbase.w = mu_style.scrollbar_size;\n\t\t} else {\n\t\t\tbase.y = b->y + b->h;\n\t\t\tbase.h = mu_style.scrollbar_size;\n\t\t}\n\n\t\t/* handle input */\n\t\tmu_update_control(id, base, 0);\n\t\tif (mu_ctx.focus == id && mu_ctx.mouse_down == MU_MOUSE_LEFT) {\n\t\t\tif (v)\n\t\t\t\tcnt->scroll.y += mu_ctx.mouse_delta.y * cs.y / base.h;\n\t\t\telse\n\t\t\t\tcnt->scroll.x += mu_ctx.mouse_delta.x * cs.x / base.w;\n\t\t}\n\t\t/* clamp scroll to limits */\n\t\tif (v)\n\t\t\tcnt->scroll.y = CLAMP(cnt->scroll.y, 0, maxscroll);\n\t\telse\n\t\t\tcnt->scroll.x = CLAMP(cnt->scroll.x, 0, maxscroll);\n\n\t\t/* draw base and thumb */\n\t\tdraw_frame(base, MU_COLOR_SCROLLBASE);\n\t\tthumb = base;\n\t\tif (v) {\n\t\t\tthumb.h = MAX(mu_style.thumb_size, base.h * b->h / cs.y);\n\t\t\tthumb.y += cnt->scroll.y * (base.h - thumb.h) / maxscroll;\n\t\t} else {\n\t\t\tthumb.w = MAX(mu_style.thumb_size, base.w * b->w / cs.x);\n\t\t\tthumb.x += cnt->scroll.x * (base.w - thumb.w) / maxscroll;\n\t\t}\n\t\tdraw_frame(thumb, MU_COLOR_SCROLLTHUMB);\n\n\t\t/* set this as the scroll_target (will get scrolled on mousewheel) */\n\t\t/* if the mouse is over it */\n\t\tif (mu_mouse_over(*b))\n\t\t\tmu_ctx.scroll_target = cnt;\n\t} else if (v) {\n\t\tcnt->scroll.y = 0;\n\t} else {\n\t\tcnt->scroll.x = 0;\n\t}\n}\n\nstatic void\nscrollbars(mu_Container *cnt, mu_Rect *body)\n{\n\tint sz = mu_style.scrollbar_size;\n\tPoint cs = cnt->content_size;\n\tcs.x += mu_style.padding * 2;\n\tcs.y += mu_style.padding * 2;\n\tmu_push_clip_rect(*body);\n\t/* resize body to make room for scrollbars */\n\tif (cs.y > cnt->body.h)\n\t\tbody->w -= sz;\n\tif (cs.x > cnt->body.w)\n\t\tbody->h -= sz;\n\t/* to create a horizontal or vertical scrollbar almost-identical code is\n\t** used; only the references to `x|y` `w|h` need to be switched */\n\tscrollbar(cnt, body, cs, 1);\n\tscrollbar(cnt, body, cs, 0);\n\tmu_pop_clip_rect();\n}\n\nstatic void\npush_container_body(mu_Container *cnt, mu_Rect body, int opt)\n{\n\tif (~opt & MU_OPT_NOSCROLL)\n\t\tscrollbars(cnt, &body);\n\tpush_layout(expand_rect(body, -mu_style.padding), cnt->scroll);\n\tcnt->body = body;\n}\n\nstatic void\nbegin_root_container(mu_Container *cnt)\n{\n\tpush_container(cnt);\n\n\t/* push container to roots list and push head command */\n\tbuffer_grow(&mu_ctx.root, sizeof(*mu_ctx.root), &mu_ctx.rootmax, mu_ctx.rootnum);\n\tmu_ctx.root[mu_ctx.rootnum++] = cnt;\n\tcnt->head = push_jump(-1);\n\n\t/* set as hover root if the mouse is overlapping this container and it has a\n\t** higher zindex than the current hover root */\n\tif (rect_overlaps_vec2(cnt->rect, mu_ctx.mouse_pos) && (!mu_ctx.hover_root || cnt->zindex > mu_ctx.hover_root->zindex))\n\t\tmu_ctx.hover_root = cnt;\n\n\t/* clipping is reset here in case a root-container is made within\n\t** another root-containers's begin/end block; this prevents the inner\n\t** root-container being clipped to the outer */\n\tbuffer_grow(&mu_ctx.clip, sizeof(*mu_ctx.clip), &mu_ctx.clipmax, mu_ctx.clipnum);\n\tmu_ctx.clip[mu_ctx.clipnum++] = unclipped_rect;\n}\n\n\nstatic void\nend_root_container(void)\n{\n\t/* push tail 'goto' jump command and set head 'skip' command. the final steps\n\t** on initing these are done in mu_end() */\n\tmu_Container *cnt = mu_get_container();\n\tcnt->tail = push_jump(-1);\n\tmu_ctx.cmds[cnt->head].jump.dst = mu_ctx.cmdsnum;\n\t/* pop base clip rect and container */\n\tmu_pop_clip_rect();\n\tpop_container();\n}\n\n\nint\nmu_begin_window_ex(mu_Container *cnt, const char *title, int opt)\n{\n\tmu_Rect rect, body, titlerect;\n\n\tif (!cnt->inited)\n\t\tmu_init_window(cnt, opt);\n\tif (!cnt->open)\n\t\treturn 0;\n\n\tbegin_root_container(cnt);\n\trect = cnt->rect;\n\tbody = rect;\n\n\t/* draw frame */\n\tif (~opt & MU_OPT_NOFRAME)\n\t\tdraw_frame(rect, MU_COLOR_WINDOWBG);\n\n\t/* moving all windows by \"dragging\" background */\n\tif (mu_ctx.last_hover_root == nil && mu_ctx.hover_root == nil && mu_ctx.mouse_pressed == MU_MOUSE_LEFT)\n\t\tmu_ctx.moving = 1;\n\telse if (mu_ctx.mouse_down != MU_MOUSE_LEFT)\n\t\tmu_ctx.moving = 0;\n\tif (mu_ctx.moving) {\n\t\tcnt->rect.x += mu_ctx.mouse_delta.x;\n\t\tcnt->rect.y += mu_ctx.mouse_delta.y;\n\t}\n\n\t/* do title bar */\n\ttitlerect = rect;\n\ttitlerect.h = mu_style.title_height;\n\tif (~opt & MU_OPT_NOTITLE) {\n\t\tmu_Id id = mu_get_id(\"!title\", 6);\n\n\t\tdraw_frame(titlerect, MU_COLOR_TITLEBG);\n\n\t\t/* do title text */\n\t\tmu_update_control(id, titlerect, opt);\n\t\tmu_draw_control_text(title, titlerect, MU_COLOR_TITLETEXT, opt);\n\t\tif (id == mu_ctx.focus && mu_ctx.mouse_down == MU_MOUSE_LEFT) {\n\t\t\tcnt->rect.x += mu_ctx.mouse_delta.x;\n\t\t\tcnt->rect.y += mu_ctx.mouse_delta.y;\n\t\t}\n\t\tbody.y += titlerect.h;\n\t\tbody.h -= titlerect.h;\n\n\t\t/* do `close` button */\n\t\tif (~opt & MU_OPT_NOCLOSE) {\n\t\t\tmu_Id id = mu_get_id(\"!close\", 6);\n\t\t\tmu_Rect r = mu_rect(\n\t\t\t\ttitlerect.x + titlerect.w - titlerect.h,\n\t\t\t\ttitlerect.y, titlerect.h, titlerect.h\n\t\t\t);\n\t\t\ttitlerect.w -= r.w;\n\t\t\tmu_draw_icon(MU_ICON_CLOSE, r);\n\t\t\tmu_update_control(id, r, opt);\n\t\t\tif (mu_ctx.mouse_pressed == MU_MOUSE_LEFT && id == mu_ctx.focus)\n\t\t\t\tcnt->open = 0;\n\t\t}\n\t}\n\n\tpush_container_body(cnt, body, opt);\n\n\t/* do `resize` handle */\n\tif (~opt & MU_OPT_NORESIZE) {\n\t\tint sz = mu_style.scrollbar_size;\n\t\tmu_Id id = mu_get_id(\"!resize\", 7);\n\t\tmu_Rect r = mu_rect(rect.x + rect.w - sz, rect.y + rect.h - sz, sz, sz);\n\t\tmu_update_control(id, r, opt);\n\t\tmu_draw_icon(MU_ICON_RESIZE, r);\n\t\tif (id == mu_ctx.focus && mu_ctx.mouse_down == MU_MOUSE_LEFT) {\n\t\t\tcnt->rect.w = MAX(96, cnt->rect.w + mu_ctx.mouse_delta.x);\n\t\t\tcnt->rect.h = MAX(64, cnt->rect.h + mu_ctx.mouse_delta.y);\n\t\t}\n\t}\n\n\t/* resize to content size */\n\tif (opt & MU_OPT_AUTOSIZE) {\n\t\tmu_Rect r = get_layout()->body;\n\t\tif (opt & MU_OPT_AUTOSIZE_W)\n\t\t\tcnt->rect.w = cnt->content_size.x + (cnt->rect.w - r.w);\n\t\tif (opt & MU_OPT_AUTOSIZE_H)\n\t\t\tcnt->rect.h = cnt->content_size.y + (cnt->rect.h - r.h);\n\t}\n\n\t/* close if this is a popup window and elsewhere was clicked */\n\tif (opt & MU_OPT_POPUP && mu_ctx.mouse_pressed && mu_ctx.last_hover_root != cnt)\n\t\tcnt->open = 0;\n\n\tmu_push_clip_rect(cnt->body);\n\treturn MU_RES_ACTIVE;\n}\n\n\nint\nmu_begin_window(mu_Container *cnt, const char *title)\n{\n\treturn mu_begin_window_ex(cnt, title, 0);\n}\n\n\nvoid\nmu_end_window(void)\n{\n\tmu_pop_clip_rect();\n\tend_root_container();\n}\n\n\nvoid\nmu_open_popup(mu_Container *cnt)\n{\n\t/* set as hover root so popup isn't closed in begin_window_ex() */\n\tmu_ctx.last_hover_root = mu_ctx.hover_root = cnt;\n\t/* init container if not inited */\n\tif (!cnt->inited)\n\t\tmu_init_window(cnt, 0);\n\t/* position at mouse cursor, open and bring-to-front */\n\tcnt->rect = mu_rect(mu_ctx.mouse_pos.x, mu_ctx.mouse_pos.y, 0, 0);\n\tcnt->open = 1;\n\tmu_bring_to_front(cnt);\n}\n\n\nint\nmu_begin_popup(mu_Container *cnt)\n{\n\treturn mu_begin_window_ex(cnt, \"\", MU_OPT_POPUP | MU_OPT_AUTOSIZE | MU_OPT_NORESIZE | MU_OPT_NOSCROLL | MU_OPT_NOTITLE | MU_OPT_CLOSED);\n}\n\n\nvoid\nmu_end_popup(void)\n{\n\tmu_end_window();\n}\n\n\nvoid\nmu_begin_panel_ex(mu_Container *cnt, int opt)\n{\n\tcnt->rect = mu_layout_next();\n\tif (~opt & MU_OPT_NOFRAME)\n\t\tdraw_frame(cnt->rect, MU_COLOR_PANELBG);\n\n\tpush_container(cnt);\n\tpush_container_body(cnt, cnt->rect, opt);\n\tmu_push_clip_rect(cnt->body);\n}\n\n\nvoid\nmu_begin_panel(mu_Container *cnt)\n{\n\tmu_begin_panel_ex(cnt, 0);\n}\n\n\nvoid\nmu_end_panel(void)\n{\n\tmu_pop_clip_rect();\n\tpop_container();\n}\n\nint\nmu_render(int force)\n{\n\tmu_Command *cmd;\n\tmu_Rect r, iconr;\n\n\tif (force || !eqrect(mu_ctx.screen, screen->r) != 0)\n\t\tmu_ctx.screen = screen->r;\n\telse if (mu_ctx.oldcmdsnum == mu_ctx.cmdsnum && memcmp(mu_ctx.oldcmds, mu_ctx.cmds, mu_ctx.cmdsnum*sizeof(mu_Command)) == 0)\n\t\tif (mu_ctx.oldstrnum == mu_ctx.strnum && memcmp(mu_ctx.oldstr, mu_ctx.str, mu_ctx.strnum) == 0)\n\t\t\treturn 0;\n\n\tif (mu_ctx.oldcmdsmax != mu_ctx.cmdsmax && (mu_ctx.oldcmds = realloc(mu_ctx.oldcmds, mu_ctx.cmdsmax*sizeof(mu_Command))) == nil)\n\t\tsysfatal(\"couldn't allocate memory for old cmds\");\n\tmu_ctx.oldcmdsmax = mu_ctx.cmdsmax;\n\tmu_ctx.oldcmdsnum = mu_ctx.cmdsnum;\n\tmemmove(mu_ctx.oldcmds, mu_ctx.cmds, mu_ctx.cmdsnum*sizeof(mu_Command));\n\n\tif (mu_ctx.oldstrmax != mu_ctx.strmax && (mu_ctx.oldstr = realloc(mu_ctx.oldstr, mu_ctx.strmax)) == nil)\n\t\tsysfatal(\"couldn't allocate memory for old strings\");\n\tmu_ctx.oldstrmax = mu_ctx.strmax;\n\tmu_ctx.oldstrnum = mu_ctx.strnum;\n\tmemmove(mu_ctx.oldstr, mu_ctx.str, mu_ctx.strnum);\n\n\tdraw(screen, screen->r, mu_style.colors[MU_COLOR_BG], nil, ZP);\n\n\tfor (cmd = mu_ctx.cmds; cmd < mu_ctx.cmds + mu_ctx.cmdsnum;) {\n\t\tswitch (cmd->type) {\n\t\tcase MU_COMMAND_TEXT:\n\t\t\tif (cmd->text.color != nil)\n\t\t\t\tstring(screen, addpt(screen->r.min, cmd->text.pos), cmd->text.color, ZP, mu_style.font, mu_ctx.str+cmd->text.s);\n\t\t\tbreak;\n\n\t\tcase MU_COMMAND_RECT:\n\t\t\tif (cmd->rect.color != nil)\n\t\t\t\tdraw(screen, screenrect(cmd->rect.rect), cmd->rect.color, nil, cmd->rect.position);\n\t\t\tbreak;\n\n\t\tcase MU_COMMAND_ICON:\n\t\t\tr = cmd->icon.rect;\n\t\t\ticonr = atlasicons[cmd->icon.id];\n\t\t\tr.x += (r.w - iconr.w) / 2;\n\t\t\tr.y += (r.h - iconr.h) / 2;\n\t\t\tr.w = iconr.w;\n\t\t\tr.h = iconr.h;\n\t\t\tdraw(screen, screenrect(r), atlasimage, nil, Pt(iconr.x, iconr.y));\n\t\t\tbreak;\n\n\t\tcase MU_COMMAND_CLIP:\n\t\t\treplclipr(screen, 0, screenrect(cmd->clip.rect));\n\t\t\tbreak;\n\n\t\tcase MU_COMMAND_JUMP:\n\t\t\tif (cmd->jump.dst < 0)\n\t\t\t\treturn 1;\n\t\t\tcmd = &mu_ctx.cmds[cmd->jump.dst];\n\t\t\tcontinue;\n\t\t}\n\n\t\tcmd++;\n\t}\n\n\treturn 1;\n}\n", "source": "neindaw/microui/microui.c", "file_type": "c"}
{"text": "#include <u.h>\n#include <libc.h>\n#include <draw.h>\n#include <microui.h>\n\nstatic char logbuf[64000];\nstatic int logbuf_updated = 0;\n\nstatic void\nwrite_log(const char *text)\n{\n\tif (logbuf[0])\n\t\tstrcat(logbuf, \"\\n\");\n\tstrcat(logbuf, text);\n\tlogbuf_updated = 1;\n}\n\n#define text_width(s) (stringwidth(mu_style.font, s) + 6)\n#define text_height() mu_style.font->height\n#define max(a, b) ((a) > (b) ? (a) : (b))\n\nstatic void\ntest_window(void)\n{\n\tstatic mu_Container window;\n\n\t/* init window manually so we can set its position and size */\n\tif (!window.inited) {\n\t\tmu_init_window(&window, 0);\n\t\twindow.rect = mu_rect(40, 40, 320, 500);\n\t}\n\n\t/* limit window to minimum size */\n\twindow.rect.w = max(window.rect.w, 240);\n\twindow.rect.h = max(window.rect.h, 300);\n\n\t/* do window */\n\tif (mu_begin_window(&window, \"Demo Window\")) {\n\n\t\t/* window info */\n\t\tstatic int show_info = 0;\n\t\tif (mu_header(&show_info, \"Window Info\")) {\n\t\t\tchar buf[64];\n\t\t\tconst int widths[] = { text_width(\"Position:\"), -1 };\n\t\t\tmu_layout_row(2, widths, 0);\n\t\t\tmu_label(\"Position:\");\n\t\t\tsprint(buf, \"%d, %d\", window.rect.x, window.rect.y); mu_label(buf);\n\t\t\tmu_label(\"Size:\");\n\t\t\tsprint(buf, \"%d, %d\", window.rect.w, window.rect.h); mu_label(buf);\n\t\t}\n\n\t\t/* labels + buttons */\n\t\tstatic int show_buttons = 1;\n\t\tif (mu_header(&show_buttons, \"Test Buttons\")) {\n\t\t\tconst int widths[] = { text_width(\"Test buttons 2:\"), -text_width(\"Button 2\t\"), -1 };\n\t\t\tmu_layout_row(3, widths, 0);\n\t\t\tmu_label(\"Test buttons 1:\");\n\t\t\tif (mu_button(\"Button 1\")) { write_log(\"Pressed button 1\"); }\n\t\t\tif (mu_button(\"Button 2\")) { write_log(\"Pressed button 2\"); }\n\t\t\tmu_label(\"Test buttons 2:\");\n\t\t\tif (mu_button(\"Button 3\")) { write_log(\"Pressed button 3\"); }\n\t\t\tif (mu_button(\"Button 4\")) { write_log(\"Pressed button 4\"); }\n\t\t}\n\n\t\t/* tree */\n\t\tstatic int show_tree = 1;\n\t\tif (mu_header(&show_tree, \"Tree and Text\")) {\n\t\t\tint widths[] = { text_width(\"Test 1a\")+text_height()*2+text_width(\"Button 3\")+6, -1 };\n\t\t\tmu_layout_row(2, widths, 0);\n\t\t\tmu_layout_begin_column();\n\t\t\tstatic int states[8];\n\t\t\tif (mu_begin_treenode(&states[0], \"Test 1\")) {\n\t\t\t\tif (mu_begin_treenode(&states[1], \"Test 1a\")) {\n\t\t\t\t\tmu_label(\"Hello\");\n\t\t\t\t\tmu_label(\"world\");\n\t\t\t\t\tmu_end_treenode();\n\t\t\t\t}\n\t\t\t\tif (mu_begin_treenode(&states[2], \"Test 1b\")) {\n\t\t\t\t\tif (mu_button(\"Button 1\")) { write_log(\"Pressed button 1\"); }\n\t\t\t\t\tif (mu_button(\"Button 2\")) { write_log(\"Pressed button 2\"); }\n\t\t\t\t\tmu_end_treenode();\n\t\t\t\t}\n\t\t\t\tmu_end_treenode();\n\t\t\t}\n\t\t\tif (mu_begin_treenode(&states[3], \"Test 2\")) {\n\t\t\t\tint widths[2];\n\t\t\t\twidths[0] = widths[1] = text_width(\"Button 3\");\n\t\t\t\tmu_layout_row(2, widths, 0);\n\t\t\t\tif (mu_button(\"Button 3\")) { write_log(\"Pressed button 3\"); }\n\t\t\t\tif (mu_button(\"Button 4\")) { write_log(\"Pressed button 4\"); }\n\t\t\t\tif (mu_button(\"Button 5\")) { write_log(\"Pressed button 5\"); }\n\t\t\t\tif (mu_button(\"Button 6\")) { write_log(\"Pressed button 6\"); }\n\t\t\t\tmu_end_treenode();\n\t\t\t}\n\t\t\tif (mu_begin_treenode(&states[4], \"Test 3\")) {\n\t\t\t\tstatic int checks[3] = { 1, 0, 1 };\n\t\t\t\tmu_checkbox(&checks[0], \"Checkbox 1\");\n\t\t\t\tmu_checkbox(&checks[1], \"Checkbox 2\");\n\t\t\t\tmu_checkbox(&checks[2], \"Checkbox 3\");\n\t\t\t\tmu_end_treenode();\n\t\t\t}\n\t\t\tmu_layout_end_column();\n\n\t\t\tmu_layout_begin_column();\n\t\t\twidths[0] = -1;\n\t\t\tmu_layout_row(1, widths, 0);\n\t\t\tmu_text(\"Lorem ipsum dolor sit amet, consectetur adipiscing \"\n\t\t\t\t\"elit. Maecenas lacinia, sem eu lacinia molestie, mi risus faucibus \"\n\t\t\t\t\"ipsum, eu varius magna felis a nulla.\");\n\t\t\tmu_layout_end_column();\n\t\t}\n\n\t\tmu_end_window();\n\t}\n}\n\n\nstatic void\nlog_window(void)\n{\n\tstatic mu_Container window;\n\n\t/* init window manually so we can set its position and size */\n\tif (!window.inited) {\n\t\tmu_init_window(&window, 0);\n\t\twindow.rect = mu_rect(370, 40, 340, 200);\n\t}\n\n\tif (mu_begin_window(&window, \"Log Window\")) {\n\t\tint widths[] = { -1, -1 };\n\n\t\t/* output text panel */\n\t\tstatic mu_Container panel;\n\t\tmu_layout_row(1, widths, -28);\n\t\tmu_begin_panel(&panel);\n\t\tmu_layout_row(1, widths, -1);\n\t\tmu_text(logbuf);\n\t\tmu_end_panel();\n\t\tif (logbuf_updated) {\n\t\t\tpanel.scroll.y = panel.content_size.y;\n\t\t\tlogbuf_updated = 0;\n\t\t}\n\n\t\t/* input textbox + submit button */\n\t\tstatic char buf[128];\n\t\tint submitted = 0;\n\t\twidths[0] = -text_width(\"Submit\")-8;\n\t\tmu_layout_row(2, widths, -1);\n\t\tif (mu_textbox(buf, sizeof(buf)) & MU_RES_SUBMIT) {\n\t\t\tmu_set_focus(mu_ctx.last_id);\n\t\t\tsubmitted = 1;\n\t\t}\n\t\tif (mu_button(\"Submit\")) { submitted = 1; }\n\t\tif (submitted) {\n\t\t\twrite_log(buf);\n\t\t\tbuf[0] = '\\0';\n\t\t}\n\n\t\tmu_end_window();\n\t}\n}\n\n\nstatic int\nuint8_slider(unsigned char *value, int low, int high)\n{\n\tstatic double tmp;\n\tmu_push_id(&value, sizeof(value));\n\ttmp = *value;\n\tint res = mu_slider_ex(&tmp, low, high, 0, \"%.0f\", MU_OPT_ALIGNCENTER);\n\t*value = tmp;\n\tmu_pop_id();\n\treturn res;\n}\n\nstatic void\nstyle_window(void)\n{\n\tstatic mu_Container window;\n\tstatic u8int cur[MU_COLOR_MAX][4], old[MU_COLOR_MAX][4];\n\tstatic struct { const char *label; int idx; } colors[] = {\n\t\t{ \"background:\", MU_COLOR_BG },\n\t\t{ \"text:\", MU_COLOR_TEXT },\n\t\t{ \"border:\", MU_COLOR_BORDER },\n\t\t{ \"windowbg:\", MU_COLOR_WINDOWBG },\n\t\t{ \"titlebg:\", MU_COLOR_TITLEBG },\n\t\t{ \"titletext:\", MU_COLOR_TITLETEXT },\n\t\t{ \"panelbg:\", MU_COLOR_PANELBG },\n\t\t{ \"button:\", MU_COLOR_BUTTON },\n\t\t{ \"buttonhover:\", MU_COLOR_BUTTONHOVER },\n\t\t{ \"buttonfocus:\", MU_COLOR_BUTTONFOCUS },\n\t\t{ \"base:\", MU_COLOR_BASE },\n\t\t{ \"basehover:\", MU_COLOR_BASEHOVER },\n\t\t{ \"basefocus:\", MU_COLOR_BASEFOCUS },\n\t\t{ \"scrollbase:\", MU_COLOR_SCROLLBASE },\n\t\t{ \"scrollthumb:\", MU_COLOR_SCROLLTHUMB },\n\t\t{ nil }\n\t};\n\n\t/* init window manually so we can set its position and size */\n\tif (!window.inited) {\n\t\tmu_init_window(&window, 0);\n\t\twindow.rect = mu_rect(370, 250, 340, 290);\n\t\tmemmove(cur, defaultcolors, sizeof(cur));\n\t\tmemmove(old, defaultcolors, sizeof(old));\n\t}\n\n\tif (mu_begin_window(&window, \"Style Editor\")) {\n\t\tint sw = max(text_width(\"255\"), mu_get_container()->body.w * 0.14);\n\t\tconst int widths[] = { text_width(\"scrollthumb:\"), sw, sw, sw, sw, -1 };\n\t\tmu_layout_row(6, widths, 0);\n\t\tfor (int i = 0; colors[i].label; i++) {\n\t\t\tmu_label(colors[i].label);\n\t\t\tuint8_slider(&cur[i][0], 0, 255);\n\t\t\tuint8_slider(&cur[i][1], 0, 255);\n\t\t\tuint8_slider(&cur[i][2], 0, 255);\n\t\t\tuint8_slider(&cur[i][3], 0, 255);\n\t\t\tif (memcmp(cur[i], old[i], 4) != 0) {\n\t\t\t\tfreeimage(mu_style.colors[i]);\n\t\t\t\tmu_style.colors[i] = mu_color(cur[i][0], cur[i][1], cur[i][2], cur[i][3]);\n\t\t\t\tmemmove(old[i], cur[i], 4);\n\t\t\t}\n\t\t\tmu_draw_rect(mu_layout_next(), mu_style.colors[i]);\n\t\t}\n\t\tmu_end_window();\n\t}\n}\n\nvoid\nprocess_frame(void)\n{\n\tmu_begin();\n\ttest_window();\n\tlog_window();\n\tstyle_window();\n\tmu_end();\n}\n", "source": "neindaw/microui/demo/frame.c", "file_type": "c"}
{"text": "#include <u.h>\n#include <libc.h>\n#include <draw.h>\n#include <mouse.h>\n#include <keyboard.h>\n#include <thread.h>\n#include <bio.h>\n#include <microui.h>\n\nvoid process_frame(void);\n\nvoid\nthreadmain(int argc, char **argv)\n{\n\tMousectl *mctl;\n\tchar *s;\n\tBiobuf *snarf;\n\tKeyboardctl *kctl;\n\tint redraw;\n\tRune key;\n\tMouse m;\n\tAlt a[] = {\n\t\t{ nil, &m, CHANRCV },\n\t\t{ nil, nil, CHANRCV },\n\t\t{ nil, &key, CHANRCV },\n\t\t{ nil, nil,  CHANEND},\n\t};\n\tint oldbuttons, b, nkey, gotevent;\n\tchar text[5];\n\n\tUSED(argc); USED(argv);\n\n\tif (initdraw(nil, nil, \"microui demo\") < 0)\n\t\tsysfatal(\"initdraw: %r\");\n\tif ((mctl = initmouse(nil, screen)) == nil)\n\t\tsysfatal(\"initmouse: %r\");\n\tif ((kctl = initkeyboard(nil)) == nil)\n\t\tsysfatal(\"initkeyboard: %r\");\n\n\ta[0].c = mctl->c;\n\ta[1].c = mctl->resizec;\n\ta[2].c = kctl->c;\n\n\tsrand(time(0));\n\tthreadsetname(\"microui demo\");\n\n\tmu_init();\n\tmu_style.font = font;\n\tmu_style.size.y = font->height;\n\tmu_style.title_height = mu_style.size.y + 6;\n\tprocess_frame();\n\n\toldbuttons = 0;\n\tredraw = 0;\n\tfor (;;) {\n\t\tprocess_frame();\n\t\tif (mu_render(redraw))\n\t\t\tflushimage(display, 1);\n\n\t\tredraw = 0;\n\t\tgotevent = 1;\n\t\tswitch (alt(a)) {\n\t\tcase 0: /* mouse */\n\t\t\tm.xy.x -= screen->r.min.x;\n\t\t\tm.xy.y -= screen->r.min.y;\n\t\t\tmu_input_mousemove(m.xy.x, m.xy.y);\n\t\t\tif ((b = (m.buttons & 1)) != (oldbuttons & 1))\n\t\t\t\t(b ? mu_input_mousedown : mu_input_mouseup)(m.xy.x, m.xy.y, MU_MOUSE_LEFT);\n\t\t\telse if ((b = (m.buttons & 2)) != (oldbuttons & 2))\n\t\t\t\t(b ? mu_input_mousedown : mu_input_mouseup)(m.xy.x, m.xy.y, MU_MOUSE_MIDDLE);\n\t\t\telse if ((b = (m.buttons & 4)) != (oldbuttons & 4))\n\t\t\t\t(b ? mu_input_mousedown : mu_input_mouseup)(m.xy.x, m.xy.y, MU_MOUSE_RIGHT);\n\t\t\tif (m.buttons == 5 && (snarf = Bopen(\"/dev/snarf\", OREAD)) != nil) {\n\t\t\t\tif ((s = Brdstr(snarf, 0, 1)) != nil) {\n\t\t\t\t\tmu_input_text(s);\n\t\t\t\t\tfree(s);\n\t\t\t\t}\n\t\t\t\tBterm(snarf);\n\t\t\t}\n\t\t\toldbuttons = m.buttons;\n\t\t\tbreak;\n\n\t\tcase 1: /* resize */\n\t\t\tgetwindow(display, Refnone);\n\t\t\tredraw = 1;\n\t\t\tbreak;\n\n\t\tcase 2: /* keyboard */\n\t\t\tnkey = -1;\n\t\t\tswitch (key) {\n\t\t\tcase Kdel: goto end;\n\t\t\tcase Kshift: nkey = MU_KEY_SHIFT; break;\n\t\t\tcase Kbs: nkey = MU_KEY_BACKSPACE; break;\n\t\t\tcase '\\n': nkey = MU_KEY_RETURN; break;\n\t\t\tcase Knack: nkey = MU_KEY_NACK; break;\n\t\t\tcase Kleft: nkey = MU_KEY_LEFT; break;\n\t\t\tcase Kright: nkey = MU_KEY_RIGHT; break;\n\t\t\tcase Kesc: mu_set_focus(0); break;\n\t\t\tdefault:\n\t\t\t\tif (key < 0xf000 || key > 0xffff) {\n\t\t\t\t\tmemset(text, 0, sizeof(text));\n\t\t\t\t\tif (runetochar(text, &key) > 0)\n\t\t\t\t\t\tmu_input_text(text);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (nkey >= 0) {\n\t\t\t\tmu_input_keydown(nkey);\n\t\t\t\tmu_input_keyup(nkey);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tgotevent = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (gotevent)\n\t\t\tprocess_frame();\n\t}\n\nend:\n\tthreadexitsall(nil);\n}\n", "source": "neindaw/microui/demo/plan9.c", "file_type": "c"}
{"text": "</$objtype/mkfile\n\nTARG=demo\n\nOFILES=\\\n\tframe.$O\\\n\tplan9.$O\\\n\ndefault:V:\tall\n\n</sys/src/cmd/mkone\n", "source": "neindaw/microui/demo/mkfile", "file_type": "mkfile"}
{"text": "#include <u.h>\n#include <libc.h>\n#include <thread.h>\n#include \"piper.h\"\n#include \"util.h\"\n\ntypedef struct Piano Piano;\n\nstruct Piano {\n\tint freq;\n\tint gain;\n\tint gate;\n\tChannel *offc;\n\tchar path[1];\n};\n\nstatic void\ngateoff(void *aux)\n{\n\tuvlong t, n;\n\tPiano *p;\n\n\tthreadsetname(\"piper/gateoff\");\n\tp = aux;\n\tfor (;;) {\n\t\tif (recv(p->offc, &t) != 1)\n\t\t\tbreak;\nnext:\n\t\twhile (1) {\n\t\t\tn = nanosec();\n\t\t\tif (n >= t)\n\t\t\t\tbreak;\n\t\t\tn = t - n;\n\t\t\tif (n > 750000000LL)\n\t\t\t\tsleep(70);\n\t\t\telse if (n > 25000000LL)\n\t\t\t\tsleep(20);\n\t\t\telse if (n > 10000000LL)\n\t\t\t\tsleep(1);\n\t\t}\n\t\tif (nbrecv(p->offc, &t) != 0)\n\t\t\tgoto next;\n\t\tfprint(p->gate, \"0\");\n\t}\n\n\tthreadexits(nil);\n}\n\nstatic int\ncmd(void *aux, Cmd *c)\n{\n\tPiano *p;\n\tuvlong off;\n\n\tp = aux;\n\tswitch (c->type) {\n\tcase CmdNote:\n\t\toff = nanosec() + 1000000000ULL*c->note[0].dur;\n\t\tsend(p->offc, &off);\n\t\tfprint(p->gain, \"%g\", c->note[0].vel);\n\t\tfprint(p->freq, \"%g\", c->note[0].freq);\n\t\tfprint(p->gate, \"1\");\n\t\tbreak;\n\n\tcase CmdRaw:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic void *\nalloc(char *path)\n{\n\tPiano *p;\n\n\tif ((p = calloc(1, sizeof(*p) + strlen(path) + 1)) != nil) {\n\t\tp->freq = pathopen(path, \"Basic/Freq/ctl\");\n\t\tp->gain = pathopen(path, \"Basic/Gain/ctl\");\n\t\tp->gate = pathopen(path, \"Basic/Gate/ctl\");\n\t\tp->offc = chancreate(sizeof(uvlong), 10);\n\t\tstrcpy(p->path, path);\n\t\tproccreate(gateoff, p, 4096);\n\t}\n\n\treturn p;\n}\n\nSynth piano = {\n\t.name = \"Piano\",\n\t.cmd = cmd,\n\t.alloc = alloc,\n};\n", "source": "neindaw/piper/piano.c", "file_type": "c"}
{"text": "</$objtype/mkfile\n\nTARG=piper\nBIN=/$objtype/bin/daw\nCFLAGS=$CFLAGS -I..\n\nOFILES=\\\n\tay.$O\\\n\tkick.$O\\\n\tpiano.$O\\\n\tpiper.$O\\\n\tutil.$O\\\n\nHFILES=\\\n\tpiper.h\n\ndefault:V: all\n\n</sys/src/cmd/mkone\n\nutil.$O: ../util.c\n\t$CC $CFLAGS $prereq\n", "source": "neindaw/piper/mkfile", "file_type": "mkfile"}
{"text": "#include <u.h>\n#include <libc.h>\n#include <thread.h>\n#include <bio.h>\n#include \"common.h\"\n#include \"piper.h\"\n#include \"util.h\"\n\ntypedef struct Inst Inst;\ntypedef struct Group Group;\n\nstruct Inst {\n\tvoid *aux;\n\tint data;\n\tint id;\n\tint numout;\n};\n\nstruct Group {\n\tchar *path;\n\tSynth *synth;\n\tInst *inst;\n\tint numinst;\n\tint clone;\n};\n\nstatic int bpm = 120;\nstatic float bar = 2.0;\nstatic float vol = 0.25;\nstatic QLock grouplock;\nstatic Group *groups;\nstatic int numgroups;\nstatic int audio;\nstatic int record = -1;\nstatic int rate = RATE;\n\nstatic Synth *synths[] = {\n\t&ay_3_8910,\n\t&kick_drum,\n\t&piano,\n};\n\nstatic void\nusage(void)\n{\n\tprint(\"usage: %s [-m] [-r rate] [-t FILE] DIR...\\n\", argv0);\n\tthreadexitsall(\"usage\");\n}\n\nstatic Inst *\ngetinst(Group *g, int id)\n{\n\tInst *inst;\n\tvoid *aux;\n\tchar *path, *s, tmp[8];\n\tBiobuf *b;\n\tint i, n, f;\n\n\tfor (i = 0; i < g->numinst; i++) {\n\t\tif (id == g->inst[i].id)\n\t\t\treturn &g->inst[i];\n\t}\n\n\tfor (i = g->numinst; i <= id;) {\n\t\t/* first see if it already exists */\n\t\tif ((path = smprint(\"%s/%d\", g->path, i)) == nil)\n\t\t\tsysfatal(\"memory\");\n\t\tif ((f = open(path, OREAD)) >= 0)\n\t\t\tclose(f);\n\t\tfree(path);\n\n\t\tif (f < 0) {\n\t\t\t/* doesn't exist, clone */\n\t\t\tseek(g->clone, 0, 0);\n\t\t\tif ((n = read(g->clone, tmp, sizeof(tmp))) < 1)\n\t\t\t\tsysfatal(\"clone failed\");\n\t\t\ttmp[n] = 0;\n\t\t\ti = atoi(tmp);\n\t\t}\n\n\t\tif ((path = smprint(\"%s/%d/%s\", g->path, i, g->synth->name)) == nil)\n\t\t\tsysfatal(\"memory\");\n\t\tif ((aux = g->synth->alloc(path)) == nil)\n\t\t\tsysfatal(\"couldn't alloc instance: %r\");\n\t\tfree(path);\n\n\t\tif ((path = smprint(\"%s/%d/data\", g->path, i)) == nil)\n\t\t\tsysfatal(\"memory\");\n\t\tif ((f = open(path, OREAD)) < 0)\n\t\t\tsysfatal(\"couldn't open data: %r\");\n\t\tfree(path);\n\n\t\tif ((g->inst = realloc(g->inst, sizeof(Inst)*(g->numinst+1))) == nil)\n\t\t\tsysfatal(\"memory\");\n\t\tinst = &g->inst[g->numinst];\n\t\tmemset(inst, 0, sizeof(*inst));\n\t\tinst->data = f;\n\t\tinst->id = i;\n\t\tinst->aux = aux;\n\t\tg->numinst++;\n\n\t\tpath = smprint(\"%s/%d/ctl\", g->path, i);\n\t\tif ((b = Bopen(path, OREAD)) == nil)\n\t\t\tsysfatal(\"%r\");\n\t\tfree(path);\n\t\twhile ((s = Brdline(b, '\\n')) != nil) {\n\t\t\tif (strncmp(s, \"numout\\t\", 7) == 0) {\n\t\t\t\ts[Blinelen(b)-1] = 0;\n\t\t\t\tinst->numout = atoi(s+7);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tBterm(b);\n\n\t\tif (inst->numout != 1 && inst->numout != 2)\n\t\t\tsysfatal(\"%s/%d: %d channels\", g->path, i, inst->numout);\n\n\t\tif (i == id)\n\t\t\treturn inst;\n\n\t\tif (f >= 0)\n\t\t\ti++;\n\t}\n\n\treturn nil;\n}\n\nstatic char *\nparse(char *s, Group *g)\n{\n\tCmd c;\n\tchar *e;\n\tInst *inst;\n\tint i, n;\n\tfloat f;\n\n\tfor (i = 1; s[i] != 0 && s[i] != '\\n' && s[i] != ';'; i++);\n\te = (s[i] == 0 || s[i] == '\\n') ? nil : s + i + 1;\n\ts[i] = 0;\n\n\tif (g != nil) {\n\t\ts++;\n\t\tif ((inst = getinst(g, i36(*s++))) != nil) {\n\t\t\tmemset(&c, 0, sizeof(c));\n\t\t\tc.type = -1;\n\n\t\t\tn = 0;\nnextnote:\n\t\t\tf = 1.0;\n\t\t\tif (*s == '!') {\n\t\t\t\tf = -1.0;\n\t\t\t\ts++;\n\t\t\t}\n\n\t\t\tif ((*s >= 'a' && *s <= 'g') || (*s >= 'A' && *s <= 'G')) {\n\t\t\t\tif (s[1] != 0) {\n\t\t\t\t\tf *= note2freq(s[0], s[1]);\n\t\t\t\t\ts += 2;\n\t\t\t\t\tc.type = CmdNote;\n\t\t\t\t\tc.note[n].freq = f;\n\t\t\t\t\tc.note[n].vel = 1.0;\n\t\t\t\t\tc.note[n].dur = bar / 16.0;\n\t\t\t\t\tif (*s != 0) {\n\t\t\t\t\t\tc.note[n].vel = (float)i36(*s) / 16.0;\n\t\t\t\t\t\ts++;\n\t\t\t\t\t\tif (*s != 0) {\n\t\t\t\t\t\t\tf = i36(*s);\n\t\t\t\t\t\t\tc.note[n].dur = bar / (f != 0 ? f : 1);\n\t\t\t\t\t\t\ts++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tn++;\n\t\t\t\t\tif (*s == ':') {\n\t\t\t\t\t\ts++;\n\t\t\t\t\t\t/* for the lack of better ideas, overwrite */\n\t\t\t\t\t\tif (n >= nelem(c.note))\n\t\t\t\t\t\t\tn--;\n\t\t\t\t\t\tgoto nextnote;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tc.numnotes = n;\n\t\t\t} else if (strncmp(s, \"vol\", 3) == 0) {\n\t\t\t\tc.type = CmdVol;\n\t\t\t\tc.vol = atof(s+3) / 100.0;\n\t\t\t} else if (*s != 0) {\n\t\t\t\tc.type = CmdRaw;\n\t\t\t\tc.raw = s;\n\t\t\t}\n\n\t\t\tif (c.type >= 0)\n\t\t\t\tg->synth->cmd(inst->aux, &c);\n\t\t}\n\t} else if (strncmp(s, \"bpm\", 3) == 0) {\n\t\tif ((i = atoi(s+3)) > 0) {\n\t\t\tbpm = i;\n\t\t\tbar = 240.0 / (float)bpm;\n\t\t}\n\t} else if (strncmp(s, \"vol\", 3) == 0) {\n\t\tvol = atof(s+3) / 100.0;\n\t}\n\n\treturn e;\n}\n\nstatic void\nmixer(void *)\n{\n\tint i, j, n, bufframes;\n\ts16int *pcm;\n\tfloat *out, *x, f;\n\tInst *inst;\n\tGroup *g;\n\n\tbufframes = rate/100;\n\tpcm = malloc(2*bufframes*sizeof(*pcm)); /* stereo */\n\tout = malloc(2*bufframes*sizeof(*out));\n\tx = malloc(2*bufframes*sizeof(*x));\n\n\tfor (;;) {\n\t\tmemset(out, 0, 2*bufframes*sizeof(*out));\n\t\tqlock(&grouplock);\n\t\tfor (i = 0; i < numgroups; i++) {\n\t\t\tg = &groups[i];\n\t\t\tfor (j = 0; j < g->numinst; j++) {\n\t\t\t\tinst = &g->inst[j];\n\t\t\t\tif (readn(inst->data, x, inst->numout*bufframes*sizeof(*x)) < 1)\n\t\t\t\t\tbreak;\n\t\t\t\tif (inst->numout == 1) {\n\t\t\t\t\tfor (n = 0; n < bufframes; n++) {\n\t\t\t\t\t\tout[n*2+0] += x[n];\n\t\t\t\t\t\tout[n*2+1] += x[n];\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor (n = 0; n < 2*bufframes; n++)\n\t\t\t\t\t\tout[n] += x[n];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tqunlock(&grouplock);\n\t\tfor (n = 0; n < 2*bufframes; n++) {\n\t\t\tf = out[n] * vol;\n\t\t\tif (f >= 1.0)\n\t\t\t\tpcm[n] = 32767;\n\t\t\telse if (f <= -1.0)\n\t\t\t\tpcm[n] = -32768;\n\t\t\telse\n\t\t\t\tpcm[n] = f * 32767.0;\n\t\t}\n\t\tif (write(audio, pcm, 2*bufframes*sizeof(*pcm)) < 0) {\n\t\t\tfprint(2, \"audio: %r\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tif (record >= 0 && write(record, pcm, 2*bufframes*sizeof(*pcm)) < 0) {\n\t\t\tfprint(2, \"record: %r\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tthreadexits(nil);\n}\n\nvoid\nthreadmain(int argc, char **argv)\n{\n\tchar *s, t[256], *to;\n\tSynth *synth;\n\tBiobuf *b;\n\tint i, j, n, nomixer;\n\n\tnomixer = 0;\n\tto = nil;\n\tARGBEGIN{\n\tcase 'm':\n\t\tnomixer = 1;\n\t\tbreak;\n\tcase 'r':\n\t\trate = atoi(EARGF(usage()));\n\t\tif (rate < 1)\n\t\t\tsysfatal(\"invalid rate %d\", rate);\n\t\tbreak;\n\tcase 't':\n\t\tto = EARGF(usage());\n\t\tbreak;\n\tdefault:\n\t\tusage();\n\t}ARGEND;\n\n\tif (argc < 1)\n\t\tusage();\n\n\tif (!nomixer && to != nil) {\n\t\tfprint(2, \"can't record with the mixer disabled\\n\");\n\t\tthreadexitsall(\"fail\");\n\t}\n\n\tif (!nomixer && (audio = open(\"/dev/audio\", OWRITE)) < 0)\n\t\tsysfatal(\"%r\");\n\tif (to != nil && (record = create(to, OWRITE|OTRUNC, 0644)) < 0)\n\t\tsysfatal(\"%r\");\n\n\tquotefmtinstall();\n\tsetfcr(FPPDBL|FPRNR);\n\n\t/* go through all groups */\n\tfor (i = 0; i < argc; i++) {\n\t\t/* search for specific synth handler by its name */\n\t\ts = smprint(\"%s/metadata\", argv[i]);\n\t\tif ((b = Bopen(s, OREAD)) == nil)\n\t\t\tsysfatal(\"%r\");\n\t\tfree(s);\n\t\tsynth = nil;\n\t\twhile ((s = Brdline(b, '\\n')) != nil) {\n\t\t\tif (strncmp(s, \"name\\t\", 5) == 0) {\n\t\t\t\ts[Blinelen(b)-1] = 0;\n\t\t\t\tfor (j = 0; j < nelem(synths) && strcmp(synths[j]->name, s+5) != 0; j++);\n\t\t\t\tif (j >= nelem(synths))\n\t\t\t\t\tsysfatal(\"unknown synth %q\\n\", s+5);\n\t\t\t\tif ((groups = realloc(groups, sizeof(Group)*(numgroups+1))) == nil)\n\t\t\t\t\tsysfatal(\"memory\");\n\t\t\t\tsynth = synths[j];\n\t\t\t\tmemset(&groups[numgroups], 0, sizeof(Group));\n\t\t\t\tif ((s = smprint(\"%s/clone\", argv[i])) == nil)\n\t\t\t\t\tsysfatal(\"memory\");\n\t\t\t\tif ((groups[numgroups].clone = open(s, OREAD)) < 0)\n\t\t\t\t\tsysfatal(\"%r\");\n\t\t\t\tfree(s);\n\t\t\t\tgroups[numgroups].path = argv[i];\n\t\t\t\tgroups[numgroups++].synth = synth;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tBterm(b);\n\t\tif (synth == nil)\n\t\t\tsysfatal(\"no name set in %s/metadata\", argv[i]);\n\t}\n\n\tif (!nomixer)\n\t\tproccreate(mixer, nil, 4096);\n\n\tfor (;;) {\n\t\tif ((n = read(0, t, sizeof(t)-1)) < 1)\n\t\t\tbreak;\n\t\tt[n] = 0;\n\t\tfor (s = t; s != nil && *s;) {\n\t\t\ti = i36(s[0]);\n\t\t\tqlock(&grouplock);\n\t\t\ts = parse(s, i < numgroups ? &groups[i] : nil);\n\t\t\tqunlock(&grouplock);\n\t\t}\n\t}\n\n\tthreadexitsall(nil);\n}\n", "source": "neindaw/piper/piper.c", "file_type": "c"}
{"text": "#include <u.h>\n#include <libc.h>\n#include \"piper.h\"\n#include \"util.h\"\n\ntypedef struct Kick Kick;\n\nstruct Kick {\n\tstruct {\n\t\tint freq;\n\t\tint attack;\n\t\tint release;\n\t}a;\n\tstruct {\n\t\tint freq;\n\t\tint attack;\n\t\tint release;\n\t\tint enable;\n\t}b;\n\tint gate;\n\tint volume;\n\tchar path[1];\n};\n\nstatic int\ncmd(void *aux, Cmd *c)\n{\n\tKick *k;\n\n\tk = aux;\n\tswitch (c->type) {\n\tcase CmdNote:\n\t\tfprint(k->gate, \"0\");\n\t\tfprint(k->volume, \"%g\", c->note[0].vel);\n\t\tfprint(k->a.freq, \"%g\", c->note[0].freq);\n\t\tfprint(k->a.release, \"%g\", c->note[0].dur);\n\t\tif (c->numnotes > 1) {\n\t\t\tfprint(k->b.freq, \"%g\", c->note[1].freq);\n\t\t\tfprint(k->b.release, \"%g\", c->note[1].dur);\n\t\t\tfprint(k->b.enable, \"%g\", c->note[1].vel);\n\t\t} else {\n\t\t\tfprint(k->b.enable, \"0\");\n\t\t}\n\t\tfprint(k->gate, \"1\");\n\t\tbreak;\n\n\tcase CmdRaw:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic void *\nalloc(char *path)\n{\n\tKick *k;\n\n\tif ((k = calloc(1, sizeof(*k) + strlen(path) + 1)) != nil) {\n\t\tk->a.freq = pathopen(path, \"A/Frequency/ctl\");\n\t\tk->a.attack = pathopen(path, \"A/Attack/ctl\");\n\t\tk->a.release = pathopen(path, \"A/Release/ctl\");\n\t\tk->b.freq = pathopen(path, \"B/Frequency/ctl\");\n\t\tk->b.attack = pathopen(path, \"B/Attack/ctl\");\n\t\tk->b.release = pathopen(path, \"B/Release/ctl\");\n\t\tk->b.enable = pathopen(path, \"B/Enable/ctl\");\n\t\tk->gate = pathopen(path, \"Control/Gate/ctl\");\n\t\tk->volume = pathopen(path, \"Control/Gain/ctl\");\n\n\t\tstrcpy(k->path, path);\n\t}\n\n\treturn k;\n}\n\nSynth kick_drum = {\n\t.name = \"Kick Drum\",\n\t.cmd = cmd,\n\t.alloc = alloc,\n};\n", "source": "neindaw/piper/kick.c", "file_type": "c"}
{"text": "#include <u.h>\n#include <libc.h>\n#include \"piper.h\"\n#include \"util.h\"\n\ntypedef struct AY AY;\n\nstruct AY {\n\tstruct {\n\t\tint freq;\n\t\tint enable;\n\t\tint noise;\n\t\tint env;\n\t\tint vol;\n\t}abc[3];\n\tstruct {\n\t\tint period;\n\t\tint alter;\n\t\tint attack;\n\t\tint cont;\n\t\tint hold;\n\t\tint hit;\n\t}env;\n\tint noisefreq;\n\tint volume;\n\tchar path[1];\n};\n\nstatic int\ncmd(void *aux, Cmd *c)\n{\n\tAY *ay;\n\tint i;\n\tfloat dur;\n\n\tay = aux;\n\tswitch (c->type) {\n\tcase CmdNote:\n\t\tfprint(ay->env.hit, \"0\");\n\t\tfor (i = 0; i < 3; i++)\n\t\t\tfprint(ay->abc[i].enable, \"0\");\n\n\t\tdur = 0.0;\n\t\tfor (i = 0; i < c->numnotes; i++) {\n\t\t\tfprint(ay->abc[i].enable, \"1\");\n\t\t\tfprint(ay->abc[i].freq, \"%g\", c->note[i].freq);\n\t\t\tfprint(ay->abc[i].vol, \"%g\", c->note[i].vel);\n\t\t\tif (dur < c->note[i].dur)\n\t\t\t\tdur = c->note[i].dur;\n\t\t}\n\n\t\tfprint(ay->env.period, \"%g\", dur);\n\t\tfprint(ay->env.hit, \"1\");\n\t\tbreak;\n\n\tcase CmdRaw:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic void *\nalloc(char *path)\n{\n\tAY *ay;\n\tint i;\n\n\tif ((ay = calloc(1, sizeof(*ay) + strlen(path) + 1)) != nil) {\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tay->abc[i].freq = pathopen(path, \"%c/Tone/Frequency/ctl\", 'A'+i);\n\t\t\tay->abc[i].enable = pathopen(path, \"%c/Tone/Enable/ctl\", 'A'+i);\n\t\t\tay->abc[i].noise = pathopen(path, \"%c/Noise/ctl\", 'A'+i);\n\t\t\tay->abc[i].env = pathopen(path, \"%c/Envelope/ctl\", 'A'+i);\n\t\t\tay->abc[i].vol = pathopen(path, \"%c/Volume/ctl\", 'A'+i);\n\t\t\tfprint(ay->abc[i].env, \"1\");\n\t\t}\n\n\t\tay->env.period = pathopen(path, \"Envelope/Period/ctl\");\n\t\tay->env.alter = pathopen(path, \"Envelope/Alternate/ctl\");\n\t\tay->env.attack = pathopen(path, \"Envelope/Attack/ctl\");\n\t\tay->env.cont = pathopen(path, \"Envelope/Continue/ctl\");\n\t\tay->env.hold = pathopen(path, \"Envelope/Hold/ctl\");\n\t\tay->env.hit = pathopen(path, \"Envelope/Hit/ctl\");\n\t\tay->noisefreq = pathopen(path, \"Noise/ctl\");\n\t\tay->volume = pathopen(path, \"Volume/ctl\");\n\n\t\tstrcpy(ay->path, path);\n\t}\n\n\treturn ay;\n}\n\nSynth ay_3_8910 = {\n\t.name = \"AY-3-8910\",\n\t.cmd = cmd,\n\t.alloc = alloc,\n};\n", "source": "neindaw/piper/ay.c", "file_type": "c"}
{"text": "</$objtype/mkfile\n\nBIN=/$objtype/bin\nTARG=fontsel\n\nOFILES=\\\n\tfontsel.$O\\\n\nHFILES=\\\n\n</sys/src/cmd/mkone\n", "source": "fontsel/mkfile", "file_type": "mkfile"}
{"text": "#include <u.h>\n#include <libc.h>\n#include <thread.h>\n#include <draw.h>\n#include <bio.h>\n#include <keyboard.h>\n#include <mouse.h>\n\n#define MIN(a,b) ((a)<=(b)?(a):(b))\n#define MAX(a,b) ((a)>=(b)?(a):(b))\n\ntypedef struct Fontdir Fontdir;\n\nstruct Fontdir {\n\tchar *name;\n\tchar *prefix;\n\tchar **fonts;\n\tint nfonts;\n\tint isttf;\n\tunion {\n\t\tint ifont;\n\t\tint sz;\n\t};\n};\n\nenum\n{\n\tCkey,\n\tCmouse,\n\tCresize,\n\tNumchan,\n\n\tTtfdefsz = 16,\n};\n\nstatic char *textdef[] = {\n\t\"Cwm fjord bank glyphs vext quiz!\",\n\t\"Gud hj\u00e4lpe Zorns m\u00f6 qvickt f\u00e5 byxa?\",\n\t\"\u0420\u0430\u0437\u044a\u044f\u0440\u0451\u043d\u043d\u044b\u0439 \u0447\u0442\u0435\u0446 \u044d\u0433\u043e\u0438\u0441\u0442\u0438\u0447\u043d\u043e \u0431\u044c\u0451\u0442 \u043f\u044f\u0442\u044c\u044e\",\n\t\"\u0436\u0435\u0440\u0434\u044f\u043c\u0438 \u0448\u0443\u0441\u0442\u0440\u043e\u0433\u043e \u0444\u0435\u0445\u0442\u043e\u0432\u0430\u043b\u044c\u0449\u0438\u043a\u0430.\",\n\t\"\",\n\t\"static int\",\n\t\"dosomestuff(Stuff *s, char *t, int n)\",\n\t\"{\",\n\t\"    if(s == nil && (t == nil || n < 1))\",\n\t\"        return 0;\",\n\t\"    fprint(2, \\\"# %c\\\\n\\\", t[0]);\",\n\t\"    return dostuff(s) || dot(t, n);\",\n\t\"}\",\n\tnil\n};\n\nstatic char **text = textdef;\n\nstatic char *prefixes[] = {\n\t\"/lib/font/bit\",\n\t\"/lib/font/ttf\",\n};\n\nstatic Font *f;\nstatic Fontdir *dirs, *cdir;\nstatic int ndirs, idir;\nstatic char lasterr[256];\nint mainstacksize = 32768;\n\nstatic void\nredraw(void)\n{\n\tPoint p;\n\tint i, w, maxw;\n\tchar t[256];\n\n\tlockdisplay(display);\n\tdraw(screen, screen->r, display->white, nil, ZP);\n\tp = screen->r.min;\n\n\tif(f == nil){\n\t\tp.x += Dx(screen->r)/2 - stringwidth(font, lasterr)/2;\n\t\tp.y += Dy(screen->r)/2 - font->height/2;\n\t\tstring(screen, p, display->black, ZP, font, lasterr);\n\t}else{\n\t\tmaxw = 0;\n\t\tfor(i = 0; text[i] != nil; i++){\n\t\t\tif((w = stringwidth(f, text[i])) > maxw)\n\t\t\t\tmaxw = w;\n\t\t}\n\t\tp.x += Dx(screen->r)/2 - maxw/2;\n\t\tp.y += Dy(screen->r)/2 - i*f->height/2;\n\n\t\tfor(i = 0; text[i] != nil; i++){\n\t\t\tstring(screen, p, display->black, ZP, f, text[i]);\n\t\t\tp.y += f->height;\n\t\t}\n\n\t}\n\n\tif(cdir->isttf)\n\t\tsnprint(t, sizeof(t), \"/n/ttf/%s.%d/font\", cdir->name, cdir->sz);\n\telse\n\t\tsnprint(t, sizeof(t), \"%s/%s\", cdir->name, cdir->fonts[cdir->ifont]);\n\tp = screen->r.max;\n\tp.x -= Dx(screen->r)/2 + stringwidth(font, t)/2;\n\tp.y -= font->height;\n\tstring(screen, p, display->black, ZP, font, t);\n\n\tflushimage(display, 1);\n\tunlockdisplay(display);\n}\n\nstatic int\nfcmp(void *a, void *b)\n{\n\treturn strcmp(*(char**)a, *(char**)b);\n}\n\nstatic int\nfontdir(char *t, int f, Fontdir *fdir)\n{\n\tDir *d;\n\tint doff, k;\n\tlong i, n;\n\n\tk = strlen(t);\n\tif(k > 4 && (cistrcmp(&t[k-4], \".ttf\") == 0 || cistrcmp(&t[k-4], \".otf\") == 0)){\n\t\tfdir->nfonts = 1;\n\t\tfdir->sz = Ttfdefsz;\n\t\tfdir->isttf = 1;\n\t\treturn 0;\n\t}\n\n\tif((n = dirreadall(f, &d)) < 1)\n\t\treturn -1;\n\tdoff = strlen(t);\n\tt[doff++] = '/';\n\tfor(i = 0; i < n; i++){\n\t\tif((k = strlen(d[i].name)) < 5 || strcmp(&d[i].name[k-5], \".font\") != 0)\n\t\t\tcontinue;\n\t\tif((fdir->fonts = realloc(fdir->fonts, sizeof(*fdir->fonts)*(fdir->nfonts+1))) == nil)\n\t\t\tsysfatal(\"no memory\");\n\t\td[i].name[k-5] = 0;\n\t\tstrcpy(t+doff, d[i].name);\n\t\tfdir->fonts[fdir->nfonts++] = strdup(t+doff);\n\t}\n\tfree(d);\n\tif(fdir->nfonts > 0)\n\t\tqsort(fdir->fonts, fdir->nfonts, sizeof(*fdir->fonts), fcmp);\n\n\treturn 0;\n}\n\nstatic int\ndcmp(void *a_, void *b_)\n{\n\tFontdir *a, *b;\n\n\ta = (Fontdir*)a_;\n\tb = (Fontdir*)b_;\n\treturn strcmp(a->name, b->name);\n}\n\nstatic void\nfindfonts(char *prefix)\n{\n\tDir *d, *din;\n\tint f, fin, doff;\n\tlong i, n;\n\tchar t[1024];\n\n\tdoff = sprint(t, \"%s\", prefix);\n\tt[doff++] = '/';\n\tt[doff] = 0;\n\tif((f = open(t, OREAD)) < 0){\n\t\tfprint(2, \"font dir: %r\\n\");\n\t\treturn;\n\t}\n\tif((n = dirreadall(f, &d)) < 1){\n\t\tfprint(2, \"%s: no fonts\\n\", t);\n\t\tclose(f);\n\t\treturn;\n\t}\n\tclose(f);\n\tfor(i = 0; i < n; i++){\n\t\tstrcpy(t+doff, d[i].name);\n\t\tif((fin = open(t, OREAD)) < 0)\n\t\t\tcontinue;\n\t\tif((din = dirfstat(fin)) != nil){\n\t\t\tif((dirs = realloc(dirs, sizeof(Fontdir)*(ndirs+1))) == nil)\n\t\t\t\tsysfatal(\"no memory\");\n\t\t\tmemset(&dirs[ndirs], 0, sizeof(Fontdir));\n\t\t\tdirs[ndirs].prefix = prefix;\n\t\t\tif(fontdir(t, fin, &dirs[ndirs]) == 0 && dirs[ndirs].nfonts > 0)\n\t\t\t\tdirs[ndirs++].name = strdup(d[i].name);\n\t\t\tfree(din);\n\t\t}\n\t\tclose(fin);\n\t}\n\tfree(d);\n}\n\nstatic void\nnewfont(void)\n{\n\tchar t[512];\n\n\tlockdisplay(display);\n\tif(f != nil)\n\t\tfreefont(f);\n\tif(cdir->isttf)\n\t\tsnprint(t, sizeof(t), \"/n/ttf/%s.%d/font\", cdir->name, cdir->sz);\n\telse\n\t\tsnprint(t, sizeof(t), \"%s/%s/%s.font\", cdir->prefix, cdir->name, cdir->fonts[cdir->ifont]);\n\tif((f = openfont(display, t)) == nil)\n\t\tsnprint(lasterr, sizeof(lasterr), \"%r\");\n\tunlockdisplay(display);\n}\n\nstatic char *\ndirgen(int i)\n{\n\treturn i < ndirs ? dirs[i].name : nil;\n}\n\nstatic char *\nfontgen(int i)\n{\n\treturn i < cdir->nfonts ? cdir->fonts[i] : nil;\n}\n\nstatic void\nusage(void)\n{\n\tprint(\"usage: %s [FILE]\\n\", argv0);\n\tthreadexitsall(\"usage\");\n}\n\nstatic void\nloadtext(int f)\n{\n\tBiobuf b;\n\tint i;\n\n\tif(f < 0 || Binit(&b, f, OREAD) != 0)\n\t\tsysfatal(\"loadtext: %r\");\n\n\ttext = nil;\n\tfor(i = 0; i < 256; i++){\n\t\tif((text = realloc(text, (i+1)*sizeof(char*))) == nil)\n\t\t\tsysfatal(\"memory\");\n\t\tif((text[i] = Brdstr(&b, '\\n', 1)) == nil)\n\t\t\tbreak;\n\t}\n\n\tclose(f);\n}\n\nvoid\nthreadmain(int argc, char **argv)\n{\n\tMousectl *mctl;\n\tKeyboardctl *kctl;\n\tRune r;\n\tMouse m;\n\tMenu menu;\n\tAlt a[Numchan+1] = {\n\t\t[Ckey] = {nil, &r, CHANRCV},\n\t\t[Cmouse] = {nil, &m, CHANRCV },\n\t\t[Cresize] = {nil, nil, CHANRCV},\n\t\t{nil, nil, CHANEND},\n\t};\n\tint n;\n\n\tARGBEGIN{\n\tdefault:\n\t\tusage();\n\t\tbreak;\n\t}ARGEND;\n\n\tif(argc > 1)\n\t\tusage();\n\telse if(argc == 1)\n\t\tloadtext(strcmp(argv[0], \"-\") == 0 ? 0 : open(argv[0], OREAD));\n\n\tfor(n = 0; n < nelem(prefixes); n++)\n\t\tfindfonts(prefixes[n]);\n\tif(ndirs < 1)\n\t\tsysfatal(\"no fonts\");\n\tqsort(dirs, ndirs, sizeof(*dirs), dcmp);\n\n\tif(initdraw(nil, nil, \"fontsel\") < 0)\n\t\tsysfatal(\"initdraw: %r\");\n\tif((kctl = initkeyboard(nil)) == nil)\n\t\tsysfatal(\"initkeyboard: %r\");\n\ta[Ckey].c = kctl->c;\n\tif((mctl = initmouse(nil, screen)) == nil)\n\t\tsysfatal(\"initmouse: %r\");\n\ta[Cmouse].c = mctl->c;\n\ta[Cresize].c = mctl->resizec;\n\tdisplay->locking = 1;\n\tunlockdisplay(display);\n\n\tmemset(&menu, 0, sizeof(menu));\n\tcdir = &dirs[0];\n\tnewfont();\n\tredraw();\n\n\tfor(;;){\n\t\tswitch(alt(a)){\n\t\tcase -1:\n\t\t\tgoto end;\n\n\t\tcase Ckey:\n\t\t\tswitch (r) {\n\t\t\tcase Kdel:\n\t\t\tcase 'q':\n\t\t\t\tgoto end;\n\t\t\tcase '-':\n\t\t\t\tcdir->ifont = MAX(cdir->isttf ? 6 : 0, cdir->ifont-1);\n\t\t\t\tnewfont();\n\t\t\t\tredraw();\n\t\t\t\tbreak;\n\t\t\tcase '+':\n\t\t\t\tcdir->ifont = MIN(cdir->isttf ? 256 : cdir->nfonts-1, cdir->ifont+1);\n\t\t\t\tnewfont();\n\t\t\t\tredraw();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase Cmouse:\n\t\t\tif(m.buttons == 2){\n\t\t\t\tmenu.gen = dirgen;\n\t\t\t\tmenu.lasthit = idir;\n\t\t\t\tif((n = menuhit(2, mctl, &menu, nil)) >= 0){\n\t\t\t\t\tidir = n;\n\t\t\t\t\tcdir = &dirs[idir];\n\t\t\t\t\tnewfont();\n\t\t\t\t\tredraw();\n\t\t\t\t}\n\t\t\t}else if(m.buttons == 4 && cdir->isttf == 0){\n\t\t\t\tmenu.gen = fontgen;\n\t\t\t\tmenu.lasthit = cdir->ifont;\n\t\t\t\tif((n = menuhit(3, mctl, &menu, nil)) >= 0){\n\t\t\t\t\tcdir->ifont = n;\n\t\t\t\t\tnewfont();\n\t\t\t\t\tredraw();\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase Cresize:\n\t\t\tgetwindow(display, Refnone);\n\t\t\tredraw();\n\t\t\tbreak;\n\t\t}\n\t}\n\nend:\n\tif(f != nil){\n\t\tif(cdir->isttf)\n\t\t\tprint(\"/n/ttf/%s.%d/font\\n\", cdir->name, cdir->sz);\n\t\telse\n\t\t\tprint(\"%s/%s/%s.font\\n\", cdir->prefix, cdir->name, cdir->fonts[cdir->ifont]);\n\t}\n\tthreadexitsall(nil);\n}\n", "source": "fontsel/fontsel.c", "file_type": "c"}
{"text": "</$objtype/mkfile\nBIN=$home/bin/$objtype\n\nTARG=ytfs\nOFILES=ytfs.$O\n\n</sys/src/cmd/mkone", "source": "ytfs/mkfile", "file_type": "mkfile"}
{"text": "#include <u.h>\n#include <libc.h>\n#include <fcall.h>\n#include <thread.h>\n#include <9p.h>\n\nenum {\n\tQdir = 0,\n\tQurl = 1,\n};\n\ntypedef struct Stream Stream;\nstruct Stream{\n\tint pid;\n\tchar *url;\n\tchar *name;\n\tint data[2];\n\tChannel *cpid;\n};\n\nenum {\n\tMaxstream = 1024,\n};\n\nstatic Stream streams[Maxstream];\nstatic int nstream = 0;\n\nstatic char *remote = nil;\nstatic char *prefix = \"https://youtube.com/watch?v=\";\nstatic char *user = nil;\n\nstatic char *Ebadqid = \"Bad QID\";\nstatic char *Esshfail = \"Ssh failed to start\";\nstatic char *Efilenotexist = \"File does not exist\";\nstatic char *Ebadwalk = \"Walk in non dir\";\nstatic char *Etoomany = \"Too many files\";\n\nstatic void\nsshproc(void *arg)\n{\n\tchar buf[512];\n\tStream *a;\n\n\ta = arg;\n\tdup(a->data[0], 1);\n\tclose(a->data[0]);\n\tclose(a->data[1]);\n\tclose(2);\n\tsnprint(buf, sizeof buf, \"youtube-dl --youtube-skip-dash-manifest -o - -f bestaudio %s | \"\n\t\t\"ffmpeg -y -i - -f mp3 -b:a 160k -metadata title=\\\"`youtube-dl -e %s`\\\" -metadata album=ytfs -\",\n\t\ta->url, a->url);\n\tprocexecl(a->cpid, \"/bin/ssh\", \"ssh\", remote, \"bash\", \"-c\", buf, nil);\n}\n\nstatic void\nfsattach(Req *r)\n{\n\tr->fid->qid = (Qid){Qdir, 0, QTDIR};\n\tr->ofcall.qid = r->fid->qid;\n\trespond(r, nil);\n}\n\nstatic char*\nfswalk1(Fid *fid, char *name, Qid *qid)\n{\n\tint i, c;\n\n\tswitch((ulong)fid->qid.path) {\n\tcase Qdir:\n\t\tif(strcmp(name, \"..\") == 0) {\n\t\t\t*qid = (Qid){Qdir, 0, QTDIR};\n\t\t\tfid->qid = *qid;\n\t\t\treturn nil;\n\t\t}\n\t\tfor(c=0,i=0;c<nstream && i<Maxstream;i++){\n\t\t\tif(streams[i].url == nil){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tc++;\n\t\t\tif(strcmp(name, streams[i].name) == 0){\n\t\t\t\t*qid = (Qid){Qurl+i, 0, QTFILE};\n\t\t\t\tfid->qid = *qid;\n\t\t\t\treturn nil;\t\n\t\t\t}\n\t\t}\n\t\treturn Efilenotexist;\n\tdefault:\n\t\treturn Ebadwalk;\n\t}\n}\n\nstatic void\nfscreate(Req *r)\n{\n\tint i;\n\tchar *name;\n\tStream *s;\n\n\tname = r->ifcall.name;\n\tfor(i=0, s=streams; i<Maxstream && s->url!=nil; i++, s++)\n\t\t;\n\tif(i == Maxstream){\n\t\trespond(r, Etoomany);\n\t\treturn;\n\t}\n\ts->url = smprint(\"%s%s\", prefix, name);\n\ts->name = smprint(\"%s%s\", name, \".mp3\");\n\tr->fid->qid = (Qid){Qurl+i, 0, 0};\n\tr->ofcall.qid = r->fid->qid;\n\tnstream++;\n\trespond(r, nil);\n}\n\nstatic void\nfsremove(Req *r)\n{\n\tlong path;\n\n\tpath = r->fid->qid.path;\n\tpath -= Qurl;\n\tif(path < 0){\n\t\trespond(r, Ebadqid);\n\t\treturn;\n\t}\n\tfree(streams[path].url);\n\tfree(streams[path].name);\n\tstreams[path].url = nil;\n\tstreams[path].name = nil;\n\tnstream--;\n\trespond(r, nil);\n}\n\nstatic void\nfsopen(Req *r)\n{\n\tFid *fid;\n\tStream *s;\n\tlong path;\n\n\tfid = r->fid;\n\tpath = fid->qid.path;\n\tr->ofcall.qid = (Qid){fid->qid.path, 0, fid->qid.vers};\n\tif(fid->qid.path == Qdir){\n\t\trespond(r, nil);\n\t\treturn;\n\t}\n\tpath -= Qurl;\n\tif(path < 0){\n\t\trespond(r, Ebadqid);\n\t\treturn;\n\t}\n\ts = streams+path;\n\tpipe(s->data);\n\ts->cpid = chancreate(sizeof(int), 0);\n\tprocrfork(sshproc, s, 8192, RFFDG);\n\tclose(s->data[0]);\n\trecv(s->cpid, &s->pid);\n\tif(s->pid < 0)\n\t\trespond(r, Esshfail);\n\trespond(r, nil);\n}\n\nstatic int\nurldirgen(int n, Dir *dir, void*)\n{\n\tStream *s;\n\n\tnulldir(dir);\n\tif(n >= nstream)\n\t\treturn -1;\n\ts = streams+n;\n\tdir->qid = (Qid){Qurl+n, 0, QTFILE};\n\tdir->mode = 0644;\n\tdir->name = estrdup9p(s->name);\n\tdir->uid = nil;\n\tdir->gid = nil;\n\tdir->muid = nil;\n\treturn 0;\n}\n\nstatic void\nfsread(Req *r)\n{\n\tStream *s;\n\tFid *fid;\n\tlong path;\n\n\tfid = r->fid;\n\tpath = fid->qid.path;\n\tif(path == Qdir){\n\t\tdirread9p(r, urldirgen, nil);\n\t\trespond(r, nil);\n\t\treturn;\n\t}\n\tpath -= Qurl;\n\tif(path < 0){\n\t\trespond(r, Ebadqid);\n\t\treturn;\n\t}\n\ts = streams+path;\n\tr->ofcall.count = read(s->data[1], r->ofcall.data, r->ifcall.count);\n\trespond(r, nil);\n}\n\nstatic void\nfsstat(Req *r)\n{\n\tDir *d;\n\tStream *s;\n\tlong path;\n\n\td = &r->d;\n\tnulldir(d);\n\tpath = r->fid->qid.path;\n\tswitch(path){\n\tcase Qdir:\n\t\td->name = estrdup9p(\"/\");\n\t\td->qid.type = QTDIR;\n\t\td->mode = DMDIR|0777;\n\t\tbreak;\n\tdefault:\n\t\tpath -= Qurl;\n\t\tif(path < 0){\n\t\t\trespond(r, Ebadqid);\n\t\t\treturn;\n\t\t}\n\t\ts = streams+path;\n\t\td->name = estrdup9p(s->name);\n\t\td->mode = 0644;\n\t\tbreak;\n\t}\n\td->uid = nil;\n\td->gid = nil;\n\td->muid = nil;\n\trespond(r, nil);\n}\n\nstatic void\nfsdestroy(Fid *f)\n{\n\tlong path;\n\tStream *s;\n\n\tpath = f->qid.path;\n\tpath -= Qurl;\n\tif((f->qid.type & (QTAUTH | QTDIR)) != 0 || path < 0)\n\t\treturn;\n\ts = streams+path;\n\tif(s->pid != 0){\n\t\tpostnote(PNGROUP, s->pid, \"kill\");\n\t\tclose(s->data[1]);\n\t\tchanfree(s->cpid);\n\t}\n}\n\nSrv fs = {\n.attach=\tfsattach,\n.walk1=\t\tfswalk1,\n.open=\t\tfsopen,\n.read=\t\tfsread,\n.create=\tfscreate,\n.remove=\tfsremove,\n.stat=\t\tfsstat,\n\n.destroyfid=\tfsdestroy,\n};\n\nstatic void\nusage(void)\n{\n\tfprint(2, \"Usage: %s [-m mtpt] remote\\n\", argv0);\n\texits(\"usage\");\n}\n\nvoid\nthreadmain(int argc, char *argv[])\n{\n\tchar *mtpt;\n\n\tmtpt = \"/n/ytfs\";\n\tARGBEGIN{\n\tcase 'D':\n\t\tchatty9p++;\n\t\tbreak;\n\tcase 'm':\n\t\tmtpt = EARGF(usage());\n\t\tbreak;\n\t}ARGEND;\n\tif(argc < 1)\n\t\tusage();\n\tremote = argv[0];\n\tmemset(streams, 0, sizeof(Stream)*Maxstream);\n\tthreadpostmountsrv(&fs, nil,  mtpt, MREPL|MCREATE);\n\tthreadexits(nil);\n}\n", "source": "ytfs/ytfs.c", "file_type": "c"}
{"text": "#!/bin/rc\n# Get dependencies for disco when no dgit is present\n# This script may not be up to date and exists only as a courtesy\n\nif(! test -e $GOPATH/src){\n\tmkdir -p $GOPATH/src\n}\n\ngitdeps = (github.com/mischief/ndb github.com/gorilla/websocket github.com/bwmarrin/discordgo)\n\ncd $GOPATH/src\n\n# Handle crypto package manually\n\necho Downloading golang.org/x/crypto\u2026\nmkdir -p $GOPATH/src/golang.org/x/crypto\ncd $GOPATH/src/golang.org/x\n\nhget https://github.com/golang/crypto/archive/master.zip > $GOPATH/src/golang.org/x/master.zip\nunzip -f master.zip\nmv crypto-master crypto\nrm master.zip\n\ncd $GOPATH/src\n\n# Handle 9fans package manually\n\necho Downloading 9fans.net/go/plan9\u2026\nmkdir -p $GOPATH/src/9fans.net/go/plan9\ncd $GOPATH/src/9fans.net/go\n\nhget https://github.com/9fans/go/archive/master.zip > $GOPATH/src/9fans.net/go/master.zip\nunzip -f master.zip\nmv go-master plan9\nrm master.zip\n\ncd $GOPATH/src\n\n# Other deps\n\necho Downloading github.com/Plan9-Archive/libauth\u2026\ngo get github.com/Plan9-Archive/libauth\n\ncd $GOPATH/src\n\nfor(i in $gitdeps){\n\techo 'Downloading '^$i^'\u2026'\n\tmkdir -p $i\n\tcd $i\n\tcd ..\n\thget 'http://'^$i^'/archive/master.zip' > master.zip\n\tunzip -f master.zip\n\trepo = `{echo $i | awk -F '/' '{print $3}'}\n\tmv $repo^'-master' $repo\n\trm master.zip\n\tcd $GOPATH/src\n}\n\necho Done.\n", "source": "disco/getdeps.rc", "file_type": "rc"}
{"text": "#include <u.h>\n#include <libc.h>\n#include <draw.h>\n#include <memdraw.h>\n#include <bio.h>\n#include \"imagefile.h\"\n\nstatic Biobuf out;\n\nstatic int\ndone(void*, char*)\n{\n\tmemendgif(&out);\n\tBflush(&out);\n\treturn 0;\n}\n\nstatic uvlong\nnanosec(void)\n{\n\tstatic uvlong fasthz, xstart;\n\tuvlong x, div;\n\tint f, n, i;\n\tchar tmp[128], *e;\n\n\tif (fasthz == ~0ULL)\n\t\treturn nsec() - xstart;\n\n\tif (fasthz == 0) {\n\t\tfasthz = ~0ULL;\n\t\tif ((f = open(\"/dev/time\", OREAD)) >= 0 && (n = read(f, tmp, sizeof(tmp)-1)) > 2) {\n\t\t\ttmp[n] = 0;\n\t\t\te = tmp;\n\t\t\tfor (i = 0; i < 3; i++)\n\t\t\t\tstrtoll(e, &e, 10);\n\t\t\tif ((fasthz = strtoll(e, nil, 10)) < 1)\n\t\t\t\tfasthz = ~0ULL;\n\t\t\telse\n\t\t\t\tcycles(&xstart);\n\t\t}\n\t\tclose(f);\n\t\tif (fasthz == ~0ULL) {\n\t\t\tfprint(2, \"couldn't get fasthz, falling back to nsec()\\n\");\n\t\t\tfprint(2, \"you might want to disable aux/timesync\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcycles(&x);\n\tx -= xstart;\n\n\tfor (div = 1000000000ULL; x < 0x1999999999999999ULL && div > 1 ; div /= 10ULL, x *= 10ULL);\n\n\treturn x / (fasthz / div);\n}\n\nstatic void\nusage(void)\n{\n\tfprint(2, \"usage: %s [-f FPS] INPUT > OUTPUT\\n\", argv0);\n\texits(\"usage\");\n}\n\nvoid\nmain(int argc, char **argv)\n{\n\tuvlong fps, x, lastx, j, dt, end, wrdiff;\n\tMemimage *i, *ni, *prevni;\n\tchar *err;\n\tu8int *prevd, *curd;\n\tint in, nprev, ncur;\n\n\tfps = 5;\n\tARGBEGIN{\n\tcase 'f':\n\t\tfps = atoi(EARGF(usage()));\n\t\tif (fps < 1 || fps > 60)\n\t\t\tusage();\n\t\tbreak;\n\t}ARGEND;\n\n\tif (argc < 1)\n\t\tusage();\n\n\tmemimageinit();\n\tif ((in = open(*argv, OREAD)) < 0)\n\t\tsysfatal(\"input: %r\");\n\tif (Binit(&out, 1, OWRITE) < 0)\n\t\tsysfatal(\"Binit failed: %r\");\n\tatnotify(done, 1);\n\n\tdt = (1000ULL/fps)*1000000ULL;\n\tprevni = nil;\n\tprevd = nil;\n\tnprev = 0;\n\twrdiff = 0;\n\tlastx = nanosec();\n\n\tfor (j = 0;;) {\n\t\tseek(in, 0, 0);\n\t\tx = nanosec();\n\t\tif ((i = readmemimage(in)) == nil || (ni = memonechan(i)) == nil) {\n\t\t\tfprint(2, \"image: %r\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tfreememimage(i);\n\t\tncur = Dy(ni->r)*(2+bytesperline(ni->r, ni->depth));\n\t\tif ((curd = malloc(ncur)) == nil || (ncur = unloadmemimage(ni, ni->r, curd, ncur)) < 0) {\n\t\t\tfprint(2, \"unload: %r\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tif (prevd == nil || (nprev != ncur || memcmp(prevd, curd, ncur) != 0)) {\n\t\t\tif (j == 0 && (err = memstartgif(&out, ni, -1)) != nil) {\n\t\t\t\tfprint(2, \"startgif: %s\\n\", err);\n\t\t\t\texits(\"startgif\");\n\t\t\t}\n\t\t\terr = memwritegif(&out, j == 0 ? ni : prevni, \"\", (x - lastx)/1000000ULL, -1);\n\t\t\tif (err != nil) {\n\t\t\t\tfprint(2, \"writegif: %s\\n\", err);\n\t\t\t\texits(\"writegif\");\n\t\t\t}\n\t\t\tlastx = x;\n\t\t\tj++;\n\t\t}\n\t\tif (prevni != nil)\n\t\t\tfreememimage(prevni);\n\t\tprevni = ni;\n\t\tfree(prevd);\n\t\tprevd = curd;\n\t\tnprev = ncur;\n\n\t\tif (wrdiff == 0) {\n\t\t\twrdiff = nanosec() - x;\n\t\t\tdt = wrdiff < dt ? dt - wrdiff : 0;\n\t\t}\n\t\tif (dt < 1)\n\t\t\tcontinue;\n\t\tend = x + dt;\n\t\tdo {\n\t\t\tx = nanosec();\n\t\t\tif (end - x > 25000000LL)\n\t\t\t\tsleep(10);\n\t\t\telse if (end - x > 15000000LL)\n\t\t\t\tsleep(5);\n\t\t\telse if (end - x > 10000000LL)\n\t\t\t\tsleep(1);\n\t\t} while (x < end);\n\t}\n\n\tclose(in);\n\n\texits(nil);\n}\n", "source": "wrec/wrec.c", "file_type": "c"}
{"text": "</$objtype/mkfile\n\nTARG=wrec\nBIN=/$objtype/bin\nCFLAGS=$CFLAGS -I/sys/src/cmd/jpg\nOFILES=\\\n\tonechan.$O\\\n\ttorgbv.$O\\\n\twritegif.$O\\\n\t$TARG.$O\n\ndefault:V:\tall\n\nonechan.$O: /sys/src/cmd/jpg/onechan.c\n\t$CC $CFLAGS $prereq\n\ntorgbv.$O: /sys/src/cmd/jpg/torgbv.c\n\t$CC $CFLAGS $prereq\n\nwritegif.$O: /sys/src/cmd/jpg/writegif.c\n\t$CC $CFLAGS $prereq\n\n</sys/src/cmd/mkone\n", "source": "wrec/mkfile", "file_type": "mkfile"}
{"text": "</$objtype/mkfile\n\nBIN=/$objtype/bin\nTARG=chibi-scheme\nMODDIR=/sys/lib/chibi-scheme\n\nCHIBI=./$O.out\nGENSTATIC=./tools/chibi-genstatic\n\nCPPFLAGS= -Iinclude -DPLAN9 -DSEXP_USE_GREEN_THREADS=0 -D__$objtype\nCFLAGS= -p $CPPFLAGS\nCFLAGS_STATIC=$CFLAGS -DSEXP_USE_STATIC_LIBS\n\nOFILES=gc.$O sexp.$O bignum.$O opcodes.$O plan9.$O vm.$O simplify.$O eval.$O main.$O $STATIC\nHFILES=include/chibi/sexp.h include/chibi/eval.h include/chibi/features.h include/chibi/install.h\nCLEANFILES=tests/basic/*.out tests/basic/*.err\n\nEXCLUDE=srfi.18 srfi.27 chibi.filesystem chibi.io \\\n\tchibi.net chibi.process chibi.stty chibi.system \\\n\tchibi.time\n\nCHIBI_LIBS = lib/chibi/filesystem.c lib/chibi/process.c \\\n\tlib/chibi/time.c lib/chibi/system.c lib/chibi/stty.c \\\n\tlib/chibi/weak.c lib/chibi/heap-stats.c lib/chibi/disasm.c \\\n\tlib/chibi/net.c\nCHIBI_IO_COMPILED_LIBS = lib/chibi/io/io.c\nCHIBI_OPT_COMPILED_LIBS = lib/chibi/optimize/rest.c \\\n\tlib/chibi/optimize/profile.c\nCOMPILED_LIBS = $CHIBI_COMPILED_LIBS $CHIBI_IO_COMPILED_LIBS \\\n\t$CHIBI_OPT_COMPILED_LIBS \\\n\tlib/srfi/33/bit.c lib/srfi/39/param.c \\\n\tlib/srfi/69/hash.c lib/srfi/95/qsort.c lib/srfi/98/env.c \\\n\tlib/scheme/time.c\n\n</sys/src/cmd/mkone\n\nclean:\n\trm -f $CLEANFILES *.[$OS] [$OS].out\n\nclibs.$O: clibs.c\n\n$TARG: $O.out\n\trm $OFILES\n\tmk 'CFLAGS=$CFLAGS_STATIC' clibs.$O $OFILES\n\tmk 'CFLAGS=$CFLAGS_STATIC' 'STATIC=clibs.$O' default\n\ntarget: $O.out\n\tmv $O.out $TARG\n\n%.c:   %.stub\n\t$CHIBI ./tools/chibi-ffi $stem.stub\n\ninclude/chibi/install.h: mkfile\n\techo '#define sexp_default_module_path \"'$MODDIR'\"' > include/chibi/install.h\n\techo '#define sexp_so_extension \".no-such-file\"' >> include/chibi/install.h\n\techo '#define sexp_platform \"plan9\"' >> include/chibi/install.h\n\techo '#define sexp_version \"'`{cat VERSION}'\"' >> include/chibi/install.h\n\techo '#define sexp_release_name \"'`{cat RELEASE}'\"' >> include/chibi/install.h\n\ndist-clean: clean\n\trm -f include/chibi/install.h clibs.c\n\ninstall:V: $BIN/$TARG\n\ttest -d $MODDIR || mkdir -p $MODDIR\n\t{cd lib; tar c .} | {cd $MODDIR ; tar x }\n\nclibs.c:V: $GENSTATIC $CHIBI $COMPILED_LIBS\n\tdu -a lib | sed 's/^[0-9]*[ \t]*//' | grep '\\.sld$' | \\\n\t$CHIBI $GENSTATIC \\\n\t-x srfi.27 -x srfi.18 -x chibi.filesystem -x chibi.io \\\n\t-x chibi.net -x chibi.process -x chibi.stty -x chibi.system \\\n\t-x chibi.time \\\n\t> ,clibs.c && mv ,clibs.c clibs.c\n\ntest:V:\n\t./$O.out -xscheme tests/r5rs-tests.scm\n\ntest-threads:\n\t./$O.out -xscheme tests/thread-tests.scm\n\ntest-numbers:\n\t./$O.out -xscheme tests/numeric-tests.scm\n\ntest-flonums:\n\t./$O.out -xscheme tests/flonum-tests.scm\n\ntest-hash:\n\t./$O.out -xscheme tests/hash-tests.scm\n\ntest-match:\n\t./$O.out -xscheme tests/match-tests.scm\n\ntest-loop:\n\t./$O.out -xscheme tests/loop-tests.scm\n\ntest-sort:\n\t./$O.out -xscheme tests/sort-tests.scm\n\ntest-records:\n\t./$O.out -xscheme tests/record-tests.scm\n\ntest-weak:\n\t./$O.out -xscheme tests/weak-tests.scm\n\ntest-unicode:\n\t./$O.out -xscheme tests/unicode-tests.scm\n\ntest-libs:\n\t./$O.out -xscheme tests/lib-tests.scm\n", "source": "Chibi Scheme/mkfile", "file_type": "mkfile"}
{"text": "/*  sexp.h -- header for sexp library                         */\n/*  Copyright (c) 2009-2022 Alex Shinn.  All rights reserved. */\n/*  BSD-style license: http://synthcode.com/license.txt       */\n\n#ifndef SEXP_H\n#define SEXP_H\n\n#ifdef __cplusplus\nextern \"C\" {\n#define SEXP_FLEXIBLE_ARRAY [SEXP_FLEXIBLE_ARRAY_SIZE]\n#else\n#define SEXP_FLEXIBLE_ARRAY []\n#endif\n\n#define SEXP_MODULE_PATH_VAR \"CHIBI_MODULE_PATH\"\n#define SEXP_NO_SYSTEM_PATH_VAR \"CHIBI_IGNORE_SYSTEM_PATH\"\n\n#include \"chibi/features.h\"\n#include \"chibi/install.h\"\n\n#ifdef _WIN32\n#include <windows.h>\n#include <errno.h>\n#define sexp_isalpha(x) (isalpha(x))\n#define sexp_isxdigit(x) (isxdigit(x))\n#define sexp_isdigit(x) (isdigit(x))\n#define sexp_tolower(x) (tolower(x))\n#define sexp_toupper(x) (toupper(x))\n#define SEXP_USE_POLL_PORT 0\n#define sexp_poll_input(ctx, port) usleep(SEXP_POLL_SLEEP_TIME)\n#define sexp_poll_output(ctx, port) usleep(SEXP_POLL_SLEEP_TIME)\n#else\n#if SEXP_USE_DL\n#include <dlfcn.h>\n#endif\n#ifndef PLAN9\n#include <errno.h>\n#include <unistd.h>\n#define SEXP_USE_POLL_PORT 1\n#define sexp_poll_input(ctx, port) sexp_poll_port(ctx, port, 1)\n#define sexp_poll_output(ctx, port) sexp_poll_port(ctx, port, 0)\n#else\n#define SEXP_USE_POLL_PORT 0\n#define sexp_poll_input(ctx, port) sleep(SEXP_POLL_SLEEP_TIME_MS)\n#define sexp_poll_output(ctx, port) sleep(SEXP_POLL_SLEEP_TIME_MS)\n#endif\n#if SEXP_USE_GREEN_THREADS\n#include <sys/time.h>\n#include <sys/select.h>\n#include <fcntl.h>\n#include <poll.h>\n#endif\n#define sexp_isalpha(x) (isalpha(x))\n#define sexp_isxdigit(x) (isxdigit(x))\n#define sexp_isdigit(x) (isdigit(x))\n#define sexp_tolower(x) (tolower(x))\n#define sexp_toupper(x) (toupper(x))\n#endif\n\n#if SEXP_USE_GC_FILE_DESCRIPTORS\n#define sexp_out_of_file_descriptors() (errno == EMFILE)\n#else\n#define sexp_out_of_file_descriptors() (0)\n#endif\n\n#ifdef __GNUC__\n#define SEXP_NO_WARN_UNUSED __attribute__((unused))\n#else\n#define SEXP_NO_WARN_UNUSED\n#endif\n\n#ifdef PLAN9\n#include <u.h>\n#include <libc.h>\n#include <fcall.h>\n#include <thread.h>\n#include <9p.h>\ntypedef unsigned long size_t;\ntypedef long long off_t;\n#define STRINGIFY(x) #x\n#define TOSTRING(x) STRINGIFY(x)\n#define exit(x)           exits(TOSTRING(x))\n#define fabsl          fabs\n#define M_PI           3.141592653589793\n#define M_LN10         2.30258509299404568402  /* log_e 10 */\n#define FLT_RADIX 2\n#define NAN NaN()\n#define INFINITY Inf(1)\n#define isfinite(x) !(isNaN(x) || isInf(x,0))\ntypedef u32int uint32_t;\ntypedef s32int int32_t;\ntypedef u64int uint64_t;\ntypedef s64int int64_t;\n#else\n#include <stddef.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdarg.h>\n#if !(defined _WIN32) || defined(__CYGWIN__)\n#include <sys/socket.h>\n#endif\n#include <sys/stat.h>\n#include <sys/types.h>\n#define _REENTRANT 1\n#include <math.h>\n#if SEXP_USE_FLONUMS\n#include <float.h>\n#include <limits.h>\n#endif\n#endif\n\n#if SEXP_USE_TRACK_ALLOC_BACKTRACE\n#include <execinfo.h>\n#endif\n\n#include <ctype.h>\n#include <stdio.h>\n\n/* tagging system\n *   bits end in     1:  fixnum\n *                  00:  pointer\n *                 010:  string cursor (optional)\n *                0110:  immediate symbol (optional)\n *            00001110:  immediate flonum (optional)\n *            00011110:  char\n *            00101110:  reader label (optional)\n *            00111110:  unique immediate (NULL, TRUE, FALSE)\n */\n\n#define SEXP_FIXNUM_BITS 1\n#define SEXP_POINTER_BITS 2\n#define SEXP_STRING_CURSOR_BITS 3\n#define SEXP_IMMEDIATE_BITS 4\n#define SEXP_EXTENDED_BITS 8\n\n#define SEXP_FIXNUM_MASK ((1<<SEXP_FIXNUM_BITS)-1)\n#define SEXP_POINTER_MASK ((1<<SEXP_POINTER_BITS)-1)\n#define SEXP_STRING_CURSOR_MASK ((1<<SEXP_STRING_CURSOR_BITS)-1)\n#define SEXP_IMMEDIATE_MASK ((1<<SEXP_IMMEDIATE_BITS)-1)\n#define SEXP_EXTENDED_MASK ((1<<SEXP_EXTENDED_BITS)-1)\n\n#define SEXP_POINTER_TAG 0\n#define SEXP_FIXNUM_TAG 1\n#define SEXP_STRING_CURSOR_TAG 2\n#define SEXP_ISYMBOL_TAG 6\n#define SEXP_IFLONUM_TAG 14\n#define SEXP_CHAR_TAG 30\n#define SEXP_READER_LABEL_TAG 46\n#define SEXP_EXTENDED_TAG 62\n\n#ifndef SEXP_POINTER_MAGIC\n#define SEXP_POINTER_MAGIC 0xFDCA9764uL /* arbitrary */\n#endif\n\n#if SEXP_USE_HASH_SYMS\n#define SEXP_SYMBOL_TABLE_SIZE 389\n#else\n#define SEXP_SYMBOL_TABLE_SIZE 1\n#endif\n\nenum sexp_types {\n  SEXP_OBJECT,\n  SEXP_TYPE,\n  SEXP_FIXNUM,\n  SEXP_NUMBER,\n  SEXP_CHAR,\n  SEXP_BOOLEAN,\n  SEXP_PAIR,\n  SEXP_SYMBOL,\n  SEXP_BYTES,\n  SEXP_STRING,\n  SEXP_VECTOR,\n  SEXP_FLONUM,\n  SEXP_BIGNUM,\n#if SEXP_USE_STABLE_ABI || SEXP_USE_RATIOS\n  SEXP_RATIO,\n#endif\n#if SEXP_USE_STABLE_ABI || SEXP_USE_COMPLEX\n  SEXP_COMPLEX,\n#endif\n#if SEXP_USE_STABLE_ABI || SEXP_USE_DISJOINT_STRING_CURSORS\n  SEXP_STRING_CURSOR,\n#endif\n  SEXP_IPORT,\n  SEXP_OPORT,\n  SEXP_FILENO,\n  SEXP_EXCEPTION,\n  SEXP_PROCEDURE,\n  SEXP_MACRO,\n  SEXP_SYNCLO,\n  SEXP_ENV,\n  SEXP_BYTECODE,\n  SEXP_CORE,\n#if SEXP_USE_STABLE_ABI || SEXP_USE_DL\n  SEXP_DL,\n#endif\n  SEXP_OPCODE,\n  SEXP_LAMBDA,\n  SEXP_CND,\n  SEXP_REF,\n  SEXP_SET,\n  SEXP_SET_SYN,\n  SEXP_SEQ,\n  SEXP_LIT,\n  SEXP_STACK,\n  SEXP_CONTEXT,\n  SEXP_CPOINTER,\n  SEXP_UNIFORM_VECTOR,\n#if SEXP_USE_STABLE_ABI || SEXP_USE_AUTO_FORCE\n  SEXP_PROMISE,\n#endif\n#if SEXP_USE_STABLE_ABI || SEXP_USE_WEAK_REFERENCES\n  SEXP_EPHEMERON,\n#endif\n  SEXP_NUM_CORE_TYPES\n};\n\n#if !SEXP_USE_DISJOINT_STRING_CURSORS\n#define SEXP_STRING_CURSOR SEXP_FIXNUM\n#endif\n\n#ifdef _WIN32\n#if SEXP_64_BIT\ntypedef unsigned int sexp_tag_t;\ntypedef unsigned long long sexp_uint_t;\ntypedef long long sexp_sint_t;\n#define SEXP_PRIdFIXNUM \"lld\"\n#else\ntypedef unsigned short sexp_tag_t;\ntypedef unsigned int sexp_uint_t;\ntypedef int sexp_sint_t;\n#define SEXP_PRIdFIXNUM \"d\"\n#endif\n#define sexp_heap_align(n) sexp_align(n, 5)\n#define sexp_heap_chunks(n) (sexp_heap_align(n)>>5)\n#elif SEXP_64_BIT\n#if PLAN9\ntypedef uintptr sexp_tag_t;\ntypedef uintptr sexp_uint_t;\ntypedef intptr sexp_sint_t;\n#else\ntypedef unsigned int sexp_tag_t;\ntypedef unsigned long sexp_uint_t;\ntypedef long sexp_sint_t;\n#endif\n#define SEXP_PRIdFIXNUM \"ld\"\n#define sexp_heap_align(n) sexp_align(n, 5)\n#define sexp_heap_chunks(n) (sexp_heap_align(n)>>5)\n#elif defined(__CYGWIN__)\ntypedef unsigned short sexp_tag_t;\ntypedef unsigned int sexp_uint_t;\ntypedef int sexp_sint_t;\n#define SEXP_PRIdFIXNUM \"d\"\n#define sexp_heap_align(n) sexp_align(n, 5)\n#define sexp_heap_chunks(n) (sexp_heap_align(n)>>5)\n#elif PLAN9\ntypedef uintptr sexp_tag_t;\ntypedef unsigned int sexp_uint_t;\ntypedef int sexp_sint_t;\n#define SEXP_PRIdFIXNUM \"d\"\n#define sexp_heap_align(n) sexp_align(n, 4)\n#define sexp_heap_chunks(n) (sexp_heap_align(n)>>4)\n#else\ntypedef unsigned short sexp_tag_t;\ntypedef unsigned int sexp_uint_t;\ntypedef int sexp_sint_t;\n#define SEXP_PRIdFIXNUM \"d\"\n#define sexp_heap_align(n) sexp_align(n, 4)\n#define sexp_heap_chunks(n) (sexp_heap_align(n)>>4)\n#endif\n\n/* procedure flags */\n#define SEXP_PROC_NONE ((sexp_uint_t)0)\n#define SEXP_PROC_VARIADIC ((sexp_uint_t)1)\n#define SEXP_PROC_UNUSED_REST ((sexp_uint_t)2)\n#define SEXP_PROC_VARIABLE_TRANSFORMER ((sexp_uint_t)4)\n\n\n#ifdef SEXP_USE_INTTYPES\n#ifdef PLAN9\n#include <ape/stdint.h>\n#else\n#include <stdint.h>\n#endif\n# ifdef UINT8_MAX\n#  define SEXP_UINT8_DEFINED 1\ntypedef uint8_t  sexp_uint8_t;\n# endif\n# ifdef UINT32_MAX\n#  define SEXP_UINT32_DEFINED 1\ntypedef uint32_t sexp_uint32_t;\ntypedef int32_t sexp_int32_t;\n# endif\n#else\n# ifdef PLAN9\n# include <ape/limits.h>\n# else\n# include <limits.h>\n# if SEXP_USE_UNIFORM_VECTOR_LITERALS\n# ifdef PLAN9\n# include <ape/stdint.h>\n# else\n# include <stdint.h>\n# endif\n# endif\n# endif\n# if UCHAR_MAX == 255\n#  define SEXP_UINT8_DEFINED 1\ntypedef unsigned char sexp_uint8_t;\n# endif\n# if UINT_MAX == 4294967295U\n#  define SEXP_UINT32_DEFINED 1\ntypedef unsigned int sexp_uint32_t;\ntypedef int sexp_int32_t;\n# elif ULONG_MAX == 4294967295UL\n#  define SEXP_UINT32_DEFINED 1\ntypedef unsigned long sexp_uint32_t;\ntypedef long sexp_int32_t;\n# elif USHRT_MAX == 4294967295U\n#  define SEXP_UINT32_DEFINED 1\ntypedef unsigned short sexp_uint32_t;\ntypedef short sexp_int32_t;\n# endif\n#endif  /* SEXP_USE_INTTYPES */\n\n#if defined(__APPLE__) || defined(_WIN64) || (defined(__CYGWIN__) && __SIZEOF_POINTER__ == 8)\n#define SEXP_PRIdOFF \"lld\"\n#else\n#define SEXP_PRIdOFF \"ld\"\n#endif\n\n#if SEXP_USE_LONG_PROCEDURE_ARGS\ntypedef int sexp_proc_num_args_t;\n#else\ntypedef short sexp_proc_num_args_t;\n#endif\n\ntypedef struct sexp_struct *sexp;\n\n#define sexp_heap_pad_size(s) (sizeof(struct sexp_heap_t) + (s) + sexp_heap_align(1))\n#define sexp_free_chunk_size (sizeof(struct sexp_free_list_t))\n#define sexp_heap_first_block(h) ((sexp)(h->data + sexp_heap_align(sexp_free_chunk_size)))\n#define sexp_heap_last_block(h) ((sexp)((char*)h->data + h->size - sexp_heap_align(sexp_free_chunk_size)))\n#define sexp_heap_end(h) ((sexp)((char*)h->data + h->size))\n\n#define __HALF_MAX_SIGNED(type) ((type)1 << (sizeof(type)*8-2))\n#define __MAX_SIGNED(type) (__HALF_MAX_SIGNED(type) - 1 + __HALF_MAX_SIGNED(type))\n#define __MIN_SIGNED(type) (-1 - __MAX_SIGNED(type))\n\n#define SEXP_UINT_T_MAX ((sexp_uint_t)-1)\n#define SEXP_UINT_T_MIN (0)\n#define SEXP_SINT_T_MAX __MAX_SIGNED(sexp_sint_t)\n#define SEXP_SINT_T_MIN __MIN_SIGNED(sexp_sint_t)\n\n#define SEXP_MAX_FIXNUM ((((sexp_sint_t)1)<<(sizeof(sexp_sint_t)*8-SEXP_FIXNUM_BITS-1))-1)\n#define SEXP_MIN_FIXNUM (-SEXP_MAX_FIXNUM-1)\n\n#if SEXP_USE_SELF_PARAMETER\n#define sexp_api_params(self, n) , sexp self, sexp_sint_t n\n#define sexp_api_pass(self, n) , self, n\n#else\n#define sexp_api_params(self, n)\n#define sexp_api_pass(self, n)\n#endif\n\n/* procedure types */\ntypedef sexp (*sexp_proc1) (sexp, sexp, sexp_sint_t);\ntypedef sexp (*sexp_proc2) (sexp, sexp, sexp_sint_t, sexp);\ntypedef sexp (*sexp_proc3) (sexp, sexp, sexp_sint_t, sexp, sexp);\ntypedef sexp (*sexp_proc4) (sexp, sexp, sexp_sint_t, sexp, sexp, sexp);\ntypedef sexp (*sexp_proc5) (sexp, sexp, sexp_sint_t, sexp, sexp, sexp, sexp);\ntypedef sexp (*sexp_proc6) (sexp, sexp, sexp_sint_t, sexp, sexp, sexp, sexp, sexp);\ntypedef sexp (*sexp_proc7) (sexp, sexp, sexp_sint_t, sexp, sexp, sexp, sexp, sexp, sexp);\ntypedef sexp (*sexp_init_proc)(sexp, sexp, sexp_sint_t, sexp, const char*, const sexp_abi_identifier_t);\nSEXP_API sexp sexp_init_library(sexp, sexp, sexp_sint_t, sexp, const char*, const sexp_abi_identifier_t);\n\ntypedef struct sexp_free_list_t *sexp_free_list;\nstruct sexp_free_list_t {\n  sexp_uint_t size;\n  sexp_free_list next;\n};\n\ntypedef struct sexp_heap_t *sexp_heap;\nstruct sexp_heap_t {\n  sexp_uint_t size, max_size, chunk_size;\n  sexp_free_list free_list;\n  sexp_heap next;\n  /* note this must be aligned on a proper heap boundary, */\n  /* so we can't just use char data[] */\n  char *data;\n};\n\nstruct sexp_gc_var_t {\n  sexp *var;\n#if SEXP_USE_DEBUG_GC\n  char *name;\n#endif\n  struct sexp_gc_var_t *next;\n};\n\nstruct sexp_library_entry_t {   /* for static builds and user exported C */\n  const char *name;             /* libaries */\n  sexp_init_proc init;\n};\n\nstruct sexp_type_struct {\n  sexp name, cpl, slots, getters, setters, id, print, dl, finalize_name;\n  sexp_tag_t tag;\n  short field_base, field_eq_len_base, field_len_base, field_len_off;\n  unsigned short field_len_scale;\n  short size_base, size_off;\n  unsigned short size_scale;\n  short weak_base, weak_len_base, weak_len_off, weak_len_scale, weak_len_extra;\n  short depth;\n  sexp_proc2 finalize;\n};\n\nstruct sexp_opcode_struct {\n  sexp name, data, data2, proc, ret_type, arg1_type, arg2_type, arg3_type,\n    argn_type, methods, dl;\n  unsigned char op_class, code, num_args, flags, inverse;\n  sexp_proc1 func;\n};\n\nstruct sexp_core_form_struct {\n  char code;\n  sexp name;\n};\n\nstruct sexp_mark_stack_ptr_t {\n  sexp *start, *end;\n  struct sexp_mark_stack_ptr_t *prev; /* TODO: remove for allocations on stack */\n};\n\n/* Note this must be kept in sync with the _sexp_type_specs type            */\n/* registry in sexp.c.  The structure of a sexp type is:                    */\n/*   [ HEADER [[EQ_FIELDS... ] GC_FIELDS...] [WEAK_FIELDS...] [OTHER...] ]  */\n/* Thus all sexp's must be contiguous and align at the start of the type.   */\n/* This is used by the gc, equal? and slot-ref (although only the latter    */\n/* expects the alignment at the start of the type). */\nstruct sexp_struct {\n  sexp_tag_t tag;\n  char markedp;\n  unsigned int immutablep:1;\n  unsigned int freep:1;\n  unsigned int brokenp:1;\n  unsigned int syntacticp:1;\n  unsigned int copyonwritep:1;\n#if SEXP_USE_TRACK_ALLOC_SOURCE\n  const char* source;\n  void* backtrace[SEXP_BACKTRACE_SIZE];\n#endif\n#if SEXP_USE_HEADER_MAGIC\n  unsigned int magic;\n#endif\n  union {\n    /* basic types */\n    double flonum;\n    char flonum_bits[sizeof(double)];  /* for eqv? comparison on flonums */\n    struct sexp_type_struct type;\n    struct {\n      sexp car, cdr;\n      sexp source;\n    } pair;\n    struct {\n      sexp_uint_t length;\n    } vector;\n    struct {\n      sexp_uint_t length;\n    } bytes;\n    struct {\n      sexp bytes;\n      unsigned char element_type;\n      sexp_sint_t length;\n    } uvector;\n    struct {\n#if SEXP_USE_PACKED_STRINGS\n#if SEXP_USE_STRING_INDEX_TABLE\n      sexp charlens;\n#endif\n      sexp_uint_t length;\n#else\n      sexp bytes;\n#if SEXP_USE_STRING_INDEX_TABLE\n      sexp charlens;\n#elif SEXP_USE_STRING_REF_CACHE\n      sexp_uint_t cached_char_idx;\n      sexp cached_cursor;\n#endif\n      sexp_uint_t offset, length;\n#endif\n    } string;\n    struct {\n      sexp_uint_t length;\n    } symbol;\n    struct {\n      sexp name;\n      sexp cookie;\n      sexp fd;\n      FILE *stream;\n      char *buf;\n      char openp, bidirp, binaryp, shutdownp, no_closep, sourcep,\n        blockedp, fold_casep;\n      sexp_uint_t offset, line, flags;\n      size_t size;\n    } port;\n    struct {\n      char openp, no_closep;\n      sexp_sint_t fd, count;\n    } fileno;\n    struct {\n      sexp kind, message, irritants, procedure, source, stack_trace;\n    } exception;\n    struct {\n      signed char sign;\n      sexp_uint_t length;\n    } bignum;\n    struct {\n      sexp numerator, denominator;\n    } ratio;\n    struct {\n      sexp real, imag;\n    } complex;\n    struct {\n      sexp parent;\n      sexp_uint_t length;\n      void *value;\n    } cpointer;\n    /* runtime types */\n    struct {\n      sexp parent, lambda, bindings;\n#if SEXP_USE_STABLE_ABI || SEXP_USE_RENAME_BINDINGS\n      sexp renames;\n#endif\n    } env;\n    struct {\n      sexp name, literals, source;\n      sexp_uint_t length, max_depth;\n    } bytecode;\n    struct {\n      sexp bc, vars;\n      char flags;  /* a boxed fixnum truncated to char */\n      sexp_proc_num_args_t num_args;\n    } procedure;\n    struct {\n      sexp proc, env, source, aux;\n    } macro;\n    struct {\n      sexp env, free_vars, expr, rename;\n    } synclo;\n    struct {\n      sexp file;\n      void* handle;\n    } dl;\n    struct sexp_opcode_struct opcode;\n    struct sexp_core_form_struct core;\n    /* ast types */\n    struct {\n      sexp name, params, body, defs, locals, flags, fv, sv, ret, types, source;\n    } lambda;\n    struct {\n      sexp test, pass, fail, source;\n    } cnd;\n    struct {\n      sexp var, value, source;\n    } set;\n    struct {\n      sexp var, value, source;\n    } set_syn;\n    struct {\n      sexp name, cell, source;\n    } ref;\n    struct {\n      sexp ls, source;\n    } seq;\n    struct {\n      sexp value, source;\n    } lit;\n    /* compiler state */\n    struct {\n      sexp_uint_t length, top;\n    } stack;\n    struct {\n      sexp stack, env, parent, child,\n        globals, dk, params, proc, name, specific, event, result;\n#if SEXP_USE_STABLE_ABI || SEXP_USE_DL\n      sexp dl;\n#endif\n      sexp_heap heap;\n      struct sexp_mark_stack_ptr_t mark_stack[SEXP_MARK_STACK_COUNT];\n      struct sexp_mark_stack_ptr_t *mark_stack_ptr;\n      struct sexp_gc_var_t *saves;\n#if SEXP_USE_GREEN_THREADS\n      sexp_sint_t refuel;\n      unsigned char* ip;\n      struct timeval tval;\n#endif\n      char tailp, tracep, timeoutp, waitp, errorp, interruptp;\n      sexp_uint_t last_fp;\n      sexp_uint_t gc_count;\n#if SEXP_USE_TIME_GC\n      sexp_uint_t gc_usecs;\n#endif\n#if SEXP_USE_TRACK_ALLOC_TIMES\n      sexp_uint_t alloc_count, alloc_usecs;\n      double alloc_usecs_sq;\n#endif\n#if SEXP_USE_TRACK_ALLOC_SIZES\n      sexp_uint_t alloc_histogram[SEXP_ALLOC_HISTOGRAM_BUCKETS];\n#endif\n    } context;\n#if SEXP_USE_STABLE_ABI || SEXP_USE_AUTO_FORCE\n    struct {\n      sexp value;\n      int donep;\n    } promise;\n#endif\n#if SEXP_USE_STABLE_ABI || SEXP_USE_WEAK_REFERENCES\n    struct {\n      sexp key, value;\n    } ephemeron;\n#endif\n  } value;\n};\n\n#define SEXP_MAKE_IMMEDIATE(n)  ((sexp) ((n<<SEXP_EXTENDED_BITS) \\\n                                          + SEXP_EXTENDED_TAG))\n\n#define SEXP_FALSE  SEXP_MAKE_IMMEDIATE(0) /* 14 0x0e */\n#define SEXP_TRUE   SEXP_MAKE_IMMEDIATE(1) /* 30 0x1e */\n#define SEXP_NULL   SEXP_MAKE_IMMEDIATE(2) /* 46 0x2e */\n#define SEXP_EOF    SEXP_MAKE_IMMEDIATE(3) /* 62 0x3e */\n#define SEXP_VOID   SEXP_MAKE_IMMEDIATE(4) /* the unspecified value */\n#define SEXP_UNDEF  SEXP_MAKE_IMMEDIATE(5) /* internal use */\n#define SEXP_CLOSE  SEXP_MAKE_IMMEDIATE(6) /* internal use */\n#define SEXP_RAWDOT SEXP_MAKE_IMMEDIATE(7) /* internal use */\n#define SEXP_STRING_OPORT SEXP_MAKE_IMMEDIATE(8)  /* internal use */\n#define SEXP_TRAMPOLINE   SEXP_MAKE_IMMEDIATE(9)  /* internal use */\n#define SEXP_UNCAUGHT     SEXP_MAKE_IMMEDIATE(10) /* internal use */\n#define SEXP_ABI_ERROR    SEXP_MAKE_IMMEDIATE(11) /* internal use */\n#if SEXP_USE_OBJECT_BRACE_LITERALS\n#define SEXP_CLOSE_BRACE  SEXP_MAKE_IMMEDIATE(12) /* internal use */\n#endif\n\n#if SEXP_USE_LIMITED_MALLOC\nvoid* sexp_malloc(size_t size);\nvoid sexp_free(void* ptr);\n#else\n#define sexp_malloc malloc\n#define sexp_free free\n#endif\n\n#if SEXP_USE_BOEHM\n\n#define sexp_gc(ctx, sum)\n\n#define sexp_gc_var(x, y)            sexp x = SEXP_VOID;\n#define sexp_gc_preserve(ctx, x, y)\n#define sexp_gc_release(ctx, x, y)\n\n#define sexp_preserve_object(ctx, x)\n#define sexp_release_object(ctx, x)\n\n#include \"gc/gc.h\"\n#define sexp_alloc(ctx, size)        GC_malloc(size)\n#define sexp_alloc_atomic(ctx, size) GC_malloc_atomic(size)\n\n#else\n\nSEXP_API sexp sexp_gc(sexp ctx, size_t *sum_freed);\n\n#define sexp_gc_var(x, y)                       \\\n  sexp x = SEXP_VOID;                           \\\n  struct sexp_gc_var_t y = {NULL, NULL};\n\n#if SEXP_USE_DEBUG_GC\n#define sexp_gc_preserve_name(ctx, x, y) (y).name = #x\n#else\n#define sexp_gc_preserve_name(ctx, x, y)\n#endif\n\n#define sexp_gc_preserve(ctx, x, y)     \\\n  do {                                  \\\n    sexp_gc_preserve_name(ctx, x, y);   \\\n    (y).var = &(x);                     \\\n    (y).next = sexp_context_saves(ctx); \\\n    sexp_context_saves(ctx) = &(y);     \\\n  } while (0)\n\n#define sexp_gc_release(ctx, x, y)   (sexp_context_saves(ctx) = y.next)\n\nSEXP_API void sexp_preserve_object(sexp ctx, sexp x);\nSEXP_API void sexp_release_object(sexp ctx, sexp x);\n\n#if SEXP_USE_MALLOC\n#define sexp_alloc(ctx, size)        sexp_malloc(size)\n#define sexp_alloc_atomic(ctx, size) sexp_malloc(size)\n#else  /* native gc */\nvoid* sexp_alloc(sexp ctx, size_t size);\n#define sexp_alloc_atomic            sexp_alloc\n#endif\n#endif\n\n#define sexp_gc_var1(x) sexp_gc_var(x, __sexp_gc_preserver1)\n#define sexp_gc_var2(x, y) sexp_gc_var1(x) sexp_gc_var(y, __sexp_gc_preserver2)\n#define sexp_gc_var3(x, y, z) sexp_gc_var2(x, y) sexp_gc_var(z, __sexp_gc_preserver3)\n#define sexp_gc_var4(x, y, z, w) sexp_gc_var3(x, y, z) sexp_gc_var(w, __sexp_gc_preserver4)\n#define sexp_gc_var5(x, y, z, w, v) sexp_gc_var4(x, y, z, w) sexp_gc_var(v, __sexp_gc_preserver5)\n#define sexp_gc_var6(x, y, z, w, v, u) sexp_gc_var5(x, y, z, w, v) sexp_gc_var(u, __sexp_gc_preserver6)\n#define sexp_gc_var7(x, y, z, w, v, u, t) sexp_gc_var6(x, y, z, w, v, u) sexp_gc_var(t, __sexp_gc_preserver7)\n\n#define sexp_gc_preserve1(ctx, x) sexp_gc_preserve(ctx, x, __sexp_gc_preserver1)\n#define sexp_gc_preserve2(ctx, x, y) sexp_gc_preserve1(ctx, x); sexp_gc_preserve(ctx, y, __sexp_gc_preserver2)\n#define sexp_gc_preserve3(ctx, x, y, z) sexp_gc_preserve2(ctx, x, y); sexp_gc_preserve(ctx, z, __sexp_gc_preserver3)\n#define sexp_gc_preserve4(ctx, x, y, z, w) sexp_gc_preserve3(ctx, x, y, z); sexp_gc_preserve(ctx, w, __sexp_gc_preserver4)\n#define sexp_gc_preserve5(ctx, x, y, z, w, v) sexp_gc_preserve4(ctx, x, y, z, w); sexp_gc_preserve(ctx, v, __sexp_gc_preserver5)\n#define sexp_gc_preserve6(ctx, x, y, z, w, v, u) sexp_gc_preserve5(ctx, x, y, z, w, v); sexp_gc_preserve(ctx, u, __sexp_gc_preserver6)\n#define sexp_gc_preserve7(ctx, x, y, z, w, v, u, t) sexp_gc_preserve6(ctx, x, y, z, w, v, u); sexp_gc_preserve(ctx, t, __sexp_gc_preserver7)\n\n#define sexp_gc_release1(ctx) sexp_gc_release(ctx, NULL, __sexp_gc_preserver1)\n#define sexp_gc_release2(ctx) sexp_gc_release(ctx, NULL, __sexp_gc_preserver1)\n#define sexp_gc_release3(ctx) sexp_gc_release(ctx, NULL, __sexp_gc_preserver1)\n#define sexp_gc_release4(ctx) sexp_gc_release(ctx, NULL, __sexp_gc_preserver1)\n#define sexp_gc_release5(ctx) sexp_gc_release(ctx, NULL, __sexp_gc_preserver1)\n#define sexp_gc_release6(ctx) sexp_gc_release(ctx, NULL, __sexp_gc_preserver1)\n#define sexp_gc_release7(ctx) sexp_gc_release(ctx, NULL, __sexp_gc_preserver1)\n\n#define sexp_align(n, bits) (((n)+(1<<(bits))-1)&(((sexp_uint_t)-1)-((1<<(bits))-1)))\n\n#if SEXP_64_BIT\n#define sexp_word_align(n) sexp_align((n), 3)\n#else\n#define sexp_word_align(n) sexp_align((n), 2)\n#endif\n\n#define sexp_sizeof(x) (offsetof(struct sexp_struct, value) \\\n                         + sizeof(((sexp)0)->value.x))\n#define sexp_offsetof(type, f) (offsetof(struct sexp_struct, value.type.f))\n#define sexp_offsetof_slot0 (offsetof(struct sexp_struct, value))\n#define sexp_sizeof_header (sexp_sizeof(flonum) - sizeof(double))\n\n#if SEXP_USE_TRACK_ALLOC_SOURCE\n#define sexp_with_current_source0(file, line) file \": \" #line\n#define sexp_with_current_source(file, line) , sexp_with_current_source0(file, line)\n#else\n#define sexp_with_current_source(file, line)\n#endif\n\n#define sexp_alloc_tagged(ctx, size, tag) sexp_alloc_tagged_aux(ctx, size, tag sexp_with_current_source(__FILE__, __LINE__))\n\n#define sexp_alloc_type(ctx, type, tag) sexp_alloc_tagged(ctx, sexp_sizeof(type), tag)\n#define sexp_alloc_bytecode(ctx, i) sexp_alloc_tagged(ctx, sexp_sizeof(bytecode) + i, SEXP_BYTECODE)\n\n#if SEXP_USE_BIGNUMS\n#include \"chibi/bignum.h\"\n#endif\n\n/***************************** predicates *****************************/\n\n#define sexp_truep(x)    ((x) != SEXP_FALSE)\n#define sexp_not(x)      ((x) == SEXP_FALSE)\n\n#define sexp_nullp(x)    ((x) == SEXP_NULL)\n#define sexp_pointerp(x) (((sexp_uint_t)(x) & SEXP_POINTER_MASK) == SEXP_POINTER_TAG)\n#define sexp_fixnump(x)  (((sexp_uint_t)(x) & SEXP_FIXNUM_MASK) == SEXP_FIXNUM_TAG)\n#if SEXP_USE_DISJOINT_STRING_CURSORS\n#define sexp_string_cursorp(x)  (((sexp_uint_t)(x) & SEXP_STRING_CURSOR_MASK) == SEXP_STRING_CURSOR_TAG)\n#else\n#define sexp_string_cursorp(x) sexp_fixnump(x)\n#endif\n#define sexp_isymbolp(x) (((sexp_uint_t)(x) & SEXP_IMMEDIATE_MASK) == SEXP_ISYMBOL_TAG)\n#define sexp_charp(x)    (((sexp_uint_t)(x) & SEXP_EXTENDED_MASK) == SEXP_CHAR_TAG)\n#define sexp_reader_labelp(x) (((sexp_uint_t)(x) & SEXP_EXTENDED_MASK) == SEXP_READER_LABEL_TAG)\n#define sexp_booleanp(x) (((x) == SEXP_TRUE) || ((x) == SEXP_FALSE))\n\n#define sexp_pointer_tag(x)      ((x)->tag)\n#define sexp_markedp(x)          ((x)->markedp)\n#define sexp_flags(x)            ((x)->flags)\n#define sexp_immutablep(x)       ((x)->immutablep)\n#define sexp_mutablep(x)         (!(x)->immutablep)\n#define sexp_freep(x)            ((x)->freep)\n#define sexp_brokenp(x)          ((x)->brokenp)\n#define sexp_pointer_magic(x)    ((x)->magic)\n#define sexp_copy_on_writep(x)   ((x)->copyonwritep)\n\n#if SEXP_USE_TRACK_ALLOC_SOURCE\n#define sexp_pointer_source(x)   ((x)->source)\n#else\n#define sexp_pointer_source(x)   \"\"\n#endif\n\n#define sexp_check_tag(x,t)  (sexp_pointerp(x) && (sexp_pointer_tag(x) == (t)))\n\n#define sexp_slot_ref(x,i)   (((sexp*)&((x)->value))[i])\n#define sexp_slot_set(x,i,v) (((sexp*)&((x)->value))[i] = (v))\n\n#define sexp_isa(a, b) (sexp_pointerp(a) && sexp_typep(b) && (sexp_pointer_tag(a) == sexp_type_tag(b)))\n\nunion sexp_flonum_conv {\n  float flonum;\n  unsigned int bits;\n};\n\n#if SEXP_USE_IMMEDIATE_FLONUMS\n#define sexp_flonump(x)      (((sexp_uint_t)(x) & SEXP_EXTENDED_MASK) == SEXP_IFLONUM_TAG)\nSEXP_API sexp sexp_flonum_predicate (sexp ctx, sexp x);\n#if SEXP_64_BIT\nSEXP_API float sexp_flonum_value (sexp x);\n#define sexp_flonum_value_set(f, x) (f = sexp_make_flonum(NULL, x))\n#define sexp_flonum_bits(f) ((char*)&f)\nSEXP_API sexp sexp_make_flonum(sexp ctx, float f);\n#else\n#define sexp_make_flonum(ctx, x)  ((sexp) ((((union sexp_flonum_conv)((float)(x))).bits & ~SEXP_EXTENDED_MASK) + SEXP_IFLONUM_TAG))\n#define sexp_flonum_value(x) (((union sexp_flonum_conv)(((unsigned int)(x)) & ~SEXP_EXTENDED_MASK)).flonum)\n#endif\n#else\n#define sexp_flonump(x)      (sexp_check_tag(x, SEXP_FLONUM))\n#define sexp_flonum_value(f) ((f)->value.flonum)\n#define sexp_flonum_value_set(f, x) ((f)->value.flonum = x)\n#define sexp_flonum_bits(f) ((f)->value.flonum_bits)\nSEXP_API sexp sexp_make_flonum(sexp ctx, double f);\n#endif\n\n#define sexp_typep(x)       (sexp_check_tag(x, SEXP_TYPE))\n#define sexp_pairp(x)       (sexp_check_tag(x, SEXP_PAIR))\n#define sexp_stringp(x)     (sexp_check_tag(x, SEXP_STRING))\n#define sexp_lsymbolp(x)    (sexp_check_tag(x, SEXP_SYMBOL))\n#define sexp_bytesp(x)      (sexp_check_tag(x, SEXP_BYTES))\n#define sexp_vectorp(x)     (sexp_check_tag(x, SEXP_VECTOR))\n#define sexp_iportp(x)      (sexp_check_tag(x, SEXP_IPORT))\n#if SEXP_USE_BIDIRECTIONAL_PORTS\n#define sexp_oportp(x)      (sexp_check_tag(x, SEXP_OPORT) || (sexp_check_tag(x, SEXP_IPORT) && sexp_port_bidirp(x)))\n#else\n#define sexp_oportp(x)      (sexp_check_tag(x, SEXP_OPORT))\n#endif\n#define sexp_filenop(x)     (sexp_check_tag(x, SEXP_FILENO))\n#if SEXP_USE_BIGNUMS\n#define sexp_bignump(x)     (sexp_check_tag(x, SEXP_BIGNUM))\n#else\n#define sexp_bignump(x)     0\n#endif\n#if SEXP_USE_RATIOS\n#define sexp_ratiop(x)      (sexp_check_tag(x, SEXP_RATIO))\n#else\n#define sexp_ratiop(x)      0\n#endif\n#if SEXP_USE_COMPLEX\n#define sexp_complexp(x)    (sexp_check_tag(x, SEXP_COMPLEX))\n#else\n#define sexp_complexp(x)    0\n#endif\n#define sexp_cpointerp(x)   (sexp_check_tag(x, SEXP_CPOINTER))\n#define sexp_exceptionp(x)  (sexp_check_tag(x, SEXP_EXCEPTION))\n#define sexp_procedurep(x)  (sexp_check_tag(x, SEXP_PROCEDURE))\n#define sexp_envp(x)        (sexp_check_tag(x, SEXP_ENV))\n#define sexp_bytecodep(x)   (sexp_check_tag(x, SEXP_BYTECODE))\n#define sexp_corep(x)       (sexp_check_tag(x, SEXP_CORE))\n#define sexp_dlp(x)         (sexp_check_tag(x, SEXP_DL))\n#define sexp_opcodep(x)     (sexp_check_tag(x, SEXP_OPCODE))\n#define sexp_macrop(x)      (sexp_check_tag(x, SEXP_MACRO))\n#define sexp_syntacticp(x)  (sexp_corep(x) || sexp_macrop(x))\n#define sexp_synclop(x)     (sexp_check_tag(x, SEXP_SYNCLO))\n#define sexp_lambdap(x)     (sexp_check_tag(x, SEXP_LAMBDA))\n#define sexp_cndp(x)        (sexp_check_tag(x, SEXP_CND))\n#define sexp_refp(x)        (sexp_check_tag(x, SEXP_REF))\n#define sexp_setp(x)        (sexp_check_tag(x, SEXP_SET))\n#define sexp_set_synp(x)    (sexp_check_tag(x, SEXP_SET_SYN))\n#define sexp_seqp(x)        (sexp_check_tag(x, SEXP_SEQ))\n#define sexp_litp(x)        (sexp_check_tag(x, SEXP_LIT))\n#define sexp_contextp(x)    (sexp_check_tag(x, SEXP_CONTEXT))\n#define sexp_promisep(x)    (sexp_check_tag(x, SEXP_PROMISE))\n#define sexp_ephemeronp(x)  (sexp_check_tag(x, SEXP_EPHEMERON))\n\n#if SEXP_USE_UNIFORM_VECTOR_LITERALS\n#define sexp_uvectorp(x)    (sexp_check_tag(x, SEXP_UNIFORM_VECTOR))\n#define sexp_u1vectorp(x)   (sexp_uvectorp(x) && sexp_uvector_type(x)==SEXP_U1)\n#define sexp_u8vectorp(x)   (sexp_bytesp(x))\n#define sexp_s8vectorp(x)   (sexp_uvectorp(x) && sexp_uvector_type(x)==SEXP_S8)\n#define sexp_u16vectorp(x)  (sexp_uvectorp(x) && sexp_uvector_type(x)==SEXP_U16)\n#define sexp_s16vectorp(x)  (sexp_uvectorp(x) && sexp_uvector_type(x)==SEXP_S16)\n#define sexp_u32vectorp(x)  (sexp_uvectorp(x) && sexp_uvector_type(x)==SEXP_U32)\n#define sexp_s32vectorp(x)  (sexp_uvectorp(x) && sexp_uvector_type(x)==SEXP_S32)\n#define sexp_u64vectorp(x)  (sexp_uvectorp(x) && sexp_uvector_type(x)==SEXP_U64)\n#define sexp_s64vectorp(x)  (sexp_uvectorp(x) && sexp_uvector_type(x)==SEXP_S64)\n#define sexp_f8vectorp(x)   (sexp_uvectorp(x) && sexp_uvector_type(x)==SEXP_F8)\n#define sexp_f16vectorp(x)  (sexp_uvectorp(x) && sexp_uvector_type(x)==SEXP_F16)\n#define sexp_f32vectorp(x)  (sexp_uvectorp(x) && sexp_uvector_type(x)==SEXP_F32)\n#define sexp_f64vectorp(x)  (sexp_uvectorp(x) && sexp_uvector_type(x)==SEXP_F64)\n#define sexp_c64vectorp(x)  (sexp_uvectorp(x) && sexp_uvector_type(x)==SEXP_C64)\n#define sexp_c128vectorp(x) (sexp_uvectorp(x) && sexp_uvector_type(x)==SEXP_C128)\n#else\n#define sexp_uvectorp(x)    (sexp_vectorp(x))\n#define sexp_u1vectorp(x)   (sexp_vectorp(x))\n#define sexp_u8vectorp(x)   (sexp_bytesp(x))\n#define sexp_s8vectorp(x)   (sexp_vectorp(x))\n#define sexp_u16vectorp(x)  (sexp_vectorp(x))\n#define sexp_s16vectorp(x)  (sexp_vectorp(x))\n#define sexp_u32vectorp(x)  (sexp_vectorp(x))\n#define sexp_s32vectorp(x)  (sexp_vectorp(x))\n#define sexp_u64vectorp(x)  (sexp_vectorp(x))\n#define sexp_s64vectorp(x)  (sexp_vectorp(x))\n#define sexp_f8vectorp(x)   (sexp_vectorp(x))\n#define sexp_f16vectorp(x)  (sexp_vectorp(x))\n#define sexp_f32vectorp(x)  (sexp_vectorp(x))\n#define sexp_f64vectorp(x)  (sexp_vectorp(x))\n#define sexp_c64vectorp(x)  (sexp_vectorp(x))\n#define sexp_c128vectorp(x) (sexp_vectorp(x))\n#endif\n\n#define sexp_applicablep(x) (sexp_procedurep(x) || sexp_opcodep(x))\n\n#if SEXP_USE_HUFF_SYMS\n#define sexp_symbolp(x)     (sexp_isymbolp(x) || sexp_lsymbolp(x))\n#else\n#define sexp_symbolp(x)     (sexp_lsymbolp(x))\n#endif\n\nSEXP_API sexp sexp_id_name(sexp x);\nSEXP_API int sexp_idp(sexp x);\n\n#define sexp_portp(x) (sexp_check_tag(x, SEXP_IPORT) || sexp_check_tag(x, SEXP_OPORT))\n\n#define sexp_stream_portp(x) (sexp_port_stream(x) != NULL)\n\n#define sexp_port_customp(x) (sexp_vectorp(sexp_port_cookie(x)) && sexp_vector_length(sexp_port_cookie(x)) == 6)\n\n/* only valid on custom ports */\n#define sexp_port_buffer(x)  (sexp_vector_ref(sexp_port_cookie(x), SEXP_ONE))\n#define sexp_port_reader(x)  (sexp_vector_ref(sexp_port_cookie(x), SEXP_TWO))\n#define sexp_port_writer(x)  (sexp_vector_ref(sexp_port_cookie(x), SEXP_THREE))\n#define sexp_port_seeker(x)  (sexp_vector_ref(sexp_port_cookie(x), SEXP_FOUR))\n#define sexp_port_closer(x)  (sexp_vector_ref(sexp_port_cookie(x), SEXP_FIVE))\n\n/***************************** constructors ****************************/\n\n#define sexp_make_boolean(x) ((x) ? SEXP_TRUE : SEXP_FALSE)\n#define sexp_unbox_boolean(x) (((x) == SEXP_FALSE) ? 0 : 1)\n\n#if SEXP_USE_SIGNED_SHIFTS\n#define sexp_make_fixnum(n)    ((sexp) ((((sexp_sint_t)(n))<<SEXP_FIXNUM_BITS) + SEXP_FIXNUM_TAG))\n#define sexp_unbox_fixnum(n)   (((sexp_sint_t)(n))>>SEXP_FIXNUM_BITS)\n#else\n#define sexp_make_fixnum(n)    ((sexp) ((((sexp_sint_t)(n))*(sexp_sint_t)((sexp_sint_t)1<<SEXP_FIXNUM_BITS)) | SEXP_FIXNUM_TAG))\n#define sexp_unbox_fixnum(n)   (((sexp_sint_t)((sexp_uint_t)(n) & ~SEXP_FIXNUM_TAG))/(sexp_sint_t)((sexp_sint_t)1<<SEXP_FIXNUM_BITS))\n#endif\n\n#define SEXP_NEG_ONE sexp_make_fixnum(-1)\n#define SEXP_ZERO    sexp_make_fixnum(0)\n#define SEXP_ONE     sexp_make_fixnum(1)\n#define SEXP_TWO     sexp_make_fixnum(2)\n#define SEXP_THREE   sexp_make_fixnum(3)\n#define SEXP_FOUR    sexp_make_fixnum(4)\n#define SEXP_FIVE    sexp_make_fixnum(5)\n#define SEXP_SIX     sexp_make_fixnum(6)\n#define SEXP_SEVEN   sexp_make_fixnum(7)\n#define SEXP_EIGHT   sexp_make_fixnum(8)\n#define SEXP_NINE    sexp_make_fixnum(9)\n#define SEXP_TEN     sexp_make_fixnum(10)\n\n#if SEXP_USE_DISJOINT_STRING_CURSORS\n#if SEXP_USE_SIGNED_SHIFTS\n#define sexp_make_string_cursor(n)    ((sexp) ((((sexp_sint_t)(n))<<SEXP_STRING_CURSOR_BITS) + SEXP_STRING_CURSOR_TAG))\n#define sexp_unbox_string_cursor(n)   (((sexp_sint_t)(n))>>SEXP_STRING_CURSOR_BITS)\n#else\n#define sexp_make_string_cursor(n)    ((sexp) ((((sexp_sint_t)(n))*(sexp_sint_t)(1uL<<SEXP_STRING_CURSOR_BITS)) | SEXP_STRING_CURSOR_TAG))\n#define sexp_unbox_string_cursor(n)   (((sexp_sint_t)((sexp_uint_t)(n) & ~SEXP_STRING_CURSOR_TAG))/(sexp_sint_t)(1uL<<SEXP_STRING_CURSOR_BITS))\n#endif\n#define sexp_string_cursor_to_fixnum(n) sexp_make_fixnum(sexp_unbox_string_cursor(n))\n#define sexp_fixnum_to_string_cursor(n) sexp_make_string_cursor(sexp_unbox_fixnum(n))\n#else\n#define sexp_make_string_cursor(n)    sexp_make_fixnum(n)\n#define sexp_unbox_string_cursor(n)   sexp_unbox_fixnum(n)\n#define sexp_string_cursor_to_fixnum(n) (n)\n#define sexp_fixnum_to_string_cursor(n) (n)\n#endif\n\n#define sexp_make_character(n)  ((sexp) ((((sexp_sint_t)(n))<<SEXP_EXTENDED_BITS) + SEXP_CHAR_TAG))\n#define sexp_unbox_character(n) ((int) (((sexp_sint_t)(n))>>SEXP_EXTENDED_BITS))\n\n#define sexp_make_reader_label(n)  ((sexp) ((((sexp_sint_t)(n))<<SEXP_EXTENDED_BITS) + SEXP_READER_LABEL_TAG))\n#define sexp_unbox_reader_label(n) ((int) (((sexp_sint_t)(n))>>SEXP_EXTENDED_BITS))\n\n#define sexp_fixnum_to_double(x) ((double)sexp_unbox_fixnum(x))\n\n#if SEXP_USE_PLACEHOLDER_DIGITS\n#define sexp_placeholder_digit_p(c) ((c) == SEXP_PLACEHOLDER_DIGIT)\n#else\n#define sexp_placeholder_digit_p(c) 0\n#endif\n\n#define sexp_placeholder_digit_value(base) ((base)/2)\n\n#if SEXP_USE_FLONUMS\n#define sexp_fp_integerp(x) (sexp_flonum_value(x) == trunc(sexp_flonum_value(x)))\n#define _or_integer_flonump(x) || (sexp_flonump(x) && sexp_fp_integerp(x))\n#else\n#define _or_integer_flonump(x)\n#endif\n\n#if SEXP_USE_BIGNUMS\nSEXP_API sexp sexp_make_integer_from_lsint(sexp ctx, sexp_lsint_t x);\nSEXP_API sexp sexp_make_unsigned_integer_from_luint(sexp ctx, sexp_luint_t x);\n#if SEXP_USE_CUSTOM_LONG_LONGS\nSEXP_API sexp sexp_make_integer(sexp ctx, long long x);\nSEXP_API sexp sexp_make_unsigned_integer(sexp ctx, unsigned long long x);\n#else\nSEXP_API sexp sexp_make_integer(sexp ctx, sexp_lsint_t x);\nSEXP_API sexp sexp_make_unsigned_integer(sexp ctx, sexp_luint_t x);\n#endif\n#define sexp_exact_integerp(x) (sexp_fixnump(x) || sexp_bignump(x))\n#else\n#define sexp_make_integer(ctx, x) sexp_make_fixnum(x)\n#define sexp_make_unsigned_integer(ctx, x) sexp_make_fixnum(x)\n#define sexp_exact_integerp(x) sexp_fixnump(x)\n#endif\n\n#define sexp_integerp(x) (sexp_exact_integerp(x) _or_integer_flonump(x))\n\n#if SEXP_USE_RATIOS\n#define sexp_exactp(x) (sexp_exact_integerp(x) || sexp_ratiop(x))\n#else\n#define sexp_exactp(x) sexp_exact_integerp(x)\n#endif\n\n#if SEXP_USE_FLONUMS\n#define sexp_fixnum_to_flonum(ctx, x) (sexp_make_flonum(ctx, sexp_unbox_fixnum(x)))\n#if SEXP_USE_RATIOS\n#define sexp_realp(x) (sexp_exact_integerp(x) || sexp_flonump(x) || sexp_ratiop(x))\n#else\n#define sexp_realp(x) (sexp_exact_integerp(x) || sexp_flonump(x))\n#endif\n#else\n#define sexp_fixnum_to_flonum(ctx, x) (x)\n#define sexp_realp(x) sexp_exact_integerp(x)\n#endif\n\n#if SEXP_USE_COMPLEX\n#define sexp_numberp(x) (sexp_realp(x) || sexp_complexp(x))\n#define sexp_real_part(x) (sexp_complexp(x) ? sexp_complex_real(x) : x)\n#define sexp_imag_part(x) (sexp_complexp(x) ? sexp_complex_imag(x) : SEXP_ZERO)\n#else\n#define sexp_numberp(x) (sexp_realp(x))\n#define sexp_real_part(x) (x)\n#define sexp_imag_part(x) SEXP_ZERO\n#endif\n\n#define sexp_exact_negativep(x) (sexp_fixnump(x) ? (sexp_unbox_fixnum(x) < 0) \\\n                                 : ((SEXP_USE_BIGNUMS && sexp_bignump(x)) \\\n                                    && (sexp_bignum_sign(x) < 0)))\n#define sexp_exact_positivep(x) (sexp_fixnump(x) ? (sexp_unbox_fixnum(x) > 0) \\\n                                 : ((SEXP_USE_BIGNUMS && sexp_bignump(x)) \\\n                                    && (sexp_bignum_sign(x) > 0)))\n#define sexp_negativep(x) (sexp_exact_negativep(x) ||                   \\\n                           (sexp_flonump(x) && sexp_flonum_value(x) < 0))\n#define sexp_positivep(x) (!(sexp_negativep(x)))\n#define sexp_pedantic_negativep(x) (                 \\\n  sexp_exact_negativep(x) ||                         \\\n  (sexp_ratiop(x) &&                                 \\\n   sexp_exact_negativep(sexp_ratio_numerator(x))) || \\\n  (sexp_flonump(x) &&                                \\\n   ((sexp_flonum_value(x) < 0) ||                    \\\n    (sexp_flonum_value(x) == 0 &&                    \\\n     1.0 / sexp_flonum_value(x) < 0))))\n\n#if SEXP_USE_BIGNUMS\n#define sexp_oddp(x) (sexp_fixnump(x) ? sexp_unbox_fixnum(x) & 1 : \\\n                      sexp_bignump(x) && (sexp_bignum_data(x)[0] & 1))\n#else\n#define sexp_oddp(x) (sexp_fixnump(x) && (sexp_unbox_fixnum(x) & 1))\n#endif\n#define sexp_evenp(x) (!(sexp_oddp(x)))\n\n#define sexp_negate_exact(x)                            \\\n  if (sexp_bignump(x))                                  \\\n    sexp_bignum_sign(x) = -sexp_bignum_sign(x);         \\\n  else if (sexp_fixnump(x))                             \\\n    x = sexp_fx_neg(x);\n\n#if SEXP_USE_IMMEDIATE_FLONUMS\n#define sexp_negate_flonum(x) (x) = sexp_make_flonum(NULL, -(sexp_flonum_value(x)))\n#else\n#define sexp_negate_flonum(x) sexp_flonum_value(x) = -(sexp_flonum_value(x))\n#endif\n\n/* TODO: Doesn't support x == SEXP_MIN_FIXNUM. */\n#define sexp_negate(x)                                  \\\n  if (sexp_flonump(x))                                  \\\n    sexp_negate_flonum(x);                              \\\n  else                                                  \\\n    sexp_negate_exact(x)\n\n#define sexp_negate_maybe_ratio(x)                      \\\n  if (sexp_ratiop(x)) {                                 \\\n    sexp_negate_exact(sexp_ratio_numerator(x));         \\\n  } else {                                              \\\n    sexp_negate(x);                                     \\\n  }\n\n#if SEXP_USE_FLONUMS || SEXP_USE_BIGNUMS\n\n#if SEXP_64_BIT\n#define sexp_bignum_to_sint(x) (sexp_bignum_sign(x)*sexp_bignum_data(x)[0])\n#define sexp_bignum_to_uint(x) (sexp_bignum_data(x)[0])\n#else\nSEXP_API long long sexp_bignum_to_sint(sexp x);\nSEXP_API unsigned long long sexp_bignum_to_uint(sexp x);\n#endif\n\n#define sexp_uint_value(x) ((unsigned long long)(sexp_fixnump(x) ? sexp_unbox_fixnum(x) : sexp_bignump(x) ? sexp_bignum_to_uint(x) : 0))\n#define sexp_sint_value(x) ((long long)(sexp_fixnump(x) ? sexp_unbox_fixnum(x) : sexp_bignump(x) ? sexp_bignum_to_sint(x) : 0))\n\n#else\n\n#define sexp_uint_value(x) ((sexp_uint_t)sexp_unbox_fixnum(x))\n#define sexp_sint_value(x) ((sexp_sint_t)sexp_unbox_fixnum(x))\n\n#endif\t/* SEXP_USE_FLONUMS || SEXP_USE_BIGNUMS */\n\n#define sexp_shift_epoch(x) ((x)-SEXP_EPOCH_OFFSET)\n#define sexp_unshift_epoch(x) ((x)+SEXP_EPOCH_OFFSET)\n\n#define sexp_infp(x) (sexp_flonump(x) && isinf(sexp_flonum_value(x)))\n#define sexp_nanp(x) (sexp_flonump(x) && isnan(sexp_flonum_value(x)))\n\n#if SEXP_USE_IEEE_EQV\n#define sexp_flonum_eqv(x, y) (memcmp(sexp_flonum_bits(x), sexp_flonum_bits(y), sizeof(double)) == 0)\n#else\n#define sexp_flonum_eqv(x, y) (sexp_flonum_value(x) == sexp_flonum_value(y))\n#endif\n\n#if SEXP_USE_MINI_FLOAT_UNIFORM_VECTORS\nSEXP_API double sexp_quarter_to_double(unsigned char q);\nSEXP_API unsigned char sexp_double_to_quarter(double f);\nSEXP_API double sexp_half_to_double(unsigned short x);\nSEXP_API unsigned short sexp_double_to_half(double x);\n#endif\n\n/*************************** field accessors **************************/\n\n#if SEXP_USE_SAFE_ACCESSORS\n#if 0\n#define sexp_field(x, type, id, field) (*(((x) && sexp_check_tag(x, id)) ? &((x)->value.type.field) : (fprintf(stderr, \"invalid field access in %s line %d: %p (%d) isn't a \"#type\"\\n\", __FILE__, __LINE__, x, (int)(sexp_pointerp(x) ? sexp_pointer_tag(x) : -1)), &(((sexp)NULL)->value.type.field))))\n#define sexp_pred_field(x, type, pred, field) (*(((x) && pred(x)) ? &((x)->value.type.field) : (fprintf(stderr, \"invalid field access in %s line %d: %p (%d) isn't a \"#type\"\\n\", __FILE__, __LINE__, x, (int)(sexp_pointerp(x) ? sexp_pointer_tag(x) : -1)), &(((sexp)NULL)->value.type.field))))\n#define sexp_cpointer_field(x, field) (*(((x) && sexp_pointerp(x) && sexp_pointer_tag(x) >= SEXP_CPOINTER) ? &((x)->value.cpointer.field) : (fprintf(stderr, \"invalid field access in %s line %d: %p (%d) isn't a cpointer\\n\", __FILE__, __LINE__, x, (int)(sexp_pointerp(x) ? sexp_pointer_tag(x) : -1)), &(((sexp)NULL)->value.cpointer.field))))\n#else\n#define sexp_field(x, type, id, field) (*({sexp _x=x; (((_x) && sexp_check_tag(_x, id)) ? &((_x)->value.type.field) : (fprintf(stderr, \"invalid field access in %s line %d: %p (%d) isn't a \"#type\"\\n\", __FILE__, __LINE__, _x, (int)(sexp_pointerp(_x) ? sexp_pointer_tag(_x) : -1)), &(((sexp)NULL)->value.type.field)));}))\n#define sexp_pred_field(x, type, pred, field) (*({sexp _x=x; (((_x) && pred(_x)) ? &((_x)->value.type.field) : (fprintf(stderr, \"invalid field access in %s line %d: %p (%d) isn't a \"#type\"\\n\", __FILE__, __LINE__, _x, (int)(sexp_pointerp(_x) ? sexp_pointer_tag(_x) : -1)), &(((sexp)NULL)->value.type.field)));}))\n#define sexp_cpointer_field(x, field) (*({sexp _x=x; (((_x) && sexp_pointerp(_x) && sexp_pointer_tag(_x) >= SEXP_CPOINTER) ? &((_x)->value.cpointer.field) : (fprintf(stderr, \"invalid field access in %s line %d: %p (%d) isn't a cpointer\\n\", __FILE__, __LINE__, _x, (int)(sexp_pointerp(_x) ? sexp_pointer_tag(_x) : -1)), &(((sexp)NULL)->value.cpointer.field)));}))\n#endif\n#else\n#define sexp_field(x, type, id, field) ((x)->value.type.field)\n#define sexp_pred_field(x, type, pred, field) ((x)->value.type.field)\n#define sexp_cpointer_field(x, field) ((x)->value.cpointer.field)\n#endif\n\n#define sexp_flexible_array_field(x, type, field_type) \\\n  ((field_type*)((char*)(x)+sexp_sizeof(type)))\n\n#define sexp_vector_length(x) (sexp_field(x, vector, SEXP_VECTOR, length))\n#define sexp_vector_data(x)   sexp_flexible_array_field(x, vector, sexp)\n\n#if SEXP_USE_SAFE_VECTOR_ACCESSORS\n#define sexp_vector_ref(x,i)   (sexp_unbox_fixnum(i)>=0 && sexp_unbox_fixnum(i)<sexp_vector_length(x) ? sexp_vector_data(x)[sexp_unbox_fixnum(i)] : (fprintf(stderr, \"vector-ref length out of range %s on line %d: vector %p (length %lu): %ld\\n\", __FILE__, __LINE__, x, sexp_vector_length(x), sexp_unbox_fixnum(i)), SEXP_VOID))\n#define sexp_vector_set(x,i,v) (sexp_unbox_fixnum(i)>=0 && sexp_unbox_fixnum(i)<sexp_vector_length(x) ? sexp_vector_data(x)[sexp_unbox_fixnum(i)]=(v) : (fprintf(stderr, \"vector-set! length out of range in %s on line %d: vector %p (length %lu): %ld\\n\", __FILE__, __LINE__, x, sexp_vector_length(x), sexp_unbox_fixnum(i)), SEXP_VOID))\n#else\n#define sexp_vector_ref(x,i)   (sexp_vector_data(x)[sexp_unbox_fixnum(i)])\n#define sexp_vector_set(x,i,v) (sexp_vector_data(x)[sexp_unbox_fixnum(i)]=(v))\n#endif\n\n#define sexp_procedure_num_args(x)   (sexp_field(x, procedure, SEXP_PROCEDURE, num_args))\n#define sexp_procedure_flags(x)      (sexp_field(x, procedure, SEXP_PROCEDURE, flags))\n#define sexp_procedure_variadic_p(x) (sexp_unbox_fixnum(sexp_procedure_flags(x)) & SEXP_PROC_VARIADIC)\n#define sexp_procedure_unused_rest_p(x) (sexp_unbox_fixnum(sexp_procedure_flags(x)) & SEXP_PROC_UNUSED_REST)\n#define sexp_procedure_variable_transformer_p(x) (sexp_unbox_fixnum(sexp_procedure_flags(x)) & SEXP_PROC_VARIABLE_TRANSFORMER)\n#define sexp_procedure_code(x)       (sexp_field(x, procedure, SEXP_PROCEDURE, bc))\n#define sexp_procedure_vars(x)       (sexp_field(x, procedure, SEXP_PROCEDURE, vars))\n#define sexp_procedure_source(x)     sexp_bytecode_source(sexp_procedure_code(x))\n\n#define sexp_bytes_length(x)  (sexp_field(x, bytes, SEXP_BYTES, length))\n#define sexp_bytes_data(x)   sexp_flexible_array_field(x, bytes, char)\n#define sexp_bytes_maybe_null_data(x) (sexp_not(x) ? NULL : sexp_bytes_data(x))\n\nstatic const unsigned char sexp_uvector_sizes[] = {\n  0, 1, 8, 8, 16, 16, 32, 32, 64, 64, 32, 64, 64, 128, 8, 16};\nstatic const unsigned char sexp_uvector_chars[] = \"#ususususuffccff\";\n\nenum sexp_uniform_vector_type {\n  SEXP_NOT_A_UNIFORM_TYPE,\n  SEXP_U1,\n  SEXP_S8,\n  SEXP_U8,\n  SEXP_S16,\n  SEXP_U16,\n  SEXP_S32,\n  SEXP_U32,\n  SEXP_S64,\n  SEXP_U64,\n  SEXP_F32,\n  SEXP_F64,\n  SEXP_C64,\n  SEXP_C128,\n  SEXP_F8,\n  SEXP_F16,\n  SEXP_END_OF_UNIFORM_TYPES\n};\n\n#define sexp_uvector_freep(x) (sexp_freep(x))\n#define sexp_uvector_element_size(uvt) (sexp_uvector_sizes[uvt])\n#define sexp_uvector_prefix(uvt) (sexp_uvector_chars[uvt])\n\n#define sexp_uvector_length(x) (sexp_field(x, uvector, SEXP_UNIFORM_VECTOR, length))\n#define sexp_uvector_type(x)   (sexp_field(x, uvector, SEXP_UNIFORM_VECTOR, element_type))\n#define sexp_uvector_data(x) sexp_bytes_data(sexp_uvector_bytes(x))\n#define sexp_uvector_maybe_null_data(x) (sexp_not(x) ? NULL : sexp_uvector_data(x))\n#define sexp_uvector_bytes(x)  (sexp_field(x, uvector, SEXP_UNIFORM_VECTOR, bytes))\n\n#define sexp_bit_ref(u1v, i)    (((sexp_uvector_data(u1v)[i/8])>>(i%8))&1)\n#define sexp_bit_set(u1v, i, x) (x ? (sexp_uvector_data(u1v)[i/8]|=(1<<(i%8))) : (sexp_uvector_data(u1v)[i/8]&=~(1<<(i%8))))\n\n#define sexp_string_size(x)     (sexp_field(x, string, SEXP_STRING, length))\n#define sexp_string_charlens(x) (sexp_field(x, string, SEXP_STRING, charlens))\n#if SEXP_USE_PACKED_STRINGS\n#define sexp_string_data(x)   sexp_flexible_array_field(x, string, char)\n#define sexp_string_bytes(x)  (x)\n#else\n#define sexp_string_bytes(x)  (sexp_field(x, string, SEXP_STRING, bytes))\n#define sexp_string_offset(x) (sexp_field(x, string, SEXP_STRING, offset))\n#define sexp_string_data(x)   (sexp_bytes_data(sexp_string_bytes(x))+sexp_string_offset(x))\n#endif\n#if SEXP_USE_STRING_REF_CACHE\n#define sexp_cached_char_idx(x) (sexp_field(x, string, SEXP_STRING, cached_char_idx))\n#define sexp_cached_cursor(x) (sexp_field(x, string, SEXP_STRING, cached_cursor))\n#endif\n#define sexp_string_maybe_null_data(x) (sexp_not(x) ? NULL : sexp_string_data(x))\n\n#if SEXP_USE_PACKED_STRINGS\n#define sexp_string_to_bytes(ctx, x)  ((x)->tag = SEXP_BYTES, x)\n#else\n#define sexp_string_to_bytes(ctx, x)  sexp_string_bytes(x)\n#endif\n\n#define sexp_bytes_ref(x, i)    (sexp_make_fixnum((unsigned char)sexp_bytes_data(x)[sexp_unbox_fixnum(i)]))\n#define sexp_bytes_set(x, i, v) (sexp_bytes_data(x)[sexp_unbox_fixnum(i)] = sexp_unbox_fixnum(v))\n\n#define sexp_lsymbol_data(x)   sexp_flexible_array_field(x, symbol, char)\n#define sexp_lsymbol_length(x) (sexp_field(x, symbol, SEXP_SYMBOL, length))\n\n#define sexp_port_stream(p)     (sexp_pred_field(p, port, sexp_portp, stream))\n#define sexp_port_name(p)       (sexp_pred_field(p, port, sexp_portp, name))\n#define sexp_port_line(p)       (sexp_pred_field(p, port, sexp_portp, line))\n#define sexp_port_openp(p)      (sexp_pred_field(p, port, sexp_portp, openp))\n#define sexp_port_bidirp(p)     (sexp_pred_field(p, port, sexp_portp, bidirp))\n#define sexp_port_binaryp(p)    (sexp_pred_field(p, port, sexp_portp, binaryp))\n#define sexp_port_shutdownp(p)  (sexp_pred_field(p, port, sexp_portp, shutdownp))\n#define sexp_port_no_closep(p)  (sexp_pred_field(p, port, sexp_portp, no_closep))\n#define sexp_port_sourcep(p)    (sexp_pred_field(p, port, sexp_portp, sourcep))\n#define sexp_port_blockedp(p)   (sexp_pred_field(p, port, sexp_portp, blockedp))\n#define sexp_port_fold_casep(p) (sexp_pred_field(p, port, sexp_portp, fold_casep))\n#define sexp_port_cookie(p)     (sexp_pred_field(p, port, sexp_portp, cookie))\n#define sexp_port_buf(p)        (sexp_pred_field(p, port, sexp_portp, buf))\n#define sexp_port_size(p)       (sexp_pred_field(p, port, sexp_portp, size))\n#define sexp_port_offset(p)     (sexp_pred_field(p, port, sexp_portp, offset))\n#define sexp_port_flags(p)      (sexp_pred_field(p, port, sexp_portp, flags))\n#define sexp_port_fd(p)         (sexp_pred_field(p, port, sexp_portp, fd))\n\n#define sexp_fileno_fd(f)        (sexp_pred_field(f, fileno, sexp_filenop, fd))\n#define sexp_fileno_count(f)     (sexp_pred_field(f, fileno, sexp_filenop, count))\n#define sexp_fileno_openp(f)     (sexp_pred_field(f, fileno, sexp_filenop, openp))\n#define sexp_fileno_socketp(f)   (sexp_pred_field(f, fileno, sexp_filenop, socketp))\n#define sexp_fileno_no_closep(f) (sexp_pred_field(f, fileno, sexp_filenop, no_closep))\n\n#define sexp_ratio_numerator(q)   (sexp_pred_field(q, ratio, sexp_ratiop, numerator))\n#define sexp_ratio_denominator(q) (sexp_pred_field(q, ratio, sexp_ratiop, denominator))\n\n#define sexp_complex_real(q)   (sexp_pred_field(q, complex, sexp_complexp, real))\n#define sexp_complex_imag(q)   (sexp_pred_field(q, complex, sexp_complexp, imag))\n\n#define sexp_exception_kind(x)      (sexp_field(x, exception, SEXP_EXCEPTION, kind))\n#define sexp_exception_message(x)   (sexp_field(x, exception, SEXP_EXCEPTION, message))\n#define sexp_exception_irritants(x) (sexp_field(x, exception, SEXP_EXCEPTION, irritants))\n#define sexp_exception_procedure(x) (sexp_field(x, exception, SEXP_EXCEPTION, procedure))\n#define sexp_exception_source(x)    (sexp_field(x, exception, SEXP_EXCEPTION, source))\n#define sexp_exception_stack_trace(x) (sexp_field(x, exception, SEXP_EXCEPTION, stack_trace))\n\n#define sexp_trampolinep(x) (sexp_exceptionp(x) && sexp_exception_kind(x) == SEXP_TRAMPOLINE)\n#define sexp_trampoline_procedure(x) sexp_exception_procedure(x)\n#define sexp_trampoline_args(x) sexp_exception_irritants(x)\n#define sexp_trampoline_abortp(x) (sexp_exception_message(x) == SEXP_TRAMPOLINE)\n\n#define sexp_cpointer_freep(x)      (sexp_freep(x))\n#define sexp_cpointer_length(x)     (sexp_cpointer_field(x, length))\n#define sexp_cpointer_parent(x)     (sexp_cpointer_field(x, parent))\n#define sexp_cpointer_value(x)      (sexp_cpointer_field(x, value))\n#define sexp_cpointer_maybe_null_value(x) (sexp_not(x) ? NULL : sexp_cpointer_value(x))\n\n#define sexp_bytecode_length(x)   (sexp_field(x, bytecode, SEXP_BYTECODE, length))\n#define sexp_bytecode_max_depth(x) (sexp_field(x, bytecode, SEXP_BYTECODE, max_depth))\n#define sexp_bytecode_name(x)     (sexp_field(x, bytecode, SEXP_BYTECODE, name))\n#define sexp_bytecode_literals(x) (sexp_field(x, bytecode, SEXP_BYTECODE, literals))\n#define sexp_bytecode_source(x)   (sexp_field(x, bytecode, SEXP_BYTECODE, source))\n#define sexp_bytecode_data(x)     sexp_flexible_array_field(x, bytecode, unsigned char)\n\n#define sexp_env_cell_syntactic_p(x)   ((x)->syntacticp)\n\n#define sexp_env_syntactic_p(x)   ((x)->syntacticp)\n#define sexp_env_parent(x)        (sexp_field(x, env, SEXP_ENV, parent))\n#define sexp_env_bindings(x)      (sexp_field(x, env, SEXP_ENV, bindings))\n#define sexp_env_renames(x)       (sexp_field(x, env, SEXP_ENV, renames))\n#define sexp_env_local_p(x)       (sexp_env_parent(x))\n#define sexp_env_global_p(x)      (! sexp_env_local_p(x))\n#define sexp_env_lambda(x)        (sexp_field(x, env, SEXP_ENV, lambda))\n\n#define sexp_macro_proc(x)        (sexp_field(x, macro, SEXP_MACRO, proc))\n#define sexp_macro_env(x)         (sexp_field(x, macro, SEXP_MACRO, env))\n#define sexp_macro_source(x)      (sexp_field(x, macro, SEXP_MACRO, source))\n#define sexp_macro_aux(x)         (sexp_field(x, macro, SEXP_MACRO, aux))\n\n#define sexp_synclo_env(x)        (sexp_field(x, synclo, SEXP_SYNCLO, env))\n#define sexp_synclo_free_vars(x)  (sexp_field(x, synclo, SEXP_SYNCLO, free_vars))\n#define sexp_synclo_expr(x)       (sexp_field(x, synclo, SEXP_SYNCLO, expr))\n#define sexp_synclo_rename(x)     (sexp_field(x, synclo, SEXP_SYNCLO, rename))\n\n#define sexp_core_code(x)         (sexp_field(x, core, SEXP_CORE, code))\n#define sexp_core_name(x)         (sexp_field(x, core, SEXP_CORE, name))\n\n#define sexp_dl_file(x)            (sexp_field(x, dl, SEXP_DL, file))\n#define sexp_dl_handle(x)          (sexp_field(x, dl, SEXP_DL, handle))\n\n#define sexp_opcode_class(x)       (sexp_field(x, opcode, SEXP_OPCODE, op_class))\n#define sexp_opcode_code(x)        (sexp_field(x, opcode, SEXP_OPCODE, code))\n#define sexp_opcode_num_args(x)    (sexp_field(x, opcode, SEXP_OPCODE, num_args))\n#define sexp_opcode_flags(x)       (sexp_field(x, opcode, SEXP_OPCODE, flags))\n#define sexp_opcode_inverse(x)     (sexp_field(x, opcode, SEXP_OPCODE, inverse))\n#define sexp_opcode_dl(x)          (sexp_field(x, opcode, SEXP_OPCODE, dl))\n#define sexp_opcode_name(x)        (sexp_field(x, opcode, SEXP_OPCODE, name))\n#define sexp_opcode_data(x)        (sexp_field(x, opcode, SEXP_OPCODE, data))\n#define sexp_opcode_data2(x)       (sexp_field(x, opcode, SEXP_OPCODE, data2))\n#define sexp_opcode_proc(x)        (sexp_field(x, opcode, SEXP_OPCODE, proc))\n#define sexp_opcode_return_type(x) (sexp_field(x, opcode, SEXP_OPCODE, ret_type))\n#define sexp_opcode_arg1_type(x)   (sexp_field(x, opcode, SEXP_OPCODE, arg1_type))\n#define sexp_opcode_arg2_type(x)   (sexp_field(x, opcode, SEXP_OPCODE, arg2_type))\n#define sexp_opcode_arg3_type(x)   (sexp_field(x, opcode, SEXP_OPCODE, arg3_type))\n#define sexp_opcode_argn_type(x)   (sexp_field(x, opcode, SEXP_OPCODE, argn_type))\n#define sexp_opcode_methods(x)     (sexp_field(x, opcode, SEXP_OPCODE, methods))\n#define sexp_opcode_func(x)        (sexp_field(x, opcode, SEXP_OPCODE, func))\n\n#define sexp_opcode_variadic_p(x)  (sexp_opcode_flags(x) & 1)\n#define sexp_opcode_opt_param_p(x) (sexp_opcode_flags(x) & 2)\n#define sexp_opcode_ref_trans_p(x) (sexp_opcode_flags(x) & 4)\n#define sexp_opcode_static_param_p(x) (sexp_opcode_flags(x) & 8)\n#define sexp_opcode_tail_call_p(x) (sexp_opcode_flags(x) & 16)\n\n#define sexp_lambda_name(x)        (sexp_field(x, lambda, SEXP_LAMBDA, name))\n#define sexp_lambda_params(x)      (sexp_field(x, lambda, SEXP_LAMBDA, params))\n#define sexp_lambda_locals(x)      (sexp_field(x, lambda, SEXP_LAMBDA, locals))\n#define sexp_lambda_defs(x)        (sexp_field(x, lambda, SEXP_LAMBDA, defs))\n#define sexp_lambda_flags(x)       (sexp_field(x, lambda, SEXP_LAMBDA, flags))\n#define sexp_lambda_body(x)        (sexp_field(x, lambda, SEXP_LAMBDA, body))\n#define sexp_lambda_fv(x)          (sexp_field(x, lambda, SEXP_LAMBDA, fv))\n#define sexp_lambda_sv(x)          (sexp_field(x, lambda, SEXP_LAMBDA, sv))\n#define sexp_lambda_return_type(x) (sexp_field(x, lambda, SEXP_LAMBDA, ret))\n#define sexp_lambda_param_types(x) (sexp_field(x, lambda, SEXP_LAMBDA, types))\n#define sexp_lambda_source(x)      (sexp_field(x, lambda, SEXP_LAMBDA, source))\n\n#define sexp_cnd_test(x)      (sexp_field(x, cnd, SEXP_CND, test))\n#define sexp_cnd_pass(x)      (sexp_field(x, cnd, SEXP_CND, pass))\n#define sexp_cnd_fail(x)      (sexp_field(x, cnd, SEXP_CND, fail))\n#define sexp_cnd_source(x)    (sexp_field(x, cnd, SEXP_CND, source))\n\n#define sexp_set_var(x)       (sexp_field(x, set, SEXP_SET, var))\n#define sexp_set_value(x)     (sexp_field(x, set, SEXP_SET, value))\n#define sexp_set_source(x)    (sexp_field(x, set, SEXP_SET, source))\n\n#define sexp_set_syn_var(x)    (sexp_field(x, set, SEXP_SET_SYN, var))\n#define sexp_set_syn_value(x)  (sexp_field(x, set, SEXP_SET_SYN, value))\n#define sexp_set_syn_source(x) (sexp_field(x, set, SEXP_SET_SYN, source))\n\n#define sexp_ref_name(x)      (sexp_field(x, ref, SEXP_REF, name))\n#define sexp_ref_cell(x)      ((x)->value.ref.cell)\n#define sexp_ref_loc(x)       (sexp_cdr(sexp_ref_cell(x)))\n#define sexp_ref_source(x)    (sexp_field(x, ref, SEXP_REF, source))\n\n#define sexp_seq_ls(x)        (sexp_field(x, seq, SEXP_SEQ, ls))\n#define sexp_seq_source(x)    (sexp_field(x, seq, SEXP_SEQ, source))\n\n#define sexp_lit_value(x)     (sexp_field(x, lit, SEXP_LIT, value))\n#define sexp_lit_source(x)    (sexp_field(x, lit, SEXP_LIT, source))\n\n#define sexp_stack_length(x)  (sexp_field(x, stack, SEXP_STACK, length))\n#define sexp_stack_top(x)     (sexp_field(x, stack, SEXP_STACK, top))\n#define sexp_stack_data(x)    sexp_flexible_array_field(x, stack, sexp)\n\n#define sexp_promise_donep(x) (sexp_field(x, promise, SEXP_PROMISE, donep))\n#define sexp_promise_value(x) (sexp_field(x, promise, SEXP_PROMISE, value))\n\n#define sexp_ephemeron_key(x)   (sexp_field(x, ephemeron, SEXP_EPHEMERON, key))\n#define sexp_ephemeron_value(x) (sexp_field(x, ephemeron, SEXP_EPHEMERON, value))\n\n#define sexp_context_env(x)      (sexp_field(x, context, SEXP_CONTEXT, env))\n#define sexp_context_stack(x)    (sexp_field(x, context, SEXP_CONTEXT, stack))\n#define sexp_context_parent(x)   (sexp_field(x, context, SEXP_CONTEXT, parent))\n#define sexp_context_child(x)    (sexp_field(x, context, SEXP_CONTEXT, child))\n#define sexp_context_mark_stack(x)     (sexp_field(x, context, SEXP_CONTEXT, mark_stack))\n#define sexp_context_mark_stack_ptr(x) (sexp_field(x, context, SEXP_CONTEXT, mark_stack_ptr))\n#define sexp_context_saves(x)    (sexp_field(x, context, SEXP_CONTEXT, saves))\n#define sexp_context_tailp(x)    (sexp_field(x, context, SEXP_CONTEXT, tailp))\n#define sexp_context_tracep(x)   (sexp_field(x, context, SEXP_CONTEXT, tracep))\n#define sexp_context_globals(x)  (sexp_field(x, context, SEXP_CONTEXT, globals))\n#define sexp_context_dk(x)       (sexp_field(x, context, SEXP_CONTEXT, dk))\n#define sexp_context_params(x)   (sexp_field(x, context, SEXP_CONTEXT, params))\n#define sexp_context_last_fp(x)  (sexp_field(x, context, SEXP_CONTEXT, last_fp))\n#define sexp_context_gc_count(x) (sexp_field(x, context, SEXP_CONTEXT, gc_count))\n#if SEXP_USE_TIME_GC\n#define sexp_context_gc_usecs(x) (sexp_field(x, context, SEXP_CONTEXT, gc_usecs))\n#else\n#define sexp_context_gc_usecs(x) 0\n#endif\n#if SEXP_USE_TRACK_ALLOC_TIMES\n#define sexp_context_alloc_count(x) (sexp_field(x, context, SEXP_CONTEXT, alloc_count))\n#define sexp_context_alloc_usecs(x) (sexp_field(x, context, SEXP_CONTEXT, alloc_usecs))\n#define sexp_context_alloc_usecs_sq(x) (sexp_field(x, context, SEXP_CONTEXT, alloc_usecs_sq))\n#endif\n#if SEXP_USE_TRACK_ALLOC_SIZES\n#define sexp_context_alloc_histogram(x) (sexp_field(x, context, SEXP_CONTEXT, alloc_histogram))\n#endif\n#define sexp_context_refuel(x)   (sexp_field(x, context, SEXP_CONTEXT, refuel))\n#define sexp_context_ip(x)       (sexp_field(x, context, SEXP_CONTEXT, ip))\n#define sexp_context_proc(x)     (sexp_field(x, context, SEXP_CONTEXT, proc))\n#define sexp_context_timeval(x)  (sexp_field(x, context, SEXP_CONTEXT, tval))\n#define sexp_context_name(x)     (sexp_field(x, context, SEXP_CONTEXT, name))\n#define sexp_context_specific(x) (sexp_field(x, context, SEXP_CONTEXT, specific))\n#define sexp_context_event(x)    (sexp_field(x, context, SEXP_CONTEXT, event))\n#define sexp_context_timeoutp(x) (sexp_field(x, context, SEXP_CONTEXT, timeoutp))\n#define sexp_context_waitp(x)    (sexp_field(x, context, SEXP_CONTEXT, waitp))\n#define sexp_context_dl(x)       (sexp_field(x, context, SEXP_CONTEXT, dl))\n\n#define sexp_context_result(x)   (sexp_field(x, context, SEXP_CONTEXT, result))\n#define sexp_context_errorp(x)   (sexp_field(x, context, SEXP_CONTEXT, errorp))\n#define sexp_context_interruptp(x) (sexp_field(x, context, SEXP_CONTEXT, interruptp))\n\n/* during compilation, sexp_context_specific is set to a vector */\n/* containing the following elements: */\n\n#define sexp_context_bc(x)       (sexp_vector_ref(sexp_context_specific(x), SEXP_ZERO))\n#define sexp_context_fv(x)       (sexp_vector_ref(sexp_context_specific(x), SEXP_ONE))\n#define sexp_context_lambda(x)   (sexp_vector_ref(sexp_context_specific(x), SEXP_TWO))\n#define sexp_context_pos(x)      (sexp_vector_ref(sexp_context_specific(x), SEXP_THREE))\n#define sexp_context_depth(x)    (sexp_vector_ref(sexp_context_specific(x), SEXP_FOUR))\n#define sexp_context_max_depth(x) (sexp_vector_ref(sexp_context_specific(x), SEXP_FIVE))\n#define sexp_context_exception(x) (sexp_vector_ref(sexp_context_specific(x), SEXP_SIX))\n\n#if SEXP_USE_ALIGNED_BYTECODE\nSEXP_API void sexp_context_align_pos(sexp ctx);\n#else\n#define sexp_context_align_pos(ctx)\n#endif\n\n#define sexp_global(ctx,x)      (sexp_vector_data(sexp_context_globals(ctx))[x])\n\n#if SEXP_USE_GLOBAL_HEAP\n#if ! SEXP_USE_BOEHM\nSEXP_API sexp_heap sexp_global_heap;\n#endif\n#define sexp_context_heap(ctx)     sexp_global_heap\n#define sexp_context_max_size(ctx) 0\n#else\n#define sexp_context_heap(ctx)     ((ctx)->value.context.heap)\n#define sexp_context_max_size(ctx) sexp_context_heap(ctx)->max_size\n#endif\n\n#if SEXP_USE_GLOBAL_SYMBOLS\n#define sexp_context_symbols(ctx) sexp_symbol_table\nSEXP_API sexp sexp_symbol_table[SEXP_SYMBOL_TABLE_SIZE];\n#else\n#define sexp_context_symbols(ctx) sexp_vector_data(sexp_global(ctx, SEXP_G_SYMBOLS))\n#endif\n\n#define sexp_context_types(ctx)    sexp_vector_data(sexp_global(ctx, SEXP_G_TYPES))\n#define sexp_type_by_index(ctx,i)  (sexp_context_types(ctx)[i])\n#define sexp_context_num_types(ctx)             \\\n  sexp_unbox_fixnum(sexp_global(ctx, SEXP_G_NUM_TYPES))\n#define sexp_context_type_array_size(ctx)                               \\\n  sexp_vector_length(sexp_global(ctx, SEXP_G_TYPES))\n\n#define sexp_object_type(ctx,x)        (sexp_type_by_index(ctx, ((x)->tag)))\n#define sexp_object_type_name(ctx,x)   (sexp_type_name(sexp_object_type(ctx, x)))\n#define sexp_type_name_by_index(ctx,i) (sexp_type_name(sexp_type_by_index(ctx,i)))\n\n#define sexp_type_size_of_object(t, x)                                  \\\n  (((sexp_uint_t*)((char*)x + sexp_type_size_off(t)))[0]                \\\n   * sexp_type_size_scale(t)                                            \\\n   + sexp_type_size_base(t))\n#define sexp_type_num_slots_of_object(t, x)                             \\\n  (((sexp_uint_t*)((char*)x + sexp_type_field_len_off(t)))[0]           \\\n   * sexp_type_field_len_scale(t)                                       \\\n   + sexp_type_field_len_base(t))\n#define sexp_type_num_eq_slots_of_object(t, x)                          \\\n  (((sexp_uint_t*)((char*)x + sexp_type_field_len_off(t)))[0]           \\\n   * sexp_type_field_len_scale(t)                                       \\\n   + sexp_type_field_eq_len_base(t))\n#define sexp_type_num_weak_slots_of_object(t, x)                        \\\n  (((sexp_uint_t*)((char*)x + sexp_type_weak_len_off(t)))[0]            \\\n   * sexp_type_weak_len_scale(t)                                        \\\n   + sexp_type_weak_len_base(t))\n\n#define sexp_context_top(x)     (sexp_stack_top(sexp_context_stack(x)))\n\n#define sexp_type_tag(x)               (sexp_field(x, type, SEXP_TYPE, tag))\n#define sexp_type_field_base(x)        (sexp_field(x, type, SEXP_TYPE, field_base))\n#define sexp_type_field_eq_len_base(x) (sexp_field(x, type, SEXP_TYPE, field_eq_len_base))\n#define sexp_type_field_len_base(x)    (sexp_field(x, type, SEXP_TYPE, field_len_base))\n#define sexp_type_field_len_off(x)     (sexp_field(x, type, SEXP_TYPE, field_len_off))\n#define sexp_type_field_len_scale(x)   (sexp_field(x, type, SEXP_TYPE, field_len_scale))\n#define sexp_type_size_base(x)         (sexp_field(x, type, SEXP_TYPE, size_base))\n#define sexp_type_size_off(x)          (sexp_field(x, type, SEXP_TYPE, size_off))\n#define sexp_type_size_scale(x)        (sexp_field(x, type, SEXP_TYPE, size_scale))\n#define sexp_type_weak_base(x)         (sexp_field(x, type, SEXP_TYPE, weak_base))\n#define sexp_type_weak_len_base(x)     (sexp_field(x, type, SEXP_TYPE, weak_len_base))\n#define sexp_type_weak_len_off(x)      (sexp_field(x, type, SEXP_TYPE, weak_len_off))\n#define sexp_type_weak_len_scale(x)    (sexp_field(x, type, SEXP_TYPE, weak_len_scale))\n#define sexp_type_weak_len_extra(x)    (sexp_field(x, type, SEXP_TYPE, weak_len_extra))\n#define sexp_type_depth(x)             (sexp_field(x, type, SEXP_TYPE, depth))\n#define sexp_type_name(x)              (sexp_field(x, type, SEXP_TYPE, name))\n#define sexp_type_cpl(x)               (sexp_field(x, type, SEXP_TYPE, cpl))\n#define sexp_type_slots(x)             (sexp_field(x, type, SEXP_TYPE, slots))\n#define sexp_type_getters(x)           (sexp_field(x, type, SEXP_TYPE, getters))\n#define sexp_type_setters(x)           (sexp_field(x, type, SEXP_TYPE, setters))\n#define sexp_type_finalize(x)          (sexp_field(x, type, SEXP_TYPE, finalize))\n#define sexp_type_finalize_name(x)     (sexp_field(x, type, SEXP_TYPE, finalize_name))\n#define sexp_type_print(x)             (sexp_field(x, type, SEXP_TYPE, print))\n#define sexp_type_dl(x)                (sexp_field(x, type, SEXP_TYPE, dl))\n#define sexp_type_id(x)                (sexp_field(x, type, SEXP_TYPE, id))\n\n#define sexp_bignum_sign(x)            (sexp_field(x, bignum, SEXP_BIGNUM, sign))\n#define sexp_bignum_length(x)          (sexp_field(x, bignum, SEXP_BIGNUM, length))\n#define sexp_bignum_data(x)            sexp_flexible_array_field(x, bignum, sexp_uint_t)\n\n/****************************** arithmetic ****************************/\n\n#define sexp_fx_add(a, b) ((sexp)(((sexp_sint_t)a)+((sexp_sint_t)b)-SEXP_FIXNUM_TAG))\n#define sexp_fx_sub(a, b) ((sexp)(((sexp_sint_t)a)-((sexp_sint_t)b)+SEXP_FIXNUM_TAG))\n#define sexp_fx_mul(a, b) ((sexp)((((((sexp_sint_t)a)-SEXP_FIXNUM_TAG)*(((sexp_sint_t)b)>>SEXP_FIXNUM_BITS))+SEXP_FIXNUM_TAG)))\n#define sexp_fx_div(a, b) (sexp_make_fixnum(sexp_unbox_fixnum(a) / sexp_unbox_fixnum(b)))\n#define sexp_fx_rem(a, b) (sexp_make_fixnum(sexp_unbox_fixnum(a) % sexp_unbox_fixnum(b)))\n#define sexp_fx_sign(a)   (+1 | (((sexp_sint_t)(a)) >> (sizeof(sexp_sint_t)*8 - 1)))\n#define sexp_fx_neg(a)    (sexp_make_fixnum(-(sexp_unbox_fixnum(a))))\n#define sexp_fx_abs(a)    ((((sexp_sint_t)a) < 0) ? sexp_fx_neg(a) : a)\n\n#define sexp_unbox_fx_abs(a) ((((sexp_sint_t)a) < 0) ? -sexp_unbox_fixnum(a) : sexp_unbox_fixnum(a))\n\n#define sexp_fp_add(x,a,b) (sexp_make_flonum(x, sexp_flonum_value(a) + sexp_flonum_value(b)))\n#define sexp_fp_sub(x,a,b) (sexp_make_flonum(x, sexp_flonum_value(a) - sexp_flonum_value(b)))\n#define sexp_fp_mul(x,a,b) (sexp_make_flonum(x, sexp_flonum_value(a) * sexp_flonum_value(b)))\n#define sexp_fp_div(x,a,b) (sexp_make_flonum(x, sexp_flonum_value(a) / sexp_flonum_value(b)))\n\n#if ! (SEXP_USE_FLONUMS || SEXP_USE_BIGNUMS)\n#define sexp_add(ctx, a, b) sexp_fx_add(a, b)\n#define sexp_sub(ctx, a, b) sexp_fx_sub(a, b)\n#define sexp_mul(ctx, a, b) sexp_fx_mul(a, b)\n#define sexp_div(ctx, a, b) sexp_fx_div(a, b)\n#endif\n\n/****************************** utilities *****************************/\n\nenum sexp_context_globals {\n#if SEXP_USE_STABLE_ABI || ! SEXP_USE_GLOBAL_SYMBOLS\n  SEXP_G_SYMBOLS,\n#endif\n  SEXP_G_ENDIANNESS,\n  SEXP_G_TYPES,\n  SEXP_G_FEATURES,\n  SEXP_G_NUM_TYPES,\n  SEXP_G_OOM_ERROR,             /* out of memory exception object */\n  SEXP_G_OOS_ERROR,             /* out of stack exception object */\n  SEXP_G_ABI_ERROR,             /* incompatible ABI loading library */\n  SEXP_G_INTERRUPT_ERROR,       /* C-c in the repl */\n  SEXP_G_OPTIMIZATIONS,\n  SEXP_G_SIGNAL_HANDLERS,\n  SEXP_G_META_ENV,\n  SEXP_G_MODULE_PATH,\n  SEXP_G_QUOTE_SYMBOL,\n  SEXP_G_QUASIQUOTE_SYMBOL,\n  SEXP_G_UNQUOTE_SYMBOL,\n  SEXP_G_UNQUOTE_SPLICING_SYMBOL,\n  SEXP_G_SYNTAX_SYMBOL,\n  SEXP_G_QUASISYNTAX_SYMBOL,\n  SEXP_G_UNSYNTAX_SYMBOL,\n  SEXP_G_UNSYNTAX_SPLICING_SYMBOL,\n  SEXP_G_EMPTY_VECTOR,\n  SEXP_G_CUR_IN_SYMBOL,\n  SEXP_G_CUR_OUT_SYMBOL,\n  SEXP_G_CUR_ERR_SYMBOL,\n  SEXP_G_INTERACTION_ENV_SYMBOL,\n  SEXP_G_CONTINUABLE_SYMBOL,\n  SEXP_G_ERR_HANDLER,\n  SEXP_G_RESUMECC_BYTECODE,\n  SEXP_G_FINAL_RESUMER,\n  SEXP_G_RANDOM_SOURCE,\n  SEXP_G_STRICT_P,\n  SEXP_G_NO_TAIL_CALLS_P,\n#if SEXP_USE_STABLE_ABI || SEXP_USE_FOLD_CASE_SYMS\n  SEXP_G_FOLD_CASE_P,\n#endif\n#if SEXP_USE_STABLE_ABI || SEXP_USE_WEAK_REFERENCES\n  SEXP_G_WEAK_OBJECTS_PRESENT,\n  SEXP_G_FILE_DESCRIPTORS,\n  SEXP_G_NUM_FILE_DESCRIPTORS,\n#endif\n#if SEXP_USE_STABLE_ABI || ! SEXP_USE_BOEHM\n  SEXP_G_PRESERVATIVES,\n#endif\n#if SEXP_USE_STABLE_ABI || SEXP_USE_GREEN_THREADS\n  SEXP_G_IO_BLOCK_ERROR,\n  SEXP_G_IO_BLOCK_ONCE_ERROR,\n  SEXP_G_THREAD_TERMINATE_ERROR,\n  SEXP_G_THREADS_SCHEDULER,\n  SEXP_G_THREADS_FRONT,\n  SEXP_G_THREADS_BACK,\n  SEXP_G_THREADS_PAUSED,\n  SEXP_G_THREADS_SIGNALS,\n  SEXP_G_THREADS_SIGNAL_RUNNER,\n  SEXP_G_THREADS_POLL_FDS,\n  SEXP_G_THREADS_FD_THREADS,\n  SEXP_G_THREADS_BLOCKER,\n  SEXP_G_THREADS_MUTEX_ID,\n  SEXP_G_THREADS_POLLFDS_ID,\n  SEXP_G_ATOMIC_P,\n#endif\n  SEXP_G_NUM_GLOBALS\n};\n\n#define sexp_list1(x,a)        sexp_cons((x), (a), SEXP_NULL)\n\nSEXP_API sexp sexp_push_op(sexp ctx, sexp* loc, sexp x);\n\n#if SEXP_USE_UNSAFE_PUSH\n#define sexp_push(ctx, ls, x)    ((ls) = sexp_cons((ctx), (x), (ls)))\n#else\n#define sexp_push(ctx, ls, x)    (sexp_push_op((ctx), &(ls), (x)))\n#endif\n#define sexp_insert(ctx, ls, x)  ((sexp_memq(ctx, (x), (ls)) != SEXP_FALSE) ? (ls) : sexp_push((ctx), (ls), (x)))\n\n#define sexp_pair_source(x) (sexp_field(x, pair, SEXP_PAIR, source))\n\n#define sexp_car(x)         (sexp_field(x, pair, SEXP_PAIR, car))\n#define sexp_cdr(x)         (sexp_field(x, pair, SEXP_PAIR, cdr))\n\n#define sexp_caar(x)      (sexp_car(sexp_car(x)))\n#define sexp_cadr(x)      (sexp_car(sexp_cdr(x)))\n#define sexp_cdar(x)      (sexp_cdr(sexp_car(x)))\n#define sexp_cddr(x)      (sexp_cdr(sexp_cdr(x)))\n#define sexp_caaar(x)     (sexp_car(sexp_caar(x)))\n#define sexp_caadr(x)     (sexp_car(sexp_cadr(x)))\n#define sexp_cadar(x)     (sexp_car(sexp_cdar(x)))\n#define sexp_caddr(x)     (sexp_car(sexp_cddr(x)))\n#define sexp_cdaar(x)     (sexp_cdr(sexp_caar(x)))\n#define sexp_cdadr(x)     (sexp_cdr(sexp_cadr(x)))\n#define sexp_cddar(x)     (sexp_cdr(sexp_cdar(x)))\n#define sexp_cdddr(x)     (sexp_cdr(sexp_cddr(x)))\n#define sexp_cadddr(x)    (sexp_cadr(sexp_cddr(x))) /* just these two */\n#define sexp_cddddr(x)    (sexp_cddr(sexp_cddr(x)))\n\n/***************************** general API ****************************/\n\n#define sexp_read_char(x, p) (sexp_port_buf(p) ? ((sexp_port_offset(p) < sexp_port_size(p)) ? ((unsigned char*)sexp_port_buf(p))[sexp_port_offset(p)++] : sexp_buffered_read_char(x, p)) : getc(sexp_port_stream(p)))\n#define sexp_push_char(x, c, p) ((c!=EOF) && (sexp_port_buf(p) ? (sexp_port_buf(p)[--sexp_port_offset(p)] = ((char)(c))) : ungetc(c, sexp_port_stream(p))))\n#define sexp_write_char(x, c, p) (sexp_port_buf(p) ? ((sexp_port_offset(p) < sexp_port_size(p)) ? ((((sexp_port_buf(p))[sexp_port_offset(p)++]) = (char)(c)), 0) : sexp_buffered_write_char(x, c, p)) : putc(c, sexp_port_stream(p)))\n#define sexp_write_string(x, s, p) (sexp_port_buf(p) ? sexp_buffered_write_string(x, s, p) : fputs(s, sexp_port_stream(p)))\n#define sexp_write_string_n(x, s, n, p) (sexp_port_buf(p) ? sexp_buffered_write_string_n(x, s, n, p) : fwrite(s, 1, n, sexp_port_stream(p)))\n#define sexp_flush(x, p) (sexp_port_buf(p) ? sexp_buffered_flush(x, p, 0) : fflush(sexp_port_stream(p)))\n#define sexp_flush_forced(x, p) (sexp_port_buf(p) ? sexp_buffered_flush(x, p, 1) : fflush(sexp_port_stream(p)))\n\nSEXP_API int sexp_buffered_read_char (sexp ctx, sexp p);\nSEXP_API int sexp_buffered_write_char (sexp ctx, int c, sexp p);\nSEXP_API int sexp_buffered_write_string_n (sexp ctx, const char *str, sexp_uint_t len, sexp p);\nSEXP_API int sexp_buffered_write_string (sexp ctx, const char *str, sexp p);\nSEXP_API int sexp_buffered_flush (sexp ctx, sexp p, int forcep);\n\n#define sexp_newline(ctx, p) sexp_write_char((ctx), '\\n', (p))\n#define sexp_at_eofp(p)      (feof(sexp_port_stream(p)))\n#define sexp_port_fileno(p)  (sexp_port_stream(p) ? fileno(sexp_port_stream(p)) : sexp_filenop(sexp_port_fd(p)) ? sexp_fileno_fd(sexp_port_fd(p)) : -1)\n\n#if SEXP_USE_AUTOCLOSE_PORTS\n#define SEXP_FINALIZE_PORT sexp_finalize_port\n#define SEXP_FINALIZE_PORTN (sexp)\"sexp_finalize_port\"\n#define SEXP_FINALIZE_FILENO sexp_finalize_fileno\n#define SEXP_FINALIZE_FILENON (sexp)\"sexp_finalize_fileno\"\n#else\n#define SEXP_FINALIZE_PORT NULL\n#define SEXP_FINALIZE_PORTN NULL\n#define SEXP_FINALIZE_FILENO NULL\n#define SEXP_FINALIZE_FILENON NULL\n#endif\n\n#if SEXP_USE_DL\nsexp sexp_finalize_dl (sexp ctx, sexp self, sexp_sint_t n, sexp dl);\n#define SEXP_FINALIZE_DL sexp_finalize_dl\n#define SEXP_FINALIZE_DLN (sexp)\"sexp_finalize_dl\"\n#else\n#define SEXP_FINALIZE_DL NULL\n#define SEXP_FINALIZE_DLN NULL\n#endif\n\n#if SEXP_USE_TRACK_ALLOC_SOURCE\n#define sexp_current_source_param , const char* source\n#else\n#define sexp_current_source_param\n#endif\n\n/* To export a library from the embedding C program to Scheme, so    */\n/* that it can be included into Scheme library foo/qux.sld as        */\n/* (include-shared \"bar\"), libraries should contain the entry        */\n/* {\"foo/bar\", init_bar}.  The signature and function of init_bar is */\n/* the same as that of sexp_init_library in shared libraries.  The   */\n/* array libraries must be terminated with {NULL, NULL} and must     */\n/* remain valid throughout its use by Chibi.                         */\n\nSEXP_API void sexp_add_static_libraries(struct sexp_library_entry_t* libraries);\n\nSEXP_API sexp sexp_alloc_tagged_aux(sexp ctx, size_t size, sexp_uint_t tag sexp_current_source_param);\nSEXP_API sexp sexp_make_context(sexp ctx, size_t size, size_t max_size);\nSEXP_API sexp sexp_cons_op(sexp ctx, sexp self, sexp_sint_t n, sexp head, sexp tail);\nSEXP_API sexp sexp_list2(sexp ctx, sexp a, sexp b);\nSEXP_API sexp sexp_list3(sexp ctx, sexp a, sexp b, sexp c);\nSEXP_API sexp sexp_equalp_bound (sexp ctx, sexp self, sexp_sint_t n, sexp a, sexp b, sexp depth, sexp bound);\nSEXP_API sexp sexp_equalp_op (sexp ctx, sexp self, sexp_sint_t n, sexp a, sexp b);\nSEXP_API sexp sexp_listp_op(sexp ctx, sexp self, sexp_sint_t n, sexp obj);\nSEXP_API sexp sexp_reverse_op(sexp ctx, sexp self, sexp_sint_t n, sexp ls);\nSEXP_API sexp sexp_nreverse_op(sexp ctx, sexp self, sexp_sint_t n, sexp ls);\nSEXP_API sexp sexp_copy_list_op(sexp ctx, sexp self, sexp_sint_t n, sexp ls);\nSEXP_API sexp sexp_append2_op(sexp ctx, sexp self, sexp_sint_t n, sexp a, sexp b);\nSEXP_API sexp sexp_memq_op(sexp ctx, sexp self, sexp_sint_t n, sexp x, sexp ls);\nSEXP_API sexp sexp_assq_op(sexp ctx, sexp self, sexp_sint_t n, sexp x, sexp ls);\nSEXP_API sexp sexp_length_op(sexp ctx, sexp self, sexp_sint_t n, sexp ls);\nSEXP_API sexp sexp_c_string(sexp ctx, const char *str, sexp_sint_t slen);\nSEXP_API sexp sexp_make_ephemeron_op(sexp ctx, sexp self, sexp_sint_t n, sexp key, sexp value);\nSEXP_API sexp sexp_make_bytes_op(sexp ctx, sexp self, sexp_sint_t n, sexp len, sexp i);\nSEXP_API sexp sexp_make_uvector_op(sexp ctx, sexp self, sexp_sint_t n, sexp elt_type, sexp len);\nSEXP_API sexp sexp_make_string_op(sexp ctx, sexp self, sexp_sint_t n, sexp len, sexp ch);\nSEXP_API sexp sexp_substring_op (sexp ctx, sexp self, sexp_sint_t n, sexp str, sexp start, sexp end);\nSEXP_API sexp sexp_subbytes_op (sexp ctx, sexp self, sexp_sint_t n, sexp str, sexp start, sexp end);\nSEXP_API sexp sexp_string_concatenate_op (sexp ctx, sexp self, sexp_sint_t n, sexp str_ls, sexp sep);\nSEXP_API sexp sexp_intern (sexp ctx, const char *str, sexp_sint_t len);\nSEXP_API sexp sexp_string_to_symbol_op (sexp ctx, sexp self, sexp_sint_t n, sexp str);\nSEXP_API sexp sexp_symbol_to_string_op (sexp ctx, sexp self, sexp_sint_t n, sexp sym);\nSEXP_API sexp sexp_string_to_number_op (sexp ctx, sexp self, sexp_sint_t n, sexp str, sexp b);\nSEXP_API sexp sexp_flonump_op (sexp ctx, sexp self, sexp_sint_t n, sexp x);\nSEXP_API sexp sexp_make_vector_op (sexp ctx, sexp self, sexp_sint_t n, sexp len, sexp dflt);\nSEXP_API sexp sexp_list_to_vector_op (sexp ctx, sexp self, sexp_sint_t n, sexp ls);\nSEXP_API sexp sexp_list_to_uvector_op (sexp ctx, sexp self, sexp_sint_t n, sexp etype, sexp ls);\nSEXP_API sexp sexp_make_cpointer (sexp ctx, sexp_uint_t type_id, void* value, sexp parent, int freep);\nSEXP_API int sexp_is_separator(int c);\nSEXP_API sexp sexp_write_op (sexp ctx, sexp self, sexp_sint_t n, sexp obj, sexp out);\nSEXP_API sexp sexp_flush_output_op (sexp ctx, sexp self, sexp_sint_t n, sexp out);\nSEXP_API sexp sexp_read_string (sexp ctx, sexp in, int sentinel);\nSEXP_API sexp sexp_read_symbol (sexp ctx, sexp in, int init, int internp);\nSEXP_API sexp sexp_read_number (sexp ctx, sexp in, int base, int exactp);\n#if SEXP_USE_BIGNUMS\nSEXP_API sexp sexp_read_bignum (sexp ctx, sexp in, sexp_uint_t init,\n                                signed char sign, sexp_uint_t base);\nSEXP_API sexp sexp_write_bignum (sexp ctx, sexp a, sexp out, sexp_uint_t base);\n#endif\nSEXP_API sexp sexp_read_float_tail(sexp ctx, sexp in, double whole, int negp);\n#if SEXP_USE_COMPLEX\nSEXP_API sexp sexp_read_complex_tail(sexp ctx, sexp in, sexp res);\n#endif\nSEXP_API sexp sexp_read_raw (sexp ctx, sexp in, sexp *shares);\nSEXP_API sexp sexp_read_op (sexp ctx, sexp self, sexp_sint_t n, sexp in);\nSEXP_API sexp sexp_char_ready_p (sexp ctx, sexp self, sexp_sint_t n, sexp in);\nSEXP_API sexp sexp_read_from_string (sexp ctx, const char *str, sexp_sint_t len);\nSEXP_API sexp sexp_read_error (sexp ctx, const char *msg, sexp ir, sexp port);\nSEXP_API sexp sexp_write_to_string (sexp ctx, sexp obj);\nSEXP_API sexp sexp_write_simple_object (sexp ctx, sexp self, sexp_sint_t n, sexp obj, sexp writer, sexp out);\nSEXP_API sexp sexp_finalize_port (sexp ctx, sexp self, sexp_sint_t n, sexp port);\nSEXP_API sexp sexp_make_fileno_op (sexp ctx, sexp self, sexp_sint_t n, sexp fd, sexp no_closep);\nSEXP_API sexp sexp_make_input_port (sexp ctx, FILE* in, sexp name);\nSEXP_API sexp sexp_make_output_port (sexp ctx, FILE* out, sexp name);\nSEXP_API sexp sexp_open_input_file_descriptor (sexp ctx, sexp self, sexp_sint_t n, sexp fileno, sexp socketp);\nSEXP_API sexp sexp_open_output_file_descriptor (sexp ctx, sexp self, sexp_sint_t n, sexp fileno, sexp socketp);\nSEXP_API sexp sexp_make_non_null_input_port (sexp ctx, FILE* in, sexp name);\nSEXP_API sexp sexp_make_non_null_output_port (sexp ctx, FILE* out, sexp name);\nSEXP_API sexp sexp_make_non_null_input_output_port (sexp ctx, FILE* io, sexp name);\nSEXP_API sexp sexp_port_outputp_op (sexp ctx, sexp self, sexp_sint_t n, sexp port);\nSEXP_API sexp sexp_port_binaryp_op (sexp ctx, sexp self, sexp_sint_t n, sexp port);\nSEXP_API sexp sexp_port_openp_op (sexp ctx, sexp self, sexp_sint_t n, sexp port);\n#if SEXP_USE_FOLD_CASE_SYMS\nSEXP_API sexp sexp_get_port_fold_case (sexp ctx, sexp self, sexp_sint_t n, sexp in);\nSEXP_API sexp sexp_set_port_fold_case (sexp ctx, sexp self, sexp_sint_t n, sexp in, sexp x);\n#endif\n#if SEXP_USE_OBJECT_BRACE_LITERALS\nSEXP_API sexp sexp_lookup_type_op (sexp ctx, sexp self, sexp_sint_t n, sexp name, sexp id);\n#endif\nSEXP_API sexp sexp_open_input_string_op (sexp ctx, sexp self, sexp_sint_t n, sexp str);\nSEXP_API sexp sexp_open_output_string_op (sexp ctx, sexp self, sexp_sint_t n);\nSEXP_API sexp sexp_get_output_string_op (sexp ctx, sexp self, sexp_sint_t n, sexp port);\nSEXP_API sexp sexp_make_immutable_op (sexp ctx, sexp self, sexp_sint_t n, sexp x);\nSEXP_API sexp sexp_make_exception (sexp ctx, sexp kind, sexp message, sexp irritants, sexp procedure, sexp source);\nSEXP_API sexp sexp_user_exception (sexp ctx, sexp self, const char *msg, sexp x);\nSEXP_API sexp sexp_user_exception_ls (sexp ctx, sexp self, const char *msg, int n, ...);\nSEXP_API sexp sexp_file_exception (sexp ctx, sexp self, const char *msg, sexp x);\nSEXP_API sexp sexp_type_exception (sexp ctx, sexp self, sexp_uint_t type_id, sexp x);\nSEXP_API sexp sexp_xtype_exception (sexp ctx, sexp self, const char *msg, sexp x);\nSEXP_API sexp sexp_range_exception (sexp ctx, sexp obj, sexp start, sexp end);\nSEXP_API sexp sexp_get_stack_trace (sexp ctx);\nSEXP_API sexp sexp_print_exception_op (sexp ctx, sexp self, sexp_sint_t n, sexp exn, sexp out);\nSEXP_API sexp sexp_stack_trace_op (sexp ctx, sexp self, sexp_sint_t n, sexp out);\nSEXP_API sexp sexp_print_exception_stack_trace_op (sexp ctx, sexp self, sexp_sint_t n, sexp exn, sexp out);\nSEXP_API sexp sexp_apply (sexp context, sexp proc, sexp args);\nSEXP_API sexp sexp_apply1 (sexp ctx, sexp f, sexp x);\nSEXP_API sexp sexp_apply2 (sexp ctx, sexp f, sexp x, sexp y);\nSEXP_API sexp sexp_apply3 (sexp ctx, sexp f, sexp x, sexp y, sexp z);\nSEXP_API sexp sexp_apply_no_err_handler (sexp ctx, sexp proc, sexp args);\nSEXP_API sexp sexp_make_trampoline (sexp ctx, sexp proc, sexp args);\nSEXP_API sexp sexp_make_foreign (sexp ctx, const char *name, int num_args, int flags, const char *fname, sexp_proc1 f, sexp data);\nSEXP_API void sexp_init(void);\n\n#if SEXP_USE_UTF8_STRINGS\nSEXP_API int sexp_utf8_initial_byte_count (int c);\nSEXP_API int sexp_utf8_char_byte_count (int c);\nSEXP_API sexp_uint_t sexp_string_utf8_length (unsigned char *p, long len);\nSEXP_API char* sexp_string_utf8_prev (unsigned char *p);\nSEXP_API sexp sexp_string_utf8_ref (sexp ctx, sexp str, sexp i);\nSEXP_API sexp sexp_string_utf8_index_ref (sexp ctx, sexp self, sexp_sint_t n, sexp str, sexp i);\nSEXP_API sexp sexp_string_index_to_cursor (sexp ctx, sexp self, sexp_sint_t n, sexp str, sexp index);\nSEXP_API sexp sexp_string_cursor_to_index (sexp ctx, sexp self, sexp_sint_t n, sexp str, sexp offset);\nSEXP_API sexp sexp_string_cursor_offset (sexp ctx, sexp self, sexp_sint_t n, sexp cur);\nSEXP_API sexp sexp_utf8_substring_op (sexp ctx, sexp self, sexp_sint_t n, sexp str, sexp start, sexp end);\nSEXP_API void sexp_utf8_encode_char (unsigned char* p, int len, int c);\nSEXP_API int sexp_write_utf8_char (sexp ctx, int c, sexp out);\n#define sexp_string_ref(ctx, s, i)    (sexp_string_utf8_index_ref(ctx, NULL, 2, s, i))\n#define sexp_string_set(ctx, s, i, ch) (sexp_string_utf8_index_set(ctx, NULL, 3, s, i, ch))\n#define sexp_string_cursor_ref(ctx, s, i)    (sexp_string_utf8_ref(ctx, s, i))\n#define sexp_string_cursor_set(ctx, s, i, ch)    (sexp_string_utf8_set(ctx, s, i, ch))\n#define sexp_string_cursor_next(s, i) sexp_make_string_cursor(sexp_unbox_string_cursor(i) + sexp_utf8_initial_byte_count(((unsigned char*)sexp_string_data(s))[sexp_unbox_string_cursor(i)]))\n#define sexp_string_cursor_prev(s, i) sexp_make_string_cursor(sexp_string_utf8_prev((unsigned char*)sexp_string_data(s)+sexp_unbox_string_cursor(i)) - sexp_string_data(s))\n#define sexp_string_length(s) sexp_string_utf8_length((unsigned char*)sexp_string_data(s), sexp_string_size(s))\n#define sexp_substring(ctx, s, i, j) sexp_utf8_substring_op(ctx, NULL, 3, s, i, j)\n#define sexp_substring_cursor(ctx, s, i, j) sexp_substring_op(ctx, NULL, 3, s, i, j)\n#else  /* ASCII strings */\n#define sexp_string_ref(ctx, s, i)    (sexp_make_character((unsigned char)sexp_string_data(s)[sexp_unbox_fixnum(i)]))\n#define sexp_string_set(ctx, s, i, ch) (sexp_string_data(s)[sexp_unbox_fixnum(i)] = sexp_unbox_character(ch))\n#define sexp_string_cursor_ref(ctx, s, i) sexp_string_ref(ctx, s, i)\n#define sexp_string_cursor_set(ctx, s, i, ch) sexp_string_set(ctx, s, i, ch)\n#define sexp_string_cursor_next(s, i) sexp_make_fixnum(sexp_unbox_fixnum(i) + 1)\n#define sexp_string_cursor_prev(s, i) sexp_make_fixnum(sexp_unbox_fixnum(i) - 1)\n#define sexp_string_length(s) sexp_string_size(s)\n#define sexp_substring(ctx, s, i, j) sexp_substring_op(ctx, NULL, 3, s, i, j)\n#define sexp_substring_cursor(ctx, s, i, j) sexp_substring_op(ctx, NULL, 3, s, i, j)\n#endif\n\n#if SEXP_USE_STRING_INDEX_TABLE\nSEXP_API void sexp_update_string_index_lookup(sexp ctx, sexp s);\n#else\n#define sexp_update_string_index_lookup(ctx, s)\n#endif\n\n#if SEXP_USE_GREEN_THREADS\nSEXP_API int sexp_maybe_block_port (sexp ctx, sexp in, int forcep);\nSEXP_API void sexp_maybe_unblock_port (sexp ctx, sexp in);\n#define sexp_check_block_port(ctx, in, forcep)          \\\n  if (sexp_maybe_block_port(ctx, in, forcep))           \\\n    return sexp_global(ctx, SEXP_G_IO_BLOCK_ERROR)\n#else\n#define sexp_maybe_block_port(ctx, in, forcep)\n#define sexp_maybe_unblock_port(ctx, in)\n#define sexp_check_block_port(ctx, in, forcep)\n#endif\n\n#define SEXP_PORT_UNKNOWN_FLAGS -1uL\n\n#define sexp_assert_type(ctx, pred, type_id, obj) if (! pred(obj)) return sexp_type_exception(ctx, self, type_id, obj)\n\n#define SEXP_COPY_DEFAULT SEXP_ZERO\n#define SEXP_COPY_FREEP   SEXP_ONE\n#define SEXP_COPY_LOADP   SEXP_TWO\n\n#if ! SEXP_USE_BOEHM && ! SEXP_USE_MALLOC\nSEXP_API void sexp_gc_init (void);\nSEXP_API int sexp_grow_heap (sexp ctx, size_t size, size_t chunk_size);\nSEXP_API sexp_heap sexp_make_heap (size_t size, size_t max_size, size_t chunk_size);\nSEXP_API void sexp_mark (sexp ctx, sexp x);\nSEXP_API sexp sexp_sweep (sexp ctx, size_t *sum_freed_ptr);\n#if SEXP_USE_FINALIZERS\nSEXP_API sexp sexp_finalize (sexp ctx);\n#else\n#define sexp_finalize(ctx) SEXP_ZERO\n#endif\n#endif\n\n#if SEXP_USE_GLOBAL_HEAP\n#define sexp_free_heap(heap)\n#define sexp_debug_heap_stats(heap)\n#define sexp_destroy_context(ctx) SEXP_TRUE\n#else\nSEXP_API void sexp_free_heap (sexp_heap heap);\nSEXP_API void sexp_debug_heap_stats (sexp_heap heap);\nSEXP_API void sexp_debug_alloc_times(sexp ctx);\nSEXP_API void sexp_debug_alloc_sizes(sexp ctx);\nSEXP_API sexp sexp_destroy_context (sexp ctx);\nSEXP_API sexp sexp_copy_context (sexp ctx, sexp dst, sexp flags);\n#endif\n\n#if SEXP_USE_SAFE_GC_MARK\nSEXP_API int sexp_in_heap_p(sexp ctx, sexp x);\n#else\n#define sexp_in_heap_p(ctx, x) 1\n#endif\n\n#if SEXP_DEBUG_GC > 1 || SEXP_USE_SAFE_GC_MARK || SEXP_USE_HEADER_MAGIC\nSEXP_API int sexp_valid_object_p(sexp ctx, sexp x);\n#else\n#define sexp_valid_object_p(ctx, x) 1\n#endif\n\n#if SEXP_USE_TYPE_DEFS\nSEXP_API sexp sexp_register_type_op (sexp, sexp, sexp_sint_t, sexp, sexp, sexp, sexp, sexp, sexp, sexp, sexp, sexp, sexp, sexp, sexp, sexp, sexp, sexp, sexp, sexp, const char*, sexp_proc2);\nSEXP_API sexp sexp_register_simple_type_op (sexp ctx, sexp self, sexp_sint_t n, sexp name, sexp parent, sexp slots);\nSEXP_API sexp sexp_finalize_c_type (sexp ctx, sexp self, sexp_sint_t n, sexp obj);\n#define sexp_register_c_type(ctx, name, finalizer)                      \\\n  sexp_register_type(ctx, name, SEXP_FALSE, SEXP_FALSE, SEXP_ZERO, SEXP_ZERO, \\\n                     SEXP_ZERO, SEXP_ZERO, SEXP_ZERO,                   \\\n                     sexp_make_fixnum(sexp_sizeof(cpointer)),           \\\n                     SEXP_ZERO, SEXP_ZERO, SEXP_ZERO, SEXP_ZERO,        \\\n                     SEXP_ZERO, SEXP_ZERO, SEXP_ZERO, NULL,             \\\n                     #finalizer, (sexp_proc2)finalizer)\n#endif\n\n#define sexp_current_input_port(ctx) sexp_parameter_ref(ctx, sexp_env_ref(ctx, sexp_context_env(ctx), sexp_global(ctx,SEXP_G_CUR_IN_SYMBOL), SEXP_FALSE))\n#define sexp_current_output_port(ctx) sexp_parameter_ref(ctx, sexp_env_ref(ctx, sexp_context_env(ctx), sexp_global(ctx,SEXP_G_CUR_OUT_SYMBOL), SEXP_FALSE))\n#define sexp_current_error_port(ctx) sexp_parameter_ref(ctx, sexp_env_ref(ctx, sexp_context_env(ctx), sexp_global(ctx,SEXP_G_CUR_ERR_SYMBOL), SEXP_FALSE))\n#define sexp_debug(ctx, msg, obj) (sexp_portp(sexp_current_error_port(ctx)) ? (sexp_write_string(ctx, msg, sexp_current_error_port(ctx)), sexp_write(ctx, obj, sexp_current_error_port(ctx)), sexp_write_char(ctx, '\\n', sexp_current_error_port(ctx))) : 0)\n\n#if SEXP_USE_POLL_PORT\nSEXP_API int sexp_poll_port(sexp ctx, sexp port, int inputp);\n#endif\n\n/* simplify primitive API interface */\n\n#define sexp_read(ctx, in) sexp_read_op(ctx, NULL, 1, in)\n#define sexp_write(ctx, obj, out) sexp_write_op(ctx, NULL, 2, obj, out)\n#define sexp_print_exception(ctx, e, out) sexp_print_exception_op(ctx, NULL, 2, e, out)\n#define sexp_print_exception_stack_trace(ctx, e, out) sexp_print_exception_stack_trace_op(ctx, NULL, 2, e, out)\n#define sexp_flush_output(ctx, out) sexp_flush_output_op(ctx, NULL, 1, out)\n#define sexp_equalp(ctx, a, b) sexp_equalp_op(ctx, NULL, 2, a, b)\n#define sexp_listp(ctx, x) sexp_listp_op(ctx, NULL, 1, x)\n#define sexp_length(ctx, x) sexp_length_op(ctx, NULL, 1, x)\n#define sexp_length_unboxed(x) sexp_unbox_fixnum(sexp_length(NULL, x))\n#define sexp_reverse(ctx, x) sexp_reverse_op(ctx, NULL, 1, x)\n#define sexp_nreverse(ctx, x) sexp_nreverse_op(ctx, NULL, 1, x)\n#define sexp_copy_list(ctx, x) sexp_copy_list_op(ctx, NULL, 1, x)\n#define sexp_cons(ctx, a, b) sexp_cons_op(ctx, NULL, 2, a, b)\n#define sexp_append2(ctx, a, b) sexp_append2_op(ctx, NULL, 2, a, b)\n#define sexp_make_vector(ctx, a, b) sexp_make_vector_op(ctx, NULL, 2, a, b)\n#define sexp_list_to_vector(ctx, x) sexp_list_to_vector_op(ctx, NULL, 1, x)\n#define sexp_list_to_uvector(ctx, etype, ls) sexp_list_to_uvector_op(ctx, NULL, 2, etype, ls)\n#define sexp_exception_type(ctx, x) sexp_exception_type_op(ctx, NULL, 1, x)\n#define sexp_string_to_symbol(ctx, s) sexp_string_to_symbol_op(ctx, NULL, 1, s)\n#define sexp_string_to_number(ctx, s, b) sexp_string_to_number_op(ctx, NULL, 2, s, b)\n#define sexp_symbol_to_string(ctx, s) sexp_symbol_to_string_op(ctx, NULL, 1, s)\n#define sexp_make_ephemeron(ctx, k, v) sexp_make_ephemeron_op(ctx, NULL, 2, k, v)\n#define sexp_make_bytes(ctx, l, i) sexp_make_bytes_op(ctx, NULL, 2, l, i)\n#if SEXP_USE_UNIFORM_VECTOR_LITERALS\n#define sexp_make_uvector(ctx, et, l) sexp_make_uvector_op(ctx, NULL, 2, et, l)\n#else\n#define sexp_make_uvector(ctx, et, l) sexp_make_vector(ctx, l, SEXP_ZERO)\n#define sexp_write_uvector NULL\n#define sexp_finalize_uvector NULL\n#endif\n#define sexp_make_string(ctx, l, c) sexp_make_string_op(ctx, NULL, 2, l, c)\n#define sexp_subbytes(ctx, a, b, c) sexp_subbytes_op(ctx, NULL, 3, a, b, c)\n#define sexp_string_concatenate(ctx, ls, s) sexp_string_concatenate_op(ctx, NULL, 2, ls, s)\n#define sexp_memq(ctx, a, b) sexp_memq_op(ctx, NULL, 2, a, b)\n#define sexp_assq(ctx, a, b) sexp_assq_op(ctx, NULL, 2, a, b)\n#define sexp_open_output_string(ctx) sexp_open_output_string_op(ctx, NULL, 0)\n#define sexp_open_input_string(ctx, s) sexp_open_input_string_op(ctx, NULL, 1, s)\n#define sexp_get_output_string(ctx, out) sexp_get_output_string_op(ctx, NULL, 1, out)\n#define sexp_expt(ctx, a, b) sexp_expt_op(ctx, NULL, 2, a, b)\n#define sexp_register_simple_type(ctx, a, b, c) sexp_register_simple_type_op(ctx, NULL, 3, a, b, c)\n#define sexp_register_type(ctx, a, b, c, d, e, f, g, h, i, j, k, l, m, o, p, q, r, sn, s) sexp_register_type_op(ctx, NULL, 18, a, b, c, d, e, f, g, h, i, j, k, l, m, o, p, q, r, sn, s)\n#define sexp_make_type_predicate(ctx, a, b) sexp_make_type_predicate_op(ctx, NULL, 2, a, b)\n#define sexp_make_constructor(ctx, a, b) sexp_make_constructor_op(ctx, NULL, 2, a, b)\n#define sexp_make_getter(ctx, a, b, c) sexp_make_getter_op(ctx, NULL, 3, a, b, c)\n#define sexp_make_setter(ctx, a, b, c) sexp_make_setter_op(ctx, NULL, 3, a, b, c)\n#define sexp_lookup_type(ctx, name, id) sexp_lookup_type_op(ctx, NULL, 2, name, id)\n#define sexp_make_fileno(ctx, fd, no_closep) sexp_make_fileno_op(ctx, NULL, 2, fd, no_closep)\n\nenum sexp_opcode_names {\n  /*  0 00 */ SEXP_OP_NOOP,\n  /*  1 01 */ SEXP_OP_RAISE,\n  /*  2 02 */ SEXP_OP_RESUMECC,\n  /*  3 03 */ SEXP_OP_CALLCC,\n  /*  4 04 */ SEXP_OP_APPLY1,\n  /*  5 05 */ SEXP_OP_TAIL_CALL,\n  /*  6 06 */ SEXP_OP_CALL,\n  /*  7 07 */ SEXP_OP_FCALL0,\n  /*  8 08 */ SEXP_OP_FCALL1,\n  /*  9 09 */ SEXP_OP_FCALL2,\n  /* 10 0A */ SEXP_OP_FCALL3,\n  /* 11 0B */ SEXP_OP_FCALL4,\n  /* 12 0C */ SEXP_OP_FCALLN,\n  /* 13 0D */ SEXP_OP_JUMP_UNLESS,\n  /* 14 0E */ SEXP_OP_JUMP,\n  /* 15 0F */ SEXP_OP_PUSH,\n  /* 16 10 */ SEXP_OP_RESERVE,\n  /* 17 11 */ SEXP_OP_DROP,\n  /* 18 12 */ SEXP_OP_GLOBAL_REF,\n  /* 19 13 */ SEXP_OP_GLOBAL_KNOWN_REF,\n  /* 20 14 */ SEXP_OP_PARAMETER_REF,\n  /* 21 15 */ SEXP_OP_STACK_REF,\n  /* 22 16 */ SEXP_OP_LOCAL_REF,\n  /* 23 17 */ SEXP_OP_LOCAL_SET,\n  /* 24 18 */ SEXP_OP_CLOSURE_REF,\n  /* 25 19 */ SEXP_OP_CLOSURE_VARS,\n  /* 26 1A */ SEXP_OP_VECTOR_REF,\n  /* 27 1B */ SEXP_OP_VECTOR_SET,\n  /* 28 1C */ SEXP_OP_VECTOR_LENGTH,\n  /* 29 1D */ SEXP_OP_BYTES_REF,\n  /* 30 1E */ SEXP_OP_BYTES_SET,\n  /* 31 1F */ SEXP_OP_BYTES_LENGTH,\n  /* 32 20 */ SEXP_OP_STRING_REF,\n  /* 33 21 */ SEXP_OP_STRING_SET,\n  /* 34 22 */ SEXP_OP_STRING_LENGTH,\n  /* 35 23 */ SEXP_OP_STRING_CURSOR_NEXT,\n  /* 36 24 */ SEXP_OP_STRING_CURSOR_PREV,\n  /* 37 25 */ SEXP_OP_STRING_CURSOR_END,\n  /* 38 26 */ SEXP_OP_MAKE_PROCEDURE,\n  /* 39 27 */ SEXP_OP_MAKE_VECTOR,\n  /* 40 28 */ SEXP_OP_MAKE_EXCEPTION,\n  /* 41 29 */ SEXP_OP_AND,\n  /* 42 2A */ SEXP_OP_NULLP,\n  /* 43 2B */ SEXP_OP_FIXNUMP,\n  /* 44 2C */ SEXP_OP_SYMBOLP,\n  /* 45 2D */ SEXP_OP_CHARP,\n  /* 46 2E */ SEXP_OP_EOFP,\n  /* 47 2F */ SEXP_OP_TYPEP,\n  /* 48 30 */ SEXP_OP_MAKE,\n  /* 49 31 */ SEXP_OP_SLOT_REF,\n  /* 50 32 */ SEXP_OP_SLOT_SET,\n  /* 51 33 */ SEXP_OP_ISA,\n  /* 52 34 */ SEXP_OP_SLOTN_REF,\n  /* 53 35 */ SEXP_OP_SLOTN_SET,\n  /* 54 36 */ SEXP_OP_CAR,\n  /* 55 37 */ SEXP_OP_CDR,\n  /* 56 38 */ SEXP_OP_SET_CAR,\n  /* 57 39 */ SEXP_OP_SET_CDR,\n  /* 58 3A */ SEXP_OP_CONS,\n  /* 59 3B */ SEXP_OP_ADD,\n  /* 60 3C */ SEXP_OP_SUB,\n  /* 61 3D */ SEXP_OP_MUL,\n  /* 62 3E */ SEXP_OP_DIV,\n  /* 63 3F */ SEXP_OP_QUOTIENT,\n  /* 64 40 */ SEXP_OP_REMAINDER,\n  /* 65 41 */ SEXP_OP_LT,\n  /* 66 42 */ SEXP_OP_LE,\n  /* 67 43 */ SEXP_OP_EQN,\n  /* 68 44 */ SEXP_OP_EQ,\n  /* 69 45 */ SEXP_OP_CHAR2INT,\n  /* 70 46 */ SEXP_OP_INT2CHAR,\n  /* 71 47 */ SEXP_OP_CHAR_UPCASE,\n  /* 72 48 */ SEXP_OP_CHAR_DOWNCASE,\n  /* 73 49 */ SEXP_OP_WRITE_CHAR,\n  /* 74 4A */ SEXP_OP_WRITE_STRING,\n  /* 75 4B */ SEXP_OP_READ_CHAR,\n  /* 76 4C */ SEXP_OP_PEEK_CHAR,\n  /* 77 4D */ SEXP_OP_YIELD,\n  /* 78 4E */ SEXP_OP_FORCE,\n  /* 79 4F */ SEXP_OP_RET,\n  /* 80 50 */ SEXP_OP_DONE,\n  SEXP_OP_SCP,\n  SEXP_OP_SC_LT,\n  SEXP_OP_SC_LE,\n  SEXP_OP_NUM_OPCODES\n};\n\n#ifdef __cplusplus\n} /* extern \"C\" */\n#endif\n\n#endif /* ! SEXP_H */\n", "source": "Chibi Scheme/include/chibi/sexp.h", "file_type": "h"}
{"text": "/* Amavect! */\n#include <u.h>\n#include <libc.h>\n#include <fcall.h>\n#include <thread.h>\n#include <9p.h>\n#include <draw.h>\n#include <memdraw.h>\n\nextern Memimage *hdrallocmemimage(char *);\nextern u32int blockloadmemimage(Memimage *i, uchar *buf, u32int n, int *miny, int comp);\n\n#define DEBUG 0\n\nenum {\n\tQroot,\n\tQcanvas,\n\tQupdate,\n};\n\ntypedef struct F {\n\tchar *name;\n\tQid qid;\n\tulong perm;\n} F;\n\ntypedef struct Readq Readq;\nstruct Readq {\n\tReq *this;\n\tReadq *last; /* doubly linked list */\n\tReadq *link;\n};\n\ntypedef struct Writeq Writeq;\nstruct Writeq {\n\tRectangle r;\n\tuchar comp; /* is compressed */\n\tint miny; /* last y row written */\n\tMemimage *mi;\n\tulong chan;\n\tuvlong s; /* residual write buf size */\n\tuvlong i; /* current buffer index */\n\tuchar *buf; /* residual write buffer, size bytesperline */\n};\n\ntypedef struct Updateq Updateq;\nstruct Updateq {\n\tUpdateq *last; /* doubly linked list */\n\tUpdateq *link;\n\tu32int fid;\n\tuchar hasread;\n\tRectangle dirty;\n};\n\nchar *user;\nMemimage *canvas, *diff;\nchar imhdr[5*12+1];\nuchar *imdata;\nUpdateq *fqhead, *fqtail;\nReadq *rqhead, *rqtail;\n\nF root = {\"/\", {Qroot, 0, QTDIR}, 0555|DMDIR};\nF canvasf = {\"canvas.bit\", {Qcanvas, 0, QTFILE}, 0666};\nF updatef = {\"update\", {Qupdate, 0, QTFILE}, 0666};\n\nvoid\nusage(void)\n{\n\tfprint(2, \"%s [-D] [-m mtpt] [-s srv] [-x width] [-y height] \\n\", argv0);\n\texits(\"usage\");\n}\n\nulong\nmemimagebytelen(Memimage *i)\n{\n\treturn Dy(i->r)*bytesperline(i->r, i->depth);\n}\n\nvoid\nimdataupdate(void)\n{\n\tunloadmemimage(canvas, canvas->r, imdata, memimagebytelen(canvas));\n}\n\n/* update the imhdr, reallocate imdata, and update imdata */\nvoid\nimhdrupdate(void)\n{\n\tchar ch[11];\n\tsnprint(imhdr, sizeof(imhdr), \"%11s %11d %11d %11d %11d \",\n\t\tchantostr(ch, canvas->chan), canvas->r.min.x, \n\t\tcanvas->r.min.y, canvas->r.max.x, canvas->r.max.y);\n\tif(imdata != nil)\n\t\timdata = realloc(imdata, memimagebytelen(canvas));\n\telse\n\t\timdata = malloc(memimagebytelen(canvas));\n\timdataupdate();\n}\n\nF *\nfilebypath(uvlong path)\n{\n\tif(path == Qroot)\n\t\treturn &root;\n\telse if(path == Qcanvas)\n\t\treturn &canvasf;\n\telse if(path == Qupdate)\n\t\treturn &updatef;\n\telse\n\t\treturn nil;\n}\n\nvoid \nfsattach(Req *r)\n{\n\tr->fid->qid = filebypath(Qroot)->qid;\n\tr->ofcall.qid = r->fid->qid;\n\trespond(r, nil);\n}\n\nchar *\nfswalk1(Fid *fid, char *name, Qid *qid)\n{\n\tif(fid->qid.path == Qroot){\n\t\tif(strcmp(name, canvasf.name) == 0){\n\t\t\t*qid = canvasf.qid;\n\t\t\tfid->qid = *qid;\n\t\t\treturn nil;\n\t\t}else if(strcmp(name, updatef.name) == 0){\n\t\t\t*qid = updatef.qid;\n\t\t\tfid->qid = *qid;\n\t\t\treturn nil;\n\t\t}else if(strcmp(name, \"..\") == 0){\n\t\t\t*qid = root.qid;\n\t\t\tfid->qid = *qid;\n\t\t\treturn nil;\n\t\t}\t\n\t}\n\treturn \"not found\";\n}\n\nvoid\nfillstat(Dir *d, uvlong path)\n{\n\tF *f;\n\t\n\tf = filebypath(path);\n\td->qid = f->qid;\t/* unique id from server */\n\td->mode = f->perm;\t/* permissions */\n\td->atime = time(0);\t/* last read time */\n\td->mtime = time(0);\t/* last write time */\n\td->length = 0;\t/* file length */\n\td->name = estrdup9p(f->name);\t/* last element of path */\n\td->uid = estrdup9p(user);\t/* owner name */\n\td->gid = estrdup9p(user);\t/* group name */\n\td->muid = estrdup9p(user);\t/* last modifier name */\n}\n\nvoid\nfsstat(Req *r)\n{\n\tfillstat(&r->d, r->fid->qid.path);\n\trespond(r, nil);\n}\n\nint\nrootgen(int n, Dir *d, void *)\n{\n\tswitch(n){\n\tcase 0:\n\t\tfillstat(d, canvasf.qid.path);\n\t\tbreak;\n\tcase 1:\n\t\tfillstat(d, updatef.qid.path);\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nvoid\nfsopen(Req *r)\n{\n\tUpdateq *fq;\n\t\n\tif(r->fid->qid.path == Qupdate){\n\t\tfq = emalloc9p(sizeof(Updateq));\n\t\tfq->fid = r->ifcall.fid;\n\t\tfq->last = fqtail;\n\t\tif(fqtail != nil)\n\t\t\tfqtail->link = fq;\n\t\telse\n\t\t\tfqhead = fq; /* assert fqhead == nil */\n\t\tfqtail = fq;\n\t\tfq->hasread = 1;\n\t\tr->fid->aux = fq;\n\t}\n\t\n\trespond(r, nil);\n}\n\n\nvoid\nreadspond(Req *r)\n{\n\tUpdateq *fq;\n\tchar s[1+12*4+1];\n\tulong n;\n\t\n\tfq = r->fid->aux;\n\t\n\tif(r->ifcall.count < 1){\n\t\trespond(r, \"buffer too small\");\n\t}else{\n\t\tr->ofcall.data[0] = 'y'; /* draw(3) y, but not really */\n\t\tn = snprint(s, sizeof(s), \" %11d %11d %11d %11d\\n\", \n\t\t\tfq->dirty.min.x, fq->dirty.min.y, \n\t\t\tfq->dirty.max.x, fq->dirty.max.y);\n\t\tif(r->ifcall.count - 1 < n)\n\t\t\tn = r->ifcall.count - 1;\n\t\tmemcpy(r->ofcall.data + 1, s, n);\n\t\tr->ofcall.count = n+1;\n\t\tfq->hasread = 1;\n\t\trespond(r,nil);\n\t}\n}\n\nvoid\nfsread(Req *r)\n{\n\tuvlong path;\n\tUpdateq *fq;\n\tReadq *rq;\n\tulong c, o, n, maxoff;\n\t\n\tpath = r->fid->qid.path;\n\tif(path == Qroot){\n\t\tdirread9p(r, rootgen, nil);\n\t\trespond(r, nil);\n\t}else if(path == Qcanvas){\n\t\tc = r->ifcall.count;\n\t\to = r->ifcall.offset;\n\t\tn = 0;\n\t\tif(o < 5*12){\n\t\t\tn += 5*12 - o;\n\t\t\tif(c < n)\n\t\t\t\tn = c;\n\t\t\tmemcpy(r->ofcall.data, imhdr + o, n);\n\t\t\tc -= n;\n\t\t\to += n;\n\t\t}\n\t\to -= 5*12;\n\t\tmaxoff = memimagebytelen(canvas);\n\t\tif(o < maxoff && c > 0){\n\t\t\tif(c + o > maxoff)\n\t\t\t\tc = maxoff - o;\n\t\t\tmemcpy(r->ofcall.data + n, imdata + o, c);\n\t\t\tn += c;\n\t\t}\n\t\tr->ofcall.count = n;\n\t\trespond(r, nil);\n\t}else if(path == Qupdate){\n\t\t/* if buffer ptr is behind, catchup, otherwise add to queue */\n\t\tfq = r->fid->aux;\n\t\tif(fq->hasread){\n\t\t\trq = emalloc9p(sizeof(Readq)); /* potential cache thrasher */\n\t\t\trq->this = r;\n\t\t\trq->last = rqtail;\n\t\t\tif(rqtail != nil)\n\t\t\t\trqtail->link = rq;\n\t\t\telse\n\t\t\t\trqhead = rq; /* assert rqhead == nil */\n\t\t\trqtail = rq;\n\t\t\tr->aux = rq;\n\t\t}else{\n\t\t\treadspond(r);\n\t\t}\n\t}else{\n\t\trespond(r, \"invalid Qid path\");\n\t}\n}\n\nvoid\nfswrite(Req *r)\n{\n\tReadq *rq, *next;\n\tint n, e, s;\n\tWriteq *wq;\n\tUpdateq *uq;\n\tRectangle rekt;\n\t\n\tif(r->fid->qid.path != Qcanvas){\n\t\trespond(r, \"Cannot write to there!\");\n\t\treturn;\n\t}\n\tn = 0;\n\t/* basic sanitization until I add support for general image types and compression */\n\twq = r->fid->aux;\n\tif(wq == nil){\n\t\tif(r->ifcall.count < 60){\n\t\t\trespond(r, \"write buffer too small, cannot recover header\");\n\t\t\treturn;\n\t\t}\n\t\twq = malloc(sizeof(Writeq));\n\t\tif(wq == nil){\n\t\t\trespond(r, \"out of memory #1\");\n\t\t\treturn;\n\t\t}\n\t\tif(memcmp(r->ifcall.data, \"compressed\\n\", 11) == 0){\n\t\t\twq->comp = 1;\n\t\t\tn += 11;\n\t\t}else{\n\t\t\twq->comp = 0;\n\t\t}\n\t\twq->mi = hdrallocmemimage(r->ifcall.data + n);\n\t\tif(wq->mi == nil){\n\t\t\tfree(wq);\n\t\t\tresponderror(r);\n\t\t\treturn;\n\t\t}\n\t\tif(!rectinrect(wq->mi->r, canvas->r)){\n\t\t\tfreememimage(wq->mi);\n\t\t\tfree(wq);\n\t\t\trespond(r, \"image size not within canvas rectangle\");\n\t\t\treturn;\n\t\t}\n\t\tn += 60;\n\t\twq->i = 0;\n\t\tif(wq->comp)\n\t\t\twq->s = 6025;\n\t\telse\n\t\t\twq->s = bytesperline(wq->mi->r, wq->mi->depth);  /* residual buffer size */\n\t\twq->buf = malloc(wq->s);  /* residual buffer for uncompressed writes */\n\t\tif(wq->buf == nil){\n\t\t\tfreememimage(wq->mi);\n\t\t\tfree(wq);\n\t\t\trespond(r, \"out of memory #2\");\n\t\t\treturn;\n\t\t}\n\t\twq->miny = wq->mi->r.min.y;\n\t\tr->fid->aux = wq;\n\t}\n\t\n\te = 1;\n\twhile(n < r->ifcall.count && e > 0){\n\t\tif(DEBUG) fprint(2, \"start: n=%d e=%d wqi=%ulld\\n\", n, e, wq->i);\n\t\tif(wq->i > 0){  /* finish a block or line */\n\t\t\ts = r->ifcall.count - n < wq->s - wq->i ? r->ifcall.count - n : wq->s - wq->i;\n\t\t\tmemcpy(wq->buf + wq->i, r->ifcall.data, s);\n\t\t\twq->i += s;\n\t\t\te = blockloadmemimage(wq->mi, wq->buf, wq->i, &wq->miny, wq->comp);\n\t\t\twq->i -= e;\n\t\t\tn += s;\n\t\t}else{\n\t\t\te = blockloadmemimage(wq->mi, (uchar*)r->ifcall.data+n, r->ifcall.count-n, &wq->miny, wq->comp);\n\t\t\tn += e;\n\t\t}\n\t\tif(e < 0){\n\t\t\tfreememimage(wq->mi);\n\t\t\tfree(wq->buf);\n\t\t\tfree(wq);\n\t\t\tr->fid->aux = nil;\n\t\t\tfprint(2, \"%r\\n\");\n\t\t\trespond(r, \"error loading image. deleting write request\");\n\t\t\treturn;\n\t\t}\n\t\tif(DEBUG) fprint(2, \"end: n=%d e=%d wqi=%ulld\\n\", n, e, wq->i);\n\t\tif(DEBUG) fprint(2, \"wq->miny: %d, wq->mi->r.max.y: %d\\n\", wq->miny, wq->mi->r.max.y);\n\t}\n\tif(n < r->ifcall.count){\n\t\twq->i = r->ifcall.count - n;\n\t\tif(wq->i > wq->s)\n\t\t\tsysfatal(\"Why would that be bigger? %ulld\", wq->i);\n\t\tmemcpy(wq->buf, r->ifcall.data+n, wq->i);\n\t}\n\tif(wq->miny == wq->mi->r.max.y && wq->i != 0){\n\t\tfreememimage(wq->mi);\n\t\tfree(wq->buf);\n\t\tfree(wq);\n\t\tr->fid->aux = nil;\n\t\trespond(r, \"too much data sent. deleting write request\");\n\t\treturn;\n\t}\n\tr->ofcall.count = r->ifcall.count;\n\tif(DEBUG) fprint(2, \"wq->miny: %d, wq->mi->r.max.y: %d\\n\", wq->miny, wq->mi->r.max.y);\n\tif(wq->miny < wq->mi->r.max.y){\n\t\trespond(r, nil);\n\t\treturn;\n\t}else if(wq->miny > wq->mi->r.max.y){\n\t\t/* assert cannot happen */\n\t\tfprint(2, \"write size error: %d > %d\", wq->miny, wq->mi->r.max.y);\n\t\tfreememimage(wq->mi);\n\t\tfree(wq->buf);\n\t\tfree(wq);\n\t\tr->fid->aux = nil;\n\t\trespond(r, \"image write too large, somehow. deleting write request\");\n\t\treturn;\n\t}\n\tif(DEBUG) fprint(2, \"successful image write\\n\");\n\t/* Successful image write. composite, update, and notify. */\n\t/*\n\t * Currently: wq->chan == diff->chan && wq->r == diff->r\n\t * To support different image write sizes, a new Memimage will\n\t * need to be allocated.\n\t */\n\tmemimagedraw(canvas, canvas->r, wq->mi, ZP, nil, ZP, SoverD);\n\trekt = wq->mi->r;\n\tfreememimage(wq->mi);\n\tfree(wq->buf);\n\tfree(wq);\n\tr->fid->aux = nil;\n\trespond(r,nil);\n\timdataupdate();\n\t/* \n\t * invalidate all updateqs\n\t * expand dirty rectangle\n\t */\n\tfor(uq = fqhead; uq != nil; uq = uq->link){\n\t\tif(uq->hasread == 1){\n\t\t\tuq->dirty = rekt;\n\t\t\tuq->hasread = 0;\n\t\t}else{\n\t\t\tcombinerect(&uq->dirty, rekt);\n\t\t}\n\t}\n\t/* respond to all waiting reads */\n\tfor(rq = rqhead; rq != nil; rq = next){\n\t\t/* respond() calls destroyreq, which frees this rq */\n\t\tnext = rq->link;\n\t\treadspond(rq->this);\n\t}\n\trqhead = nil;\n\trqtail = nil;\n}\n\nvoid\nfsflush(Req *r)\n{\n\tReadq *rq;\n\tfor(rq = rqhead; rq != nil; rq = rq->link){\n\t\tif(r->ifcall.oldtag == rq->this->tag){\n\t\t\trespond(rq->this, \"interrupted\");\n\t\t\tif(rq->last != nil)\n\t\t\t\trq->last->link = rq->link;\n\t\t\telse\n\t\t\t\trqhead = rq->link;\n\t\t\tif(rq->link != nil)\n\t\t\t\trq->link->last = rq->last;\n\t\t\telse\n\t\t\t\trqtail = rq->last;\n\t\t\trespond(r, nil);\n\t\t\treturn;\n\t\t}\n\t}\n\trespond(r, \"invalid tag\");\n}\n\nvoid\nfsdestroyfid(Fid *fid)\n{\n\tUpdateq *fq;\n\tWriteq *wq;\n\t\n\tif(fid->aux == nil)\n\t\treturn;\n\tif(fid->qid.path == Qupdate){\n\t\tfq = fid->aux;\n\t\t/* remove self from DLL */\n\t\tif(fq->last == nil){\n\t\t\tfqhead = fq->link;\n\t\t}else{\n\t\t\tfq->last->link = fq->link;\n\t\t}\n\t\tif(fq->link == nil){\n\t\t\tfqtail = fq->last;\n\t\t}else{\n\t\t\tfq->link->last = fq->last;\n\t\t}\n\t\t\n\t\tfree(fq);\n\t\tfid->aux = nil;\n\t}else if(fid->qid.path == Qcanvas){\n\t\twq = fid->aux;\n\t\tfreememimage(wq->mi);\n\t\tfree(wq->buf);\n\t\tfree(wq);\n\t\tfid->aux = nil;\n\t}else{ /* assert this branch cannot happen */\n\t\tsysfatal(\"unknown dangling fid->aux, qid=%ulld\", fid->qid.path);\n\t}\n}\n\nvoid\nfsdestroyreq(Req *r)\n{\n\tReadq *rq;\n\t\n\tif(r->aux == nil)\n\t\treturn;\n\trq = r->aux;\n\t/* remove self from DLL */\n\tif(rq->last == nil){\n\t\trqhead = rq->link;\n\t}else{\n\t\trq->last->link = rq->link;\n\t}\n\tif(rq->link == nil){\n\t\trqtail = rq->last;\n\t}else{\n\t\trq->link->last = rq->last;\n\t}\n\t\n\tfree(rq);\n\tr->aux = nil;\n}\n\nSrv fs = {\n\t.attach = fsattach,\n\t.walk1 = fswalk1,\n\t.stat = fsstat,\n\t.open = fsopen,\n\t.read = fsread,\n\t.write = fswrite,\n\t.flush = fsflush,\n\t.destroyfid = fsdestroyfid,\n\t.destroyreq = fsdestroyreq,\n};\n\nvoid\nmain(int argc, char *argv[])\n{\n\tchar *mtpt, *srv;\n\tint x, y;\n\t\n\tmtpt = \"/mnt/whiteboard\";\n\tsrv = nil;\n\tx = 512;\n\ty = 512;\n\tARGBEGIN{\n\tcase 'm':\n\t\tmtpt = EARGF(usage());\n\t\tbreak;\n\tcase 's':\n\t\tsrv = EARGF(usage());\n\t\tbreak;\n\tcase 'x':\n\t\tx = strtol(EARGF(usage()), nil, 0);\n\t\tbreak;\n\tcase 'y':\n\t\ty = strtol(EARGF(usage()), nil, 0);\n\t\tbreak;\n\tcase 'D':\n\t\tchatty9p++;\n\t\tbreak;\n\tdefault:\n\t\tusage();\n\t}ARGEND;\n\t\n\tif(x <= 1)\n\t\texits(\"x too small\");\n\tif(x >= 1024) /* don't break the network */\n\t\texits(\"x too big\");\n\tif(y <= 1)\n\t\texits(\"y too small\");\n\tif(y >= 1024)\n\t\texits(\"y too big\");\n\t\n\tif(memimageinit() < 0)\n\t\tsysfatal(\"%r\");\n\tcanvas = allocmemimage(Rect(0,0,x,y), RGB24);\n\tmemfillcolor(canvas, 0xA0A0A0FF);\n\timhdrupdate();\n\tdiff = allocmemimage(Rect(0,0,x,y), RGBA32);\n\t\n\tuser = getuser();\n\tpostmountsrv(&fs, srv, mtpt, MREPL);\n\t\n\texits(nil);\n}\n", "source": "whiteboardfs/whiteboardfs.c", "file_type": "c"}
{"text": "</$objtype/mkfile\n\nTARG=whiteboardfs dryerase\n\nEXE=${TARG:%=$O.%}\nINST=${TARG:%=/$objtype/bin/%}\n\ndefault:V: all\n\n/$objtype/bin/%: $O.%\n\tcp $prereq $target\n\n$O.%: %.$O\n\t$LD $LDFLAGS -o $target $prereq\n\n$O.whiteboardfs: whiteboardfs.$O imageload.$O\n\t$LD $LDFLAGS -o $target $prereq\n\n%.$O: %.c\n\t$CC $CFLAGS $stem.c\n\n/sys/man/4/whiteboardfs: whiteboardfs.4.man\n\tcp whiteboardfs.4.man /sys/man/4/whiteboardfs\n\nall:V: $EXE\n\ninstall:V: $INST man\n\nman:V: /sys/man/4/whiteboardfs\n\nclean:V:\n\trm -f $O.$TARG [$OS].$TARG *.[$OS]\n", "source": "whiteboardfs/mkfile", "file_type": "mkfile"}
{"text": "/* Amavect! */\n/*\n * This is a reimplementation of readimage, creadimage, writeimage, readmemimage,\n * creadmemimage, writememimage in such a way that breaks down into\n * functions that can be used to construct Images over 9p.\n * There is some repetition between the current readimage and creadimage, so I\n * thought I could consolidate that.\n *\n * neglects old image format\n * \n * i like to put fake in front of my function defs.\n */\n#include <u.h>\n#include <libc.h>\n#include <draw.h>\n#include <memdraw.h>\n\n/* \n * Allocate an empty memimage based on the 60 byte header.\n * Assumes *hdr contains points to at least 60 bytes.\n * returns nil on error\n */\nMemimage *\nhdrallocmemimage(char *hdr)\n{\n\tulong chan;\n\tRectangle r;\n\tMemimage *i;\n\t\n\tif(hdr[11] != ' '){\n\t\twerrstr(\"hdrallocmemimage: bad format\");\n\t\treturn nil;\n\t}\n\t\n\thdr[11] = '\\0';\n\tif((chan = strtochan(hdr)) == 0){\n\t\twerrstr(\"hdrallocmemimage: bad channel string %s\", hdr);\n\t\treturn nil;\n\t}\n\t\n\thdr[1*12+11] = hdr[2*12+11] = hdr[3*12+11] = hdr[4*12+11] = '\\0';\n\tr.min.x=atoi(hdr+1*12);\n\tr.min.y=atoi(hdr+2*12);\n\tr.max.x=atoi(hdr+3*12);\n\tr.max.y=atoi(hdr+4*12);\n\tif(r.min.x > r.max.x || r.min.y > r.max.y){\n\t\twerrstr(\"hdrallocmemimage: bad rectangle\");\n\t\treturn nil;\n\t}\n\n\ti = allocmemimage(r, chan);\n\tif(i == nil)\n\t\treturn nil;\n\treturn i;\n}\n\n/*\n * send a maximum 6025 byte data buffer block\n * overwrites miny to be the the last row updated\n * returns number of bytes read from buffer, -1 on failure\n * \n * currently returns -1 if n is not the same as the block size.\n */\nu32int\nblockcloadmemimage(Memimage *i, uchar *buf, u32int n, int *miny)\n{\n\tint maxy;\n\tint nb, ncblock;\n\t\n\tif(n < 2*12){\n\t\twerrstr(\"blockcloadmemimage: short read\");\n\t\treturn -1;\n\t}\n\tbuf[0*12+11] = buf[1*12+11] = '\\0';\n\tnb = atoi((char*)buf+1*12);\n\tif(n < nb + 2*12)\n\t\treturn 0;\n\tmaxy = atoi((char*)buf+0*12);\n\tif(maxy <= *miny || maxy > i->r.max.y){\n\t\twerrstr(\"blockcloadmemimage: bad maxy %d\", maxy);\n\t\treturn -1;\n\t}\n\tncblock = _compblocksize(i->r, i->depth);\n\tif(nb <= 0 || nb > ncblock){\n\t\twerrstr(\"blockcloadmemimage: bad count %d\", nb);\n\t\treturn -1;\n\t}\n\tif(nb + 2*12 != n){\n\t\twerrstr(\"blockcloadmemimage: block size != buffer size, %d != %d\", nb, n);\n\t\treturn -1;\n\t}\n\tif(cloadmemimage(i, Rect(i->r.min.x, *miny, i->r.max.x, maxy), buf+2*12, nb) < 0){\n\t\twerrstr(\"blockcloadmemimage: bad cloadmemimage\");\n\t\treturn -1;\n\t}\n\t*miny = maxy;\n\treturn nb+24;\n}\n\n/* \n * returns number of bytes written. \n * returns -1 on error, or 0 on no bytes written\n */\nu32int\nlineloadmemimage(Memimage *i, uchar *buf, u32int n, int *miny)\n{\n\tu32int l, dy;\n\t\n\tl = bytesperline(i->r, i->depth);\n\tif(l <= 0){\n\t\twerrstr(\"blockloadmemimage: bad bytes per line size %d\", l);\n\t\treturn -1;\n\t}\n\tdy = n / l;\n\tif(dy == 0)\n\t\treturn 0;\n\tif(dy + *miny > i->r.max.y){\n\t\twerrstr(\"blockloadmemimage: buf size too large %d\", n);\n\t\treturn -1;\n\t}\n\tif(loadmemimage(i, Rect(i->r.min.x, *miny, i->r.max.x, *miny+dy), buf, dy*l) < 0){\n\t\twerrstr(\"blockloadmemimage: bad loadmemimage\");\n\t\treturn -1;\n\t}\n\t*miny += dy;\n\treturn dy*l;\n}\n\nu32int\nblockloadmemimage(Memimage *i, uchar *buf, u32int n, int *miny, int comp)\n{\n\tif(comp)\n\t\treturn blockcloadmemimage(i, buf, n, miny);\n\telse\n\t\treturn lineloadmemimage(i, buf, n, miny);\n}\n", "source": "whiteboardfs/imageload.c", "file_type": "c"}
{"text": "#include <u.h>\n#include <libc.h>\n#include <draw.h>\n#include <thread.h>\n#include <keyboard.h>\n#include <mouse.h>\n\nImage in[3];\nImage out[3];\n\nImage *outbuf;\n\nImage *canvas;\nImage clear;\nImage grey;\nImage lpen;\nImage rpen;\nImage *pencol;\nPoint drawpt;\nint pensize;\nint reading;\n\nstruct{\n\tint ufd;\n\tint cfd;\n\tChannel *recvc; /* Image *i, recv image from updateproc */\n\tChannel *sendc; /* Image *i, send image from updateproc */\n\tChannel *readc; /* char, signals when reading */ \n} ups;\n\nstruct{\n\tint cfd;\n\tChannel *recvc; /* Image *i, receive Image from sendproc */\n\tChannel *sendc; /* Image *i, send Image to sendproc */\n\tChannel *donec; /* char, signals a send was done */\n} sends;\n\nstruct{\n\tChannel *chan; /* ulong */\n\tint rxfd;\n\tint txfd;\n} picker;\n\nvoid\nerror(char *s)\n{\n\tfprint(2, \"%s: %s: %r\\n\", argv0, s);\n\tthreadexitsall(s);\n}\n\nPoint\nptclip(Point p, Rectangle r)\n{\n\tif(p.x < r.min.x)\n\t\tp.x = r.min.x;\n\telse if(p.x > r.max.x - 1)\n\t\tp.x = r.max.x - 1;\n\tif(p.y < r.min.y)\n\t\tp.y = r.min.y;\n\telse if(p.y > r.max.y - 1)\n\t\tp.y = r.max.y - 1;\n\treturn p;\n}\n\nvoid\nexpandrect(Rectangle *r, Point p, int radius)\n{\n\tif(p.x - radius < r->min.x)\n\t\tr->min.x = p.x - radius;\n\tif(p.x + radius + 1 > r->max.x)\n\t\tr->max.x = p.x + radius + 1;\n\tif(p.y - radius < r->min.y)\n\t\tr->min.y = p.y - radius;\n\tif(p.y + radius + 1 > r->max.y)\n\t\tr->max.y = p.y + radius + 1;\n}\n\nvoid\nstallocimage(Image *ai, Rectangle r, ulong chan, int repl, ulong col)\n{\n\tif(_allocimage(ai, display, r, chan, repl, col, 0, 0) == nil)\n\t\terror(\"allocimage failed\");\n}\n\nvoid\nusage(void)\n{\n\tfprint(2, \"usage: %s [-c] [-d dir]\\n\", argv0);\n\tthreadexitsall(\"usage\");\n}\n\nvoid\ndogetwindow(void)\n{\n\tlockdisplay(display);\n\tif(getwindow(display, Refnone) < 0)\n\t\terror(\"Cannot reconnect to display: %r\");\n\tunlockdisplay(display);\n}\n\nvoid\nredraw(void)\n{\n\tPoint ss, lu, mid;\n\tint y;\n\tchar *mesg;\n\t\n\tlockdisplay(display);\n\tdraw(screen, screen->r, display->black, nil, ZP);\n\tmid.x = Dx(screen->r)/2 + screen->r.min.x;\n\tmid.y = Dy(screen->r)/2 + screen->r.min.y;\n\tdraw(screen, Rect(mid.x, screen->r.min.y, screen->r.max.x, mid.y), display->white, nil, ZP);\n\tdraw(screen, Rect(screen->r.min.x, mid.y, mid.x, screen->r.max.y), display->white, nil, ZP);\n\tdraw(screen, screen->r, pencol, nil, ZP);\n\tdrawpt.x = (Dx(screen->r) - Dx(canvas->r))/2 + screen->r.min.x;\n\tdrawpt.y = (Dy(screen->r) - Dy(canvas->r))/2 + screen->r.min.y;\n\tborder(screen, rectaddpt(canvas->r, drawpt), -2, &grey, ZP);\n\tdraw(screen, screen->r, canvas, nil, subpt(screen->r.min, drawpt));\n\tif(outbuf != nil)\n\t\tdraw(screen, screen->r, outbuf, nil, subpt(screen->r.min, drawpt));\n\tif(sends.recvc->n + sends.sendc->n != nelem(out)){\n\t\tmesg = \"writing...\";\n\t}else{\n\t\tmesg = \"ready.\";\n\t}\n\tss = stringsize(display->defaultfont, mesg);\n\tdraw(screen, Rpt(screen->r.min, addpt(screen->r.min, ss)), display->white, nil, ZP);\n\tstring(screen, screen->r.min, display->black, ZP, display->defaultfont, mesg);\n\t\n\tif(reading){\n\t\tmesg = \"reading...\";\n\t}else{\n\t\tmesg = \"done.\";\n\t}\n\ty = ss.y;\n\tss = stringsize(display->defaultfont, mesg);\n\tss.y += y;\n\tlu = addpt(screen->r.min, Pt(0,y));\n\tdraw(screen, Rpt(lu, addpt(screen->r.min, ss)), display->white, nil, ZP);\n\tstring(screen, lu, display->black, ZP, display->defaultfont, mesg);\n\t\n\tunlockdisplay(display);\n}\n\n/* \n * load multiple lines at a time\n * do not load only a rectangle, as that requires single-line reads\n * thus, Image rectangles without a width equal to canvas will error\n */\nvoid\nreadrectimage(Image *i, int fd)\n{\n\tstatic uchar buf[8192];\n\tint l, chunk, miny, maxy, dy, n, m;\n\tRectangle r;\n\t\n\tr = i->r;\n\t\n\tif(r.min.x != canvas->r.min.x || \n\t\tr.max.x != canvas->r.max.x){\n\t\terror(\"readrectimage: bad image width\");\n\t}\n\t\n\tminy = i->r.min.y;\n\tmaxy = i->r.max.y;\n\t\n\tchunk = sizeof(buf);\n\tl = bytesperline(i->r, i->depth);\n\tif(l > chunk)\n\t\terror(\"readrectimage: image does not fit buffer\");\n\t\n\tseek(fd, 5*12+l*miny, 0);\n\t\n\twhile(maxy > miny){\n\t\tdy = maxy - miny;\n\t\tif(dy*l > chunk)\n\t\t\tdy = chunk/l;\n\t\tn = dy*l;\n\t\tm = readn(fd, buf, n);\n\t\tif(m != n){\n\t\t\tfprint(2, \"readrectimage: read count %d not %d: %r\", m, n);\n\t\t\tthreadexitsall(\"bad read\");\n\t\t}\n\t\t\n\t\tlockdisplay(display);\n\t\tif(loadimage(i, Rect(r.min.x, miny, r.max.x, miny+dy), buf, n) <= 0){\n\t\t\tunlockdisplay(display);\n\t\t\terror(\"readrectimage: loadimage failed\");\n\t\t}\n\t\tunlockdisplay(display);\n\t\tminy += dy;\n\t}\n}\n\nvoid\nupdateproc(void*)\n{\n\t/* uses struct ups instead of aux arg */\n\tchar s[2+4*12];\n\tlong n;\n\tImage *im;\n\tRectangle r;\n\t\n\tthreadsetname(\"updater\");\n\tim = nil;\n\t\n\tfor(;;){\n\t\tn = recv(ups.sendc, &im);\n\t\tif(im == nil)\n\t\t\tbreak;\n\t\tn = read(ups.ufd, s, sizeof(s));\n\t\tif(n <= 0)\n\t\t\tbreak;\n\t\tsend(ups.readc, nil);\n\t\t\n\t\tr.min.x = canvas->r.min.x;\n\t\tr.min.y = atoi(s+2+12);\n\t\tr.max.x = canvas->r.max.x;\n\t\tr.max.y = atoi(s+2+3*12);\n\t\t/* unimplemented: dynamic resizing */\n\t\tif(!rectinrect(r, canvas->r))\n\t\t\terror(\"canvas rectangle changed\");\n\t\tlockdisplay(display);\n\t\t_freeimage1(im);\n\t\tstallocimage(im, r, canvas->chan, 0, DNofill);\n\t\tunlockdisplay(display);\n\t\treadrectimage(im, ups.cfd);\n\t\tif(im == nil)\n\t\t\terror(\"invalid image update read\");\n\t\tsend(ups.recvc, &im);\n\t}\n\tyield();  /* if error is due to exiting, we'll exit here */\n\tif(n < 0){\n\t\terror(\"Whiteboard probably closed.\");\n\t}\n\terror(\"updater: unknown error\");\n}\n\nvoid\ninitupdateproc(char *cpath, char *upath)\n{\n\tint i;\n\t\n\tif((ups.cfd = open(cpath, ORDWR)) < 0)\n\t\terror(\"whiteboard not mounted\");\n\tif((ups.ufd = open(upath, ORDWR)) < 0)\n\t\terror(\"whiteboard not mounted\");\n\tups.recvc = chancreate(sizeof(Image *), nelem(in));\n\tups.sendc = chancreate(sizeof(Image *), nelem(in));\n\tups.readc = chancreate(sizeof(char), nelem(in));\n\t\n\tfor(i = 0; i < nelem(in); i++){\n\t\tsendp(ups.sendc, &in[i]);\n\t}\n\t\n\tproccreate(updateproc, &ups, 0x2000);\n}\n\nvoid\nsendproc(void*)\n{\n\t/* uses struct ups instead of aux arg */\n\tint n;\n\tImage *im;\n\t\n\tim = nil;\n\tthreadsetname(\"sender\");\n\tfor(;;){\n\t\tn = recv(sends.sendc, &im);\n\t\tif(n != 1)\n\t\t\tbreak;\n\t\t\n\t\twriteimage(sends.cfd, im, 1);\n\t\tlockdisplay(display);\n\t\t_freeimage1(im);\n\t\tunlockdisplay(display);\n\t\tsend(sends.recvc, &im);\n\t\tsend(sends.donec, nil);\n\t}\n\tyield(); /* if error is due to exiting, we'll exit here */\n\tif(n < 0)\n\t\terror(\"whiteboard probably closed\");\n\terror(\"sender: unknown error\");\n}\n\nvoid\ninitsendproc(char *path)\n{\n\tint i;\n\t\n\tif((sends.cfd = open(path, ORDWR)) < 0)\n\t\terror(\"whiteboard not mounted\");\n\t\n\tsends.recvc = chancreate(sizeof(Image*), nelem(out));\n\tsends.sendc = chancreate(sizeof(Image*), nelem(out));\n\tsends.donec = chancreate(sizeof(char), nelem(out));\n\t\n\tfor(i = 0; i < nelem(out); i++){\n\t\tsendp(sends.recvc, &out[i]);\n\t}\n\t\n\tproccreate(sendproc, &sends, 0x2000);\n}\n\nvoid\npickerproc(void*)\n{\n\tchar buf[12];\n\tulong col;\n\tint n;\n\t\n\tfor(;;){\n\t\tn = read(picker.rxfd, buf, sizeof(buf));\n\t\tif(n <= 0){\n\t\t\tyield(); /* if error is due to exiting, we'll exit here */\n\t\t\tif(n < 0){\n\t\t\t\terror(\"whiteboard probably closed\");\n\t\t\t}\n\t\t\tif(n == 0){\n\t\t\t\t/* picker closed */\n\t\t\t\tthreadexitsall(nil);\n\t\t\t}\n\t\t}\n\t\tbuf[sizeof(buf)-1] = '\\0';\n\t\tcol = strtoul(buf, nil, 0);\n\t\tsend(picker.chan, &col);\n\t}\n}\n\nvoid\ninitpicker(void)\n{\n\tint rxfd[2];\n\tint txfd[2];\n\tint pid;\n\tchar *srvwsys;\n\tint wsysfd;\n\t\n\tif(pipe(rxfd) < 0)\n\t\terror(\"pipe failed\");\n\tif(pipe(txfd) < 0)\n\t\terror(\"pipe failed\");\n\tpicker.rxfd = rxfd[0];\n\tpicker.txfd = txfd[0];\n\tpid = rfork(RFFDG|RFREND|RFPROC|RFNOWAIT);\n\t\n\tif(pid == 0){\n\t\tclose(rxfd[0]);\n\t\tclose(txfd[0]);\n\t\tclose(0);\n\t\tclose(1);\n\t\tdup(rxfd[1], 1);\n\t\tdup(txfd[1], 0);\n\t\tsrvwsys = getenv(\"wsys\");\n\t\tif(srvwsys == nil)\n\t\t\terror(\"can't find $wsys\");\n\t\trfork(RFNAMEG);\n\t\twsysfd = open(srvwsys, ORDWR);\n\t\tif(wsysfd < 0)\n\t\t\terror(\"can't open $wsys\");\n\t\tif(mount(wsysfd, -1, \"/mnt/wsys\", MREPL, \"new -dx 400 -dy 300\") < 0)\n\t\t\terror(\"can't mount new window\");\n\t\tif(bind(\"/mnt/wsys\", \"/dev\", MBEFORE) < 0)\n\t\t\terror(\"can't bind\");\n\t\texecl(\"/bin/makeu\", \"makeu\", \"-pi\", \"-c\", \"0x000000FF\", nil);\n\t\t//execl(\"/bin/pal\", \"pal\", \"-pic\", nil);\n\t\terror(\"picker exec failed\");\n\t}\n\tclose(rxfd[1]);\n\tclose(txfd[1]);\n\tpicker.chan = chancreate(sizeof(ulong), 1);\n\tproccreate(pickerproc, &sends, 0x1000);\n}\n\nvoid\nthreadmain(int argc, char **argv)\n{\n\tstatic Keyboardctl *kctl;\n\tRune r;\n\tstatic Mousectl *mctl;\n\tstatic Mouse m, mold; /* don't you love puns? */\n\tPoint drawpt, clippt;\n\tint state;\n\tchar *dir;\n\tstatic char cpath[128];\n\tstatic char upath[128];\n\tulong col;\n\tuchar ldcol[4];\n\tImage *im;\n\tint cfd;\n\tint cflag;\n\tRectangle dirty;\n\t\n\tdir = \"/mnt/whiteboard\";\n\tcflag = 0;\n\tARGBEGIN{\n\tcase 'd':\n\t\tdir = EARGF(usage());\n\t\tbreak;\n\tcase 'c':\n\t\tcflag = 1;\n\t\tbreak;\n\tdefault:\n\t\tusage();\n\t}ARGEND;\n\t\n\tif(initdraw(nil, nil, argv0) < 0)\n\t\terror(\"cannot initdraw\");\n\tdisplay->locking = 1;\n\tunlockdisplay(display);\n\t\n\tsnprint(cpath, sizeof(cpath), \"%s/%s\", dir, \"canvas.bit\");\n\tsnprint(upath, sizeof(upath), \"%s/%s\", dir, \"update\");\n\tinitsendproc(cpath);\n\tinitupdateproc(cpath, upath);\n\tsleep(1000);\n\tif((mctl = initmouse(nil, screen)) == nil)\n\t\terror(\"cannot initmouse\");\n\tif((kctl = initkeyboard(nil)) == nil)\n\t\terror(\"cannot initkeyboard\");\n\t\n\tif(cflag){\n\t\tinitpicker();\n\t}else{\n\t\tpicker.chan = nil;\n\t}\n\t\n\tdogetwindow();\n\t\n\tif((cfd = open(cpath, ORDWR)) < 0)\n\t\terror(\"whiteboard not mounted\");\n\tcanvas = readimage(display, cfd, 1);\n\tclose(cfd);\n\tif(canvas == nil)\n\t\terror(\"cannot readimage\");\n\tif(!rectinrect(canvas->r, Rect(0,0,1920,1080)))\n\t\terror(\"whiteboard canvas too big or improper size\");\n\t\n\tlockdisplay(display);\n\tstallocimage(&clear, Rect(0,0,1,1), RGBA32, 1, DTransparent);\n\tstallocimage(&grey, Rect(0,0,1,1), RGBA32, 1, 0x555555FF);\n\tstallocimage(&lpen, Rect(0,0,1,1), RGBA32, 1, DBlack);\n\tstallocimage(&rpen, Rect(0,0,1,1), RGBA32, 1, DWhite);\n\tunlockdisplay(display);\n\tpencol = &lpen;\n\t\n\tstate = 0;\n\tmold.buttons = 0;\n\tmold.xy = screen->r.min;\n\t\n\tdogetwindow();\n\tredraw();\n\t\n\t/* \n\t * Channels:\n\t * recv mouse channel\n\t * recv resize channel\n\t * recv keys channel\n\t * recv update channel\n\t * recv picker channel\n\t * \n\t * send Image channel to send proc\n\t * send proc must freeimage() after\n\t * recv Image channel from send proc\n\t * recv Image channel from update proc\n\t * main proc must composite and freeimage() after\n\t * \n\t * \n\t * \n\t */\n\t\n\tenum { MOUSE, RESIZE, KEYS, SEND, READ, UPDATE, PICKER, NONE };\n\tAlt alts[] = {\n\t\t[MOUSE] =  {mctl->c, &m, CHANRCV},\n\t\t[RESIZE] =  {mctl->resizec, nil, CHANRCV},\n\t\t[KEYS] = {kctl->c, &r, CHANRCV},\n\t\t[SEND] = {sends.donec, nil, CHANRCV},\n\t\t[READ] = {ups.readc, nil, CHANRCV},\n\t\t[UPDATE] = {ups.recvc, &im, CHANRCV},\n\t\t[PICKER] =  {picker.chan, &col, CHANEND},\n\t\t[NONE] =  {nil, nil, CHANEND},\n\t};\n\t\n\tif(cflag)\n\t\talts[PICKER].op = CHANRCV;\n\t\n\tfor(;;){\n\t\tlockdisplay(display);\n\t\tflushimage(display, 1);\n\t\tunlockdisplay(display);\nnoflush:\n\t\tswitch(alt(alts)){\n\t\tcase MOUSE:\n\t\t\tdrawpt.x = (Dx(screen->r) - Dx(canvas->r))/2 + screen->r.min.x;\n\t\t\tdrawpt.y = (Dy(screen->r) - Dy(canvas->r))/2 + screen->r.min.y;\n\t\t\tm.xy = subpt(m.xy, drawpt); /* relative coords */\n\t\t\tswitch(state){\n\t\t\tcase 0:\n\t\t\t\tif(m.buttons == 1)\n\t\t\t\t\tpencol = &lpen;\n\t\t\t\telse if(m.buttons == 4)\n\t\t\t\t\tpencol = &rpen;\n\t\t\t\telse\n\t\t\t\t\tgoto noflush;\n\t\t\t\tunloadimage(pencol, pencol->r,\n\t\t\t\t\tldcol, sizeof(ldcol));\n\t\t\t\tcol = ldcol[0];\n\t\t\t\tcol |= ldcol[1]<<8;\n\t\t\t\tcol |= ldcol[2]<<16;\n\t\t\t\tcol |= ldcol[3]<<24;\n\t\t\t\tif(ptinrect(m.xy, canvas->r)){\n\t\t\t\t\trecv(sends.recvc, &outbuf);\n\t\t\t\t\tlockdisplay(display);\n\t\t\t\t\tstallocimage(outbuf, canvas->r, RGBA32, 0, DTransparent);\n\t\t\t\t\tunlockdisplay(display);\n\t\t\t\t\tstate = 1;\n\t\t\t\t\tdirty.min = m.xy;\n\t\t\t\t\tdirty.max = addpt(m.xy, Pt(1,1));\n\t\t\t\t\texpandrect(&dirty, m.xy, pensize);\n\t\t\t\t}\t\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tif(ptinrect(m.xy, canvas->r) || ptinrect(mold.xy, canvas->r)){\n\t\t\t\t\tlockdisplay(display);\n\t\t\t\t\tline(outbuf, mold.xy, m.xy, Enddisc,\n\t\t\t\t\t\tEnddisc, pensize, pencol, ZP);\n\t\t\t\t\tunlockdisplay(display);\n\t\t\t\t\tclippt = ptclip(m.xy, canvas->r);\n\t\t\t\t\texpandrect(&dirty, clippt, pensize);\n\t\t\t\t}\n\t\t\t\tif(m.buttons == 0){\n\t\t\t\t\trectclip(&dirty, canvas->r);\n\t\t\t\t\toutbuf->r = dirty;\n\t\t\t\t\tlockdisplay(display);\n\t\t\t\t\tdraw(canvas, canvas->r, outbuf, nil, ZP);\n\t\t\t\t\tunlockdisplay(display);\n\t\t\t\t\tsend(sends.sendc, &outbuf);\n\t\t\t\t\toutbuf = nil;\n\t\t\t\t\tstate = 0;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tredraw();\n\t\t\tmold = m;\n\t\t\tbreak;\n\t\tcase RESIZE:\n\t\t\tdogetwindow();\n\t\t\tredraw();\n\t\t\tbreak;\n\t\tcase KEYS:\n\t\t\tif(r == Kdel){\n\t\t\t\tthreadexitsall(nil);\n\t\t\t}else if(r == ']'){\n\t\t\t\tpensize += 1;\n\t\t\t\tif(pensize > 42)\n\t\t\t\t\tpensize = 42;\n\t\t\t}else if(r == '['){\n\t\t\t\tpensize -= 1;\n\t\t\t\tif(pensize < 0)\n\t\t\t\t\tpensize = 0;\n\t\t\t}\n\t\t\tgoto noflush;\n\t\tcase SEND:\n\t\t\tredraw();\n\t\t\tbreak;\n\t\tcase READ:\n\t\t\treading++;\n\t\t\tredraw();\n\t\t\tbreak;\n\t\tcase UPDATE:\n\t\t\treading--;\n\t\t\tlockdisplay(display);\n\t\t\tdraw(canvas, canvas->r, im, nil, ZP);\n\t\t\tunlockdisplay(display);\n\t\t\tsend(ups.sendc, &im);\n\t\t\tredraw();\n\t\t\tbreak;\n\t\tcase PICKER:\n\t\t\tldcol[0] = col>>0 & 0xFF;\n\t\t\tldcol[1] = col>>8 & 0xFF;\n\t\t\tldcol[2] = col>>16 & 0xFF;\n\t\t\tldcol[3] = col>>24 & 0xFF;\n\t\t\tlockdisplay(display);\n\t\t\tloadimage(pencol, pencol->r, ldcol, sizeof(ldcol));\n\t\t\tunlockdisplay(display);\n\t\t\tredraw();\n\t\t\tbreak;\n\t\tcase NONE:\n\t\t\tprint(\"I'm a woodchuck, not a woodchucker! (thanks for playing)\\n\");\n\t\t\tgoto noflush;\n\t\t}\n\t}\n}\n", "source": "whiteboardfs/dryerase.c", "file_type": "c"}
